{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Python SDK","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The Frequenz Python SDK is a development kit for interacting with the Frequenz development platform.</p>"},{"location":"#installation","title":"Installation","text":"<p>First, you need to make sure you have Python installed (at least version 3.11):</p> <pre><code>$ python3 --version\nPython 3.11.4\n</code></pre> <p>Note</p> <p>These instructions assume you are using a POSIX compatible <code>sh</code> shell.</p> <p>If that command doesn't print a version newer than 3.11.0, you'll need to download and install Python first.</p> <p>To install the SDK, you probably want to create a new virtual environment first:</p> <pre><code>mkdir my-sdk-project\ncd my-sdk-project\npython3 -m venv .venv\n. .venv/bin/activate\n</code></pre> <p>Tip</p> <p>Using <code>direnv</code> can greatly simplify this process as it automates the creation, activation, and deactivation of the virtual environment. The first time you enable <code>direnv</code>, the virtual environment will be created, and each time you enter or leave a subdirectory, it will be activated and deactivated, respectively.</p> <pre><code>sudo apt install direnv # if you use Debian/Ubuntu\nmkdir my-sdk-project\ncd my-sdk-project\necho \"layout python python3\" &gt; .envrc\ndirenv allow\n</code></pre> <p>This will create the virtual environment and activate it automatically for you.</p> <p>Now you can install the SDK by using <code>pip</code> (if you don't have <code>pip</code> installed you can follow the official instructions):</p> <pre><code>python3 -m pip install frequenz-sdk\n</code></pre> <p>To verify that the installation worked, you can invoke the Python interpreter and import the SDK:</p> <pre><code>$ python3\nPython 3.11.4 (main, Jun  7 2023, 10:13:09) [GCC 12.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import frequenz.sdk\n&gt;&gt;&gt;\n</code></pre>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Python SDK","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>User Guide</li> <li>Tutorials</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>sdk<ul> <li>actor<ul> <li>power_distributing<ul> <li>power_distributing</li> <li>request</li> <li>result</li> </ul> </li> </ul> </li> <li>config</li> <li>microgrid<ul> <li>client</li> <li>component</li> <li>component_graph</li> <li>connection_manager</li> <li>fuse</li> <li>metadata</li> </ul> </li> <li>timeseries<ul> <li>battery_pool</li> <li>ev_charger_pool</li> <li>formula_engine</li> <li>grid</li> <li>logical_meter</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/sdk/","title":"Index","text":""},{"location":"reference/frequenz/sdk/#frequenz.sdk","title":"frequenz.sdk","text":"<p>Frequenz Python SDK.</p>"},{"location":"reference/frequenz/sdk/actor/","title":"Index","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor","title":"frequenz.sdk.actor","text":"<p>Actors are a primitive unit of computation that runs autonomously.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--actor-programming-model","title":"Actor Programming Model","text":"<p>From Wikipedia</p> <p>The actor model in computer science is a mathematical model of concurrent computation that treats an actor as the basic building block of concurrent computation. In response to a message it receives, an actor can: make local decisions, create more actors, send more messages, and determine how to respond to the next message received. Actors may modify their own private state, but can only affect each other indirectly through messaging (removing the need for lock-based synchronization).</p> <p>We won't get into much more detail here because it is outside the scope of this documentation. However, if you are interested in learning more about the actor programming model, here are some useful resources:</p> <ul> <li>Actor Model (Wikipedia)</li> <li>How the Actor Model Meets the Needs of Modern, Distributed Systems   (Akka)</li> </ul>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--frequenz-sdk-actors","title":"Frequenz SDK Actors","text":"<p>The <code>Actor</code> class serves as the foundation for creating concurrent tasks and all actors in the SDK inherit from it. This class provides a straightforward way to implement actors. It shares similarities with the traditional actor programming model but also has some unique features:</p> <ul> <li> <p>Message Passing: Like traditional actors, our <code>Actor</code>   class communicates through message passing. Even when no particular message passing   mechanism is enforced, the SDK actors use <code>frequenz.channels</code> for communication.</p> </li> <li> <p>Automatic Restart: If an unhandled exception occurs in an actor's logic   (<code>_run()</code> method), the actor will be automatically restarted. This ensures   robustness in the face of errors.</p> </li> <li> <p>Simplified Task Management: Actors manage asynchronous tasks using   <code>asyncio</code>. You can create and manage tasks within the actor, and the   <code>Actor</code> class handles task cancellation and cleanup.</p> </li> <li> <p>Simplified lifecycle management: Actors are [async context managers] and also   a <code>run()</code> function is provided to easily run a group of   actors and wait for them to finish.</p> </li> </ul>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--lifecycle","title":"Lifecycle","text":"<p>Actors are not started when they are created. There are 3 main ways to start an actor (from most to least recommended):</p> <ol> <li>By using the <code>run()</code> function.</li> <li>By using the actor as an async context manager.</li> <li>By using the <code>start()</code> method.</li> </ol> <p>Warning</p> <ol> <li> <p>If an actor raises an unhandled exception, it will be restarted automatically.</p> </li> <li> <p>Actors manage <code>asyncio.Task</code> objects, so a reference to the actor object must    be held for as long as the actor is expected to be running, otherwise its tasks    will be cancelled and the actor will stop. For more information, please refer to    the Python <code>asyncio</code>    documentation.</p> </li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--the-run-function","title":"The <code>run()</code> Function","text":"<p>The <code>run()</code> function can start many actors at once and waits for them to finish. If any of the actors are stopped with errors, the errors will be logged.</p> Example <pre><code>from frequenz.sdk.actor import Actor, run\nclass MyActor(Actor):\nasync def _run(self) -&gt; None:\nprint(\"Hello World!\")\nawait run(MyActor()) # (1)!\n</code></pre> <ol> <li>This line will block until the actor is stopped.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--async-context-manager","title":"Async Context Manager","text":"<p>When an actor is used as an async context manager, it is started when the <code>async with</code> block is entered and stopped automatically when the block is exited (even if an exception is raised).</p> Example <pre><code>from frequenz.sdk.actor import Actor\nclass MyActor(Actor):\nasync def _run(self) -&gt; None:\nprint(\"Hello World!\")\nasync with MyActor() as actor: # (1)!\nprint(\"The actor is running\")\n# (2)!\n</code></pre> <ol> <li><code>start()</code> is called automatically when entering     the <code>async with</code> block.</li> <li><code>stop()</code> is called automatically when exiting     the <code>async with</code> block.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--the-start-method","title":"The <code>start()</code> Method","text":"<p>When using the <code>start()</code> method, the actor is started in the background and the method returns immediately. The actor will continue to run until it is manually stopped.</p> Example <pre><code>from frequenz.sdk.actor import Actor\nclass MyActor(Actor):\nasync def _run(self) -&gt; None:\nprint(\"Hello World!\")\nactor = MyActor() # (1)!\nactor.start() # (2)!\nprint(\"The actor is running\") # (3)!\nawait actor.stop() # (4)!\n</code></pre> <ol> <li>The actor is created but not started yet.</li> <li>The actor is started manually, it keeps running in the background.</li> <li> <p>Danger</p> <p>If this function would raise an exception, the actor will never be stopped!</p> </li> <li> <p>Until the actor is stopped manually.</p> </li> </ol> <p>Warning</p> <p>This method is not recommended because it is easy to forget to stop the actor manually, especially in error conditions.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--communication","title":"Communication","text":"<p>The <code>Actor</code> class doesn't impose any specific way to communicate between actors. However, <code>frequenz.channels</code> are always used as the communication mechanism between actors in the SDK.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--implementing-an-actor","title":"Implementing an Actor","text":"<p>To implement an actor, you must inherit from the <code>Actor</code> class and implement an initializer and the abstract <code>_run()</code> method.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--initialization","title":"Initialization","text":"<p>The initializer is called when the actor is created. The <code>Actor</code> class initializer (<code>__init__</code>) should be always called first in the class we are implementing to make sure actors are properly initialized.</p> <p>The <code>Actor.__init__()</code> takes one optional argument, a <code>name</code> that will be used to identify the actor in logs. If no name is provided, a default name will be generated, but it is recommended that <code>Actor</code> subclasses can also receive a name as an argument to make it easier to identify individual instances in logs more easily.</p> <p>The actor initializer normally also accepts as arguments the input channels receivers and output channels senders that will be used for communication. These channels should be created outside the actor and passed to it as arguments to ensure actors can be composed easily.</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\nclass EchoActor(Actor):  # (1)!\ndef __init__(\nself,\ninput: Receiver[int],  # (2)!\noutput: Sender[int],  # (3)!\nname: str | None = None,  # (4)!\n) -&gt; None:\nsuper().__init__(name=name) # (5)!\nself._input: Receiver[int] = input  # (6)!\nself._output: Sender[int] = output  # (7)!\n</code></pre> <ol> <li> <p>We define a new actor class called <code>EchoActor</code> that inherits from     <code>Actor</code>.</p> </li> <li> <p>We accept an <code>input</code> argument that will be used to receive messages from     a channel.</p> </li> <li>We accept an <code>output</code> argument that will be used to send messages to a channel.</li> <li>We accept an optional <code>name</code> argument that will be used to identify the actor in     logs.</li> <li>We call <code>Actor.__init__()</code> to make sure the     actor is properly initialized.</li> <li>We store the <code>input</code> argument in a private instance variable to use it later.</li> <li>We store the <code>output</code> argument in a private instance variable to use it later.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--the-_run-method","title":"The <code>_run()</code> Method","text":"<p>The abstract <code>_run()</code> method is called automatically by the base class when the actor is started.</p> <p>Normally an actor should run forever (or until it is stopped), so it is very common to have an infinite loop in the <code>_run()</code> method, typically receiving messages from one or more channels (receivers), processing them and sending the results to other channels (senders).</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\nclass EchoActor(Actor):\ndef __init__(\nself,\ninput: Receiver[int],\noutput: Sender[int],\nname: str | None = None,\n) -&gt; None:\nsuper().__init__(name=name)\nself._input: Receiver[int] = input\nself._output: Sender[int] = output\nasync def _run(self) -&gt; None:  # (1)!\nasync for msg in self._input:  # (2)!\nawait self._output.send(msg)  # (3)!\n</code></pre> <ol> <li>We implement the abstract <code>_run()</code> method.</li> <li>We receive messages from the <code>input</code> channel one by one.</li> <li>We send the received message to the <code>output</code> channel.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--stopping","title":"Stopping","text":"<p>By default, the <code>stop()</code> method will call the <code>cancel()</code> method (which will cancel all the tasks created by the actor) and will wait for them to finish.</p> <p>This means that when an actor is stopped, the <code>_run()</code> method will receive a <code>CancelledError</code> exception. You should have this in mind when implementing your actor and make sure to handle this exception properly if you need to do any cleanup.</p> <p>The actor will handle the <code>CancelledError</code> exception automatically if it is not handled in the <code>_run()</code> method, so if there is no need for extra cleanup, you don't need to worry about it.</p> <p>If an unhandled exception is raised in the <code>_run()</code> method, the actor will re-run the <code>_run()</code> method automatically. This ensures robustness in the face of errors, but you should also have this in mind if you need to do any cleanup to make sure the re-run doesn't cause any problems.</p> Tip <p>You could implement your own <code>stop()</code> method to, for example, send a message to a channel to notify that the actor should stop, or any other more graceful way to stop the actor if you need to make sure it can't be interrupted at any <code>await</code> point.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--spawning-extra-tasks","title":"Spawning Extra Tasks","text":"<p>Actors run at least one background task, created automatically by the <code>Actor</code> class. But <code>Actor</code> inherits from <code>BackgroundService</code>, which provides a few methods to create and manage extra tasks.</p> <p>If your actor needs to spawn extra tasks, you can use <code>BackgroundService</code> facilities to manage the tasks, so they are also automatically stopped when the actor is stopped.</p> <p>All you need to do is add the newly spawned tasks to the actor's <code>tasks</code> set.</p> Example <pre><code>import asyncio\nfrom frequenz.sdk.actor import Actor\nclass MyActor(Actor):\nasync def _run(self) -&gt; None:\nextra_task = asyncio.create_task(self._extra_task())  # (1)!\nself.tasks.add(extra_task)  # (2)!\nwhile True:  # (3)!\nprint(\"_run() running\")\nawait asyncio.sleep(1)\nasync def _extra_task(self) -&gt; None:\nwhile True:  # (4)!\nprint(\"_extra_task() running\")\nawait asyncio.sleep(1.1)\nasync with MyActor() as actor:  # (5)!\nawait asyncio.sleep(3)  # (6)!\n# (7)!\n</code></pre> <ol> <li>We create a new task using <code>asyncio.create_task()</code>.</li> <li>We add the task to the actor's <code>tasks</code> set.     This ensures the task will be cancelled and cleaned up when the actor is stopped.</li> <li>We leave the actor running forever.</li> <li>The extra task will also run forever.</li> <li>The actor is started.</li> <li>We wait for 3 seconds, the actor should print a bunch of \"_run() running\" and     \"_extra_task() running\" messages while it's running.</li> <li>The actor is stopped and the extra task is cancelled automatically.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--examples","title":"Examples","text":"<p>Here are a few simple but complete examples to demonstrate how to create actors and connect them using channels.</p> <p>Tip</p> <p>The code examples are annotated with markers (like ), you can click on them to see the step-by-step explanation of what's going on. The annotations are numbered according to the order of execution.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--composing-actors","title":"Composing actors","text":"<p>This example shows how to create two actors and connect them using broadcast channels.</p> compose.py<pre><code>import asyncio\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.sdk.actor import Actor\nclass Actor1(Actor):  # (1)!\ndef __init__(\nself,\nreceiver: Receiver[str],\noutput: Sender[str],\nname: str | None = None,\n) -&gt; None:\nsuper().__init__(name=name)\nself._receiver = receiver\nself._output = output\nasync def _run(self) -&gt; None:\nasync for msg in self._receiver:\nawait self._output.send(f\"Actor1 forwarding: {msg!r}\")  # (8)!\nclass Actor2(Actor):\ndef __init__(\nself,\nreceiver: Receiver[str],\noutput: Sender[str],\nname: str | None = None,\n) -&gt; None:\nsuper().__init__(name=name)\nself._receiver = receiver\nself._output = output\nasync def _run(self) -&gt; None:\nasync for msg in self._receiver:\nawait self._output.send(f\"Actor2 forwarding: {msg!r}\")  # (9)!\nasync def main() -&gt; None:  # (2)!\n# (4)!\ninput_channel: Broadcast[str] = Broadcast(\"Input to Actor1\")\nmiddle_channel: Broadcast[str] = Broadcast(\"Actor1 -&gt; Actor2 stream\")\noutput_channel: Broadcast[str] = Broadcast(\"Actor2 output\")\ninput_sender = input_channel.new_sender()\noutput_receiver = output_channel.new_receiver()\nasync with (  # (5)!\nActor1(input_channel.new_receiver(), middle_channel.new_sender(), \"actor1\"),\nActor2(middle_channel.new_receiver(), output_channel.new_sender(), \"actor1\"),\n):\nawait input_sender.send(\"Hello\")  # (6)!\nmsg = await output_receiver.receive()  # (7)!\nprint(msg)  # (10)!\n# (11)!\nif __name__ == \"__main__\":  # (3)!\nasyncio.run(main())\n</code></pre> <ol> <li> <p>We define 2 actors: <code>Actor1</code> and <code>Actor2</code> that will just forward a message    from an input channel to an output channel, adding some text.</p> </li> <li> <p>We define an async <code>main()</code> function with the main logic of our asyncio program.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We create a bunch of broadcast channels to connect our actors.</p> <ul> <li><code>input_channel</code> is the input channel for <code>Actor1</code>.</li> <li><code>middle_channel</code> is the channel that connects <code>Actor1</code> and <code>Actor2</code>.</li> <li><code>output_channel</code> is the output channel for <code>Actor2</code>.</li> </ul> </li> <li> <p>We create two actors and use them as async context managers, <code>Actor1</code> and     <code>Actor2</code>, and connect them by creating new     senders and     receivers from the channels.</p> <p>Note</p> <p>We don't use the <code>run()</code> function here because we want to stop the actors when we are done with them, but the actors will run forever (as long as the channel is not closed). So the async context manager is a better fit for this example.</p> </li> <li> <p>We schedule the sending of the message    <code>Hello</code> to <code>Actor1</code> via <code>input_channel</code>.</p> </li> <li> <p>We receive (await) the response from    <code>Actor2</code> via <code>output_channel</code>. Between this and the previous steps the    <code>async</code> calls in the actors will be executed.</p> </li> <li> <p><code>Actor1</code> sends the re-formatted message (<code>Actor1 forwarding: Hello</code>) to    <code>Actor2</code> via the <code>middle_channel</code>.</p> </li> <li> <p><code>Actor2</code> sends the re-formatted message (<code>Actor2 forwarding: \"Actor1    forwarding: 'Hello'\"</code>) to the <code>output_channel</code>.</p> </li> <li> <p>Finally, we print the received message, which will still be <code>Actor2     forwarding: \"Actor1 forwarding: 'Hello'\"</code>.</p> </li> <li> <p>The actors are stopped and cleaned up automatically when the <code>async with</code>     block ends.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Actor2 forwarding: \"Actor1 forwarding: 'Hello'\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--receiving-from-multiple-channels","title":"Receiving from multiple channels","text":"<p>This example shows how to create an actor that receives messages from multiple broadcast channels using <code>select()</code>.</p> select.py<pre><code>import asyncio\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.channels.util import select, selected_from\nfrom frequenz.sdk.actor import Actor, run\nclass EchoActor(Actor):  # (1)!\ndef __init__(\nself,\nreceiver_1: Receiver[bool],\nreceiver_2: Receiver[bool],\noutput: Sender[bool],\nname: str | None = None,\n) -&gt; None:\nsuper().__init__(name=name)\nself._receiver_1 = receiver_1\nself._receiver_2 = receiver_2\nself._output = output\nasync def _run(self) -&gt; None:  # (2)!\nasync for selected in select(self._receiver_1, self._receiver_2):  # (10)!\nif selected_from(selected, self._receiver_1):  # (11)!\nprint(f\"Received from receiver_1: {selected.value}\")\nawait self._output.send(selected.value)\nif not selected.value:  # (12)!\nbreak\nelif selected_from(selected, self._receiver_2):  # (13)!\nprint(f\"Received from receiver_2: {selected.value}\")\nawait self._output.send(selected.value)\nif not selected.value:  # (14)!\nbreak\nelse:\nassert False, \"Unknown selected channel\"\nprint(\"EchoActor finished\")\n# (15)!\n# (3)!\ninput_channel_1 = Broadcast[bool](\"input_channel_1\")\ninput_channel_2 = Broadcast[bool](\"input_channel_2\")\necho_channel = Broadcast[bool](\"echo_channel\")\necho_actor = EchoActor(  # (4)!\ninput_channel_1.new_receiver(),\ninput_channel_2.new_receiver(),\necho_channel.new_sender(),\n\"echo-actor\",\n)\necho_receiver = echo_channel.new_receiver()  # (5)!\nasync def main() -&gt; None:  # (6)!\n# (8)!\nawait input_channel_1.new_sender().send(True)\nawait input_channel_2.new_sender().send(False)\nawait run(echo_actor)  # (9)!\nawait echo_channel.close()  # (16)!\nasync for message in echo_receiver:  # (17)!\nprint(f\"Received {message=}\")\nif __name__ == \"__main__\":  # (7)!\nasyncio.run(main())\n</code></pre> <ol> <li> <p>We define an <code>EchoActor</code> that receives messages from two channels and sends     them to another channel.</p> </li> <li> <p>We implement the <code>_run()</code> method that will receive messages from the two     channels using and send them to the output channel. The <code>run()</code> method will stop if     a <code>False</code> message is received.</p> </li> <li> <p>We create the channels that will be used with the actor.</p> </li> <li> <p>We create the actor and connect it to the channels by creating new receivers and     senders from the channels.</p> </li> <li> <p>We create a receiver for the <code>echo_channel</code> to eventually receive the messages sent     by the actor.</p> </li> <li> <p>We define the <code>main()</code> function that will run the actor.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We send a message to each of the input channels. These messages will be queued in     the channels until they are consumed by the actor.</p> </li> <li> <p>We start the actor and wait for it to finish using the     <code>run()</code> function.</p> </li> <li> <p>The <code>select()</code> function will get the first message     available from the two channels. The order in which they will be handled is     unknown, but in this example we assume that the first message will be from     <code>input_channel_1</code> (<code>True</code>) and the second from <code>input_channel_1</code> (<code>False</code>).</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>True</code> for the <code>input_channel_1</code> receiver. <code>selected.value</code> holds the received     message, so <code>\"Received from receiver_1: True\"</code> will be printed and <code>True</code> will be     sent to the <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>True</code>, the loop will continue, going back to the and the     the loop will continue, going back to the     <code>select()</code> function.</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>False</code> for the <code>input_channel_1</code> receiver and <code>True</code> for the <code>input_channel_2</code>     receiver. The message stored in <code>selected.value</code> will now be <code>False</code>, so     <code>\"Received from receiver_2: False\"</code> will be printed and <code>False</code> will be sent to the     <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>False</code>, the loop will break.</p> </li> <li> <p>The <code>_run()</code> method will finish normally and the actor will be stopped, so     the <code>run()</code> function will return.</p> </li> <li> <p>We close the <code>echo_channel</code> to make sure the <code>echo_receiver</code> will stop receiving     messages after all the queued messages are consumed (otherwise the step 17 will     never end!).</p> </li> <li> <p>We receive the messages sent by the actor to the <code>echo_channel</code> one by one and print     them, it should print first <code>Received message=True</code> and then <code>Received     message=False</code>.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Received from receiver_1: True\nReceived from receiver_2: False\nReceived message=True\nReceived message=False\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor","title":"frequenz.sdk.actor.Actor","text":"<p>             Bases: <code>BackgroundService</code>, <code>ABC</code></p> <p>A primitive unit of computation that runs autonomously.</p> <p>To implement an actor, subclasses must implement the <code>_run()</code> method, which should run the actor's logic. The <code>_run()</code> method is called by the base class when the actor is started, and is expected to run until the actor is stopped.</p> <p>Info</p> <p>Please read the <code>actor</code> module documentation for more comprehensive guide on how to use and implement actors properly.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>class Actor(BackgroundService, abc.ABC):\n\"\"\"A primitive unit of computation that runs autonomously.\n    To implement an actor, subclasses must implement the\n    [`_run()`][frequenz.sdk.actor--the-_run-method] method, which should run the actor's\n    logic. The [`_run()`][frequenz.sdk.actor--the-_run-method] method is called by the\n    base class when the actor is started, and is expected to run until the actor is\n    stopped.\n    !!! info\n        Please read the [`actor` module documentation][frequenz.sdk.actor] for more\n        comprehensive guide on how to use and implement actors properly.\n    \"\"\"\nRESTART_DELAY: timedelta = timedelta(seconds=2)\n\"\"\"The delay to wait between restarts of this actor.\"\"\"\n_restart_limit: int | None = None\n\"\"\"The number of times actors can be restarted when they are stopped by unhandled exceptions.\n    If this is bigger than 0 or `None`, the actor will be restarted when there is an\n    unhanded exception in the `_run()` method.\n    If `None`, the actor will be restarted an unlimited number of times.\n    !!! note\n        This is mostly used for testing purposes and shouldn't be set in production.\n    \"\"\"\ndef start(self) -&gt; None:\n\"\"\"Start this actor.\n        If this actor is already running, this method does nothing.\n        \"\"\"\nif self.is_running:\nreturn\nself._tasks.clear()\nself._tasks.add(asyncio.create_task(self._run_loop()))\n@abc.abstractmethod\nasync def _run(self) -&gt; None:\n\"\"\"Run this actor's logic.\"\"\"\nasync def _delay_if_restart(self, iteration: int) -&gt; None:\n\"\"\"Delay the restart of this actor's n'th iteration.\n        Args:\n            iteration: The current iteration of the restart.\n        \"\"\"\n# NB: I think it makes sense (in the future) to think about deminishing returns\n# the longer the actor has been running.\n# Not just for the restart-delay but actually for the n_restarts counter as well.\nif iteration &gt; 0:\ndelay = self.RESTART_DELAY.total_seconds()\n_logger.info(\"Actor %s: Waiting %s seconds...\", self, delay)\nawait asyncio.sleep(delay)\nasync def _run_loop(self) -&gt; None:\n\"\"\"Run this actor's task in a loop until `_restart_limit` is reached.\n        Raises:\n            asyncio.CancelledError: If this actor's `_run()` gets cancelled.\n            Exception: If this actor's `_run()` raises any other `Exception` and reached\n                the maximum number of restarts.\n            BaseException: If this actor's `_run()` raises any other `BaseException`.\n        \"\"\"\n_logger.info(\"Actor %s: Started.\", self)\nn_restarts = 0\nwhile True:\ntry:\nawait self._delay_if_restart(n_restarts)\nawait self._run()\n_logger.info(\"Actor %s: _run() returned without error.\", self)\nexcept asyncio.CancelledError:\n_logger.info(\"Actor %s: Cancelled.\", self)\nraise\nexcept Exception:  # pylint: disable=broad-except\n_logger.exception(\"Actor %s: Raised an unhandled exception.\", self)\nlimit_str = \"\u221e\" if self._restart_limit is None else self._restart_limit\nlimit_str = f\"({n_restarts}/{limit_str})\"\nif self._restart_limit is None or n_restarts &lt; self._restart_limit:\nn_restarts += 1\n_logger.info(\"Actor %s: Restarting %s...\", self._name, limit_str)\ncontinue\n_logger.info(\n\"Actor %s: Maximum restarts attempted %s, bailing out...\",\nself,\nlimit_str,\n)\nraise\nexcept BaseException:  # pylint: disable=broad-except\n_logger.exception(\"Actor %s: Raised a BaseException.\", self)\nraise\nbreak\n_logger.info(\"Actor %s: Stopped.\", self)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: collections.abc.Set[asyncio.Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n\"\"\"Enter an async context.\n    Start this background service.\n    Returns:\n        This background service.\n    \"\"\"\nself.start()\nreturn self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\nself,\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Exit an async context.\n    Stop this background service.\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\nawait self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; collections.abc.Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n\"\"\"Await this background service.\n    An awaited background service will wait for all its tasks to finish.\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\nreturn self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Destroy this instance.\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\nself.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str | None = None) -&gt; None\n</code></pre> <p>Initialize this BackgroundService.</p> PARAMETER  DESCRIPTION <code>name</code> <p>The name of this background service. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __init__(self, *, name: str | None = None) -&gt; None:\n\"\"\"Initialize this BackgroundService.\n    Args:\n        name: The name of this background service. If `None`, `str(id(self))` will\n            be used. This is used mostly for debugging purposes.\n    \"\"\"\nself._name: str = str(id(self)) if name is None else name\nself._tasks: set[asyncio.Task[Any]] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n\"\"\"Cancel all running tasks spawned by this background service.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nfor task in self._tasks:\ntask.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start this actor.\n    If this actor is already running, this method does nothing.\n    \"\"\"\nif self.is_running:\nreturn\nself._tasks.clear()\nself._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this background service.\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\nif not self._tasks:\nreturn\nself.cancel(msg)\ntry:\nawait self.wait()\nexcept BaseExceptionGroup as exc_group:\n# We want to ignore CancelledError here as we explicitly cancelled all the\n# tasks.\n_, rest = exc_group.split(asyncio.CancelledError)\nif rest is not None:\n# We are filtering out from an exception group, we really don't want to\n# add the exceptions we just filtered by adding a from clause here.\nraise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n\"\"\"Wait this background service to finish.\n    Wait until all background service tasks are finished.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n# We need to account for tasks that were created between when we started\n# awaiting and we finished awaiting.\nwhile self._tasks:\ndone, pending = await asyncio.wait(self._tasks)\nassert not pending\n# We remove the done tasks, but there might be new ones created after we\n# started waiting.\nself._tasks = self._tasks - done\nexceptions: list[BaseException] = []\nfor task in done:\ntry:\n# This will raise a CancelledError if the task was cancelled or any\n# other exception if the task raised one.\n_ = task.result()\nexcept BaseException as error:  # pylint: disable=broad-except\nexceptions.append(error)\nif exceptions:\nraise BaseExceptionGroup(\nf\"Error while stopping background service {self}\", exceptions\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService","title":"frequenz.sdk.actor.BackgroundService","text":"<p>             Bases: <code>ABC</code></p> <p>A background service that can be started and stopped.</p> <p>A background service is a service that runs in the background spawning one or more tasks. The service can be started and stopped and can work as an async context manager to provide deterministic cleanup.</p> <p>To implement a background service, subclasses must implement the <code>start()</code> method, which should start the background tasks needed by the service, and add them to the <code>_tasks</code> protected attribute.</p> <p>If you need to collect results or handle exceptions of the tasks when stopping the service, then you need to also override the <code>stop()</code> method, as the base implementation does not collect any results and re-raises all exceptions.</p> <p>Warning</p> <p>As background services manage <code>asyncio.Task</code> objects, a reference to them must be held for as long as the background service is expected to be running, otherwise its tasks will be cancelled and the service will stop. For more information, please refer to the Python <code>asyncio</code> documentation.</p> Example <pre><code>import datetime\nimport asyncio\nclass Clock(BackgroundService):\ndef __init__(self, resolution_s: float, *, name: str | None = None) -&gt; None:\nsuper().__init__(name=name)\nself._resolution_s = resolution_s\ndef start(self) -&gt; None:\nself._tasks.add(asyncio.create_task(self._tick()))\nasync def _tick(self) -&gt; None:\nwhile True:\nawait asyncio.sleep(self._resolution_s)\nprint(datetime.datetime.now())\nasync def main() -&gt; None:\n# As an async context manager\nasync with Clock(resolution_s=1):\nawait asyncio.sleep(5)\n# Manual start/stop (only use if necessary, as cleanup is more complicated)\nclock = Clock(resolution_s=1)\nclock.start()\nawait asyncio.sleep(5)\nawait clock.stop()\nasyncio.run(main())\n</code></pre> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>class BackgroundService(abc.ABC):\n\"\"\"A background service that can be started and stopped.\n    A background service is a service that runs in the background spawning one or more\n    tasks. The service can be [started][frequenz.sdk.actor.BackgroundService.start]\n    and [stopped][frequenz.sdk.actor.BackgroundService.stop] and can work as an\n    async context manager to provide deterministic cleanup.\n    To implement a background service, subclasses must implement the\n    [`start()`][frequenz.sdk.actor.BackgroundService.start] method, which should\n    start the background tasks needed by the service, and add them to the `_tasks`\n    protected attribute.\n    If you need to collect results or handle exceptions of the tasks when stopping the\n    service, then you need to also override the\n    [`stop()`][frequenz.sdk.actor.BackgroundService.stop] method, as the base\n    implementation does not collect any results and re-raises all exceptions.\n    !!! warning\n        As background services manage [`asyncio.Task`][] objects, a reference to them\n        must be held for as long as the background service is expected to be running,\n        otherwise its tasks will be cancelled and the service will stop. For more\n        information, please refer to the [Python `asyncio`\n        documentation](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task).\n    Example:\n        ```python\n        import datetime\n        import asyncio\n        class Clock(BackgroundService):\n            def __init__(self, resolution_s: float, *, name: str | None = None) -&gt; None:\n                super().__init__(name=name)\n                self._resolution_s = resolution_s\n            def start(self) -&gt; None:\n                self._tasks.add(asyncio.create_task(self._tick()))\n            async def _tick(self) -&gt; None:\n                while True:\n                    await asyncio.sleep(self._resolution_s)\n                    print(datetime.datetime.now())\n        async def main() -&gt; None:\n            # As an async context manager\n            async with Clock(resolution_s=1):\n                await asyncio.sleep(5)\n            # Manual start/stop (only use if necessary, as cleanup is more complicated)\n            clock = Clock(resolution_s=1)\n            clock.start()\n            await asyncio.sleep(5)\n            await clock.stop()\n        asyncio.run(main())\n        ```\n    \"\"\"\ndef __init__(self, *, name: str | None = None) -&gt; None:\n\"\"\"Initialize this BackgroundService.\n        Args:\n            name: The name of this background service. If `None`, `str(id(self))` will\n                be used. This is used mostly for debugging purposes.\n        \"\"\"\nself._name: str = str(id(self)) if name is None else name\nself._tasks: set[asyncio.Task[Any]] = set()\n@abc.abstractmethod\ndef start(self) -&gt; None:\n\"\"\"Start this background service.\"\"\"\n@property\ndef name(self) -&gt; str:\n\"\"\"The name of this background service.\n        Returns:\n            The name of this background service.\n        \"\"\"\nreturn self._name\n@property\ndef tasks(self) -&gt; collections.abc.Set[asyncio.Task[Any]]:\n\"\"\"Return the set of running tasks spawned by this background service.\n        Users typically should not modify the tasks in the returned set and only use\n        them for informational purposes.\n        !!! danger\n            Changing the returned tasks may lead to unexpected behavior, don't do it\n            unless the class explicitly documents it is safe to do so.\n        Returns:\n            The set of running tasks spawned by this background service.\n        \"\"\"\nreturn self._tasks\n@property\ndef is_running(self) -&gt; bool:\n\"\"\"Return whether this background service is running.\n        A service is considered running when at least one task is running.\n        Returns:\n            Whether this background service is running.\n        \"\"\"\nreturn any(not task.done() for task in self._tasks)\ndef cancel(self, msg: str | None = None) -&gt; None:\n\"\"\"Cancel all running tasks spawned by this background service.\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\nfor task in self._tasks:\ntask.cancel(msg)\nasync def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this background service.\n        This method cancels all running tasks spawned by this service and waits for them\n        to finish.\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception.\n        [//]: # (# noqa: DAR401 rest)\n        \"\"\"\nif not self._tasks:\nreturn\nself.cancel(msg)\ntry:\nawait self.wait()\nexcept BaseExceptionGroup as exc_group:\n# We want to ignore CancelledError here as we explicitly cancelled all the\n# tasks.\n_, rest = exc_group.split(asyncio.CancelledError)\nif rest is not None:\n# We are filtering out from an exception group, we really don't want to\n# add the exceptions we just filtered by adding a from clause here.\nraise rest  # pylint: disable=raise-missing-from\nasync def __aenter__(self) -&gt; Self:\n\"\"\"Enter an async context.\n        Start this background service.\n        Returns:\n            This background service.\n        \"\"\"\nself.start()\nreturn self\nasync def __aexit__(\nself,\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Exit an async context.\n        Stop this background service.\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception raised, if any.\n            exc_tb: The traceback of the exception raised, if any.\n        \"\"\"\nawait self.stop()\nasync def wait(self) -&gt; None:\n\"\"\"Wait this background service to finish.\n        Wait until all background service tasks are finished.\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception (`CancelError` is not considered an error and not returned in\n                the exception group).\n        \"\"\"\n# We need to account for tasks that were created between when we started\n# awaiting and we finished awaiting.\nwhile self._tasks:\ndone, pending = await asyncio.wait(self._tasks)\nassert not pending\n# We remove the done tasks, but there might be new ones created after we\n# started waiting.\nself._tasks = self._tasks - done\nexceptions: list[BaseException] = []\nfor task in done:\ntry:\n# This will raise a CancelledError if the task was cancelled or any\n# other exception if the task raised one.\n_ = task.result()\nexcept BaseException as error:  # pylint: disable=broad-except\nexceptions.append(error)\nif exceptions:\nraise BaseExceptionGroup(\nf\"Error while stopping background service {self}\", exceptions\n)\ndef __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n\"\"\"Await this background service.\n        An awaited background service will wait for all its tasks to finish.\n        Returns:\n            An implementation-specific generator for the awaitable.\n        \"\"\"\nreturn self.wait().__await__()\ndef __del__(self) -&gt; None:\n\"\"\"Destroy this instance.\n        Cancel all running tasks spawned by this background service.\n        \"\"\"\nself.cancel(\"{self!r} was deleted\")\ndef __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n        Returns:\n            A string representation of this instance.\n        \"\"\"\nreturn f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\ndef __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n        Returns:\n            A string representation of this instance.\n        \"\"\"\nreturn f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: collections.abc.Set[asyncio.Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n\"\"\"Enter an async context.\n    Start this background service.\n    Returns:\n        This background service.\n    \"\"\"\nself.start()\nreturn self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\nself,\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Exit an async context.\n    Stop this background service.\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\nawait self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; collections.abc.Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n\"\"\"Await this background service.\n    An awaited background service will wait for all its tasks to finish.\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\nreturn self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Destroy this instance.\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\nself.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str | None = None) -&gt; None\n</code></pre> <p>Initialize this BackgroundService.</p> PARAMETER  DESCRIPTION <code>name</code> <p>The name of this background service. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __init__(self, *, name: str | None = None) -&gt; None:\n\"\"\"Initialize this BackgroundService.\n    Args:\n        name: The name of this background service. If `None`, `str(id(self))` will\n            be used. This is used mostly for debugging purposes.\n    \"\"\"\nself._name: str = str(id(self)) if name is None else name\nself._tasks: set[asyncio.Task[Any]] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n\"\"\"Cancel all running tasks spawned by this background service.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nfor task in self._tasks:\ntask.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.start","title":"start  <code>abstractmethod</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>@abc.abstractmethod\ndef start(self) -&gt; None:\n\"\"\"Start this background service.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this background service.\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\nif not self._tasks:\nreturn\nself.cancel(msg)\ntry:\nawait self.wait()\nexcept BaseExceptionGroup as exc_group:\n# We want to ignore CancelledError here as we explicitly cancelled all the\n# tasks.\n_, rest = exc_group.split(asyncio.CancelledError)\nif rest is not None:\n# We are filtering out from an exception group, we really don't want to\n# add the exceptions we just filtered by adding a from clause here.\nraise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n\"\"\"Wait this background service to finish.\n    Wait until all background service tasks are finished.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n# We need to account for tasks that were created between when we started\n# awaiting and we finished awaiting.\nwhile self._tasks:\ndone, pending = await asyncio.wait(self._tasks)\nassert not pending\n# We remove the done tasks, but there might be new ones created after we\n# started waiting.\nself._tasks = self._tasks - done\nexceptions: list[BaseException] = []\nfor task in done:\ntry:\n# This will raise a CancelledError if the task was cancelled or any\n# other exception if the task raised one.\n_ = task.result()\nexcept BaseException as error:  # pylint: disable=broad-except\nexceptions.append(error)\nif exceptions:\nraise BaseExceptionGroup(\nf\"Error while stopping background service {self}\", exceptions\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry","title":"frequenz.sdk.actor.ChannelRegistry","text":"<p>Dynamically creates, own and provide access to channels.</p> <p>It can be used by actors to dynamically establish a communication channel between each other.  Channels are identified by string names.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>class ChannelRegistry:\n\"\"\"Dynamically creates, own and provide access to channels.\n    It can be used by actors to dynamically establish a communication channel\n    between each other.  Channels are identified by string names.\n    \"\"\"\ndef __init__(self, *, name: str) -&gt; None:\n\"\"\"Create a `ChannelRegistry` instance.\n        Args:\n            name: A unique name for the registry.\n        \"\"\"\nself._name = name\nself._channels: dict[str, Broadcast[typing.Any]] = {}\ndef set_resend_latest(self, key: str, resend_latest: bool) -&gt; None:\n\"\"\"Set the `resend_latest` flag for a given channel.\n        This flag controls whether the latest value of the channel should be resent to\n        new receivers, in slow streams.\n        `resend_latest` is `False` by default.  It is safe to be set in data/reporting\n        channels, but is not recommended for use in channels that stream control\n        instructions.\n        Args:\n            key: The key to identify the channel.\n            resend_latest: Whether to resend the latest value to new receivers, for the\n                given channel.\n        \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\n# This attribute is protected in the current version of the channels library,\n# but that will change in the future.\nself._channels[  # pylint: disable=protected-access\nkey\n]._resend_latest = resend_latest\ndef new_sender(self, key: str) -&gt; Sender[typing.Any]:\n\"\"\"Get a sender to a dynamically created channel with the given key.\n        Args:\n            key: A key to identify the channel.\n        Returns:\n            A sender to a dynamically created channel with the given key.\n        \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\nreturn self._channels[key].new_sender()\ndef new_receiver(self, key: str, maxsize: int = 50) -&gt; Receiver[typing.Any]:\n\"\"\"Get a receiver to a dynamically created channel with the given key.\n        Args:\n            key: A key to identify the channel.\n            maxsize: The maximum size of the receiver.\n        Returns:\n            A receiver for a dynamically created channel with the given key.\n        \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\nreturn self._channels[key].new_receiver(maxsize=maxsize)\ndef new_receiver_fetcher(self, key: str) -&gt; ReceiverFetcher[typing.Any]:\n\"\"\"Get a receiver fetcher to a dynamically created channel with the given key.\n        Args:\n            key: A key to identify the channel.\n        Returns:\n            A receiver fetcher for a dynamically created channel with the given key.\n        \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\nreturn _RegistryReceiverFetcher(self, key)\nasync def _close_channel(self, key: str) -&gt; None:\n\"\"\"Close a channel with the given key.\n        This method is private and should only be used in special cases.\n        Args:\n            key: A key to identify the channel.\n        \"\"\"\nif key in self._channels:\nif channel := self._channels.pop(key, None):\nawait channel.close()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str) -&gt; None\n</code></pre> <p>Create a <code>ChannelRegistry</code> instance.</p> PARAMETER  DESCRIPTION <code>name</code> <p>A unique name for the registry.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def __init__(self, *, name: str) -&gt; None:\n\"\"\"Create a `ChannelRegistry` instance.\n    Args:\n        name: A unique name for the registry.\n    \"\"\"\nself._name = name\nself._channels: dict[str, Broadcast[typing.Any]] = {}\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver(\nkey: str, maxsize: int = 50\n) -&gt; Receiver[typing.Any]\n</code></pre> <p>Get a receiver to a dynamically created channel with the given key.</p> PARAMETER  DESCRIPTION <code>key</code> <p>A key to identify the channel.</p> <p> TYPE: <code>str</code> </p> <code>maxsize</code> <p>The maximum size of the receiver.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[Any]</code> <p>A receiver for a dynamically created channel with the given key.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def new_receiver(self, key: str, maxsize: int = 50) -&gt; Receiver[typing.Any]:\n\"\"\"Get a receiver to a dynamically created channel with the given key.\n    Args:\n        key: A key to identify the channel.\n        maxsize: The maximum size of the receiver.\n    Returns:\n        A receiver for a dynamically created channel with the given key.\n    \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\nreturn self._channels[key].new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.new_receiver_fetcher","title":"new_receiver_fetcher","text":"<pre><code>new_receiver_fetcher(\nkey: str,\n) -&gt; ReceiverFetcher[typing.Any]\n</code></pre> <p>Get a receiver fetcher to a dynamically created channel with the given key.</p> PARAMETER  DESCRIPTION <code>key</code> <p>A key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ReceiverFetcher[Any]</code> <p>A receiver fetcher for a dynamically created channel with the given key.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def new_receiver_fetcher(self, key: str) -&gt; ReceiverFetcher[typing.Any]:\n\"\"\"Get a receiver fetcher to a dynamically created channel with the given key.\n    Args:\n        key: A key to identify the channel.\n    Returns:\n        A receiver fetcher for a dynamically created channel with the given key.\n    \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\nreturn _RegistryReceiverFetcher(self, key)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.new_sender","title":"new_sender","text":"<pre><code>new_sender(key: str) -&gt; Sender[typing.Any]\n</code></pre> <p>Get a sender to a dynamically created channel with the given key.</p> PARAMETER  DESCRIPTION <code>key</code> <p>A key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Sender[Any]</code> <p>A sender to a dynamically created channel with the given key.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def new_sender(self, key: str) -&gt; Sender[typing.Any]:\n\"\"\"Get a sender to a dynamically created channel with the given key.\n    Args:\n        key: A key to identify the channel.\n    Returns:\n        A sender to a dynamically created channel with the given key.\n    \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\nreturn self._channels[key].new_sender()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.set_resend_latest","title":"set_resend_latest","text":"<pre><code>set_resend_latest(key: str, resend_latest: bool) -&gt; None\n</code></pre> <p>Set the <code>resend_latest</code> flag for a given channel.</p> <p>This flag controls whether the latest value of the channel should be resent to new receivers, in slow streams.</p> <p><code>resend_latest</code> is <code>False</code> by default.  It is safe to be set in data/reporting channels, but is not recommended for use in channels that stream control instructions.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key to identify the channel.</p> <p> TYPE: <code>str</code> </p> <code>resend_latest</code> <p>Whether to resend the latest value to new receivers, for the given channel.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def set_resend_latest(self, key: str, resend_latest: bool) -&gt; None:\n\"\"\"Set the `resend_latest` flag for a given channel.\n    This flag controls whether the latest value of the channel should be resent to\n    new receivers, in slow streams.\n    `resend_latest` is `False` by default.  It is safe to be set in data/reporting\n    channels, but is not recommended for use in channels that stream control\n    instructions.\n    Args:\n        key: The key to identify the channel.\n        resend_latest: Whether to resend the latest value to new receivers, for the\n            given channel.\n    \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\n# This attribute is protected in the current version of the channels library,\n# but that will change in the future.\nself._channels[  # pylint: disable=protected-access\nkey\n]._resend_latest = resend_latest\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest","title":"frequenz.sdk.actor.ComponentMetricRequest  <code>dataclass</code>","text":"<p>A request object to start streaming a metric for a component.</p> Source code in <code>frequenz/sdk/actor/_data_sourcing/_component_metric_request.py</code> <pre><code>@dataclass\nclass ComponentMetricRequest:\n\"\"\"A request object to start streaming a metric for a component.\"\"\"\nnamespace: str\n\"\"\"The namespace that this request belongs to.\n    Metric requests with a shared namespace enable the reuse of channels within\n    that namespace.\n    If for example, an actor making a multiple requests, uses the name of the\n    actor as the namespace, then requests from the actor will get reused when\n    possible.\n    \"\"\"\ncomponent_id: int\n\"\"\"The ID of the requested component.\"\"\"\nmetric_id: ComponentMetricId\n\"\"\"The ID of the requested component's metric.\"\"\"\nstart_time: datetime | None\n\"\"\"The start time from which data is required.\n    When None, we will stream only live data.\n    \"\"\"\ndef get_channel_name(self) -&gt; str:\n\"\"\"Return a channel name constructed from Self.\n        This channel name can be used by the sending side and receiving sides to\n        identify the right channel from the ChannelRegistry.\n        Returns:\n            A string denoting a channel name.\n        \"\"\"\nreturn (\nf\"component-stream::{self.component_id}::{self.metric_id.name}::\"\nf\"{self.start_time}::{self.namespace}\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID of the requested component.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.metric_id","title":"metric_id  <code>instance-attribute</code>","text":"<pre><code>metric_id: ComponentMetricId\n</code></pre> <p>The ID of the requested component's metric.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.namespace","title":"namespace  <code>instance-attribute</code>","text":"<pre><code>namespace: str\n</code></pre> <p>The namespace that this request belongs to.</p> <p>Metric requests with a shared namespace enable the reuse of channels within that namespace.</p> <p>If for example, an actor making a multiple requests, uses the name of the actor as the namespace, then requests from the actor will get reused when possible.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.start_time","title":"start_time  <code>instance-attribute</code>","text":"<pre><code>start_time: datetime | None\n</code></pre> <p>The start time from which data is required.</p> <p>When None, we will stream only live data.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.get_channel_name","title":"get_channel_name","text":"<pre><code>get_channel_name() -&gt; str\n</code></pre> <p>Return a channel name constructed from Self.</p> <p>This channel name can be used by the sending side and receiving sides to identify the right channel from the ChannelRegistry.</p> RETURNS DESCRIPTION <code>str</code> <p>A string denoting a channel name.</p> Source code in <code>frequenz/sdk/actor/_data_sourcing/_component_metric_request.py</code> <pre><code>def get_channel_name(self) -&gt; str:\n\"\"\"Return a channel name constructed from Self.\n    This channel name can be used by the sending side and receiving sides to\n    identify the right channel from the ChannelRegistry.\n    Returns:\n        A string denoting a channel name.\n    \"\"\"\nreturn (\nf\"component-stream::{self.component_id}::{self.metric_id.name}::\"\nf\"{self.start_time}::{self.namespace}\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor","title":"frequenz.sdk.actor.ComponentMetricsResamplingActor","text":"<p>             Bases: <code>Actor</code></p> <p>An actor to resample microgrid component metrics.</p> Source code in <code>frequenz/sdk/actor/_resampling.py</code> <pre><code>class ComponentMetricsResamplingActor(Actor):\n\"\"\"An actor to resample microgrid component metrics.\"\"\"\ndef __init__(  # pylint: disable=too-many-arguments\nself,\n*,\nchannel_registry: ChannelRegistry,\ndata_sourcing_request_sender: Sender[ComponentMetricRequest],\nresampling_request_receiver: Receiver[ComponentMetricRequest],\nconfig: ResamplerConfig,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Initialize an instance.\n        Args:\n            channel_registry: The channel registry used to get senders and\n                receivers for data sourcing subscriptions.\n            data_sourcing_request_sender: The sender used to send requests to\n                the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor]\n                to subscribe to component metrics.\n            resampling_request_receiver: The receiver to use to receive new\n                resampling subscription requests.\n            config: The configuration for the resampler.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\nsuper().__init__(name=name)\nself._channel_registry: ChannelRegistry = channel_registry\nself._data_sourcing_request_sender: Sender[\nComponentMetricRequest\n] = data_sourcing_request_sender\nself._resampling_request_receiver: Receiver[\nComponentMetricRequest\n] = resampling_request_receiver\nself._resampler: Resampler = Resampler(config)\nself._active_req_channels: set[str] = set()\nasync def _subscribe(self, request: ComponentMetricRequest) -&gt; None:\n\"\"\"Request data for a component metric.\n        Args:\n            request: The request for component metric data.\n        \"\"\"\nrequest_channel_name = request.get_channel_name()\n# If we are already handling this request, there is nothing to do.\nif request_channel_name in self._active_req_channels:\nreturn\nself._active_req_channels.add(request_channel_name)\ndata_source_request = dataclasses.replace(\nrequest, namespace=request.namespace + \":Source\"\n)\ndata_source_channel_name = data_source_request.get_channel_name()\nawait self._data_sourcing_request_sender.send(data_source_request)\nreceiver = self._channel_registry.new_receiver(data_source_channel_name)\n# This is a temporary hack until the Sender implementation uses\n# exceptions to report errors.\nsender = self._channel_registry.new_sender(request_channel_name)\nasync def sink_adapter(sample: Sample[Quantity]) -&gt; None:\nawait sender.send(sample)\nself._resampler.add_timeseries(request_channel_name, receiver, sink_adapter)\nasync def _process_resampling_requests(self) -&gt; None:\n\"\"\"Process resampling data requests.\"\"\"\nasync for request in self._resampling_request_receiver:\nawait self._subscribe(request)\nasync def _run(self) -&gt; None:\n\"\"\"Resample known component metrics and process resampling requests.\n        If there is a resampling error while resampling some component metric,\n        then that metric will be discarded and not resampled any more. Any\n        other error will be propagated (most likely ending in the actor being\n        restarted).\n        This method creates 2 main tasks:\n        - One task to process incoming subscription requests to resample new metrics.\n        - One task to run the resampler.\n        Raises:\n            RuntimeError: If there is some unexpected error while resampling or\n                handling requests.\n        [//]: # (# noqa: DAR401 error)\n        \"\"\"\ntasks_to_cancel: set[asyncio.Task[None]] = set()\ntry:\nsubscriptions_task = asyncio.create_task(\nself._process_resampling_requests()\n)\ntasks_to_cancel.add(subscriptions_task)\nwhile True:\nresampling_task = asyncio.create_task(self._resampler.resample())\ntasks_to_cancel.add(resampling_task)\ndone, _ = await asyncio.wait(\n[resampling_task, subscriptions_task],\nreturn_when=asyncio.FIRST_COMPLETED,\n)\nif subscriptions_task in done:\ntasks_to_cancel.remove(subscriptions_task)\nraise RuntimeError(\n\"There was a problem with the subscriptions channel.\"\n)\nif resampling_task in done:\ntasks_to_cancel.remove(resampling_task)\n# The resampler shouldn't end without an exception\nerror = resampling_task.exception()\nassert (\nerror is not None\n), \"The resample() function shouldn't exit normally.\"\n# We don't know what to do with something other than\n# ResamplingError, so propagate the exception if that is the\n# case.\nif not isinstance(error, ResamplingError):\nraise error\nfor source, source_error in error.exceptions.items():\n_logger.error(\n\"Error resampling source %s, removing source...\", source\n)\nremoved = self._resampler.remove_timeseries(source)\nif not removed:\n_logger.warning(\n\"Got an exception from an unknown source: \"\n\"source=%r, exception=%r\",\nsource,\nsource_error,\n)\n# The resampling_task will be re-created if we reached this point\nfinally:\nawait asyncio.gather(*[cancel_and_await(t) for t in tasks_to_cancel])\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: collections.abc.Set[asyncio.Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n\"\"\"Enter an async context.\n    Start this background service.\n    Returns:\n        This background service.\n    \"\"\"\nself.start()\nreturn self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\nself,\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Exit an async context.\n    Stop this background service.\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\nawait self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; collections.abc.Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n\"\"\"Await this background service.\n    An awaited background service will wait for all its tasks to finish.\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\nreturn self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Destroy this instance.\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\nself.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n*,\nchannel_registry: ChannelRegistry,\ndata_sourcing_request_sender: Sender[\nComponentMetricRequest\n],\nresampling_request_receiver: Receiver[\nComponentMetricRequest\n],\nconfig: ResamplerConfig,\nname: str | None = None\n) -&gt; None\n</code></pre> <p>Initialize an instance.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>The channel registry used to get senders and receivers for data sourcing subscriptions.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>data_sourcing_request_sender</code> <p>The sender used to send requests to the <code>DataSourcingActor</code> to subscribe to component metrics.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>resampling_request_receiver</code> <p>The receiver to use to receive new resampling subscription requests.</p> <p> TYPE: <code>Receiver[ComponentMetricRequest]</code> </p> <code>config</code> <p>The configuration for the resampler.</p> <p> TYPE: <code>ResamplerConfig</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_resampling.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\nself,\n*,\nchannel_registry: ChannelRegistry,\ndata_sourcing_request_sender: Sender[ComponentMetricRequest],\nresampling_request_receiver: Receiver[ComponentMetricRequest],\nconfig: ResamplerConfig,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Initialize an instance.\n    Args:\n        channel_registry: The channel registry used to get senders and\n            receivers for data sourcing subscriptions.\n        data_sourcing_request_sender: The sender used to send requests to\n            the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor]\n            to subscribe to component metrics.\n        resampling_request_receiver: The receiver to use to receive new\n            resampling subscription requests.\n        config: The configuration for the resampler.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\nsuper().__init__(name=name)\nself._channel_registry: ChannelRegistry = channel_registry\nself._data_sourcing_request_sender: Sender[\nComponentMetricRequest\n] = data_sourcing_request_sender\nself._resampling_request_receiver: Receiver[\nComponentMetricRequest\n] = resampling_request_receiver\nself._resampler: Resampler = Resampler(config)\nself._active_req_channels: set[str] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n\"\"\"Cancel all running tasks spawned by this background service.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nfor task in self._tasks:\ntask.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start this actor.\n    If this actor is already running, this method does nothing.\n    \"\"\"\nif self.is_running:\nreturn\nself._tasks.clear()\nself._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this background service.\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\nif not self._tasks:\nreturn\nself.cancel(msg)\ntry:\nawait self.wait()\nexcept BaseExceptionGroup as exc_group:\n# We want to ignore CancelledError here as we explicitly cancelled all the\n# tasks.\n_, rest = exc_group.split(asyncio.CancelledError)\nif rest is not None:\n# We are filtering out from an exception group, we really don't want to\n# add the exceptions we just filtered by adding a from clause here.\nraise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n\"\"\"Wait this background service to finish.\n    Wait until all background service tasks are finished.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n# We need to account for tasks that were created between when we started\n# awaiting and we finished awaiting.\nwhile self._tasks:\ndone, pending = await asyncio.wait(self._tasks)\nassert not pending\n# We remove the done tasks, but there might be new ones created after we\n# started waiting.\nself._tasks = self._tasks - done\nexceptions: list[BaseException] = []\nfor task in done:\ntry:\n# This will raise a CancelledError if the task was cancelled or any\n# other exception if the task raised one.\n_ = task.result()\nexcept BaseException as error:  # pylint: disable=broad-except\nexceptions.append(error)\nif exceptions:\nraise BaseExceptionGroup(\nf\"Error while stopping background service {self}\", exceptions\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor","title":"frequenz.sdk.actor.ConfigManagingActor","text":"<p>             Bases: <code>Actor</code></p> <p>An actor that monitors a TOML configuration file for updates.</p> <p>When the file is updated, the new configuration is sent, as a <code>dict</code>, to the <code>output</code> sender.</p> <p>When the actor is started, if a configuration file already exists, then it will be read and sent to the <code>output</code> sender before the actor starts monitoring the file for updates. This way users can rely on the actor to do the initial configuration reading too.</p> Source code in <code>frequenz/sdk/actor/_config_managing.py</code> <pre><code>class ConfigManagingActor(Actor):\n\"\"\"An actor that monitors a TOML configuration file for updates.\n    When the file is updated, the new configuration is sent, as a [`dict`][], to the\n    `output` sender.\n    When the actor is started, if a configuration file already exists, then it will be\n    read and sent to the `output` sender before the actor starts monitoring the file\n    for updates. This way users can rely on the actor to do the initial configuration\n    reading too.\n    \"\"\"\ndef __init__(\nself,\nconfig_path: pathlib.Path | str,\noutput: Sender[Config],\nevent_types: abc.Set[FileWatcher.EventType] = frozenset(FileWatcher.EventType),\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Initialize this instance.\n        Args:\n            config_path: The path to the TOML file with the configuration.\n            output: The sender to send the config to.\n            event_types: The set of event types to monitor.\n            name: The name of the actor. If `None`, `str(id(self))` will\n                be used. This is used mostly for debugging purposes.\n        \"\"\"\nsuper().__init__(name=name)\nself._config_path: pathlib.Path = (\nconfig_path\nif isinstance(config_path, pathlib.Path)\nelse pathlib.Path(config_path)\n)\n# FileWatcher can't watch for non-existing files, so we need to watch for the\n# parent directory instead just in case a configuration file doesn't exist yet\n# or it is deleted and recreated again.\nself._file_watcher: FileWatcher = FileWatcher(\npaths=[self._config_path.parent], event_types=event_types\n)\nself._output: Sender[Config] = output\ndef _read_config(self) -&gt; dict[str, Any]:\n\"\"\"Read the contents of the configuration file.\n        Returns:\n            A dictionary containing configuration variables.\n        Raises:\n            ValueError: If config file cannot be read.\n        \"\"\"\ntry:\nwith self._config_path.open(\"rb\") as toml_file:\nreturn tomllib.load(toml_file)\nexcept ValueError as err:\nlogging.error(\"%s: Can't read config file, err: %s\", self, err)\nraise\nasync def send_config(self) -&gt; None:\n\"\"\"Send the configuration to the output sender.\"\"\"\nconf_vars = self._read_config()\nconfig = Config(conf_vars)\nawait self._output.send(config)\nasync def _run(self) -&gt; None:\n\"\"\"Monitor for and send configuration file updates.\n        At startup, the Config Manager sends the current config so that it\n        can be cache in the Broadcast channel and served to receivers even if\n        there hasn't been any change to the config file itself.\n        \"\"\"\nawait self.send_config()\nasync for event in self._file_watcher:\n# Since we are watching the whole parent directory, we need to make sure\n# we only react to events related to the configuration file.\nif event.path != self._config_path:\ncontinue\nmatch event.type:\ncase FileWatcher.EventType.CREATE:\n_logger.info(\n\"%s: The configuration file %s was created, sending new config...\",\nself,\nself._config_path,\n)\nawait self.send_config()\ncase FileWatcher.EventType.MODIFY:\n_logger.info(\n\"%s: The configuration file %s was modified, sending update...\",\nself,\nself._config_path,\n)\nawait self.send_config()\ncase FileWatcher.EventType.DELETE:\n_logger.info(\n\"%s: The configuration file %s was deleted, ignoring...\",\nself,\nself._config_path,\n)\ncase _:\nassert_never(event.type)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: collections.abc.Set[asyncio.Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n\"\"\"Enter an async context.\n    Start this background service.\n    Returns:\n        This background service.\n    \"\"\"\nself.start()\nreturn self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\nself,\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Exit an async context.\n    Stop this background service.\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\nawait self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; collections.abc.Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n\"\"\"Await this background service.\n    An awaited background service will wait for all its tasks to finish.\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\nreturn self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Destroy this instance.\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\nself.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__init__","title":"__init__","text":"<pre><code>__init__(\nconfig_path: pathlib.Path | str,\noutput: Sender[Config],\nevent_types: abc.Set[FileWatcher.EventType] = frozenset(\nFileWatcher.EventType\n),\n*,\nname: str | None = None\n) -&gt; None\n</code></pre> <p>Initialize this instance.</p> PARAMETER  DESCRIPTION <code>config_path</code> <p>The path to the TOML file with the configuration.</p> <p> TYPE: <code>Path | str</code> </p> <code>output</code> <p>The sender to send the config to.</p> <p> TYPE: <code>Sender[Config]</code> </p> <code>event_types</code> <p>The set of event types to monitor.</p> <p> TYPE: <code>Set[EventType]</code> DEFAULT: <code>frozenset(EventType)</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_config_managing.py</code> <pre><code>def __init__(\nself,\nconfig_path: pathlib.Path | str,\noutput: Sender[Config],\nevent_types: abc.Set[FileWatcher.EventType] = frozenset(FileWatcher.EventType),\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Initialize this instance.\n    Args:\n        config_path: The path to the TOML file with the configuration.\n        output: The sender to send the config to.\n        event_types: The set of event types to monitor.\n        name: The name of the actor. If `None`, `str(id(self))` will\n            be used. This is used mostly for debugging purposes.\n    \"\"\"\nsuper().__init__(name=name)\nself._config_path: pathlib.Path = (\nconfig_path\nif isinstance(config_path, pathlib.Path)\nelse pathlib.Path(config_path)\n)\n# FileWatcher can't watch for non-existing files, so we need to watch for the\n# parent directory instead just in case a configuration file doesn't exist yet\n# or it is deleted and recreated again.\nself._file_watcher: FileWatcher = FileWatcher(\npaths=[self._config_path.parent], event_types=event_types\n)\nself._output: Sender[Config] = output\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n\"\"\"Cancel all running tasks spawned by this background service.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nfor task in self._tasks:\ntask.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.send_config","title":"send_config  <code>async</code>","text":"<pre><code>send_config() -&gt; None\n</code></pre> <p>Send the configuration to the output sender.</p> Source code in <code>frequenz/sdk/actor/_config_managing.py</code> <pre><code>async def send_config(self) -&gt; None:\n\"\"\"Send the configuration to the output sender.\"\"\"\nconf_vars = self._read_config()\nconfig = Config(conf_vars)\nawait self._output.send(config)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start this actor.\n    If this actor is already running, this method does nothing.\n    \"\"\"\nif self.is_running:\nreturn\nself._tasks.clear()\nself._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this background service.\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\nif not self._tasks:\nreturn\nself.cancel(msg)\ntry:\nawait self.wait()\nexcept BaseExceptionGroup as exc_group:\n# We want to ignore CancelledError here as we explicitly cancelled all the\n# tasks.\n_, rest = exc_group.split(asyncio.CancelledError)\nif rest is not None:\n# We are filtering out from an exception group, we really don't want to\n# add the exceptions we just filtered by adding a from clause here.\nraise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n\"\"\"Wait this background service to finish.\n    Wait until all background service tasks are finished.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n# We need to account for tasks that were created between when we started\n# awaiting and we finished awaiting.\nwhile self._tasks:\ndone, pending = await asyncio.wait(self._tasks)\nassert not pending\n# We remove the done tasks, but there might be new ones created after we\n# started waiting.\nself._tasks = self._tasks - done\nexceptions: list[BaseException] = []\nfor task in done:\ntry:\n# This will raise a CancelledError if the task was cancelled or any\n# other exception if the task raised one.\n_ = task.result()\nexcept BaseException as error:  # pylint: disable=broad-except\nexceptions.append(error)\nif exceptions:\nraise BaseExceptionGroup(\nf\"Error while stopping background service {self}\", exceptions\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor","title":"frequenz.sdk.actor.DataSourcingActor","text":"<p>             Bases: <code>Actor</code></p> <p>An actor that provides data streams of metrics as time series.</p> Source code in <code>frequenz/sdk/actor/_data_sourcing/data_sourcing.py</code> <pre><code>class DataSourcingActor(Actor):\n\"\"\"An actor that provides data streams of metrics as time series.\"\"\"\ndef __init__(\nself,\nrequest_receiver: Receiver[ComponentMetricRequest],\nregistry: ChannelRegistry,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create a `DataSourcingActor` instance.\n        Args:\n            request_receiver: A channel receiver to accept metric requests from.\n            registry: A channel registry.  To be replaced by a singleton\n                instance.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\nsuper().__init__(name=name)\nself._request_receiver = request_receiver\nself._microgrid_api_source = MicrogridApiSource(registry)\nasync def _run(self) -&gt; None:\n\"\"\"Run the actor.\"\"\"\nasync for request in self._request_receiver:\nawait self._microgrid_api_source.add_metric(request)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: collections.abc.Set[asyncio.Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n\"\"\"Enter an async context.\n    Start this background service.\n    Returns:\n        This background service.\n    \"\"\"\nself.start()\nreturn self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\nself,\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Exit an async context.\n    Stop this background service.\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\nawait self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; collections.abc.Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n\"\"\"Await this background service.\n    An awaited background service will wait for all its tasks to finish.\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\nreturn self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Destroy this instance.\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\nself.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__init__","title":"__init__","text":"<pre><code>__init__(\nrequest_receiver: Receiver[ComponentMetricRequest],\nregistry: ChannelRegistry,\n*,\nname: str | None = None\n) -&gt; None\n</code></pre> <p>Create a <code>DataSourcingActor</code> instance.</p> PARAMETER  DESCRIPTION <code>request_receiver</code> <p>A channel receiver to accept metric requests from.</p> <p> TYPE: <code>Receiver[ComponentMetricRequest]</code> </p> <code>registry</code> <p>A channel registry.  To be replaced by a singleton instance.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_data_sourcing/data_sourcing.py</code> <pre><code>def __init__(\nself,\nrequest_receiver: Receiver[ComponentMetricRequest],\nregistry: ChannelRegistry,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create a `DataSourcingActor` instance.\n    Args:\n        request_receiver: A channel receiver to accept metric requests from.\n        registry: A channel registry.  To be replaced by a singleton\n            instance.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\nsuper().__init__(name=name)\nself._request_receiver = request_receiver\nself._microgrid_api_source = MicrogridApiSource(registry)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n\"\"\"Cancel all running tasks spawned by this background service.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nfor task in self._tasks:\ntask.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start this actor.\n    If this actor is already running, this method does nothing.\n    \"\"\"\nif self.is_running:\nreturn\nself._tasks.clear()\nself._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this background service.\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\nif not self._tasks:\nreturn\nself.cancel(msg)\ntry:\nawait self.wait()\nexcept BaseExceptionGroup as exc_group:\n# We want to ignore CancelledError here as we explicitly cancelled all the\n# tasks.\n_, rest = exc_group.split(asyncio.CancelledError)\nif rest is not None:\n# We are filtering out from an exception group, we really don't want to\n# add the exceptions we just filtered by adding a from clause here.\nraise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n\"\"\"Wait this background service to finish.\n    Wait until all background service tasks are finished.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n# We need to account for tasks that were created between when we started\n# awaiting and we finished awaiting.\nwhile self._tasks:\ndone, pending = await asyncio.wait(self._tasks)\nassert not pending\n# We remove the done tasks, but there might be new ones created after we\n# started waiting.\nself._tasks = self._tasks - done\nexceptions: list[BaseException] = []\nfor task in done:\ntry:\n# This will raise a CancelledError if the task was cancelled or any\n# other exception if the task raised one.\n_ = task.result()\nexcept BaseException as error:  # pylint: disable=broad-except\nexceptions.append(error)\nif exceptions:\nraise BaseExceptionGroup(\nf\"Error while stopping background service {self}\", exceptions\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig","title":"frequenz.sdk.actor.ResamplerConfig  <code>dataclass</code>","text":"<p>Resampler configuration.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>@dataclass(frozen=True)\nclass ResamplerConfig:\n\"\"\"Resampler configuration.\"\"\"\nresampling_period: timedelta\n\"\"\"The resampling period.\n    This is the time it passes between resampled data should be calculated.\n    It must be a positive time span.\n    \"\"\"\nmax_data_age_in_periods: float = 3.0\n\"\"\"The maximum age a sample can have to be considered *relevant* for resampling.\n    Expressed in number of periods, where period is the `resampling_period`\n    if we are downsampling (resampling period bigger than the input period) or\n    the input sampling period if we are upsampling (input period bigger than\n    the resampling period).\n    It must be bigger than 1.0.\n    Example:\n        If `resampling_period` is 3 seconds, the input sampling period is\n        1 and `max_data_age_in_periods` is 2, then data older than 3*2\n        = 6 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n        If `resampling_period` is 3 seconds, the input sampling period is\n        5 and `max_data_age_in_periods` is 2, then data older than 5*2\n        = 10 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n    \"\"\"\nresampling_function: ResamplingFunction = average\n\"\"\"The resampling function.\n    This function will be applied to the sequence of relevant samples at\n    a given time. The result of the function is what is sent as the resampled\n    value.\n    \"\"\"\ninitial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n\"\"\"The initial length of the resampling buffer.\n    The buffer could grow or shrink depending on the source properties,\n    like sampling rate, to make sure all the requested past sampling periods\n    can be stored.\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\nwarn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n\"\"\"The minimum length of the resampling buffer that will emit a warning.\n    If a buffer grows bigger than this value, it will emit a warning in the\n    logs, so buffers don't grow too big inadvertently.\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\nmax_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n\"\"\"The maximum length of the resampling buffer.\n    Buffers won't be allowed to grow beyond this point even if it would be\n    needed to keep all the requested past sampling periods. An error will be\n    emitted in the logs if the buffer length needs to be truncated to this\n    value.\n    It must be at bigger than `warn_buffer_len`.\n    \"\"\"\nalign_to: datetime | None = UNIX_EPOCH\n\"\"\"The time to align the resampling period to.\n    The resampling period will be aligned to this time, so the first resampled\n    sample will be at the first multiple of `resampling_period` starting from\n    `align_to`. It must be an aware datetime and can be in the future too.\n    If `align_to` is `None`, the resampling period will be aligned to the\n    time the resampler is created.\n    \"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n        Raises:\n            ValueError: If any value is out of range.\n        \"\"\"\nif self.resampling_period.total_seconds() &lt; 0.0:\nraise ValueError(\nf\"resampling_period ({self.resampling_period}) must be positive\"\n)\nif self.max_data_age_in_periods &lt; 1.0:\nraise ValueError(\nf\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n)\nif self.warn_buffer_len &lt; 1:\nraise ValueError(\nf\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n)\nif self.max_buffer_len &lt;= self.warn_buffer_len:\nraise ValueError(\nf\"max_buffer_len ({self.max_buffer_len}) should \"\nf\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n)\nif self.initial_buffer_len &lt; 1:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n)\nif self.initial_buffer_len &gt; self.max_buffer_len:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\nf\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n\"initial_buffer_len or a bigger max_buffer_len\"\n)\nif self.initial_buffer_len &gt; self.warn_buffer_len:\n_logger.warning(\n\"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\nself.initial_buffer_len,\nself.warn_buffer_len,\n)\nif self.align_to is not None and self.align_to.tzinfo is None:\nraise ValueError(\nf\"align_to ({self.align_to}) should be a timezone aware datetime\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.align_to","title":"align_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>align_to: datetime | None = UNIX_EPOCH\n</code></pre> <p>The time to align the resampling period to.</p> <p>The resampling period will be aligned to this time, so the first resampled sample will be at the first multiple of <code>resampling_period</code> starting from <code>align_to</code>. It must be an aware datetime and can be in the future too.</p> <p>If <code>align_to</code> is <code>None</code>, the resampling period will be aligned to the time the resampler is created.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.initial_buffer_len","title":"initial_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n</code></pre> <p>The initial length of the resampling buffer.</p> <p>The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.max_buffer_len","title":"max_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n</code></pre> <p>The maximum length of the resampling buffer.</p> <p>Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value.</p> <p>It must be at bigger than <code>warn_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.max_data_age_in_periods","title":"max_data_age_in_periods  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_data_age_in_periods: float = 3.0\n</code></pre> <p>The maximum age a sample can have to be considered relevant for resampling.</p> <p>Expressed in number of periods, where period is the <code>resampling_period</code> if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period).</p> <p>It must be bigger than 1.0.</p> Example <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 1 and <code>max_data_age_in_periods</code> is 2, then data older than 3*2 = 6 seconds will be discarded when creating a new sample and never passed to the resampling function.</p> <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 5 and <code>max_data_age_in_periods</code> is 2, then data older than 5*2 = 10 seconds will be discarded when creating a new sample and never passed to the resampling function.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.resampling_function","title":"resampling_function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resampling_function: ResamplingFunction = average\n</code></pre> <p>The resampling function.</p> <p>This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.resampling_period","title":"resampling_period  <code>instance-attribute</code>","text":"<pre><code>resampling_period: timedelta\n</code></pre> <p>The resampling period.</p> <p>This is the time it passes between resampled data should be calculated.</p> <p>It must be a positive time span.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.warn_buffer_len","title":"warn_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n</code></pre> <p>The minimum length of the resampling buffer that will emit a warning.</p> <p>If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertently.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Check that config values are valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any value is out of range.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n    Raises:\n        ValueError: If any value is out of range.\n    \"\"\"\nif self.resampling_period.total_seconds() &lt; 0.0:\nraise ValueError(\nf\"resampling_period ({self.resampling_period}) must be positive\"\n)\nif self.max_data_age_in_periods &lt; 1.0:\nraise ValueError(\nf\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n)\nif self.warn_buffer_len &lt; 1:\nraise ValueError(\nf\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n)\nif self.max_buffer_len &lt;= self.warn_buffer_len:\nraise ValueError(\nf\"max_buffer_len ({self.max_buffer_len}) should \"\nf\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n)\nif self.initial_buffer_len &lt; 1:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n)\nif self.initial_buffer_len &gt; self.max_buffer_len:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\nf\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n\"initial_buffer_len or a bigger max_buffer_len\"\n)\nif self.initial_buffer_len &gt; self.warn_buffer_len:\n_logger.warning(\n\"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\nself.initial_buffer_len,\nself.warn_buffer_len,\n)\nif self.align_to is not None and self.align_to.tzinfo is None:\nraise ValueError(\nf\"align_to ({self.align_to}) should be a timezone aware datetime\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.run","title":"frequenz.sdk.actor.run  <code>async</code>","text":"<pre><code>run(*actors: Actor) -&gt; None\n</code></pre> <p>Await the completion of all actors.</p> <p>Info</p> <p>Please read the <code>actor</code> module documentation for more comprehensive guide on how to use and implement actors properly.</p> PARAMETER  DESCRIPTION <code>*actors</code> <p>the actors to be awaited.</p> <p> TYPE: <code>Actor</code> DEFAULT: <code>()</code> </p> Source code in <code>frequenz/sdk/actor/_run_utils.py</code> <pre><code>async def run(*actors: Actor) -&gt; None:\n\"\"\"Await the completion of all actors.\n    !!! info\n        Please read the [`actor` module documentation][frequenz.sdk.actor] for more\n        comprehensive guide on how to use and implement actors properly.\n    Args:\n        *actors: the actors to be awaited.\n    \"\"\"\n_logger.info(\"Starting %s actor(s)...\", len(actors))\nfor actor in actors:\nif actor.is_running:\n_logger.info(\"Actor %s: Already running, skipping start.\", actor)\nelse:\n_logger.info(\"Actor %s: Starting...\", actor)\nactor.start()\n# Wait until all actors are done\npending_tasks = {asyncio.create_task(a.wait(), name=str(a)) for a in actors}\nwhile pending_tasks:\ndone_tasks, pending_tasks = await asyncio.wait(\npending_tasks, return_when=asyncio.FIRST_COMPLETED\n)\n# This should always be only one task, but we handle many for extra safety\nfor task in done_tasks:\n# Cancellation needs to be checked first, otherwise the other methods\n# could raise a CancelledError\nif task.cancelled():\n_logger.info(\"Actor %s: Cancelled while running.\", task.get_name())\nelif exception := task.exception():\n_logger.error(\n\"Actor %s: Raised an exception while running.\",\ntask.get_name(),\nexc_info=exception,\n)\nelse:\n_logger.info(\"Actor %s: Finished normally.\", task.get_name())\n_logger.info(\"All %s actor(s) finished.\", len(actors))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/","title":"Index","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing","title":"frequenz.sdk.actor.power_distributing","text":"<p>This module provides feature to set power between many batteries.</p> <p>Distributing power is very important to keep the microgrid ready for the power requirements. This module provides PowerDistributingActor that knows how to distribute power. It also provides all the secondary features that should be used to communicate with PowerDistributingActor and send requests for charging or discharging power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Result","title":"frequenz.sdk.actor.power_distributing.Result  <code>module-attribute</code>","text":"<pre><code>Result = Success | PartialFailure | Error | OutOfBounds\n</code></pre> <p>Power distribution result.</p> <p>Example: Handling power distribution results</p> <pre><code>```python\nfrom typing import assert_never\n\nfrom frequenz.sdk.actor.power_distributing import (\n    Error,\n    OutOfBounds,\n    PartialFailure,\n    Result,\n    Success,\n)\nfrom frequenz.sdk.actor.power_distributing.request import Request\nfrom frequenz.sdk.actor.power_distributing.result import PowerBounds\nfrom frequenz.sdk.timeseries._quantities import Power\n\ndef handle_power_request_result(result: Result) -&gt; None:\n    match result:\n        case Success() as success:\n            print(f\"Power request was successful: {success}\")\n        case PartialFailure() as partial_failure:\n            print(f\"Power request was partially successful: {partial_failure}\")\n        case OutOfBounds() as out_of_bounds:\n            print(f\"Power request was out of bounds: {out_of_bounds}\")\n        case Error() as error:\n            print(f\"Power request failed: {error}\")\n        case _ as unreachable:\n            assert_never(unreachable)\n\nrequest = Request(\n    namespace=\"TestChannel\",\n    power=Power.from_watts(123.4),\n    batteries={8, 18},\n)\n\nresults: list[Result] = [\n    Success(\n        request,\n        succeeded_power=Power.from_watts(123.4),\n        succeeded_batteries={8, 18},\n        excess_power=Power.zero(),\n    ),\n    PartialFailure(\n        request,\n        succeeded_power=Power.from_watts(103.4),\n        succeeded_batteries={8},\n        excess_power=Power.zero(),\n        failed_batteries={18},\n        failed_power=Power.from_watts(20.0),\n    ),\n    OutOfBounds(request, bounds=PowerBounds(0, 0, 0, 800)),\n    Error(request, msg=\"The batteries are not available\"),\n]\n\nfor r in results:\n    handle_power_request_result(r)\n```\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus","title":"frequenz.sdk.actor.power_distributing.BatteryStatus  <code>dataclass</code>","text":"<p>Status of the batteries.</p> Source code in <code>frequenz/sdk/actor/power_distributing/_battery_pool_status.py</code> <pre><code>@dataclass\nclass BatteryStatus:\n\"\"\"Status of the batteries.\"\"\"\nworking: set[int]\n\"\"\"Set of working battery ids.\"\"\"\nuncertain: set[int]\n\"\"\"Set of batteries that should be used only if there are no working batteries.\"\"\"\ndef get_working_batteries(self, batteries: abc.Set[int]) -&gt; set[int]:\n\"\"\"From the given set of batteries return working batteries.\n        Args:\n            batteries: Set of batteries\n        Returns:\n            Subset with working batteries.\n        \"\"\"\nworking = self.working.intersection(batteries)\nif len(working) &gt; 0:\nreturn working\nreturn self.uncertain.intersection(batteries)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus.uncertain","title":"uncertain  <code>instance-attribute</code>","text":"<pre><code>uncertain: set[int]\n</code></pre> <p>Set of batteries that should be used only if there are no working batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus.working","title":"working  <code>instance-attribute</code>","text":"<pre><code>working: set[int]\n</code></pre> <p>Set of working battery ids.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus.get_working_batteries","title":"get_working_batteries","text":"<pre><code>get_working_batteries(batteries: abc.Set[int]) -&gt; set[int]\n</code></pre> <p>From the given set of batteries return working batteries.</p> PARAMETER  DESCRIPTION <code>batteries</code> <p>Set of batteries</p> <p> TYPE: <code>Set[int]</code> </p> RETURNS DESCRIPTION <code>set[int]</code> <p>Subset with working batteries.</p> Source code in <code>frequenz/sdk/actor/power_distributing/_battery_pool_status.py</code> <pre><code>def get_working_batteries(self, batteries: abc.Set[int]) -&gt; set[int]:\n\"\"\"From the given set of batteries return working batteries.\n    Args:\n        batteries: Set of batteries\n    Returns:\n        Subset with working batteries.\n    \"\"\"\nworking = self.working.intersection(batteries)\nif len(working) &gt; 0:\nreturn working\nreturn self.uncertain.intersection(batteries)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error","title":"frequenz.sdk.actor.power_distributing.Error  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseResultMixin</code></p> <p>Result returned when an error occurred and power was not set at all.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Error(_BaseResultMixin):\n\"\"\"Result returned when an error occurred and power was not set at all.\"\"\"\nmsg: str\n\"\"\"The error message explaining why error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg: str\n</code></pre> <p>The error message explaining why error happened.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds","title":"frequenz.sdk.actor.power_distributing.OutOfBounds  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseResultMixin</code></p> <p>Result returned when the power was not set because it was out of bounds.</p> <p>This result happens when the originating request was done with <code>adjust_power = False</code> and the requested power is not within the batteries bounds.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass OutOfBounds(_BaseResultMixin):\n\"\"\"Result returned when the power was not set because it was out of bounds.\n    This result happens when the originating request was done with\n    `adjust_power = False` and the requested power is not within the batteries bounds.\n    \"\"\"\nbounds: PowerBounds\n\"\"\"The power bounds for the requested batteries.\n    If the requested power negative, then this value is the lower bound.\n    Otherwise it is upper bound.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds.bounds","title":"bounds  <code>instance-attribute</code>","text":"<pre><code>bounds: PowerBounds\n</code></pre> <p>The power bounds for the requested batteries.</p> <p>If the requested power negative, then this value is the lower bound. Otherwise it is upper bound.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure","title":"frequenz.sdk.actor.power_distributing.PartialFailure  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when any battery failed to perform the request.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PartialFailure(_BaseSuccessMixin, _BaseResultMixin):\n\"\"\"Result returned when any battery failed to perform the request.\"\"\"\nfailed_power: Power\n\"\"\"The part of the requested power that failed to be set.\"\"\"\nfailed_batteries: set[int]\n\"\"\"The subset of batteries for which the request failed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.excess_power","title":"excess_power  <code>instance-attribute</code>","text":"<pre><code>excess_power: Power\n</code></pre> <p>The part of the requested power that could not be fulfilled.</p> <p>This happens when the requested power is outside the available power bounds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.failed_batteries","title":"failed_batteries  <code>instance-attribute</code>","text":"<pre><code>failed_batteries: set[int]\n</code></pre> <p>The subset of batteries for which the request failed.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.failed_power","title":"failed_power  <code>instance-attribute</code>","text":"<pre><code>failed_power: Power\n</code></pre> <p>The part of the requested power that failed to be set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.succeeded_batteries","title":"succeeded_batteries  <code>instance-attribute</code>","text":"<pre><code>succeeded_batteries: set[int]\n</code></pre> <p>The subset of batteries for which power was set successfully.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.succeeded_power","title":"succeeded_power  <code>instance-attribute</code>","text":"<pre><code>succeeded_power: Power\n</code></pre> <p>The part of the requested power that was successfully set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor","title":"frequenz.sdk.actor.power_distributing.PowerDistributingActor","text":"<p>             Bases: <code>Actor</code></p> <p>Actor to distribute the power between batteries in a microgrid.</p> <p>The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time.</p> <p>For each user a bidirectional channel needs to be created through which they can send and receive requests and responses.</p> <p>It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout + time for processing the request.</p> <p>Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED.</p> <ul> <li>If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed.</li> </ul> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>class PowerDistributingActor(Actor):\n# pylint: disable=too-many-instance-attributes\n\"\"\"Actor to distribute the power between batteries in a microgrid.\n    The purpose of this tool is to keep an equal SoC level in all batteries.\n    The PowerDistributingActor can have many concurrent users which at this time\n    need to be known at construction time.\n    For each user a bidirectional channel needs to be created through which\n    they can send and receive requests and responses.\n    It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if\n    the processing function fails then the response will never come.\n    The timeout should be Result:request_timeout + time for processing the request.\n    Edge cases:\n    * If there are 2 requests to be processed for the same subset of batteries, then\n    only the latest request will be processed. Older request will be ignored. User with\n    older request will get response with Result.Status.IGNORED.\n    * If there are 2 requests and their subset of batteries is different but they\n    overlap (they have at least one common battery), then then both batteries\n    will be processed. However it is not expected so the proper error log will be\n    printed.\n    \"\"\"\ndef __init__(\nself,\nrequests_receiver: Receiver[Request],\nresults_sender: Sender[Result],\nbattery_status_sender: Sender[BatteryStatus],\nwait_for_data_sec: float = 2,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create class instance.\n        Args:\n            requests_receiver: Receiver for receiving power requests from the power manager.\n            results_sender: Sender for sending results to the power manager.\n            battery_status_sender: Channel for sending information which batteries are\n                working.\n            wait_for_data_sec: How long actor should wait before processing first\n                request. It is a time needed to collect first components data.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\nsuper().__init__(name=name)\nself._requests_receiver = requests_receiver\nself._result_sender = results_sender\nself._wait_for_data_sec = wait_for_data_sec\n# NOTE: power_distributor_exponent should be received from ConfigManager\nself.power_distributor_exponent: float = 1.0\n\"\"\"The exponent for the power distribution algorithm.\n        The exponent determines how fast the batteries should strive to the\n        equal SoC level.\n        \"\"\"\nself.distribution_algorithm = DistributionAlgorithm(\nself.power_distributor_exponent\n)\n\"\"\"The distribution algorithm used to distribute power between batteries.\"\"\"\nbatteries: Iterable[\nComponent\n] = connection_manager.get().component_graph.components(\ncomponent_category={ComponentCategory.BATTERY}\n)\nmaps = _get_battery_inverter_mappings(\n[battery.component_id for battery in batteries]\n)\nself._bat_invs_map = maps[\"bat_invs\"]\nself._inv_bats_map = maps[\"inv_bats\"]\nself._bat_bats_map = maps[\"bat_bats\"]\nself._inv_invs_map = maps[\"inv_invs\"]\nself._battery_receivers: dict[int, Peekable[BatteryData]] = {}\nself._inverter_receivers: dict[int, Peekable[InverterData]] = {}\nself._all_battery_status = BatteryPoolStatus(\nbattery_ids=set(self._bat_invs_map.keys()),\nbattery_status_sender=battery_status_sender,\nmax_blocking_duration_sec=30.0,\nmax_data_age_sec=10.0,\n)\ndef _get_bounds(\nself,\npairs_data: list[InvBatPair],\n) -&gt; PowerBounds:\n\"\"\"Get power bounds for given batteries.\n        Args:\n            pairs_data: list of battery and adjacent inverter data pairs.\n        Returns:\n            Power bounds for given batteries.\n        \"\"\"\nreturn PowerBounds(\ninclusion_lower=sum(\nmax(\nbattery.power_bounds.inclusion_lower,\nsum(\ninverter.active_power_inclusion_lower_bound\nfor inverter in inverters\n),\n)\nfor battery, inverters in pairs_data\n),\ninclusion_upper=sum(\nmin(\nbattery.power_bounds.inclusion_upper,\nsum(\ninverter.active_power_inclusion_upper_bound\nfor inverter in inverters\n),\n)\nfor battery, inverters in pairs_data\n),\nexclusion_lower=min(\nsum(battery.power_bounds.exclusion_lower for battery, _ in pairs_data),\nsum(\ninverter.active_power_exclusion_lower_bound\nfor _, inverters in pairs_data\nfor inverter in inverters\n),\n),\nexclusion_upper=max(\nsum(battery.power_bounds.exclusion_upper for battery, _ in pairs_data),\nsum(\ninverter.active_power_exclusion_upper_bound\nfor _, inverters in pairs_data\nfor inverter in inverters\n),\n),\n)\nasync def _run(self) -&gt; None:  # pylint: disable=too-many-locals\n\"\"\"Run actor main function.\n        It waits for new requests in task_queue and process it, and send\n        `set_power` request with distributed power.\n        The output of the `set_power` method is processed.\n        Every battery and inverter that failed or didn't respond in time will be marked\n        as broken for some time.\n        \"\"\"\nawait self._create_channels()\napi = connection_manager.get().api_client\n# Wait few seconds to get data from the channels created above.\nawait asyncio.sleep(self._wait_for_data_sec)\nasync for request in self._requests_receiver:\ntry:\npairs_data: list[InvBatPair] = self._get_components_data(\nrequest.batteries\n)\nexcept KeyError as err:\nawait self._result_sender.send(Error(request=request, msg=str(err)))\ncontinue\nif not pairs_data:\nerror_msg = (\n\"No data for at least one of the given \"\nf\"batteries {str(request.batteries)}\"\n)\nawait self._result_sender.send(\nError(request=request, msg=str(error_msg))\n)\ncontinue\nerror = self._check_request(request, pairs_data)\nif error:\nawait self._result_sender.send(error)\ncontinue\ntry:\ndistribution = self._get_power_distribution(request, pairs_data)\nexcept ValueError as err:\n_logger.exception(\"Couldn't distribute power\")\nerror_msg = f\"Couldn't distribute power, error: {str(err)}\"\nawait self._result_sender.send(\nError(request=request, msg=str(error_msg))\n)\ncontinue\ndistributed_power_value = (\nrequest.power.as_watts() - distribution.remaining_power\n)\nbattery_distribution: dict[int, float] = {}\nfor inverter_id, dist in distribution.distribution.items():\nfor battery_id in self._inv_bats_map[inverter_id]:\nbattery_distribution[battery_id] = (\nbattery_distribution.get(battery_id, 0.0) + dist\n)\n_logger.debug(\n\"Distributing power %d between the batteries %s\",\ndistributed_power_value,\nstr(battery_distribution),\n)\nfailed_power, failed_batteries = await self._set_distributed_power(\napi, distribution, request.request_timeout\n)\nresponse: Success | PartialFailure\nif len(failed_batteries) &gt; 0:\nsucceed_batteries = set(battery_distribution.keys()) - failed_batteries\nresponse = PartialFailure(\nrequest=request,\nsucceeded_power=Power.from_watts(\ndistributed_power_value - failed_power\n),\nsucceeded_batteries=succeed_batteries,\nfailed_power=Power.from_watts(failed_power),\nfailed_batteries=failed_batteries,\nexcess_power=Power.from_watts(distribution.remaining_power),\n)\nelse:\nsucceed_batteries = set(battery_distribution.keys())\nresponse = Success(\nrequest=request,\nsucceeded_power=Power.from_watts(distributed_power_value),\nsucceeded_batteries=succeed_batteries,\nexcess_power=Power.from_watts(distribution.remaining_power),\n)\nasyncio.gather(\n*[\nself._all_battery_status.update_status(\nsucceed_batteries, failed_batteries\n),\nself._result_sender.send(response),\n]\n)\nasync def _set_distributed_power(\nself,\napi: MicrogridApiClient,\ndistribution: DistributionResult,\ntimeout: timedelta,\n) -&gt; tuple[float, set[int]]:\n\"\"\"Send distributed power to the inverters.\n        Args:\n            api: Microgrid api client\n            distribution: Distribution result\n            timeout: How long wait for the response\n        Returns:\n            Tuple where first element is total failed power, and the second element\n            set of batteries that failed.\n        \"\"\"\ntasks = {\ninverter_id: asyncio.create_task(api.set_power(inverter_id, power))\nfor inverter_id, power in distribution.distribution.items()\n}\n_, pending = await asyncio.wait(\ntasks.values(),\ntimeout=timeout.total_seconds(),\nreturn_when=ALL_COMPLETED,\n)\nawait self._cancel_tasks(pending)\nreturn self._parse_result(tasks, distribution.distribution, timeout)\ndef _get_power_distribution(\nself, request: Request, inv_bat_pairs: list[InvBatPair]\n) -&gt; DistributionResult:\n\"\"\"Get power distribution result for the batteries in the request.\n        Args:\n            request: the power request to process.\n            inv_bat_pairs: the battery and adjacent inverter data pairs.\n        Returns:\n            the power distribution result.\n        \"\"\"\navailable_bat_ids = _get_all_from_map(\nself._bat_bats_map, {pair.battery.component_id for pair in inv_bat_pairs}\n)\nunavailable_bat_ids = request.batteries - available_bat_ids\nunavailable_inv_ids: set[int] = set()\nfor inverter_ids in [\nself._bat_invs_map[battery_id_set] for battery_id_set in unavailable_bat_ids\n]:\nunavailable_inv_ids = unavailable_inv_ids.union(inverter_ids)\nresult = self.distribution_algorithm.distribute_power(\nrequest.power.as_watts(), inv_bat_pairs\n)\nreturn result\ndef _check_request(\nself,\nrequest: Request,\npairs_data: list[InvBatPair],\n) -&gt; Result | None:\n\"\"\"Check whether the given request if correct.\n        Args:\n            request: request to check\n            pairs_data: list of battery and adjacent inverter data pairs.\n        Returns:\n            Result for the user if the request is wrong, None otherwise.\n        \"\"\"\nif not request.batteries:\nreturn Error(request=request, msg=\"Empty battery IDs in the request\")\nfor battery in request.batteries:\n_logger.debug(\"Checking battery %d\", battery)\nif battery not in self._battery_receivers:\nmsg = (\nf\"No battery {battery}, available batteries: \"\nf\"{list(self._battery_receivers.keys())}\"\n)\nreturn Error(request=request, msg=msg)\nbounds = self._get_bounds(pairs_data)\npower = request.power.as_watts()\n# Zero power requests are always forwarded to the microgrid API, even if they\n# are outside the exclusion bounds.\nif is_close_to_zero(power):\nreturn None\nif request.adjust_power:\n# Automatic power adjustments can only bring down the requested power down\n# to the inclusion bounds.\n#\n# If the requested power is in the exclusion bounds, it is NOT possible to\n# increase it so that it is outside the exclusion bounds.\nif bounds.exclusion_lower &lt; power &lt; bounds.exclusion_upper:\nreturn OutOfBounds(request=request, bounds=bounds)\nelse:\nin_lower_range = bounds.inclusion_lower &lt;= power &lt;= bounds.exclusion_lower\nin_upper_range = bounds.exclusion_upper &lt;= power &lt;= bounds.inclusion_upper\nif not (in_lower_range or in_upper_range):\nreturn OutOfBounds(request=request, bounds=bounds)\nreturn None\ndef _get_components_data(self, batteries: abc.Set[int]) -&gt; list[InvBatPair]:\n\"\"\"Get data for the given batteries and adjacent inverters.\n        Args:\n            batteries: Batteries that needs data.\n        Raises:\n            KeyError: If any battery in the given list doesn't exists in microgrid.\n        Returns:\n            Pairs of battery and adjacent inverter data.\n        \"\"\"\npairs_data: list[InvBatPair] = []\nworking_batteries = self._all_battery_status.get_working_batteries(batteries)\nfor battery_id in working_batteries:\nif battery_id not in self._battery_receivers:\nraise KeyError(\nf\"No battery {battery_id}, \"\nf\"available batteries: {list(self._battery_receivers.keys())}\"\n)\nconnected_inverters = _get_all_from_map(self._bat_invs_map, batteries)\n# Check to see if inverters are involved that are connected to batteries\n# that were not requested.\nbatteries_from_inverters = _get_all_from_map(\nself._inv_bats_map, connected_inverters\n)\nif batteries_from_inverters != batteries:\nextra_batteries = batteries_from_inverters - batteries\nraise KeyError(\nf\"Inverters {_get_all_from_map(self._bat_invs_map, extra_batteries)} \"\nf\"are connected to batteries that were not requested: {extra_batteries}\"\n)\n# set of set of batteries one for each working_battery\nbattery_sets: frozenset[frozenset[int]] = frozenset(\nself._bat_bats_map[working_battery] for working_battery in working_batteries\n)\nfor battery_ids in battery_sets:\ninverter_ids: frozenset[int] = self._bat_invs_map[next(iter(battery_ids))]\ndata = self._get_battery_inverter_data(battery_ids, inverter_ids)\nif data is None:\n_logger.warning(\n\"Skipping battery set %s because at least one of its messages isn't correct.\",\nlist(battery_ids),\n)\ncontinue\nassert len(data.inverter) &gt; 0\npairs_data.append(data)\nreturn pairs_data\ndef _get_battery_inverter_data(\nself, battery_ids: frozenset[int], inverter_ids: frozenset[int]\n) -&gt; InvBatPair | None:\n\"\"\"Get battery and inverter data if they are correct.\n        Each float data from the microgrid can be \"NaN\".\n        We can't do math operations on \"NaN\".\n        So check all the metrics and if any are \"NaN\" then return None.\n        Args:\n            battery_ids: battery ids\n            inverter_ids: inverter ids\n        Returns:\n            Data for the battery and adjacent inverter without NaN values.\n                Return None if we could not replace NaN values.\n        \"\"\"\nbattery_data_none = [\nself._battery_receivers[battery_id].peek() for battery_id in battery_ids\n]\ninverter_data_none = [\nself._inverter_receivers[inverter_id].peek() for inverter_id in inverter_ids\n]\n# It means that nothing has been send on this channels, yet.\n# This should be handled by BatteryStatus. BatteryStatus should not return\n# this batteries as working.\nif not all(battery_data_none) or not all(inverter_data_none):\n_logger.error(\n\"Battery %s or inverter %s send no data, yet. They should be not used.\",\nbattery_ids,\ninverter_ids,\n)\nreturn None\nbattery_data = cast(list[BatteryData], battery_data_none)\ninverter_data = cast(list[InverterData], inverter_data_none)\nDataType = TypeVar(\"DataType\", BatteryData, InverterData)\ndef metric_is_nan(data: DataType, metrics: list[str]) -&gt; bool:\n\"\"\"Check if non-replaceable metrics are NaN.\"\"\"\nassert data is not None\nreturn any(map(lambda metric: isnan(getattr(data, metric)), metrics))\ndef nan_metric_in_list(data: list[DataType], metrics: list[str]) -&gt; bool:\n\"\"\"Check if any metric is NaN.\"\"\"\nreturn any(map(lambda datum: metric_is_nan(datum, metrics), data))\ncrucial_metrics_bat = [\n\"soc\",\n\"soc_lower_bound\",\n\"soc_upper_bound\",\n\"capacity\",\n\"power_inclusion_lower_bound\",\n\"power_inclusion_upper_bound\",\n]\ncrucial_metrics_inv = [\n\"active_power_inclusion_lower_bound\",\n\"active_power_inclusion_upper_bound\",\n]\nif nan_metric_in_list(battery_data, crucial_metrics_bat):\n_logger.debug(\"Some metrics for battery set %s are NaN\", list(battery_ids))\nreturn None\nif nan_metric_in_list(inverter_data, crucial_metrics_inv):\n_logger.debug(\n\"Some metrics for inverter set %s are NaN\", list(inverter_ids)\n)\nreturn None\nreturn InvBatPair(AggregatedBatteryData(battery_data), inverter_data)\nasync def _create_channels(self) -&gt; None:\n\"\"\"Create channels to get data of components in microgrid.\"\"\"\napi = connection_manager.get().api_client\nfor battery_id, inverter_ids in self._bat_invs_map.items():\nbat_recv: Receiver[BatteryData] = await api.battery_data(battery_id)\nself._battery_receivers[battery_id] = bat_recv.into_peekable()\nfor inverter_id in inverter_ids:\ninv_recv: Receiver[InverterData] = await api.inverter_data(inverter_id)\nself._inverter_receivers[inverter_id] = inv_recv.into_peekable()\ndef _parse_result(\nself,\ntasks: dict[int, asyncio.Task[None]],\ndistribution: dict[int, float],\nrequest_timeout: timedelta,\n) -&gt; tuple[float, set[int]]:\n\"\"\"Parse the results of `set_power` requests.\n        Check if any task has failed and determine the reason for failure.\n        If any task did not succeed, then the corresponding battery is marked as broken.\n        Args:\n            tasks: A dictionary where the key is the inverter ID and the value is the task that\n                set the power for this inverter. Each task should be finished or cancelled.\n            distribution: A dictionary where the key is the inverter ID and the value is how much\n                power was set to the corresponding inverter.\n            request_timeout: The timeout that was used for the request.\n        Returns:\n            A tuple where the first element is the total failed power, and the second element is\n            the set of batteries that failed.\n        \"\"\"\nfailed_power: float = 0.0\nfailed_batteries: set[int] = set()\nfor inverter_id, aws in tasks.items():\nbattery_ids = self._inv_bats_map[inverter_id]\ntry:\naws.result()\nexcept grpc.aio.AioRpcError as err:\nfailed_power += distribution[inverter_id]\nfailed_batteries = failed_batteries.union(battery_ids)\nif err.code() == grpc.StatusCode.OUT_OF_RANGE:\n_logger.debug(\n\"Set power for battery %s failed, error %s\",\nbattery_ids,\nstr(err),\n)\nelse:\n_logger.warning(\n\"Set power for battery %s failed, error %s. Mark it as broken.\",\nbattery_ids,\nstr(err),\n)\nexcept asyncio.exceptions.CancelledError:\nfailed_power += distribution[inverter_id]\nfailed_batteries = failed_batteries.union(battery_ids)\n_logger.warning(\n\"Battery %s didn't respond in %f sec. Mark it as broken.\",\nbattery_ids,\nrequest_timeout.total_seconds(),\n)\nreturn failed_power, failed_batteries\nasync def _cancel_tasks(self, tasks: Iterable[asyncio.Task[Any]]) -&gt; None:\n\"\"\"Cancel given asyncio tasks and wait for them.\n        Args:\n            tasks: tasks to cancel.\n        \"\"\"\nfor aws in tasks:\naws.cancel()\nawait asyncio.gather(*tasks, return_exceptions=True)\nasync def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this actor.\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\nawait self._all_battery_status.stop()\nawait super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.distribution_algorithm","title":"distribution_algorithm  <code>instance-attribute</code>","text":"<pre><code>distribution_algorithm = DistributionAlgorithm(\nself.power_distributor_exponent\n)\n</code></pre> <p>The distribution algorithm used to distribute power between batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.power_distributor_exponent","title":"power_distributor_exponent  <code>instance-attribute</code>","text":"<pre><code>power_distributor_exponent: float = 1.0\n</code></pre> <p>The exponent for the power distribution algorithm.</p> <p>The exponent determines how fast the batteries should strive to the equal SoC level.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: collections.abc.Set[asyncio.Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n\"\"\"Enter an async context.\n    Start this background service.\n    Returns:\n        This background service.\n    \"\"\"\nself.start()\nreturn self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\nself,\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Exit an async context.\n    Stop this background service.\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\nawait self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; collections.abc.Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n\"\"\"Await this background service.\n    An awaited background service will wait for all its tasks to finish.\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\nreturn self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Destroy this instance.\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\nself.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__init__","title":"__init__","text":"<pre><code>__init__(\nrequests_receiver: Receiver[Request],\nresults_sender: Sender[Result],\nbattery_status_sender: Sender[BatteryStatus],\nwait_for_data_sec: float = 2,\n*,\nname: str | None = None\n) -&gt; None\n</code></pre> <p>Create class instance.</p> PARAMETER  DESCRIPTION <code>requests_receiver</code> <p>Receiver for receiving power requests from the power manager.</p> <p> TYPE: <code>Receiver[Request]</code> </p> <code>results_sender</code> <p>Sender for sending results to the power manager.</p> <p> TYPE: <code>Sender[Result]</code> </p> <code>battery_status_sender</code> <p>Channel for sending information which batteries are working.</p> <p> TYPE: <code>Sender[BatteryStatus]</code> </p> <code>wait_for_data_sec</code> <p>How long actor should wait before processing first request. It is a time needed to collect first components data.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>def __init__(\nself,\nrequests_receiver: Receiver[Request],\nresults_sender: Sender[Result],\nbattery_status_sender: Sender[BatteryStatus],\nwait_for_data_sec: float = 2,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create class instance.\n    Args:\n        requests_receiver: Receiver for receiving power requests from the power manager.\n        results_sender: Sender for sending results to the power manager.\n        battery_status_sender: Channel for sending information which batteries are\n            working.\n        wait_for_data_sec: How long actor should wait before processing first\n            request. It is a time needed to collect first components data.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\nsuper().__init__(name=name)\nself._requests_receiver = requests_receiver\nself._result_sender = results_sender\nself._wait_for_data_sec = wait_for_data_sec\n# NOTE: power_distributor_exponent should be received from ConfigManager\nself.power_distributor_exponent: float = 1.0\n\"\"\"The exponent for the power distribution algorithm.\n    The exponent determines how fast the batteries should strive to the\n    equal SoC level.\n    \"\"\"\nself.distribution_algorithm = DistributionAlgorithm(\nself.power_distributor_exponent\n)\n\"\"\"The distribution algorithm used to distribute power between batteries.\"\"\"\nbatteries: Iterable[\nComponent\n] = connection_manager.get().component_graph.components(\ncomponent_category={ComponentCategory.BATTERY}\n)\nmaps = _get_battery_inverter_mappings(\n[battery.component_id for battery in batteries]\n)\nself._bat_invs_map = maps[\"bat_invs\"]\nself._inv_bats_map = maps[\"inv_bats\"]\nself._bat_bats_map = maps[\"bat_bats\"]\nself._inv_invs_map = maps[\"inv_invs\"]\nself._battery_receivers: dict[int, Peekable[BatteryData]] = {}\nself._inverter_receivers: dict[int, Peekable[InverterData]] = {}\nself._all_battery_status = BatteryPoolStatus(\nbattery_ids=set(self._bat_invs_map.keys()),\nbattery_status_sender=battery_status_sender,\nmax_blocking_duration_sec=30.0,\nmax_data_age_sec=10.0,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n\"\"\"Cancel all running tasks spawned by this background service.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nfor task in self._tasks:\ntask.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start this actor.\n    If this actor is already running, this method does nothing.\n    \"\"\"\nif self.is_running:\nreturn\nself._tasks.clear()\nself._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this actor.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this actor.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nawait self._all_battery_status.stop()\nawait super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n\"\"\"Wait this background service to finish.\n    Wait until all background service tasks are finished.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n# We need to account for tasks that were created between when we started\n# awaiting and we finished awaiting.\nwhile self._tasks:\ndone, pending = await asyncio.wait(self._tasks)\nassert not pending\n# We remove the done tasks, but there might be new ones created after we\n# started waiting.\nself._tasks = self._tasks - done\nexceptions: list[BaseException] = []\nfor task in done:\ntry:\n# This will raise a CancelledError if the task was cancelled or any\n# other exception if the task raised one.\n_ = task.result()\nexcept BaseException as error:  # pylint: disable=broad-except\nexceptions.append(error)\nif exceptions:\nraise BaseExceptionGroup(\nf\"Error while stopping background service {self}\", exceptions\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request","title":"frequenz.sdk.actor.power_distributing.Request  <code>dataclass</code>","text":"<p>Request to set power to the <code>PowerDistributingActor</code>.</p> Source code in <code>frequenz/sdk/actor/power_distributing/request.py</code> <pre><code>@dataclasses.dataclass\nclass Request:\n\"\"\"Request to set power to the `PowerDistributingActor`.\"\"\"\npower: Power\n\"\"\"The requested power.\"\"\"\nbatteries: abc.Set[int]\n\"\"\"The component ids of the batteries to be used for this request.\"\"\"\nrequest_timeout: timedelta = timedelta(seconds=5.0)\n\"\"\"The maximum amount of time to wait for the request to be fulfilled.\"\"\"\nadjust_power: bool = True\n\"\"\"Whether to adjust the power to match the bounds.\n    If `True`, the power will be adjusted (lowered) to match the bounds, so\n    only the reduced power will be set.\n    If `False` and the power is outside the batteries' bounds, the request will\n    fail and be replied to with an `OutOfBound` result.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.adjust_power","title":"adjust_power  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>adjust_power: bool = True\n</code></pre> <p>Whether to adjust the power to match the bounds.</p> <p>If <code>True</code>, the power will be adjusted (lowered) to match the bounds, so only the reduced power will be set.</p> <p>If <code>False</code> and the power is outside the batteries' bounds, the request will fail and be replied to with an <code>OutOfBound</code> result.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.batteries","title":"batteries  <code>instance-attribute</code>","text":"<pre><code>batteries: abc.Set[int]\n</code></pre> <p>The component ids of the batteries to be used for this request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.power","title":"power  <code>instance-attribute</code>","text":"<pre><code>power: Power\n</code></pre> <p>The requested power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.request_timeout","title":"request_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_timeout: timedelta = timedelta(seconds=5.0)\n</code></pre> <p>The maximum amount of time to wait for the request to be fulfilled.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success","title":"frequenz.sdk.actor.power_distributing.Success  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when setting the power succeeded for all batteries.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Success(_BaseSuccessMixin, _BaseResultMixin):  # Order matters here. See above.\n\"\"\"Result returned when setting the power succeeded for all batteries.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/","title":"power_distributing","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing","title":"frequenz.sdk.actor.power_distributing.power_distributing","text":"<p>Actor to distribute power between batteries.</p> <p>When charge/discharge method is called the power should be distributed so that the SoC in batteries stays at the same level. That way of distribution prevents using only one battery, increasing temperature, and maximize the total amount power to charge/discharge.</p> <p>Purpose of this actor is to keep SoC level of each component at the equal level.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor","title":"frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor","text":"<p>             Bases: <code>Actor</code></p> <p>Actor to distribute the power between batteries in a microgrid.</p> <p>The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time.</p> <p>For each user a bidirectional channel needs to be created through which they can send and receive requests and responses.</p> <p>It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout + time for processing the request.</p> <p>Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED.</p> <ul> <li>If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed.</li> </ul> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>class PowerDistributingActor(Actor):\n# pylint: disable=too-many-instance-attributes\n\"\"\"Actor to distribute the power between batteries in a microgrid.\n    The purpose of this tool is to keep an equal SoC level in all batteries.\n    The PowerDistributingActor can have many concurrent users which at this time\n    need to be known at construction time.\n    For each user a bidirectional channel needs to be created through which\n    they can send and receive requests and responses.\n    It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if\n    the processing function fails then the response will never come.\n    The timeout should be Result:request_timeout + time for processing the request.\n    Edge cases:\n    * If there are 2 requests to be processed for the same subset of batteries, then\n    only the latest request will be processed. Older request will be ignored. User with\n    older request will get response with Result.Status.IGNORED.\n    * If there are 2 requests and their subset of batteries is different but they\n    overlap (they have at least one common battery), then then both batteries\n    will be processed. However it is not expected so the proper error log will be\n    printed.\n    \"\"\"\ndef __init__(\nself,\nrequests_receiver: Receiver[Request],\nresults_sender: Sender[Result],\nbattery_status_sender: Sender[BatteryStatus],\nwait_for_data_sec: float = 2,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create class instance.\n        Args:\n            requests_receiver: Receiver for receiving power requests from the power manager.\n            results_sender: Sender for sending results to the power manager.\n            battery_status_sender: Channel for sending information which batteries are\n                working.\n            wait_for_data_sec: How long actor should wait before processing first\n                request. It is a time needed to collect first components data.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\nsuper().__init__(name=name)\nself._requests_receiver = requests_receiver\nself._result_sender = results_sender\nself._wait_for_data_sec = wait_for_data_sec\n# NOTE: power_distributor_exponent should be received from ConfigManager\nself.power_distributor_exponent: float = 1.0\n\"\"\"The exponent for the power distribution algorithm.\n        The exponent determines how fast the batteries should strive to the\n        equal SoC level.\n        \"\"\"\nself.distribution_algorithm = DistributionAlgorithm(\nself.power_distributor_exponent\n)\n\"\"\"The distribution algorithm used to distribute power between batteries.\"\"\"\nbatteries: Iterable[\nComponent\n] = connection_manager.get().component_graph.components(\ncomponent_category={ComponentCategory.BATTERY}\n)\nmaps = _get_battery_inverter_mappings(\n[battery.component_id for battery in batteries]\n)\nself._bat_invs_map = maps[\"bat_invs\"]\nself._inv_bats_map = maps[\"inv_bats\"]\nself._bat_bats_map = maps[\"bat_bats\"]\nself._inv_invs_map = maps[\"inv_invs\"]\nself._battery_receivers: dict[int, Peekable[BatteryData]] = {}\nself._inverter_receivers: dict[int, Peekable[InverterData]] = {}\nself._all_battery_status = BatteryPoolStatus(\nbattery_ids=set(self._bat_invs_map.keys()),\nbattery_status_sender=battery_status_sender,\nmax_blocking_duration_sec=30.0,\nmax_data_age_sec=10.0,\n)\ndef _get_bounds(\nself,\npairs_data: list[InvBatPair],\n) -&gt; PowerBounds:\n\"\"\"Get power bounds for given batteries.\n        Args:\n            pairs_data: list of battery and adjacent inverter data pairs.\n        Returns:\n            Power bounds for given batteries.\n        \"\"\"\nreturn PowerBounds(\ninclusion_lower=sum(\nmax(\nbattery.power_bounds.inclusion_lower,\nsum(\ninverter.active_power_inclusion_lower_bound\nfor inverter in inverters\n),\n)\nfor battery, inverters in pairs_data\n),\ninclusion_upper=sum(\nmin(\nbattery.power_bounds.inclusion_upper,\nsum(\ninverter.active_power_inclusion_upper_bound\nfor inverter in inverters\n),\n)\nfor battery, inverters in pairs_data\n),\nexclusion_lower=min(\nsum(battery.power_bounds.exclusion_lower for battery, _ in pairs_data),\nsum(\ninverter.active_power_exclusion_lower_bound\nfor _, inverters in pairs_data\nfor inverter in inverters\n),\n),\nexclusion_upper=max(\nsum(battery.power_bounds.exclusion_upper for battery, _ in pairs_data),\nsum(\ninverter.active_power_exclusion_upper_bound\nfor _, inverters in pairs_data\nfor inverter in inverters\n),\n),\n)\nasync def _run(self) -&gt; None:  # pylint: disable=too-many-locals\n\"\"\"Run actor main function.\n        It waits for new requests in task_queue and process it, and send\n        `set_power` request with distributed power.\n        The output of the `set_power` method is processed.\n        Every battery and inverter that failed or didn't respond in time will be marked\n        as broken for some time.\n        \"\"\"\nawait self._create_channels()\napi = connection_manager.get().api_client\n# Wait few seconds to get data from the channels created above.\nawait asyncio.sleep(self._wait_for_data_sec)\nasync for request in self._requests_receiver:\ntry:\npairs_data: list[InvBatPair] = self._get_components_data(\nrequest.batteries\n)\nexcept KeyError as err:\nawait self._result_sender.send(Error(request=request, msg=str(err)))\ncontinue\nif not pairs_data:\nerror_msg = (\n\"No data for at least one of the given \"\nf\"batteries {str(request.batteries)}\"\n)\nawait self._result_sender.send(\nError(request=request, msg=str(error_msg))\n)\ncontinue\nerror = self._check_request(request, pairs_data)\nif error:\nawait self._result_sender.send(error)\ncontinue\ntry:\ndistribution = self._get_power_distribution(request, pairs_data)\nexcept ValueError as err:\n_logger.exception(\"Couldn't distribute power\")\nerror_msg = f\"Couldn't distribute power, error: {str(err)}\"\nawait self._result_sender.send(\nError(request=request, msg=str(error_msg))\n)\ncontinue\ndistributed_power_value = (\nrequest.power.as_watts() - distribution.remaining_power\n)\nbattery_distribution: dict[int, float] = {}\nfor inverter_id, dist in distribution.distribution.items():\nfor battery_id in self._inv_bats_map[inverter_id]:\nbattery_distribution[battery_id] = (\nbattery_distribution.get(battery_id, 0.0) + dist\n)\n_logger.debug(\n\"Distributing power %d between the batteries %s\",\ndistributed_power_value,\nstr(battery_distribution),\n)\nfailed_power, failed_batteries = await self._set_distributed_power(\napi, distribution, request.request_timeout\n)\nresponse: Success | PartialFailure\nif len(failed_batteries) &gt; 0:\nsucceed_batteries = set(battery_distribution.keys()) - failed_batteries\nresponse = PartialFailure(\nrequest=request,\nsucceeded_power=Power.from_watts(\ndistributed_power_value - failed_power\n),\nsucceeded_batteries=succeed_batteries,\nfailed_power=Power.from_watts(failed_power),\nfailed_batteries=failed_batteries,\nexcess_power=Power.from_watts(distribution.remaining_power),\n)\nelse:\nsucceed_batteries = set(battery_distribution.keys())\nresponse = Success(\nrequest=request,\nsucceeded_power=Power.from_watts(distributed_power_value),\nsucceeded_batteries=succeed_batteries,\nexcess_power=Power.from_watts(distribution.remaining_power),\n)\nasyncio.gather(\n*[\nself._all_battery_status.update_status(\nsucceed_batteries, failed_batteries\n),\nself._result_sender.send(response),\n]\n)\nasync def _set_distributed_power(\nself,\napi: MicrogridApiClient,\ndistribution: DistributionResult,\ntimeout: timedelta,\n) -&gt; tuple[float, set[int]]:\n\"\"\"Send distributed power to the inverters.\n        Args:\n            api: Microgrid api client\n            distribution: Distribution result\n            timeout: How long wait for the response\n        Returns:\n            Tuple where first element is total failed power, and the second element\n            set of batteries that failed.\n        \"\"\"\ntasks = {\ninverter_id: asyncio.create_task(api.set_power(inverter_id, power))\nfor inverter_id, power in distribution.distribution.items()\n}\n_, pending = await asyncio.wait(\ntasks.values(),\ntimeout=timeout.total_seconds(),\nreturn_when=ALL_COMPLETED,\n)\nawait self._cancel_tasks(pending)\nreturn self._parse_result(tasks, distribution.distribution, timeout)\ndef _get_power_distribution(\nself, request: Request, inv_bat_pairs: list[InvBatPair]\n) -&gt; DistributionResult:\n\"\"\"Get power distribution result for the batteries in the request.\n        Args:\n            request: the power request to process.\n            inv_bat_pairs: the battery and adjacent inverter data pairs.\n        Returns:\n            the power distribution result.\n        \"\"\"\navailable_bat_ids = _get_all_from_map(\nself._bat_bats_map, {pair.battery.component_id for pair in inv_bat_pairs}\n)\nunavailable_bat_ids = request.batteries - available_bat_ids\nunavailable_inv_ids: set[int] = set()\nfor inverter_ids in [\nself._bat_invs_map[battery_id_set] for battery_id_set in unavailable_bat_ids\n]:\nunavailable_inv_ids = unavailable_inv_ids.union(inverter_ids)\nresult = self.distribution_algorithm.distribute_power(\nrequest.power.as_watts(), inv_bat_pairs\n)\nreturn result\ndef _check_request(\nself,\nrequest: Request,\npairs_data: list[InvBatPair],\n) -&gt; Result | None:\n\"\"\"Check whether the given request if correct.\n        Args:\n            request: request to check\n            pairs_data: list of battery and adjacent inverter data pairs.\n        Returns:\n            Result for the user if the request is wrong, None otherwise.\n        \"\"\"\nif not request.batteries:\nreturn Error(request=request, msg=\"Empty battery IDs in the request\")\nfor battery in request.batteries:\n_logger.debug(\"Checking battery %d\", battery)\nif battery not in self._battery_receivers:\nmsg = (\nf\"No battery {battery}, available batteries: \"\nf\"{list(self._battery_receivers.keys())}\"\n)\nreturn Error(request=request, msg=msg)\nbounds = self._get_bounds(pairs_data)\npower = request.power.as_watts()\n# Zero power requests are always forwarded to the microgrid API, even if they\n# are outside the exclusion bounds.\nif is_close_to_zero(power):\nreturn None\nif request.adjust_power:\n# Automatic power adjustments can only bring down the requested power down\n# to the inclusion bounds.\n#\n# If the requested power is in the exclusion bounds, it is NOT possible to\n# increase it so that it is outside the exclusion bounds.\nif bounds.exclusion_lower &lt; power &lt; bounds.exclusion_upper:\nreturn OutOfBounds(request=request, bounds=bounds)\nelse:\nin_lower_range = bounds.inclusion_lower &lt;= power &lt;= bounds.exclusion_lower\nin_upper_range = bounds.exclusion_upper &lt;= power &lt;= bounds.inclusion_upper\nif not (in_lower_range or in_upper_range):\nreturn OutOfBounds(request=request, bounds=bounds)\nreturn None\ndef _get_components_data(self, batteries: abc.Set[int]) -&gt; list[InvBatPair]:\n\"\"\"Get data for the given batteries and adjacent inverters.\n        Args:\n            batteries: Batteries that needs data.\n        Raises:\n            KeyError: If any battery in the given list doesn't exists in microgrid.\n        Returns:\n            Pairs of battery and adjacent inverter data.\n        \"\"\"\npairs_data: list[InvBatPair] = []\nworking_batteries = self._all_battery_status.get_working_batteries(batteries)\nfor battery_id in working_batteries:\nif battery_id not in self._battery_receivers:\nraise KeyError(\nf\"No battery {battery_id}, \"\nf\"available batteries: {list(self._battery_receivers.keys())}\"\n)\nconnected_inverters = _get_all_from_map(self._bat_invs_map, batteries)\n# Check to see if inverters are involved that are connected to batteries\n# that were not requested.\nbatteries_from_inverters = _get_all_from_map(\nself._inv_bats_map, connected_inverters\n)\nif batteries_from_inverters != batteries:\nextra_batteries = batteries_from_inverters - batteries\nraise KeyError(\nf\"Inverters {_get_all_from_map(self._bat_invs_map, extra_batteries)} \"\nf\"are connected to batteries that were not requested: {extra_batteries}\"\n)\n# set of set of batteries one for each working_battery\nbattery_sets: frozenset[frozenset[int]] = frozenset(\nself._bat_bats_map[working_battery] for working_battery in working_batteries\n)\nfor battery_ids in battery_sets:\ninverter_ids: frozenset[int] = self._bat_invs_map[next(iter(battery_ids))]\ndata = self._get_battery_inverter_data(battery_ids, inverter_ids)\nif data is None:\n_logger.warning(\n\"Skipping battery set %s because at least one of its messages isn't correct.\",\nlist(battery_ids),\n)\ncontinue\nassert len(data.inverter) &gt; 0\npairs_data.append(data)\nreturn pairs_data\ndef _get_battery_inverter_data(\nself, battery_ids: frozenset[int], inverter_ids: frozenset[int]\n) -&gt; InvBatPair | None:\n\"\"\"Get battery and inverter data if they are correct.\n        Each float data from the microgrid can be \"NaN\".\n        We can't do math operations on \"NaN\".\n        So check all the metrics and if any are \"NaN\" then return None.\n        Args:\n            battery_ids: battery ids\n            inverter_ids: inverter ids\n        Returns:\n            Data for the battery and adjacent inverter without NaN values.\n                Return None if we could not replace NaN values.\n        \"\"\"\nbattery_data_none = [\nself._battery_receivers[battery_id].peek() for battery_id in battery_ids\n]\ninverter_data_none = [\nself._inverter_receivers[inverter_id].peek() for inverter_id in inverter_ids\n]\n# It means that nothing has been send on this channels, yet.\n# This should be handled by BatteryStatus. BatteryStatus should not return\n# this batteries as working.\nif not all(battery_data_none) or not all(inverter_data_none):\n_logger.error(\n\"Battery %s or inverter %s send no data, yet. They should be not used.\",\nbattery_ids,\ninverter_ids,\n)\nreturn None\nbattery_data = cast(list[BatteryData], battery_data_none)\ninverter_data = cast(list[InverterData], inverter_data_none)\nDataType = TypeVar(\"DataType\", BatteryData, InverterData)\ndef metric_is_nan(data: DataType, metrics: list[str]) -&gt; bool:\n\"\"\"Check if non-replaceable metrics are NaN.\"\"\"\nassert data is not None\nreturn any(map(lambda metric: isnan(getattr(data, metric)), metrics))\ndef nan_metric_in_list(data: list[DataType], metrics: list[str]) -&gt; bool:\n\"\"\"Check if any metric is NaN.\"\"\"\nreturn any(map(lambda datum: metric_is_nan(datum, metrics), data))\ncrucial_metrics_bat = [\n\"soc\",\n\"soc_lower_bound\",\n\"soc_upper_bound\",\n\"capacity\",\n\"power_inclusion_lower_bound\",\n\"power_inclusion_upper_bound\",\n]\ncrucial_metrics_inv = [\n\"active_power_inclusion_lower_bound\",\n\"active_power_inclusion_upper_bound\",\n]\nif nan_metric_in_list(battery_data, crucial_metrics_bat):\n_logger.debug(\"Some metrics for battery set %s are NaN\", list(battery_ids))\nreturn None\nif nan_metric_in_list(inverter_data, crucial_metrics_inv):\n_logger.debug(\n\"Some metrics for inverter set %s are NaN\", list(inverter_ids)\n)\nreturn None\nreturn InvBatPair(AggregatedBatteryData(battery_data), inverter_data)\nasync def _create_channels(self) -&gt; None:\n\"\"\"Create channels to get data of components in microgrid.\"\"\"\napi = connection_manager.get().api_client\nfor battery_id, inverter_ids in self._bat_invs_map.items():\nbat_recv: Receiver[BatteryData] = await api.battery_data(battery_id)\nself._battery_receivers[battery_id] = bat_recv.into_peekable()\nfor inverter_id in inverter_ids:\ninv_recv: Receiver[InverterData] = await api.inverter_data(inverter_id)\nself._inverter_receivers[inverter_id] = inv_recv.into_peekable()\ndef _parse_result(\nself,\ntasks: dict[int, asyncio.Task[None]],\ndistribution: dict[int, float],\nrequest_timeout: timedelta,\n) -&gt; tuple[float, set[int]]:\n\"\"\"Parse the results of `set_power` requests.\n        Check if any task has failed and determine the reason for failure.\n        If any task did not succeed, then the corresponding battery is marked as broken.\n        Args:\n            tasks: A dictionary where the key is the inverter ID and the value is the task that\n                set the power for this inverter. Each task should be finished or cancelled.\n            distribution: A dictionary where the key is the inverter ID and the value is how much\n                power was set to the corresponding inverter.\n            request_timeout: The timeout that was used for the request.\n        Returns:\n            A tuple where the first element is the total failed power, and the second element is\n            the set of batteries that failed.\n        \"\"\"\nfailed_power: float = 0.0\nfailed_batteries: set[int] = set()\nfor inverter_id, aws in tasks.items():\nbattery_ids = self._inv_bats_map[inverter_id]\ntry:\naws.result()\nexcept grpc.aio.AioRpcError as err:\nfailed_power += distribution[inverter_id]\nfailed_batteries = failed_batteries.union(battery_ids)\nif err.code() == grpc.StatusCode.OUT_OF_RANGE:\n_logger.debug(\n\"Set power for battery %s failed, error %s\",\nbattery_ids,\nstr(err),\n)\nelse:\n_logger.warning(\n\"Set power for battery %s failed, error %s. Mark it as broken.\",\nbattery_ids,\nstr(err),\n)\nexcept asyncio.exceptions.CancelledError:\nfailed_power += distribution[inverter_id]\nfailed_batteries = failed_batteries.union(battery_ids)\n_logger.warning(\n\"Battery %s didn't respond in %f sec. Mark it as broken.\",\nbattery_ids,\nrequest_timeout.total_seconds(),\n)\nreturn failed_power, failed_batteries\nasync def _cancel_tasks(self, tasks: Iterable[asyncio.Task[Any]]) -&gt; None:\n\"\"\"Cancel given asyncio tasks and wait for them.\n        Args:\n            tasks: tasks to cancel.\n        \"\"\"\nfor aws in tasks:\naws.cancel()\nawait asyncio.gather(*tasks, return_exceptions=True)\nasync def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this actor.\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\nawait self._all_battery_status.stop()\nawait super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.distribution_algorithm","title":"distribution_algorithm  <code>instance-attribute</code>","text":"<pre><code>distribution_algorithm = DistributionAlgorithm(\nself.power_distributor_exponent\n)\n</code></pre> <p>The distribution algorithm used to distribute power between batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.power_distributor_exponent","title":"power_distributor_exponent  <code>instance-attribute</code>","text":"<pre><code>power_distributor_exponent: float = 1.0\n</code></pre> <p>The exponent for the power distribution algorithm.</p> <p>The exponent determines how fast the batteries should strive to the equal SoC level.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: collections.abc.Set[asyncio.Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n\"\"\"Enter an async context.\n    Start this background service.\n    Returns:\n        This background service.\n    \"\"\"\nself.start()\nreturn self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\nself,\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Exit an async context.\n    Stop this background service.\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\nawait self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; collections.abc.Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n\"\"\"Await this background service.\n    An awaited background service will wait for all its tasks to finish.\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\nreturn self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Destroy this instance.\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\nself.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__init__","title":"__init__","text":"<pre><code>__init__(\nrequests_receiver: Receiver[Request],\nresults_sender: Sender[Result],\nbattery_status_sender: Sender[BatteryStatus],\nwait_for_data_sec: float = 2,\n*,\nname: str | None = None\n) -&gt; None\n</code></pre> <p>Create class instance.</p> PARAMETER  DESCRIPTION <code>requests_receiver</code> <p>Receiver for receiving power requests from the power manager.</p> <p> TYPE: <code>Receiver[Request]</code> </p> <code>results_sender</code> <p>Sender for sending results to the power manager.</p> <p> TYPE: <code>Sender[Result]</code> </p> <code>battery_status_sender</code> <p>Channel for sending information which batteries are working.</p> <p> TYPE: <code>Sender[BatteryStatus]</code> </p> <code>wait_for_data_sec</code> <p>How long actor should wait before processing first request. It is a time needed to collect first components data.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>def __init__(\nself,\nrequests_receiver: Receiver[Request],\nresults_sender: Sender[Result],\nbattery_status_sender: Sender[BatteryStatus],\nwait_for_data_sec: float = 2,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create class instance.\n    Args:\n        requests_receiver: Receiver for receiving power requests from the power manager.\n        results_sender: Sender for sending results to the power manager.\n        battery_status_sender: Channel for sending information which batteries are\n            working.\n        wait_for_data_sec: How long actor should wait before processing first\n            request. It is a time needed to collect first components data.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\nsuper().__init__(name=name)\nself._requests_receiver = requests_receiver\nself._result_sender = results_sender\nself._wait_for_data_sec = wait_for_data_sec\n# NOTE: power_distributor_exponent should be received from ConfigManager\nself.power_distributor_exponent: float = 1.0\n\"\"\"The exponent for the power distribution algorithm.\n    The exponent determines how fast the batteries should strive to the\n    equal SoC level.\n    \"\"\"\nself.distribution_algorithm = DistributionAlgorithm(\nself.power_distributor_exponent\n)\n\"\"\"The distribution algorithm used to distribute power between batteries.\"\"\"\nbatteries: Iterable[\nComponent\n] = connection_manager.get().component_graph.components(\ncomponent_category={ComponentCategory.BATTERY}\n)\nmaps = _get_battery_inverter_mappings(\n[battery.component_id for battery in batteries]\n)\nself._bat_invs_map = maps[\"bat_invs\"]\nself._inv_bats_map = maps[\"inv_bats\"]\nself._bat_bats_map = maps[\"bat_bats\"]\nself._inv_invs_map = maps[\"inv_invs\"]\nself._battery_receivers: dict[int, Peekable[BatteryData]] = {}\nself._inverter_receivers: dict[int, Peekable[InverterData]] = {}\nself._all_battery_status = BatteryPoolStatus(\nbattery_ids=set(self._bat_invs_map.keys()),\nbattery_status_sender=battery_status_sender,\nmax_blocking_duration_sec=30.0,\nmax_data_age_sec=10.0,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n\"\"\"Cancel all running tasks spawned by this background service.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nfor task in self._tasks:\ntask.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start this actor.\n    If this actor is already running, this method does nothing.\n    \"\"\"\nif self.is_running:\nreturn\nself._tasks.clear()\nself._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this actor.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this actor.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nawait self._all_battery_status.stop()\nawait super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n\"\"\"Wait this background service to finish.\n    Wait until all background service tasks are finished.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n# We need to account for tasks that were created between when we started\n# awaiting and we finished awaiting.\nwhile self._tasks:\ndone, pending = await asyncio.wait(self._tasks)\nassert not pending\n# We remove the done tasks, but there might be new ones created after we\n# started waiting.\nself._tasks = self._tasks - done\nexceptions: list[BaseException] = []\nfor task in done:\ntry:\n# This will raise a CancelledError if the task was cancelled or any\n# other exception if the task raised one.\n_ = task.result()\nexcept BaseException as error:  # pylint: disable=broad-except\nexceptions.append(error)\nif exceptions:\nraise BaseExceptionGroup(\nf\"Error while stopping background service {self}\", exceptions\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/","title":"request","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request","title":"frequenz.sdk.actor.power_distributing.request","text":"<p>Definition of the user request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request","title":"frequenz.sdk.actor.power_distributing.request.Request  <code>dataclass</code>","text":"<p>Request to set power to the <code>PowerDistributingActor</code>.</p> Source code in <code>frequenz/sdk/actor/power_distributing/request.py</code> <pre><code>@dataclasses.dataclass\nclass Request:\n\"\"\"Request to set power to the `PowerDistributingActor`.\"\"\"\npower: Power\n\"\"\"The requested power.\"\"\"\nbatteries: abc.Set[int]\n\"\"\"The component ids of the batteries to be used for this request.\"\"\"\nrequest_timeout: timedelta = timedelta(seconds=5.0)\n\"\"\"The maximum amount of time to wait for the request to be fulfilled.\"\"\"\nadjust_power: bool = True\n\"\"\"Whether to adjust the power to match the bounds.\n    If `True`, the power will be adjusted (lowered) to match the bounds, so\n    only the reduced power will be set.\n    If `False` and the power is outside the batteries' bounds, the request will\n    fail and be replied to with an `OutOfBound` result.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.adjust_power","title":"adjust_power  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>adjust_power: bool = True\n</code></pre> <p>Whether to adjust the power to match the bounds.</p> <p>If <code>True</code>, the power will be adjusted (lowered) to match the bounds, so only the reduced power will be set.</p> <p>If <code>False</code> and the power is outside the batteries' bounds, the request will fail and be replied to with an <code>OutOfBound</code> result.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.batteries","title":"batteries  <code>instance-attribute</code>","text":"<pre><code>batteries: abc.Set[int]\n</code></pre> <p>The component ids of the batteries to be used for this request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.power","title":"power  <code>instance-attribute</code>","text":"<pre><code>power: Power\n</code></pre> <p>The requested power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.request_timeout","title":"request_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_timeout: timedelta = timedelta(seconds=5.0)\n</code></pre> <p>The maximum amount of time to wait for the request to be fulfilled.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/","title":"result","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result","title":"frequenz.sdk.actor.power_distributing.result","text":"<p>Results from PowerDistributingActor.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Result","title":"frequenz.sdk.actor.power_distributing.result.Result  <code>module-attribute</code>","text":"<pre><code>Result = Success | PartialFailure | Error | OutOfBounds\n</code></pre> <p>Power distribution result.</p> <p>Example: Handling power distribution results</p> <pre><code>```python\nfrom typing import assert_never\n\nfrom frequenz.sdk.actor.power_distributing import (\n    Error,\n    OutOfBounds,\n    PartialFailure,\n    Result,\n    Success,\n)\nfrom frequenz.sdk.actor.power_distributing.request import Request\nfrom frequenz.sdk.actor.power_distributing.result import PowerBounds\nfrom frequenz.sdk.timeseries._quantities import Power\n\ndef handle_power_request_result(result: Result) -&gt; None:\n    match result:\n        case Success() as success:\n            print(f\"Power request was successful: {success}\")\n        case PartialFailure() as partial_failure:\n            print(f\"Power request was partially successful: {partial_failure}\")\n        case OutOfBounds() as out_of_bounds:\n            print(f\"Power request was out of bounds: {out_of_bounds}\")\n        case Error() as error:\n            print(f\"Power request failed: {error}\")\n        case _ as unreachable:\n            assert_never(unreachable)\n\nrequest = Request(\n    namespace=\"TestChannel\",\n    power=Power.from_watts(123.4),\n    batteries={8, 18},\n)\n\nresults: list[Result] = [\n    Success(\n        request,\n        succeeded_power=Power.from_watts(123.4),\n        succeeded_batteries={8, 18},\n        excess_power=Power.zero(),\n    ),\n    PartialFailure(\n        request,\n        succeeded_power=Power.from_watts(103.4),\n        succeeded_batteries={8},\n        excess_power=Power.zero(),\n        failed_batteries={18},\n        failed_power=Power.from_watts(20.0),\n    ),\n    OutOfBounds(request, bounds=PowerBounds(0, 0, 0, 800)),\n    Error(request, msg=\"The batteries are not available\"),\n]\n\nfor r in results:\n    handle_power_request_result(r)\n```\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error","title":"frequenz.sdk.actor.power_distributing.result.Error  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseResultMixin</code></p> <p>Result returned when an error occurred and power was not set at all.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Error(_BaseResultMixin):\n\"\"\"Result returned when an error occurred and power was not set at all.\"\"\"\nmsg: str\n\"\"\"The error message explaining why error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg: str\n</code></pre> <p>The error message explaining why error happened.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds","title":"frequenz.sdk.actor.power_distributing.result.OutOfBounds  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseResultMixin</code></p> <p>Result returned when the power was not set because it was out of bounds.</p> <p>This result happens when the originating request was done with <code>adjust_power = False</code> and the requested power is not within the batteries bounds.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass OutOfBounds(_BaseResultMixin):\n\"\"\"Result returned when the power was not set because it was out of bounds.\n    This result happens when the originating request was done with\n    `adjust_power = False` and the requested power is not within the batteries bounds.\n    \"\"\"\nbounds: PowerBounds\n\"\"\"The power bounds for the requested batteries.\n    If the requested power negative, then this value is the lower bound.\n    Otherwise it is upper bound.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds.bounds","title":"bounds  <code>instance-attribute</code>","text":"<pre><code>bounds: PowerBounds\n</code></pre> <p>The power bounds for the requested batteries.</p> <p>If the requested power negative, then this value is the lower bound. Otherwise it is upper bound.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure","title":"frequenz.sdk.actor.power_distributing.result.PartialFailure  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when any battery failed to perform the request.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PartialFailure(_BaseSuccessMixin, _BaseResultMixin):\n\"\"\"Result returned when any battery failed to perform the request.\"\"\"\nfailed_power: Power\n\"\"\"The part of the requested power that failed to be set.\"\"\"\nfailed_batteries: set[int]\n\"\"\"The subset of batteries for which the request failed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.excess_power","title":"excess_power  <code>instance-attribute</code>","text":"<pre><code>excess_power: Power\n</code></pre> <p>The part of the requested power that could not be fulfilled.</p> <p>This happens when the requested power is outside the available power bounds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_batteries","title":"failed_batteries  <code>instance-attribute</code>","text":"<pre><code>failed_batteries: set[int]\n</code></pre> <p>The subset of batteries for which the request failed.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_power","title":"failed_power  <code>instance-attribute</code>","text":"<pre><code>failed_power: Power\n</code></pre> <p>The part of the requested power that failed to be set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.succeeded_batteries","title":"succeeded_batteries  <code>instance-attribute</code>","text":"<pre><code>succeeded_batteries: set[int]\n</code></pre> <p>The subset of batteries for which power was set successfully.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.succeeded_power","title":"succeeded_power  <code>instance-attribute</code>","text":"<pre><code>succeeded_power: Power\n</code></pre> <p>The part of the requested power that was successfully set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds","title":"frequenz.sdk.actor.power_distributing.result.PowerBounds  <code>dataclass</code>","text":"<p>Inclusion and exclusion power bounds for requested batteries.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PowerBounds:\n\"\"\"Inclusion and exclusion power bounds for requested batteries.\"\"\"\ninclusion_lower: float\n\"\"\"The lower value of the inclusion power bounds for the requested batteries.\"\"\"\nexclusion_lower: float\n\"\"\"The lower value of the exclusion power bounds for the requested batteries.\"\"\"\nexclusion_upper: float\n\"\"\"The upper value of the exclusion power bounds for the requested batteries.\"\"\"\ninclusion_upper: float\n\"\"\"The upper value of the inclusion power bounds for the requested batteries.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.exclusion_lower","title":"exclusion_lower  <code>instance-attribute</code>","text":"<pre><code>exclusion_lower: float\n</code></pre> <p>The lower value of the exclusion power bounds for the requested batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.exclusion_upper","title":"exclusion_upper  <code>instance-attribute</code>","text":"<pre><code>exclusion_upper: float\n</code></pre> <p>The upper value of the exclusion power bounds for the requested batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.inclusion_lower","title":"inclusion_lower  <code>instance-attribute</code>","text":"<pre><code>inclusion_lower: float\n</code></pre> <p>The lower value of the inclusion power bounds for the requested batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.inclusion_upper","title":"inclusion_upper  <code>instance-attribute</code>","text":"<pre><code>inclusion_upper: float\n</code></pre> <p>The upper value of the inclusion power bounds for the requested batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success","title":"frequenz.sdk.actor.power_distributing.result.Success  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when setting the power succeeded for all batteries.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Success(_BaseSuccessMixin, _BaseResultMixin):  # Order matters here. See above.\n\"\"\"Result returned when setting the power succeeded for all batteries.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/config/","title":"config","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config","title":"frequenz.sdk.config","text":"<p>Config interface.</p>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config","title":"frequenz.sdk.config.Config","text":"<p>Stores config variables.</p> <p>Config variables are read from a file. Only single file can be read. If new file is read, then previous configs will be forgotten.</p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>class Config:\n\"\"\"\n    Stores config variables.\n    Config variables are read from a file.\n    Only single file can be read.\n    If new file is read, then previous configs will be forgotten.\n    \"\"\"\ndef __init__(self, conf_vars: dict[str, Any]):\n\"\"\"Instantiate the config store and read config variables from the file.\n        Args:\n            conf_vars: Dict containing configuration variables\n        \"\"\"\nself._conf_store: dict[str, Any] = conf_vars\ndef get(self, key: str, default: Any = None) -&gt; Any:\n\"\"\"Get the value for the specified key.\n        If the key is not in the configs, then return default.\n        Args:\n            key: Key to be searched.\n            default: Value to be returned if the key is not found.  Defaults to\n                None.\n        Returns:\n            value in str format or default.\n        \"\"\"\nreturn self._conf_store.get(key, default)\ndef get_dict(\nself, key_prefix: str, expected_values_type: T | None\n) -&gt; dict[str, Any]:\n\"\"\"Get a dictionary based on config key prefixes.\n        For example, if key_prefix is \"my_dict\", then the following config store:\n            {\n                'some_key': 'some_value',\n                'my_dict_key1': 'value1',\n                'my_dict_key2': 'value2',\n            }\n        Will return:\n            {\n                'key1': 'value1',\n                'key2': 'value2',\n            }\n        Args:\n            key_prefix: Only get configuration variables starting with this\n                prefix.\n            expected_values_type: If provided, the value will be validated against\n                this type.\n        Returns:\n            A dictionary containing the keys prefixed with `key_prefix` as keys\n                (but with the prefix removed) and the values as values.\n        \"\"\"\nresult: dict[str, Any] = {}\nfor key, value in self._conf_store.items():\nif key.startswith(key_prefix):\nnew_key = key[len(key_prefix) :]\nif expected_values_type is not None:\nvalue = self.get_as(key, expected_values_type)\nresult[new_key] = value\nreturn result\ndef get_as(self, key: str, expected_type: Any) -&gt; Any:\n\"\"\"Get and convert the value to specified type.\n        Check if type of the value is as expected.  If type is correct, then\n        return converted value.  Otherwise Raise ValueError.\n        Type can be:\n            * Any typing module type.\n            * Any pydantic strict types (e.g. pydantic.StrictInt)\n        Args:\n            key: Key to be search\n            expected_type: type for the value\n        Raises:\n            ValueError: If can't convert value to the expected type.\n            KeyError: If specified key is not in config.\n        Returns:\n            Value for the specified key, converted to specified type.\n        Example:\n            For `var1='[1, 2.0, 3.5]'`:\n                * `get_as(\"var1\", List[int])` -&gt; `[1,2,3]`\n                * `get_as(\"var1\", List[float])` -&gt; `[1.0,2.0,3.5]`\n                * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; [ValueError][]\n                * `get_as(\"var1\", List[pydantic.StrictFloat])` -&gt; [ValueError][]\n            For `var1='[1,2,3]'`:\n                * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; `[1,2,3]`\n        \"\"\"\nvalue = self[key]\nif str is expected_type:\nreturn value\ntry:\nobj = json.loads(value)\nmetadata = getattr(expected_type, \"__metadata__\", (None,))[0]\nstrict = metadata.strict if isinstance(metadata, Strict) else False\nadapter = TypeAdapter(expected_type)\nparsed_value = adapter.validate_python(obj, strict=strict)\nexcept (ValidationError, ValueError) as err:\nraise ValueError(\nf\"Could not convert config variable: {key} = '{value}' \"\nf\"to type {str(expected_type)}, err:\" + str(err)\n) from err\nreturn parsed_value\ndef __getitem__(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified key.\n        If the key is not in the configs, then raise KeyError.\n        Args:\n            key: key to be searched.\n        Raises:\n            KeyError: If key is not in found.\n        Returns:\n            Dictionary if the corresponding value is a subsection in the .toml\n                file or a primitive type it is a simple value.\n        \"\"\"\nvalue = self._conf_store.get(key, None)\nif value is None:\nraise KeyError(f\"Unknown config name {key}\")\nreturn value\ndef __contains__(self, key: str) -&gt; bool:\n\"\"\"Return whether the specified key is in the storage.\n        Args:\n            key: Config variable name.\n        Returns:\n            True if key is in the storage, otherwise returns False.\n        \"\"\"\nreturn key in self._conf_store\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.__contains__","title":"__contains__","text":"<pre><code>__contains__(key: str) -&gt; bool\n</code></pre> <p>Return whether the specified key is in the storage.</p> PARAMETER  DESCRIPTION <code>key</code> <p>Config variable name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if key is in the storage, otherwise returns False.</p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n\"\"\"Return whether the specified key is in the storage.\n    Args:\n        key: Config variable name.\n    Returns:\n        True if key is in the storage, otherwise returns False.\n    \"\"\"\nreturn key in self._conf_store\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Get the value for the specified key.</p> <p>If the key is not in the configs, then raise KeyError.</p> PARAMETER  DESCRIPTION <code>key</code> <p>key to be searched.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If key is not in found.</p> RETURNS DESCRIPTION <code>Any</code> <p>Dictionary if the corresponding value is a subsection in the .toml file or a primitive type it is a simple value.</p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified key.\n    If the key is not in the configs, then raise KeyError.\n    Args:\n        key: key to be searched.\n    Raises:\n        KeyError: If key is not in found.\n    Returns:\n        Dictionary if the corresponding value is a subsection in the .toml\n            file or a primitive type it is a simple value.\n    \"\"\"\nvalue = self._conf_store.get(key, None)\nif value is None:\nraise KeyError(f\"Unknown config name {key}\")\nreturn value\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.__init__","title":"__init__","text":"<pre><code>__init__(conf_vars: dict[str, Any])\n</code></pre> <p>Instantiate the config store and read config variables from the file.</p> PARAMETER  DESCRIPTION <code>conf_vars</code> <p>Dict containing configuration variables</p> <p> TYPE: <code>dict[str, Any]</code> </p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def __init__(self, conf_vars: dict[str, Any]):\n\"\"\"Instantiate the config store and read config variables from the file.\n    Args:\n        conf_vars: Dict containing configuration variables\n    \"\"\"\nself._conf_store: dict[str, Any] = conf_vars\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.get","title":"get","text":"<pre><code>get(key: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value for the specified key.</p> <p>If the key is not in the configs, then return default.</p> PARAMETER  DESCRIPTION <code>key</code> <p>Key to be searched.</p> <p> TYPE: <code>str</code> </p> <code>default</code> <p>Value to be returned if the key is not found.  Defaults to None.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>value in str format or default.</p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n\"\"\"Get the value for the specified key.\n    If the key is not in the configs, then return default.\n    Args:\n        key: Key to be searched.\n        default: Value to be returned if the key is not found.  Defaults to\n            None.\n    Returns:\n        value in str format or default.\n    \"\"\"\nreturn self._conf_store.get(key, default)\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.get_as","title":"get_as","text":"<pre><code>get_as(key: str, expected_type: Any) -&gt; Any\n</code></pre> <p>Get and convert the value to specified type.</p> <p>Check if type of the value is as expected.  If type is correct, then return converted value.  Otherwise Raise ValueError.</p> Type can be <ul> <li>Any typing module type.</li> <li>Any pydantic strict types (e.g. pydantic.StrictInt)</li> </ul> PARAMETER  DESCRIPTION <code>key</code> <p>Key to be search</p> <p> TYPE: <code>str</code> </p> <code>expected_type</code> <p>type for the value</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If can't convert value to the expected type.</p> <code>KeyError</code> <p>If specified key is not in config.</p> RETURNS DESCRIPTION <code>Any</code> <p>Value for the specified key, converted to specified type.</p> Example <p>For <code>var1='[1, 2.0, 3.5]'</code>:     * <code>get_as(\"var1\", List[int])</code> -&gt; <code>[1,2,3]</code>     * <code>get_as(\"var1\", List[float])</code> -&gt; <code>[1.0,2.0,3.5]</code>     * <code>get_as(\"var1\", List[pydantic.StrictInt])</code> -&gt; ValueError     * <code>get_as(\"var1\", List[pydantic.StrictFloat])</code> -&gt; ValueError</p> <p>For <code>var1='[1,2,3]'</code>:     * <code>get_as(\"var1\", List[pydantic.StrictInt])</code> -&gt; <code>[1,2,3]</code></p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def get_as(self, key: str, expected_type: Any) -&gt; Any:\n\"\"\"Get and convert the value to specified type.\n    Check if type of the value is as expected.  If type is correct, then\n    return converted value.  Otherwise Raise ValueError.\n    Type can be:\n        * Any typing module type.\n        * Any pydantic strict types (e.g. pydantic.StrictInt)\n    Args:\n        key: Key to be search\n        expected_type: type for the value\n    Raises:\n        ValueError: If can't convert value to the expected type.\n        KeyError: If specified key is not in config.\n    Returns:\n        Value for the specified key, converted to specified type.\n    Example:\n        For `var1='[1, 2.0, 3.5]'`:\n            * `get_as(\"var1\", List[int])` -&gt; `[1,2,3]`\n            * `get_as(\"var1\", List[float])` -&gt; `[1.0,2.0,3.5]`\n            * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; [ValueError][]\n            * `get_as(\"var1\", List[pydantic.StrictFloat])` -&gt; [ValueError][]\n        For `var1='[1,2,3]'`:\n            * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; `[1,2,3]`\n    \"\"\"\nvalue = self[key]\nif str is expected_type:\nreturn value\ntry:\nobj = json.loads(value)\nmetadata = getattr(expected_type, \"__metadata__\", (None,))[0]\nstrict = metadata.strict if isinstance(metadata, Strict) else False\nadapter = TypeAdapter(expected_type)\nparsed_value = adapter.validate_python(obj, strict=strict)\nexcept (ValidationError, ValueError) as err:\nraise ValueError(\nf\"Could not convert config variable: {key} = '{value}' \"\nf\"to type {str(expected_type)}, err:\" + str(err)\n) from err\nreturn parsed_value\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.get_dict","title":"get_dict","text":"<pre><code>get_dict(\nkey_prefix: str, expected_values_type: T | None\n) -&gt; dict[str, Any]\n</code></pre> <p>Get a dictionary based on config key prefixes.</p> <p>For example, if key_prefix is \"my_dict\", then the following config store:     {         'some_key': 'some_value',         'my_dict_key1': 'value1',         'my_dict_key2': 'value2',     } Will return:     {         'key1': 'value1',         'key2': 'value2',     }</p> PARAMETER  DESCRIPTION <code>key_prefix</code> <p>Only get configuration variables starting with this prefix.</p> <p> TYPE: <code>str</code> </p> <code>expected_values_type</code> <p>If provided, the value will be validated against this type.</p> <p> TYPE: <code>T | None</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A dictionary containing the keys prefixed with <code>key_prefix</code> as keys (but with the prefix removed) and the values as values.</p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def get_dict(\nself, key_prefix: str, expected_values_type: T | None\n) -&gt; dict[str, Any]:\n\"\"\"Get a dictionary based on config key prefixes.\n    For example, if key_prefix is \"my_dict\", then the following config store:\n        {\n            'some_key': 'some_value',\n            'my_dict_key1': 'value1',\n            'my_dict_key2': 'value2',\n        }\n    Will return:\n        {\n            'key1': 'value1',\n            'key2': 'value2',\n        }\n    Args:\n        key_prefix: Only get configuration variables starting with this\n            prefix.\n        expected_values_type: If provided, the value will be validated against\n            this type.\n    Returns:\n        A dictionary containing the keys prefixed with `key_prefix` as keys\n            (but with the prefix removed) and the values as values.\n    \"\"\"\nresult: dict[str, Any] = {}\nfor key, value in self._conf_store.items():\nif key.startswith(key_prefix):\nnew_key = key[len(key_prefix) :]\nif expected_values_type is not None:\nvalue = self.get_as(key, expected_values_type)\nresult[new_key] = value\nreturn result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/","title":"Index","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid","title":"frequenz.sdk.microgrid","text":"<p>A microgrid is a local electrical grid that connects a set of electrical components together.  They are often built around a passive power consumer, to supplement the electricity consumed from the public grid with on-site power generation or storage systems.</p> <p>Microgrids can also function in island-mode, without a grid connection, or without a local power consumer, but they have to have at least one of the two, to be meaningful.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--frequenz-sdk-microgrid-model","title":"Frequenz SDK Microgrid Model","text":"<p>The SDK aims to provide an abstract model of the microgrid that enables high-level interactions with microgrid components, without having to worry about (or even be aware of) location-specific details such as:</p> <ul> <li>where the meters are placed,</li> <li>how many batteries,</li> <li>whether there's a grid connection or a passive consumer,</li> <li>what models the inverters are, etc.</li> <li>whether components are having downtimes, because metrics and   limits get adjusted automatically when components are having downtimes.</li> </ul> <p>Users of the SDK can develop applications around this interface once and deploy anywhere, and the SDK will take care of translating the requests and instructions to correspond to the specific microgrid configurations.</p> <pre><code>flowchart LR\n\nsubgraph Left[Measurements only]\ndirection LR\n  grid[\"Grid Connection\"]\n  consumer[\"Consumer\"]\n  pv[\"PV Arrays\"]\n  chp[\"CHP\"]\nend\n\njunction(( ))\n\nsubgraph Right[Measurements and control]\ndirection LR\n  bat[\"Batteries\"]\n  ev[\"EV Chargers\"]\nend\n\ngrid --- junction\nconsumer --- junction\npv --- junction\nchp --- junction\n\njunction --- bat\njunction --- ev</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--grid","title":"Grid","text":"<p>This refers to a microgrid's connection to the external Grid.  The power flowing through this connection can be streamed through <code>grid_power</code>.</p> <p>In locations without a grid connection, this method remains accessible, and streams zero values.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--consumer","title":"Consumer","text":"<p>This is the main power consumer at the site of a microgrid, and often the load the microgrid is built to support.  The power drawn by the consumer is available through <code>consumer_power</code></p> <p>In locations without a consumer, this method streams zero values.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--producers-pv-arrays-chp","title":"Producers: PV Arrays, CHP","text":"<p>The total PV power production in a microgrid can be streamed through <code>pv_power</code> , and similarly the total CHP production in a site can be streamed through <code>chp_power</code>.  And total producer power is available through <code>producer_power</code>.</p> <p>As is the case with the other methods, if PV Arrays or CHPs are not available in a microgrid, the corresponding methods stream zero values.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--batteries","title":"Batteries","text":"<p>The total Battery power is available through <code>battery_pool</code>'s <code>power</code>.  The battery pool by default uses all batteries available at a location, but battery pool instances can be created for subsets of batteries if necessary, by specifying the battery ids.</p> <p>The <code>battery_pool</code> also provides <code>soc</code>, <code>capacity</code>, <code>temperature</code> and available power bounds through the <code>power_status</code> method.</p> <p>The <code>battery_pool</code> also provides control methods <code>propose_power</code> (which accepts values in the Passive Sign Convention and supports both charging and discharging), or through <code>propose_charge</code>, or <code>propose_discharge</code>.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--ev-chargers","title":"EV Chargers","text":"<p>The <code>ev_charger_pool</code> offers a <code>power</code> method that streams the total power measured for all the EV Chargers at a site.</p> <p>It also offers a <code>component_data</code> method for fetching the status of individual EV Chargers, including state changes like when an EV is connected or disconnected, and a <code>set_bounds</code> method to limit the charge power of individual EV Chargers.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.battery_pool","title":"frequenz.sdk.microgrid.battery_pool","text":"<pre><code>battery_pool(\nbattery_ids: abc.Set[int] | None = None,\nname: str | None = None,\npriority: int = -sys.maxsize - 1,\n) -&gt; BatteryPool\n</code></pre> <p>Return a new <code>BatteryPool</code> instance for the given parameters.</p> <p>The priority value is used to resolve conflicts when multiple actors are trying to propose different power values for the same set of batteries.</p> <p>Note</p> <p>When specifying priority, bigger values indicate higher priority. The default priority is the lowest possible value.</p> PARAMETER  DESCRIPTION <code>battery_ids</code> <p>Optional set of IDs of batteries to be managed by the <code>BatteryPool</code>. If not specified, all batteries available in the component graph are used.</p> <p> TYPE: <code>Set[int] | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>An optional name used to identify this instance of the pool or a corresponding actor in the logs.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>priority</code> <p>The priority of the actor making the call.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-maxsize - 1</code> </p> RETURNS DESCRIPTION <code>BatteryPool</code> <p>A <code>BatteryPool</code> instance.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def battery_pool(\nbattery_ids: abc.Set[int] | None = None,\nname: str | None = None,\npriority: int = -sys.maxsize - 1,\n) -&gt; BatteryPool:\n\"\"\"Return a new `BatteryPool` instance for the given parameters.\n    The priority value is used to resolve conflicts when multiple actors are trying to\n    propose different power values for the same set of batteries.\n    !!! note\n        When specifying priority, bigger values indicate higher priority. The default\n        priority is the lowest possible value.\n    Args:\n        battery_ids: Optional set of IDs of batteries to be managed by the `BatteryPool`.\n            If not specified, all batteries available in the component graph are used.\n        name: An optional name used to identify this instance of the pool or a\n            corresponding actor in the logs.\n        priority: The priority of the actor making the call.\n    Returns:\n        A `BatteryPool` instance.\n    \"\"\"\nreturn _get().battery_pool(battery_ids, name, priority)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ev_charger_pool","title":"frequenz.sdk.microgrid.ev_charger_pool","text":"<pre><code>ev_charger_pool(\nev_charger_ids: set[int] | None = None,\n) -&gt; EVChargerPool\n</code></pre> <p>Return the corresponding EVChargerPool instance for the given ids.</p> <p>If an EVChargerPool instance for the given ids doesn't exist, a new one is created and returned.</p> PARAMETER  DESCRIPTION <code>ev_charger_ids</code> <p>Optional set of IDs of EV Chargers to be managed by the EVChargerPool.  If not specified, all EV Chargers available in the component graph are used.</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>EVChargerPool</code> <p>An EVChargerPool instance.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def ev_charger_pool(ev_charger_ids: set[int] | None = None) -&gt; EVChargerPool:\n\"\"\"Return the corresponding EVChargerPool instance for the given ids.\n    If an EVChargerPool instance for the given ids doesn't exist, a new one is\n    created and returned.\n    Args:\n        ev_charger_ids: Optional set of IDs of EV Chargers to be managed by the\n            EVChargerPool.  If not specified, all EV Chargers available in the\n            component graph are used.\n    Returns:\n        An EVChargerPool instance.\n    \"\"\"\nreturn _get().ev_charger_pool(ev_charger_ids)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.frequency","title":"frequenz.sdk.microgrid.frequency","text":"<pre><code>frequency(\ncomponent: Component | None = None,\n) -&gt; GridFrequency\n</code></pre> <p>Return the grid frequency.</p> PARAMETER  DESCRIPTION <code>component</code> <p>Optional component to get the frequency for. If not specified, the frequency of the grid is returned.</p> <p> TYPE: <code>Component | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>GridFrequency</code> <p>The grid frequency.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def frequency(component: Component | None = None) -&gt; GridFrequency:\n\"\"\"Return the grid frequency.\n    Args:\n        component: Optional component to get the frequency for. If not specified,\n            the frequency of the grid is returned.\n    Returns:\n        The grid frequency.\n    \"\"\"\nreturn _get().frequency(component)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.grid","title":"frequenz.sdk.microgrid.grid","text":"<pre><code>grid() -&gt; Grid | None\n</code></pre> <p>Return the grid instance.</p> RETURNS DESCRIPTION <code>Grid | None</code> <p>The Grid instance.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def grid() -&gt; Grid | None:\n\"\"\"Return the grid instance.\n    Returns:\n        The Grid instance.\n    \"\"\"\nreturn _get().grid()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.initialize","title":"frequenz.sdk.microgrid.initialize  <code>async</code>","text":"<pre><code>initialize(\nhost: str, port: int, resampler_config: ResamplerConfig\n) -&gt; None\n</code></pre> <p>Initialize the microgrid connection manager and the data pipeline.</p> PARAMETER  DESCRIPTION <code>host</code> <p>Host to connect to, to reach the microgrid API.</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>port to connect to.</p> <p> TYPE: <code>int</code> </p> <code>resampler_config</code> <p>Configuration for the resampling actor.</p> <p> TYPE: <code>ResamplerConfig</code> </p> Source code in <code>frequenz/sdk/microgrid/__init__.py</code> <pre><code>async def initialize(host: str, port: int, resampler_config: ResamplerConfig) -&gt; None:\n\"\"\"Initialize the microgrid connection manager and the data pipeline.\n    Args:\n        host: Host to connect to, to reach the microgrid API.\n        port: port to connect to.\n        resampler_config: Configuration for the resampling actor.\n    \"\"\"\nawait connection_manager.initialize(host, port)\napi_client = connection_manager.get().api_client\ncomponents = await api_client.components()\ninitialize_grid(components)\nawait _data_pipeline.initialize(resampler_config)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.logical_meter","title":"frequenz.sdk.microgrid.logical_meter","text":"<pre><code>logical_meter() -&gt; LogicalMeter\n</code></pre> <p>Return the logical meter instance.</p> <p>If a LogicalMeter instance doesn't exist, a new one is created and returned.</p> RETURNS DESCRIPTION <code>LogicalMeter</code> <p>A logical meter instance.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def logical_meter() -&gt; LogicalMeter:\n\"\"\"Return the logical meter instance.\n    If a LogicalMeter instance doesn't exist, a new one is created and returned.\n    Returns:\n        A logical meter instance.\n    \"\"\"\nreturn _get().logical_meter()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/","title":"component_graph","text":""},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph","title":"frequenz.sdk.microgrid.component_graph","text":"<p>Defines a graph representation of how microgrid components are connected.</p> <p>The component graph is an approximate representation of the microgrid circuit, abstracted to a level appropriate for higher-level monitoring and control. Examples of use-cases would be:</p> <ul> <li> <p>using the graph structure to infer which component measurements     need to be combined to obtain grid power or onsite load</p> </li> <li> <p>identifying which inverter(s) need to be engaged to (dis)charge     a particular battery</p> </li> <li> <p>understanding which power flows in the microgrid are derived from     green and grey sources</p> </li> </ul> <p>It deliberately does not include all pieces of hardware placed in the microgrid, instead limiting itself to just those that are needed to monitor and control the flow of power.</p>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph","title":"frequenz.sdk.microgrid.component_graph.ComponentGraph","text":"<p>             Bases: <code>ABC</code></p> <p>Interface for component graph implementations.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>class ComponentGraph(ABC):\n\"\"\"Interface for component graph implementations.\"\"\"\n@abstractmethod\ndef components(\nself,\ncomponent_id: set[int] | None = None,\ncomponent_category: set[ComponentCategory] | None = None,\n) -&gt; set[Component]:\n\"\"\"Fetch the components of the microgrid.\n        Args:\n            component_id: filter out any components not matching one of the provided IDs\n            component_category: filter out any components not matching one of the\n                provided types\n        Returns:\n            Set of the components currently connected to the microgrid, filtered by\n                the provided `component_id` and `component_category` values.\n        \"\"\"\n@abstractmethod\ndef connections(\nself,\nstart: set[int] | None = None,\nend: set[int] | None = None,\n) -&gt; set[Connection]:\n\"\"\"Fetch the connections between microgrid components.\n        Args:\n            start: filter out any connections whose `start` does not match one of these\n                component IDs\n            end: filter out any connections whose `end` does not match one of these\n                component IDs\n        Returns:\n            Set of the connections between components in the microgrid, filtered by\n                the provided `start`/`end` choices.\n        \"\"\"\n@abstractmethod\ndef predecessors(self, component_id: int) -&gt; set[Component]:\n\"\"\"Fetch the graph predecessors of the specified component.\n        Args:\n            component_id: numerical ID of the component whose predecessors should be\n                fetched\n        Returns:\n            Set of IDs of the components that are predecessors of `component_id`,\n                i.e. for which there is a connection from each of these components to\n                `component_id`.\n        Raises:\n            KeyError: if the specified `component_id` is not in the graph\n        \"\"\"\n@abstractmethod\ndef successors(self, component_id: int) -&gt; set[Component]:\n\"\"\"Fetch the graph successors of the specified component.\n        Args:\n            component_id: numerical ID of the component whose successors should be\n                fetched\n        Returns:\n            Set of IDs of the components that are successors of `component_id`,\n                i.e. for which there is a connection from `component_id` to each of\n                these components.\n        Raises:\n            KeyError: if the specified `component_id` is not in the graph\n        \"\"\"\n@abstractmethod\ndef is_pv_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV inverter.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a PV inverter.\n        \"\"\"\n@abstractmethod\ndef is_pv_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV meter.\n        This is done by checking if the component has only PV inverters as its\n        successors.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a PV meter.\n        \"\"\"\n@abstractmethod\ndef is_pv_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a PV chain.\n        A component is part of a PV chain if it is a PV meter or a PV inverter.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is part of a PV chain.\n        \"\"\"\n@abstractmethod\ndef is_battery_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery inverter.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a battery inverter.\n        \"\"\"\n@abstractmethod\ndef is_battery_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery meter.\n        This is done by checking if the component has only battery inverters as its\n        predecessors.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a battery meter.\n        \"\"\"\n@abstractmethod\ndef is_battery_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a battery chain.\n        A component is part of a battery chain if it is a battery meter or a battery\n        inverter.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is part of a battery chain.\n        \"\"\"\n@abstractmethod\ndef is_ev_charger(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is an EV charger.\n        \"\"\"\n@abstractmethod\ndef is_ev_charger_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger meter.\n        This is done by checking if the component has only EV chargers as its\n        successors.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is an EV charger meter.\n        \"\"\"\n@abstractmethod\ndef is_ev_charger_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of an EV charger chain.\n        A component is part of an EV charger chain if it is an EV charger meter or an\n        EV charger.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is part of an EV charger chain.\n        \"\"\"\n@abstractmethod\ndef is_chp(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a CHP.\n        \"\"\"\n@abstractmethod\ndef is_chp_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP meter.\n        This is done by checking if the component has only CHPs as its successors.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a CHP meter.\n        \"\"\"\n@abstractmethod\ndef is_chp_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a CHP chain.\n        A component is part of a CHP chain if it is a CHP meter or a CHP.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is part of a CHP chain.\n        \"\"\"\n@abstractmethod\ndef dfs(\nself,\ncurrent_node: Component,\nvisited: set[Component],\ncondition: Callable[[Component], bool],\n) -&gt; set[Component]:\n\"\"\"\n        Search for components that fulfill the condition in the Graph.\n        DFS is used for searching the graph. The graph traversal is stopped\n        once a component fulfills the condition.\n        Args:\n            current_node: The current node to search from.\n            visited: The set of visited nodes.\n            condition: The condition function to check for.\n        Returns:\n            A set of component ids where the corresponding components fulfill\n            the condition function.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.components","title":"components  <code>abstractmethod</code>","text":"<pre><code>components(\ncomponent_id: set[int] | None = None,\ncomponent_category: set[ComponentCategory]\n| None = None,\n) -&gt; set[Component]\n</code></pre> <p>Fetch the components of the microgrid.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>filter out any components not matching one of the provided IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>component_category</code> <p>filter out any components not matching one of the provided types</p> <p> TYPE: <code>set[ComponentCategory] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>Set of the components currently connected to the microgrid, filtered by the provided <code>component_id</code> and <code>component_category</code> values.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef components(\nself,\ncomponent_id: set[int] | None = None,\ncomponent_category: set[ComponentCategory] | None = None,\n) -&gt; set[Component]:\n\"\"\"Fetch the components of the microgrid.\n    Args:\n        component_id: filter out any components not matching one of the provided IDs\n        component_category: filter out any components not matching one of the\n            provided types\n    Returns:\n        Set of the components currently connected to the microgrid, filtered by\n            the provided `component_id` and `component_category` values.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.connections","title":"connections  <code>abstractmethod</code>","text":"<pre><code>connections(\nstart: set[int] | None = None,\nend: set[int] | None = None,\n) -&gt; set[Connection]\n</code></pre> <p>Fetch the connections between microgrid components.</p> PARAMETER  DESCRIPTION <code>start</code> <p>filter out any connections whose <code>start</code> does not match one of these component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>end</code> <p>filter out any connections whose <code>end</code> does not match one of these component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>set[Connection]</code> <p>Set of the connections between components in the microgrid, filtered by the provided <code>start</code>/<code>end</code> choices.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef connections(\nself,\nstart: set[int] | None = None,\nend: set[int] | None = None,\n) -&gt; set[Connection]:\n\"\"\"Fetch the connections between microgrid components.\n    Args:\n        start: filter out any connections whose `start` does not match one of these\n            component IDs\n        end: filter out any connections whose `end` does not match one of these\n            component IDs\n    Returns:\n        Set of the connections between components in the microgrid, filtered by\n            the provided `start`/`end` choices.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.dfs","title":"dfs  <code>abstractmethod</code>","text":"<pre><code>dfs(\ncurrent_node: Component,\nvisited: set[Component],\ncondition: Callable[[Component], bool],\n) -&gt; set[Component]\n</code></pre> <p>Search for components that fulfill the condition in the Graph.</p> <p>DFS is used for searching the graph. The graph traversal is stopped once a component fulfills the condition.</p> PARAMETER  DESCRIPTION <code>current_node</code> <p>The current node to search from.</p> <p> TYPE: <code>Component</code> </p> <code>visited</code> <p>The set of visited nodes.</p> <p> TYPE: <code>set[Component]</code> </p> <code>condition</code> <p>The condition function to check for.</p> <p> TYPE: <code>Callable[[Component], bool]</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>A set of component ids where the corresponding components fulfill</p> <code>set[Component]</code> <p>the condition function.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef dfs(\nself,\ncurrent_node: Component,\nvisited: set[Component],\ncondition: Callable[[Component], bool],\n) -&gt; set[Component]:\n\"\"\"\n    Search for components that fulfill the condition in the Graph.\n    DFS is used for searching the graph. The graph traversal is stopped\n    once a component fulfills the condition.\n    Args:\n        current_node: The current node to search from.\n        visited: The set of visited nodes.\n        condition: The condition function to check for.\n    Returns:\n        A set of component ids where the corresponding components fulfill\n        the condition function.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_battery_chain","title":"is_battery_chain  <code>abstractmethod</code>","text":"<pre><code>is_battery_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of a battery chain.</p> <p>A component is part of a battery chain if it is a battery meter or a battery inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a battery chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a battery chain.\n    A component is part of a battery chain if it is a battery meter or a battery\n    inverter.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is part of a battery chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_battery_inverter","title":"is_battery_inverter  <code>abstractmethod</code>","text":"<pre><code>is_battery_inverter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a battery inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a battery inverter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery inverter.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a battery inverter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_battery_meter","title":"is_battery_meter  <code>abstractmethod</code>","text":"<pre><code>is_battery_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a battery meter.</p> <p>This is done by checking if the component has only battery inverters as its predecessors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a battery meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery meter.\n    This is done by checking if the component has only battery inverters as its\n    predecessors.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a battery meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_chp","title":"is_chp  <code>abstractmethod</code>","text":"<pre><code>is_chp(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a CHP.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a CHP.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_chp(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a CHP.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_chp_chain","title":"is_chp_chain  <code>abstractmethod</code>","text":"<pre><code>is_chp_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of a CHP chain.</p> <p>A component is part of a CHP chain if it is a CHP meter or a CHP.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a CHP chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_chp_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a CHP chain.\n    A component is part of a CHP chain if it is a CHP meter or a CHP.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is part of a CHP chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_chp_meter","title":"is_chp_meter  <code>abstractmethod</code>","text":"<pre><code>is_chp_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a CHP meter.</p> <p>This is done by checking if the component has only CHPs as its successors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a CHP meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_chp_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP meter.\n    This is done by checking if the component has only CHPs as its successors.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a CHP meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_ev_charger","title":"is_ev_charger  <code>abstractmethod</code>","text":"<pre><code>is_ev_charger(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is an EV charger.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is an EV charger.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is an EV charger.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_ev_charger_chain","title":"is_ev_charger_chain  <code>abstractmethod</code>","text":"<pre><code>is_ev_charger_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of an EV charger chain.</p> <p>A component is part of an EV charger chain if it is an EV charger meter or an EV charger.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of an EV charger chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of an EV charger chain.\n    A component is part of an EV charger chain if it is an EV charger meter or an\n    EV charger.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is part of an EV charger chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_ev_charger_meter","title":"is_ev_charger_meter  <code>abstractmethod</code>","text":"<pre><code>is_ev_charger_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is an EV charger meter.</p> <p>This is done by checking if the component has only EV chargers as its successors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is an EV charger meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger meter.\n    This is done by checking if the component has only EV chargers as its\n    successors.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is an EV charger meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_pv_chain","title":"is_pv_chain  <code>abstractmethod</code>","text":"<pre><code>is_pv_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of a PV chain.</p> <p>A component is part of a PV chain if it is a PV meter or a PV inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a PV chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a PV chain.\n    A component is part of a PV chain if it is a PV meter or a PV inverter.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is part of a PV chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_pv_inverter","title":"is_pv_inverter  <code>abstractmethod</code>","text":"<pre><code>is_pv_inverter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a PV inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a PV inverter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV inverter.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a PV inverter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_pv_meter","title":"is_pv_meter  <code>abstractmethod</code>","text":"<pre><code>is_pv_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a PV meter.</p> <p>This is done by checking if the component has only PV inverters as its successors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a PV meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV meter.\n    This is done by checking if the component has only PV inverters as its\n    successors.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a PV meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.predecessors","title":"predecessors  <code>abstractmethod</code>","text":"<pre><code>predecessors(component_id: int) -&gt; set[Component]\n</code></pre> <p>Fetch the graph predecessors of the specified component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>numerical ID of the component whose predecessors should be fetched</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>Set of IDs of the components that are predecessors of <code>component_id</code>, i.e. for which there is a connection from each of these components to <code>component_id</code>.</p> RAISES DESCRIPTION <code>KeyError</code> <p>if the specified <code>component_id</code> is not in the graph</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef predecessors(self, component_id: int) -&gt; set[Component]:\n\"\"\"Fetch the graph predecessors of the specified component.\n    Args:\n        component_id: numerical ID of the component whose predecessors should be\n            fetched\n    Returns:\n        Set of IDs of the components that are predecessors of `component_id`,\n            i.e. for which there is a connection from each of these components to\n            `component_id`.\n    Raises:\n        KeyError: if the specified `component_id` is not in the graph\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.successors","title":"successors  <code>abstractmethod</code>","text":"<pre><code>successors(component_id: int) -&gt; set[Component]\n</code></pre> <p>Fetch the graph successors of the specified component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>numerical ID of the component whose successors should be fetched</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>Set of IDs of the components that are successors of <code>component_id</code>, i.e. for which there is a connection from <code>component_id</code> to each of these components.</p> RAISES DESCRIPTION <code>KeyError</code> <p>if the specified <code>component_id</code> is not in the graph</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef successors(self, component_id: int) -&gt; set[Component]:\n\"\"\"Fetch the graph successors of the specified component.\n    Args:\n        component_id: numerical ID of the component whose successors should be\n            fetched\n    Returns:\n        Set of IDs of the components that are successors of `component_id`,\n            i.e. for which there is a connection from `component_id` to each of\n            these components.\n    Raises:\n        KeyError: if the specified `component_id` is not in the graph\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.InvalidGraphError","title":"frequenz.sdk.microgrid.component_graph.InvalidGraphError","text":"<p>             Bases: <code>Exception</code></p> <p>Exception type that will be thrown if graph data is not valid.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>class InvalidGraphError(Exception):\n\"\"\"Exception type that will be thrown if graph data is not valid.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/","title":"connection_manager","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager","title":"frequenz.sdk.microgrid.connection_manager","text":"<p>Microgrid Connection Manager singleton abstraction.</p> <p>This module provides a singleton abstraction over the microgrid. The main purpose is to provide the connection the microgrid API client and the microgrid component graph.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager","title":"frequenz.sdk.microgrid.connection_manager.ConnectionManager","text":"<p>             Bases: <code>ABC</code></p> <p>Creates and stores core features.</p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>class ConnectionManager(ABC):\n\"\"\"Creates and stores core features.\"\"\"\ndef __init__(self, host: str, port: int) -&gt; None:\n\"\"\"Create object instance.\n        Args:\n            host: server host\n            port: server port\n        \"\"\"\nsuper().__init__()\nself._host: str = host\nself._port: int = port\n@property\ndef host(self) -&gt; str:\n\"\"\"Get host of the currently connected server.\n        Returns:\n            host\n        \"\"\"\nreturn self._host\n@property\ndef port(self) -&gt; int:\n\"\"\"Get port of the currently connected server.\n        Returns:\n            port\n        \"\"\"\nreturn self._port\n@property\n@abstractmethod\ndef api_client(self) -&gt; MicrogridApiClient:\n\"\"\"Get MicrogridApiClient.\n        Returns:\n            api client\n        \"\"\"\n@property\n@abstractmethod\ndef component_graph(self) -&gt; ComponentGraph:\n\"\"\"Get component graph.\n        Returns:\n            component graph\n        \"\"\"\n@property\n@abstractmethod\ndef microgrid_id(self) -&gt; int | None:\n\"\"\"Get the ID of the microgrid if available.\n        Returns:\n            the ID of the microgrid if available, None otherwise.\n        \"\"\"\n@property\n@abstractmethod\ndef location(self) -&gt; Location | None:\n\"\"\"Get the location of the microgrid if available.\n        Returns:\n            the location of the microgrid if available, None otherwise.\n        \"\"\"\nasync def _update_api(self, host: str, port: int) -&gt; None:\nself._host = host\nself._port = port\n@abstractmethod\nasync def _initialize(self) -&gt; None:\n\"\"\"Initialize the object. This function should be called only once.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.api_client","title":"api_client  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>api_client: MicrogridApiClient\n</code></pre> <p>Get MicrogridApiClient.</p> RETURNS DESCRIPTION <code>MicrogridApiClient</code> <p>api client</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.component_graph","title":"component_graph  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>component_graph: ComponentGraph\n</code></pre> <p>Get component graph.</p> RETURNS DESCRIPTION <code>ComponentGraph</code> <p>component graph</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.host","title":"host  <code>property</code>","text":"<pre><code>host: str\n</code></pre> <p>Get host of the currently connected server.</p> RETURNS DESCRIPTION <code>str</code> <p>host</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.location","title":"location  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>location: Location | None\n</code></pre> <p>Get the location of the microgrid if available.</p> RETURNS DESCRIPTION <code>Location | None</code> <p>the location of the microgrid if available, None otherwise.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.microgrid_id","title":"microgrid_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>microgrid_id: int | None\n</code></pre> <p>Get the ID of the microgrid if available.</p> RETURNS DESCRIPTION <code>int | None</code> <p>the ID of the microgrid if available, None otherwise.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.port","title":"port  <code>property</code>","text":"<pre><code>port: int\n</code></pre> <p>Get port of the currently connected server.</p> RETURNS DESCRIPTION <code>int</code> <p>port</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.__init__","title":"__init__","text":"<pre><code>__init__(host: str, port: int) -&gt; None\n</code></pre> <p>Create object instance.</p> PARAMETER  DESCRIPTION <code>host</code> <p>server host</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>server port</p> <p> TYPE: <code>int</code> </p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n\"\"\"Create object instance.\n    Args:\n        host: server host\n        port: server port\n    \"\"\"\nsuper().__init__()\nself._host: str = host\nself._port: int = port\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.get","title":"frequenz.sdk.microgrid.connection_manager.get","text":"<pre><code>get() -&gt; ConnectionManager\n</code></pre> <p>Get the MicrogridApi instance created by initialize().</p> <p>This function should be only called after initialize().</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Raised when: * If <code>initialize()</code> method was not called before this call. * If <code>initialize()</code> methods was called but was not awaited and instance was     not created yet.</p> RETURNS DESCRIPTION <code>ConnectionManager</code> <p>MicrogridApi instance.</p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>def get() -&gt; ConnectionManager:\n\"\"\"Get the MicrogridApi instance created by initialize().\n    This function should be only called after initialize().\n    Raises:\n        RuntimeError: Raised when:\n            * If `initialize()` method was not called before this call.\n            * If `initialize()` methods was called but was not awaited and instance was\n                not created yet.\n    Returns:\n        MicrogridApi instance.\n    \"\"\"\nif _CONNECTION_MANAGER is None:\nraise RuntimeError(\n\"ConnectionManager is not initialized. \"\n\"Call `await microgrid.initialize()` first.\"\n)\nreturn _CONNECTION_MANAGER\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.initialize","title":"frequenz.sdk.microgrid.connection_manager.initialize  <code>async</code>","text":"<pre><code>initialize(host: str, port: int) -&gt; None\n</code></pre> <p>Initialize the MicrogridApi. This function should be called only once.</p> PARAMETER  DESCRIPTION <code>host</code> <p>Microgrid host</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Microgrid port</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If method was called more then once.</p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>async def initialize(host: str, port: int) -&gt; None:\n\"\"\"Initialize the MicrogridApi. This function should be called only once.\n    Args:\n        host: Microgrid host\n        port: Microgrid port\n    Raises:\n        AssertionError: If method was called more then once.\n    \"\"\"\n# From Doc: pylint just try to discourage this usage.\n# That doesn't mean you cannot use it.\nglobal _CONNECTION_MANAGER  # pylint: disable=global-statement\nif _CONNECTION_MANAGER is not None:\nraise AssertionError(\"MicrogridApi was already initialized.\")\n_logger.info(\"Connecting to microgrid at %s:%s\", host, port)\nmicrogrid_api = _InsecureConnectionManager(host, port)\nawait microgrid_api._initialize()  # pylint: disable=protected-access\n# Check again that _MICROGRID_API is None in case somebody had the great idea of\n# calling initialize() twice and in parallel.\nif _CONNECTION_MANAGER is not None:\nraise AssertionError(\"MicrogridApi was already initialized.\")\n_CONNECTION_MANAGER = microgrid_api\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/fuse/","title":"fuse","text":""},{"location":"reference/frequenz/sdk/microgrid/fuse/#frequenz.sdk.microgrid.fuse","title":"frequenz.sdk.microgrid.fuse","text":"<p>Fuse data class.</p>"},{"location":"reference/frequenz/sdk/microgrid/fuse/#frequenz.sdk.microgrid.fuse-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/fuse/#frequenz.sdk.microgrid.fuse.Fuse","title":"frequenz.sdk.microgrid.fuse.Fuse  <code>dataclass</code>","text":"<p>Fuse data class.</p> Source code in <code>frequenz/sdk/microgrid/fuse.py</code> <pre><code>@dataclass(frozen=True)\nclass Fuse:\n\"\"\"Fuse data class.\"\"\"\nmax_current: Current\n\"\"\"Rated current of the fuse.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/fuse/#frequenz.sdk.microgrid.fuse.Fuse-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/fuse/#frequenz.sdk.microgrid.fuse.Fuse.max_current","title":"max_current  <code>instance-attribute</code>","text":"<pre><code>max_current: Current\n</code></pre> <p>Rated current of the fuse.</p>"},{"location":"reference/frequenz/sdk/microgrid/metadata/","title":"metadata","text":""},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata","title":"frequenz.sdk.microgrid.metadata","text":"<p>Metadata that describes a microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location","title":"frequenz.sdk.microgrid.metadata.Location  <code>dataclass</code>","text":"<p>Metadata for the location of microgrid.</p> Source code in <code>frequenz/sdk/microgrid/metadata.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Location:\n\"\"\"Metadata for the location of microgrid.\"\"\"\nlatitude: float | None = None\n\"\"\"The latitude of the microgrid in degree.\"\"\"\nlongitude: float | None = None\n\"\"\"The longitude of the microgrid in degree.\"\"\"\ntimezone: ZoneInfo | None = None\n\"\"\"The timezone of the microgrid.\n    The timezone will be set to None if the latitude or longitude points\n    are not set or the timezone cannot be found given the location points.\n    \"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Initialize the timezone of the microgrid.\"\"\"\nif self.latitude is None or self.longitude is None or self.timezone is not None:\nreturn\ntimezone = _timezone_finder.timezone_at(lat=self.latitude, lng=self.longitude)\nif timezone:\n# The dataclass is frozen, so it needs to use __setattr__ to set the timezone.\nobject.__setattr__(self, \"timezone\", ZoneInfo(key=timezone))\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float | None = None\n</code></pre> <p>The latitude of the microgrid in degree.</p>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float | None = None\n</code></pre> <p>The longitude of the microgrid in degree.</p>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location.timezone","title":"timezone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timezone: ZoneInfo | None = None\n</code></pre> <p>The timezone of the microgrid.</p> <p>The timezone will be set to None if the latitude or longitude points are not set or the timezone cannot be found given the location points.</p>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Initialize the timezone of the microgrid.</p> Source code in <code>frequenz/sdk/microgrid/metadata.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Initialize the timezone of the microgrid.\"\"\"\nif self.latitude is None or self.longitude is None or self.timezone is not None:\nreturn\ntimezone = _timezone_finder.timezone_at(lat=self.latitude, lng=self.longitude)\nif timezone:\n# The dataclass is frozen, so it needs to use __setattr__ to set the timezone.\nobject.__setattr__(self, \"timezone\", ZoneInfo(key=timezone))\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Metadata","title":"frequenz.sdk.microgrid.metadata.Metadata  <code>dataclass</code>","text":"<p>Metadata for the microgrid.</p> Source code in <code>frequenz/sdk/microgrid/metadata.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Metadata:\n\"\"\"Metadata for the microgrid.\"\"\"\nmicrogrid_id: int | None = None\n\"\"\"The ID of the microgrid.\"\"\"\nlocation: Location | None = None\n\"\"\"The location of the microgrid.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Metadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Metadata.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: Location | None = None\n</code></pre> <p>The location of the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Metadata.microgrid_id","title":"microgrid_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int | None = None\n</code></pre> <p>The ID of the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/","title":"client","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client","title":"frequenz.sdk.microgrid.client","text":"<p>Microgrid API client.</p> <p>This package provides a low-level interface for interacting with the microgrid API.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection","title":"frequenz.sdk.microgrid.client.Connection","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Metadata for a connection between microgrid components.</p> Source code in <code>frequenz/sdk/microgrid/client/_connection.py</code> <pre><code>class Connection(NamedTuple):\n\"\"\"Metadata for a connection between microgrid components.\"\"\"\nstart: int\n\"\"\"The component ID that represents the start component of the connection.\"\"\"\nend: int\n\"\"\"The component ID that represents the end component of the connection.\"\"\"\ndef is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n        Returns:\n            `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n                otherwise.\n        \"\"\"\nreturn self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection.end","title":"end  <code>instance-attribute</code>","text":"<pre><code>end: int\n</code></pre> <p>The component ID that represents the end component of the connection.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: int\n</code></pre> <p>The component ID that represents the start component of the connection.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection.is_valid","title":"is_valid","text":"<pre><code>is_valid() -&gt; bool\n</code></pre> <p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>start &gt;= 0</code>, <code>end &gt; 0</code>, and <code>start != end</code>, <code>False</code> otherwise.</p> Source code in <code>frequenz/sdk/microgrid/client/_connection.py</code> <pre><code>def is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n    Returns:\n        `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n            otherwise.\n    \"\"\"\nreturn self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff","title":"frequenz.sdk.microgrid.client.ExponentialBackoff","text":"<p>             Bases: <code>RetryStrategy</code></p> <p>Provides methods for calculating the exponential interval between retries.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class ExponentialBackoff(RetryStrategy):\n\"\"\"Provides methods for calculating the exponential interval between retries.\"\"\"\nDEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL\n\"\"\"Default retry interval, in seconds.\"\"\"\nDEFAULT_MAX_INTERVAL = 60.0\n\"\"\"Default maximum retry interval, in seconds.\"\"\"\nDEFAULT_MULTIPLIER = 2.0\n\"\"\"Default multiplier for exponential increment.\"\"\"\n# pylint: disable=too-many-arguments\ndef __init__(\nself,\ninitial_interval: float = DEFAULT_INTERVAL,\nmax_interval: float = DEFAULT_MAX_INTERVAL,\nmultiplier: float = DEFAULT_MULTIPLIER,\njitter: float = DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None:\n\"\"\"Create a `ExponentialBackoff` instance.\n        Args:\n            initial_interval: time to wait for before the first retry, in\n                seconds.\n            max_interval: maximum interval, in seconds.\n            multiplier: exponential increment for interval.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\nself._initial = initial_interval\nself._max = max_interval\nself._multiplier = multiplier\nself._jitter = jitter\nself._limit = limit\nself._count = 0\ndef next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nexp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\nreturn min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.DEFAULT_INTERVAL","title":"DEFAULT_INTERVAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL\n</code></pre> <p>Default retry interval, in seconds.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.DEFAULT_MAX_INTERVAL","title":"DEFAULT_MAX_INTERVAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_MAX_INTERVAL = 60.0\n</code></pre> <p>Default maximum retry interval, in seconds.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.DEFAULT_MULTIPLIER","title":"DEFAULT_MULTIPLIER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_MULTIPLIER = 2.0\n</code></pre> <p>Default multiplier for exponential increment.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.__init__","title":"__init__","text":"<pre><code>__init__(\ninitial_interval: float = DEFAULT_INTERVAL,\nmax_interval: float = DEFAULT_MAX_INTERVAL,\nmultiplier: float = DEFAULT_MULTIPLIER,\njitter: float = DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None\n</code></pre> <p>Create a <code>ExponentialBackoff</code> instance.</p> PARAMETER  DESCRIPTION <code>initial_interval</code> <p>time to wait for before the first retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_INTERVAL</code> </p> <code>max_interval</code> <p>maximum interval, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MAX_INTERVAL</code> </p> <code>multiplier</code> <p>exponential increment for interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MULTIPLIER</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __init__(\nself,\ninitial_interval: float = DEFAULT_INTERVAL,\nmax_interval: float = DEFAULT_MAX_INTERVAL,\nmultiplier: float = DEFAULT_MULTIPLIER,\njitter: float = DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None:\n\"\"\"Create a `ExponentialBackoff` instance.\n    Args:\n        initial_interval: time to wait for before the first retry, in\n            seconds.\n        max_interval: maximum interval, in seconds.\n        multiplier: exponential increment for interval.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\nself._initial = initial_interval\nself._max = max_interval\nself._multiplier = multiplier\nself._jitter = jitter\nself._limit = limit\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\nwhile True:\ninterval = self.next_interval()\nif interval is None:\nbreak\nyield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.copy","title":"copy","text":"<pre><code>copy() -&gt; RetryStrategy\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>RetryStrategy</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\nret = deepcopy(self)\nret.reset()\nreturn ret\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\nif self._limit is None:\nreturn f\"({self._count}/\u221e)\"\nreturn f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.next_interval","title":"next_interval","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nexp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\nreturn min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n    To be called as soon as a connection is successful.\n    \"\"\"\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff","title":"frequenz.sdk.microgrid.client.LinearBackoff","text":"<p>             Bases: <code>RetryStrategy</code></p> <p>Provides methods for calculating the interval between retries.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class LinearBackoff(RetryStrategy):\n\"\"\"Provides methods for calculating the interval between retries.\"\"\"\ndef __init__(\nself,\ninterval: float = DEFAULT_RETRY_INTERVAL,\njitter: float = DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None:\n\"\"\"Create a `LinearBackoff` instance.\n        Args:\n            interval: time to wait for before the next retry, in seconds.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\nself._interval = interval\nself._jitter = jitter\nself._limit = limit\nself._count = 0\ndef next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nreturn self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.__init__","title":"__init__","text":"<pre><code>__init__(\ninterval: float = DEFAULT_RETRY_INTERVAL,\njitter: float = DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None\n</code></pre> <p>Create a <code>LinearBackoff</code> instance.</p> PARAMETER  DESCRIPTION <code>interval</code> <p>time to wait for before the next retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_INTERVAL</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __init__(\nself,\ninterval: float = DEFAULT_RETRY_INTERVAL,\njitter: float = DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None:\n\"\"\"Create a `LinearBackoff` instance.\n    Args:\n        interval: time to wait for before the next retry, in seconds.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\nself._interval = interval\nself._jitter = jitter\nself._limit = limit\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\nwhile True:\ninterval = self.next_interval()\nif interval is None:\nbreak\nyield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.copy","title":"copy","text":"<pre><code>copy() -&gt; RetryStrategy\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>RetryStrategy</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\nret = deepcopy(self)\nret.reset()\nreturn ret\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\nif self._limit is None:\nreturn f\"({self._count}/\u221e)\"\nreturn f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.next_interval","title":"next_interval","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nreturn self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n    To be called as soon as a connection is successful.\n    \"\"\"\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient","title":"frequenz.sdk.microgrid.client.MicrogridApiClient","text":"<p>             Bases: <code>ABC</code></p> <p>Base interface for microgrid API clients to implement.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>class MicrogridApiClient(ABC):\n\"\"\"Base interface for microgrid API clients to implement.\"\"\"\n@abstractmethod\nasync def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n        Returns:\n            Iterator whose elements are all the components in the microgrid.\n        \"\"\"\n@abstractmethod\nasync def metadata(self) -&gt; Metadata:\n\"\"\"Fetch the microgrid metadata.\n        Returns:\n            the microgrid metadata.\n        \"\"\"\n@abstractmethod\nasync def connections(\nself,\nstarts: set[int] | None = None,\nends: set[int] | None = None,\n) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n        Args:\n            starts: if set and non-empty, only include connections whose start\n                value matches one of the provided component IDs\n            ends: if set and non-empty, only include connections whose end value\n                matches one of the provided component IDs\n        Returns:\n            Microgrid connections matching the provided start and end filters.\n        \"\"\"\n@abstractmethod\nasync def meter_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Args:\n            component_id: id of the meter to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime meter data.\n        \"\"\"\n@abstractmethod\nasync def battery_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Args:\n            component_id: id of the battery to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime battery data.\n        \"\"\"\n@abstractmethod\nasync def inverter_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Args:\n            component_id: id of the inverter to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime inverter data.\n        \"\"\"\n@abstractmethod\nasync def ev_charger_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Args:\n            component_id: id of the ev charger to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime ev charger data.\n        \"\"\"\n@abstractmethod\nasync def set_power(self, component_id: int, power_w: float) -&gt; None:\n\"\"\"Send request to the Microgrid to set power for component.\n        If power &gt; 0, then component will be charged with this power.\n        If power &lt; 0, then component will be discharged with this power.\n        If power == 0, then stop charging or discharging component.\n        Args:\n            component_id: id of the component to set power.\n            power_w: power to set for the component.\n        \"\"\"\n@abstractmethod\nasync def set_bounds(self, component_id: int, lower: float, upper: float) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to the Microgrid service.\n        Args:\n            component_id: ID of the component to set bounds for.\n            lower: Lower bound to be set for the component.\n            upper: Upper bound to be set for the component.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.battery_data","title":"battery_data  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>battery_data(\ncomponent_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[BatteryData]\n</code></pre> <p>Return a channel receiver that provides a <code>BatteryData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the battery to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[BatteryData]</code> <p>A channel receiver that provides realtime battery data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def battery_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Args:\n        component_id: id of the battery to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime battery data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.components","title":"components  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>components() -&gt; Iterable[Component]\n</code></pre> <p>Fetch all the components present in the microgrid.</p> RETURNS DESCRIPTION <code>Iterable[Component]</code> <p>Iterator whose elements are all the components in the microgrid.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n    Returns:\n        Iterator whose elements are all the components in the microgrid.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.connections","title":"connections  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>connections(\nstarts: set[int] | None = None,\nends: set[int] | None = None,\n) -&gt; Iterable[Connection]\n</code></pre> <p>Fetch the connections between components in the microgrid.</p> PARAMETER  DESCRIPTION <code>starts</code> <p>if set and non-empty, only include connections whose start value matches one of the provided component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>ends</code> <p>if set and non-empty, only include connections whose end value matches one of the provided component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[Connection]</code> <p>Microgrid connections matching the provided start and end filters.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def connections(\nself,\nstarts: set[int] | None = None,\nends: set[int] | None = None,\n) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n    Args:\n        starts: if set and non-empty, only include connections whose start\n            value matches one of the provided component IDs\n        ends: if set and non-empty, only include connections whose end value\n            matches one of the provided component IDs\n    Returns:\n        Microgrid connections matching the provided start and end filters.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.ev_charger_data","title":"ev_charger_data  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>ev_charger_data(\ncomponent_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[EVChargerData]\n</code></pre> <p>Return a channel receiver that provides an <code>EvChargeData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the ev charger to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A channel receiver that provides realtime ev charger data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def ev_charger_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Args:\n        component_id: id of the ev charger to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime ev charger data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.inverter_data","title":"inverter_data  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>inverter_data(\ncomponent_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[InverterData]\n</code></pre> <p>Return a channel receiver that provides an <code>InverterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the inverter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[InverterData]</code> <p>A channel receiver that provides realtime inverter data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def inverter_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Args:\n        component_id: id of the inverter to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime inverter data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.metadata","title":"metadata  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>metadata() -&gt; Metadata\n</code></pre> <p>Fetch the microgrid metadata.</p> RETURNS DESCRIPTION <code>Metadata</code> <p>the microgrid metadata.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def metadata(self) -&gt; Metadata:\n\"\"\"Fetch the microgrid metadata.\n    Returns:\n        the microgrid metadata.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.meter_data","title":"meter_data  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>meter_data(\ncomponent_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[MeterData]\n</code></pre> <p>Return a channel receiver that provides a <code>MeterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the meter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[MeterData]</code> <p>A channel receiver that provides realtime meter data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def meter_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Args:\n        component_id: id of the meter to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime meter data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.set_bounds","title":"set_bounds  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>set_bounds(\ncomponent_id: int, lower: float, upper: float\n) -&gt; None\n</code></pre> <p>Send <code>SetBoundsParam</code>s received from a channel to the Microgrid service.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>ID of the component to set bounds for.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>Lower bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> <code>upper</code> <p>Upper bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def set_bounds(self, component_id: int, lower: float, upper: float) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to the Microgrid service.\n    Args:\n        component_id: ID of the component to set bounds for.\n        lower: Lower bound to be set for the component.\n        upper: Upper bound to be set for the component.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.set_power","title":"set_power  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>set_power(component_id: int, power_w: float) -&gt; None\n</code></pre> <p>Send request to the Microgrid to set power for component.</p> <p>If power &gt; 0, then component will be charged with this power. If power &lt; 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the component to set power.</p> <p> TYPE: <code>int</code> </p> <code>power_w</code> <p>power to set for the component.</p> <p> TYPE: <code>float</code> </p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def set_power(self, component_id: int, power_w: float) -&gt; None:\n\"\"\"Send request to the Microgrid to set power for component.\n    If power &gt; 0, then component will be charged with this power.\n    If power &lt; 0, then component will be discharged with this power.\n    If power == 0, then stop charging or discharging component.\n    Args:\n        component_id: id of the component to set power.\n        power_w: power to set for the component.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient","title":"frequenz.sdk.microgrid.client.MicrogridGrpcClient","text":"<p>             Bases: <code>MicrogridApiClient</code></p> <p>Microgrid API client implementation using gRPC as the underlying protocol.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>class MicrogridGrpcClient(MicrogridApiClient):\n\"\"\"Microgrid API client implementation using gRPC as the underlying protocol.\"\"\"\ndef __init__(\nself,\ngrpc_channel: grpc.aio.Channel,\ntarget: str,\nretry_spec: RetryStrategy = LinearBackoff(),\n) -&gt; None:\n\"\"\"Initialize the class instance.\n        Args:\n            grpc_channel: asyncio-supporting gRPC channel\n            target: server (host:port) to be used for asyncio-supporting gRPC\n                channel that the client should use to contact the API\n            retry_spec: Specs on how to retry if the connection to a streaming\n                method gets lost.\n        \"\"\"\nself.target = target\n\"\"\"The location (as \"host:port\") of the microgrid API gRPC server.\"\"\"\nself.api = MicrogridStub(grpc_channel)\n\"\"\"The gRPC stub for the microgrid API.\"\"\"\nself._component_streams: dict[int, Broadcast[Any]] = {}\nself._streaming_tasks: dict[int, asyncio.Task[None]] = {}\nself._retry_spec = retry_spec\nasync def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n        Returns:\n            Iterator whose elements are all the components in the microgrid.\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\ntry:\n# grpc.aio is missing types and mypy thinks this is not awaitable,\n# but it is\ncomponent_list = await self.api.ListComponents(\nmicrogrid_pb.ComponentFilter(),\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n)  # type: ignore[misc]\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to list components. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\ncomponents_only = filter(\nlambda c: c.category\nis not components_pb.ComponentCategory.COMPONENT_CATEGORY_SENSOR,\ncomponent_list.components,\n)\nresult: Iterable[Component] = map(\nlambda c: Component(\nc.id,\n_component_category_from_protobuf(c.category),\n_component_type_from_protobuf(c.category, c.inverter),\n_component_metadata_from_protobuf(c.category, c.grid),\n),\ncomponents_only,\n)\nreturn result\nasync def metadata(self) -&gt; Metadata:\n\"\"\"Fetch the microgrid metadata.\n        If there is an error fetching the metadata, the microgrid ID and\n        location will be set to None.\n        Returns:\n            the microgrid metadata.\n        \"\"\"\nmicrogrid_metadata: microgrid_pb.MicrogridMetadata | None = None\ntry:\nmicrogrid_metadata = await self.api.GetMicrogridMetadata(\nEmpty(),\ntimeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n)  # type: ignore[misc]\nexcept grpc.aio.AioRpcError:\n_logger.exception(\"The microgrid metadata is not available.\")\nif not microgrid_metadata:\nreturn Metadata()\nlocation: Location | None = None\nif microgrid_metadata.location:\nlocation = Location(\nlatitude=microgrid_metadata.location.latitude,\nlongitude=microgrid_metadata.location.longitude,\n)\nreturn Metadata(microgrid_id=microgrid_metadata.microgrid_id, location=location)\nasync def connections(\nself,\nstarts: set[int] | None = None,\nends: set[int] | None = None,\n) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n        Args:\n            starts: if set and non-empty, only include connections whose start\n                value matches one of the provided component IDs\n            ends: if set and non-empty, only include connections whose end value\n                matches one of the provided component IDs\n        Returns:\n            Microgrid connections matching the provided start and end filters.\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\nconnection_filter = microgrid_pb.ConnectionFilter(starts=starts, ends=ends)\ntry:\nvalid_components, all_connections = await asyncio.gather(\nself.components(),\n# grpc.aio is missing types and mypy thinks this is not\n# awaitable, but it is\ncast(\nAwaitable[microgrid_pb.ConnectionList],\nself.api.ListConnections(\nconnection_filter,\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n),\n),\n)\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to list connections. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\n# Filter out the components filtered in `components` method.\n# id=0 is an exception indicating grid component.\nvalid_ids = {c.component_id for c in valid_components}\nvalid_ids.add(0)\nconnections = filter(\nlambda c: (c.start in valid_ids and c.end in valid_ids),\nall_connections.connections,\n)\nresult: Iterable[Connection] = map(\nlambda c: Connection(c.start, c.end), connections\n)\nreturn result\nasync def _component_data_task(\nself,\ncomponent_id: int,\ntransform: Callable[[microgrid_pb.ComponentData], _GenericComponentData],\nsender: Sender[_GenericComponentData],\n) -&gt; None:\n\"\"\"Read data from the microgrid API and send to a channel.\n        Args:\n            component_id: id of the component to get data for.\n            transform: A method for transforming raw component data into the\n                desired output type.\n            sender: A channel sender, to send the component data to.\n        \"\"\"\nretry_spec: RetryStrategy = self._retry_spec.copy()\nwhile True:\n_logger.debug(\n\"Making call to `GetComponentData`, for component_id=%d\", component_id\n)\ntry:\ncall = self.api.StreamComponentData(\nmicrogrid_pb.ComponentIdParam(id=component_id),\n)\n# grpc.aio is missing types and mypy thinks this is not\n# async iterable, but it is\nasync for msg in call:  # type: ignore[attr-defined]\nawait sender.send(transform(msg))\nexcept grpc.aio.AioRpcError as err:\napi_details = f\"Microgrid API: {self.target}.\"\n_logger.exception(\n\"`GetComponentData`, for component_id=%d: exception: %s api: %s\",\ncomponent_id,\nerr,\napi_details,\n)\nif interval := retry_spec.next_interval():\n_logger.warning(\n\"`GetComponentData`, for component_id=%d: connection ended, \"\n\"retrying %s in %0.3f seconds.\",\ncomponent_id,\nretry_spec.get_progress(),\ninterval,\n)\nawait asyncio.sleep(interval)\nelse:\n_logger.warning(\n\"`GetComponentData`, for component_id=%d: connection ended, \"\n\"retry limit exceeded %s.\",\ncomponent_id,\nretry_spec.get_progress(),\n)\nbreak\ndef _get_component_data_channel(\nself,\ncomponent_id: int,\ntransform: Callable[[microgrid_pb.ComponentData], _GenericComponentData],\n) -&gt; Broadcast[_GenericComponentData]:\n\"\"\"Return the broadcast channel for a given component_id.\n        If a broadcast channel for the given component_id doesn't exist, create\n        a new channel and a task for reading data from the microgrid api and\n        sending them to the channel.\n        Args:\n            component_id: id of the component to get data for.\n            transform: A method for transforming raw component data into the\n                desired output type.\n        Returns:\n            The channel for the given component_id.\n        \"\"\"\nif component_id in self._component_streams:\nreturn self._component_streams[component_id]\ntask_name = f\"raw-component-data-{component_id}\"\nchan = Broadcast[_GenericComponentData](task_name)\nself._component_streams[component_id] = chan\nself._streaming_tasks[component_id] = asyncio.create_task(\nself._component_data_task(\ncomponent_id,\ntransform,\nchan.new_sender(),\n),\nname=task_name,\n)\nreturn chan\nasync def _expect_category(\nself,\ncomponent_id: int,\nexpected_category: ComponentCategory,\n) -&gt; None:\n\"\"\"Check if the given component_id is of the expected type.\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n        Args:\n            component_id: Component id to check.\n            expected_category: Component category that the given id is expected\n                to have.\n        \"\"\"\ntry:\ncomp = next(\ncomp\nfor comp in await self.components()\nif comp.component_id == component_id\n)\nexcept StopIteration as exc:\nraise ValueError(\nf\"Unable to find component with id {component_id}\"\n) from exc\nif comp.category != expected_category:\nraise ValueError(\nf\"Component id {component_id} is a {comp.category}\"\nf\", not a {expected_category}.\"\n)\nasync def meter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n        Args:\n            component_id: id of the meter to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime meter data.\n        \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.METER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nMeterData.from_proto,\n).new_receiver(maxsize=maxsize)\nasync def battery_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n        Args:\n            component_id: id of the battery to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime battery data.\n        \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.BATTERY,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nBatteryData.from_proto,\n).new_receiver(maxsize=maxsize)\nasync def inverter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n        Args:\n            component_id: id of the inverter to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime inverter data.\n        \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.INVERTER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nInverterData.from_proto,\n).new_receiver(maxsize=maxsize)\nasync def ev_charger_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n        Args:\n            component_id: id of the ev charger to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime ev charger data.\n        \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.EV_CHARGER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nEVChargerData.from_proto,\n).new_receiver(maxsize=maxsize)\nasync def set_power(self, component_id: int, power_w: float) -&gt; None:\n\"\"\"Send request to the Microgrid to set power for component.\n        If power &gt; 0, then component will be charged with this power.\n        If power &lt; 0, then component will be discharged with this power.\n        If power == 0, then stop charging or discharging component.\n        Args:\n            component_id: id of the component to set power.\n            power_w: power to set for the component.\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\ntry:\nawait self.api.SetPowerActive(\nmicrogrid_pb.SetPowerActiveParam(\ncomponent_id=component_id, power=power_w\n),\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n)  # type: ignore[misc]\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to set power. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\nasync def set_bounds(\nself,\ncomponent_id: int,\nlower: float,\nupper: float,\n) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to the Microgrid service.\n        Args:\n            component_id: ID of the component to set bounds for.\n            lower: Lower bound to be set for the component.\n            upper: Upper bound to be set for the component.\n        Raises:\n            ValueError: when upper bound is less than 0, or when lower bound is\n                greater than 0.\n            grpc.aio.AioRpcError: if connection to Microgrid API cannot be established\n                or when the api call exceeded timeout\n        \"\"\"\napi_details = f\"Microgrid API: {self.target}.\"\nif upper &lt; 0:\nraise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\nif lower &gt; 0:\nraise ValueError(f\"Lower bound {upper} must be less than or equal to 0.\")\ntarget_metric = (\nmicrogrid_pb.SetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE\n)\ntry:\nself.api.AddInclusionBounds(\nmicrogrid_pb.SetBoundsParam(\ncomponent_id=component_id,\ntarget_metric=target_metric,\nbounds=metrics_pb.Bounds(lower=lower, upper=upper),\n),\n)\nexcept grpc.aio.AioRpcError as err:\n_logger.error(\n\"set_bounds write failed: %s, for message: %s, api: %s. Err: %s\",\nerr,\nnext,\napi_details,\nerr.details(),\n)\nraise\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.api","title":"api  <code>instance-attribute</code>","text":"<pre><code>api = MicrogridStub(grpc_channel)\n</code></pre> <p>The gRPC stub for the microgrid API.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target = target\n</code></pre> <p>The location (as \"host:port\") of the microgrid API gRPC server.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.__init__","title":"__init__","text":"<pre><code>__init__(\ngrpc_channel: grpc.aio.Channel,\ntarget: str,\nretry_spec: RetryStrategy = LinearBackoff(),\n) -&gt; None\n</code></pre> <p>Initialize the class instance.</p> PARAMETER  DESCRIPTION <code>grpc_channel</code> <p>asyncio-supporting gRPC channel</p> <p> TYPE: <code>Channel</code> </p> <code>target</code> <p>server (host:port) to be used for asyncio-supporting gRPC channel that the client should use to contact the API</p> <p> TYPE: <code>str</code> </p> <code>retry_spec</code> <p>Specs on how to retry if the connection to a streaming method gets lost.</p> <p> TYPE: <code>RetryStrategy</code> DEFAULT: <code>LinearBackoff()</code> </p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>def __init__(\nself,\ngrpc_channel: grpc.aio.Channel,\ntarget: str,\nretry_spec: RetryStrategy = LinearBackoff(),\n) -&gt; None:\n\"\"\"Initialize the class instance.\n    Args:\n        grpc_channel: asyncio-supporting gRPC channel\n        target: server (host:port) to be used for asyncio-supporting gRPC\n            channel that the client should use to contact the API\n        retry_spec: Specs on how to retry if the connection to a streaming\n            method gets lost.\n    \"\"\"\nself.target = target\n\"\"\"The location (as \"host:port\") of the microgrid API gRPC server.\"\"\"\nself.api = MicrogridStub(grpc_channel)\n\"\"\"The gRPC stub for the microgrid API.\"\"\"\nself._component_streams: dict[int, Broadcast[Any]] = {}\nself._streaming_tasks: dict[int, asyncio.Task[None]] = {}\nself._retry_spec = retry_spec\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.battery_data","title":"battery_data  <code>async</code>","text":"<pre><code>battery_data(\ncomponent_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[BatteryData]\n</code></pre> <p>Return a channel receiver that provides a <code>BatteryData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the battery to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[BatteryData]</code> <p>A channel receiver that provides realtime battery data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def battery_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n    Args:\n        component_id: id of the battery to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime battery data.\n    \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.BATTERY,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nBatteryData.from_proto,\n).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.components","title":"components  <code>async</code>","text":"<pre><code>components() -&gt; Iterable[Component]\n</code></pre> <p>Fetch all the components present in the microgrid.</p> RETURNS DESCRIPTION <code>Iterable[Component]</code> <p>Iterator whose elements are all the components in the microgrid.</p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n    Returns:\n        Iterator whose elements are all the components in the microgrid.\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\ntry:\n# grpc.aio is missing types and mypy thinks this is not awaitable,\n# but it is\ncomponent_list = await self.api.ListComponents(\nmicrogrid_pb.ComponentFilter(),\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n)  # type: ignore[misc]\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to list components. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\ncomponents_only = filter(\nlambda c: c.category\nis not components_pb.ComponentCategory.COMPONENT_CATEGORY_SENSOR,\ncomponent_list.components,\n)\nresult: Iterable[Component] = map(\nlambda c: Component(\nc.id,\n_component_category_from_protobuf(c.category),\n_component_type_from_protobuf(c.category, c.inverter),\n_component_metadata_from_protobuf(c.category, c.grid),\n),\ncomponents_only,\n)\nreturn result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.connections","title":"connections  <code>async</code>","text":"<pre><code>connections(\nstarts: set[int] | None = None,\nends: set[int] | None = None,\n) -&gt; Iterable[Connection]\n</code></pre> <p>Fetch the connections between components in the microgrid.</p> PARAMETER  DESCRIPTION <code>starts</code> <p>if set and non-empty, only include connections whose start value matches one of the provided component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>ends</code> <p>if set and non-empty, only include connections whose end value matches one of the provided component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[Connection]</code> <p>Microgrid connections matching the provided start and end filters.</p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def connections(\nself,\nstarts: set[int] | None = None,\nends: set[int] | None = None,\n) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n    Args:\n        starts: if set and non-empty, only include connections whose start\n            value matches one of the provided component IDs\n        ends: if set and non-empty, only include connections whose end value\n            matches one of the provided component IDs\n    Returns:\n        Microgrid connections matching the provided start and end filters.\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\nconnection_filter = microgrid_pb.ConnectionFilter(starts=starts, ends=ends)\ntry:\nvalid_components, all_connections = await asyncio.gather(\nself.components(),\n# grpc.aio is missing types and mypy thinks this is not\n# awaitable, but it is\ncast(\nAwaitable[microgrid_pb.ConnectionList],\nself.api.ListConnections(\nconnection_filter,\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n),\n),\n)\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to list connections. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\n# Filter out the components filtered in `components` method.\n# id=0 is an exception indicating grid component.\nvalid_ids = {c.component_id for c in valid_components}\nvalid_ids.add(0)\nconnections = filter(\nlambda c: (c.start in valid_ids and c.end in valid_ids),\nall_connections.connections,\n)\nresult: Iterable[Connection] = map(\nlambda c: Connection(c.start, c.end), connections\n)\nreturn result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.ev_charger_data","title":"ev_charger_data  <code>async</code>","text":"<pre><code>ev_charger_data(\ncomponent_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[EVChargerData]\n</code></pre> <p>Return a channel receiver that provides an <code>EvChargeData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the ev charger to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A channel receiver that provides realtime ev charger data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def ev_charger_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n    Args:\n        component_id: id of the ev charger to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime ev charger data.\n    \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.EV_CHARGER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nEVChargerData.from_proto,\n).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.inverter_data","title":"inverter_data  <code>async</code>","text":"<pre><code>inverter_data(\ncomponent_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[InverterData]\n</code></pre> <p>Return a channel receiver that provides an <code>InverterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the inverter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[InverterData]</code> <p>A channel receiver that provides realtime inverter data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def inverter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n    Args:\n        component_id: id of the inverter to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime inverter data.\n    \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.INVERTER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nInverterData.from_proto,\n).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.metadata","title":"metadata  <code>async</code>","text":"<pre><code>metadata() -&gt; Metadata\n</code></pre> <p>Fetch the microgrid metadata.</p> <p>If there is an error fetching the metadata, the microgrid ID and location will be set to None.</p> RETURNS DESCRIPTION <code>Metadata</code> <p>the microgrid metadata.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def metadata(self) -&gt; Metadata:\n\"\"\"Fetch the microgrid metadata.\n    If there is an error fetching the metadata, the microgrid ID and\n    location will be set to None.\n    Returns:\n        the microgrid metadata.\n    \"\"\"\nmicrogrid_metadata: microgrid_pb.MicrogridMetadata | None = None\ntry:\nmicrogrid_metadata = await self.api.GetMicrogridMetadata(\nEmpty(),\ntimeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n)  # type: ignore[misc]\nexcept grpc.aio.AioRpcError:\n_logger.exception(\"The microgrid metadata is not available.\")\nif not microgrid_metadata:\nreturn Metadata()\nlocation: Location | None = None\nif microgrid_metadata.location:\nlocation = Location(\nlatitude=microgrid_metadata.location.latitude,\nlongitude=microgrid_metadata.location.longitude,\n)\nreturn Metadata(microgrid_id=microgrid_metadata.microgrid_id, location=location)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.meter_data","title":"meter_data  <code>async</code>","text":"<pre><code>meter_data(\ncomponent_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[MeterData]\n</code></pre> <p>Return a channel receiver that provides a <code>MeterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the meter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[MeterData]</code> <p>A channel receiver that provides realtime meter data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def meter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n    Args:\n        component_id: id of the meter to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime meter data.\n    \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.METER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nMeterData.from_proto,\n).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.set_bounds","title":"set_bounds  <code>async</code>","text":"<pre><code>set_bounds(\ncomponent_id: int, lower: float, upper: float\n) -&gt; None\n</code></pre> <p>Send <code>SetBoundsParam</code>s received from a channel to the Microgrid service.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>ID of the component to set bounds for.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>Lower bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> <code>upper</code> <p>Upper bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>when upper bound is less than 0, or when lower bound is greater than 0.</p> <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def set_bounds(\nself,\ncomponent_id: int,\nlower: float,\nupper: float,\n) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to the Microgrid service.\n    Args:\n        component_id: ID of the component to set bounds for.\n        lower: Lower bound to be set for the component.\n        upper: Upper bound to be set for the component.\n    Raises:\n        ValueError: when upper bound is less than 0, or when lower bound is\n            greater than 0.\n        grpc.aio.AioRpcError: if connection to Microgrid API cannot be established\n            or when the api call exceeded timeout\n    \"\"\"\napi_details = f\"Microgrid API: {self.target}.\"\nif upper &lt; 0:\nraise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\nif lower &gt; 0:\nraise ValueError(f\"Lower bound {upper} must be less than or equal to 0.\")\ntarget_metric = (\nmicrogrid_pb.SetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE\n)\ntry:\nself.api.AddInclusionBounds(\nmicrogrid_pb.SetBoundsParam(\ncomponent_id=component_id,\ntarget_metric=target_metric,\nbounds=metrics_pb.Bounds(lower=lower, upper=upper),\n),\n)\nexcept grpc.aio.AioRpcError as err:\n_logger.error(\n\"set_bounds write failed: %s, for message: %s, api: %s. Err: %s\",\nerr,\nnext,\napi_details,\nerr.details(),\n)\nraise\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.set_power","title":"set_power  <code>async</code>","text":"<pre><code>set_power(component_id: int, power_w: float) -&gt; None\n</code></pre> <p>Send request to the Microgrid to set power for component.</p> <p>If power &gt; 0, then component will be charged with this power. If power &lt; 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the component to set power.</p> <p> TYPE: <code>int</code> </p> <code>power_w</code> <p>power to set for the component.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def set_power(self, component_id: int, power_w: float) -&gt; None:\n\"\"\"Send request to the Microgrid to set power for component.\n    If power &gt; 0, then component will be charged with this power.\n    If power &lt; 0, then component will be discharged with this power.\n    If power == 0, then stop charging or discharging component.\n    Args:\n        component_id: id of the component to set power.\n        power_w: power to set for the component.\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\ntry:\nawait self.api.SetPowerActive(\nmicrogrid_pb.SetPowerActiveParam(\ncomponent_id=component_id, power=power_w\n),\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n)  # type: ignore[misc]\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to set power. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy","title":"frequenz.sdk.microgrid.client.RetryStrategy","text":"<p>             Bases: <code>ABC</code></p> <p>Interface for implementing retry strategies.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class RetryStrategy(ABC):\n\"\"\"Interface for implementing retry strategies.\"\"\"\n_limit: int | None\n_count: int\n@abstractmethod\ndef next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\ndef get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n        Returns:\n            String denoting retry progress in the form \"(count/limit)\"\n        \"\"\"\nif self._limit is None:\nreturn f\"({self._count}/\u221e)\"\nreturn f\"({self._count}/{self._limit})\"\ndef reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n        To be called as soon as a connection is successful.\n        \"\"\"\nself._count = 0\ndef copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n        Returns:\n            A deepcopy of `self`.\n        \"\"\"\nret = deepcopy(self)\nret.reset()\nreturn ret\ndef __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n        Yields:\n            Next retry interval in seconds.\n        \"\"\"\nwhile True:\ninterval = self.next_interval()\nif interval is None:\nbreak\nyield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\nwhile True:\ninterval = self.next_interval()\nif interval is None:\nbreak\nyield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.copy","title":"copy","text":"<pre><code>copy() -&gt; RetryStrategy\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>RetryStrategy</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\nret = deepcopy(self)\nret.reset()\nreturn ret\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\nif self._limit is None:\nreturn f\"({self._count}/\u221e)\"\nreturn f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.next_interval","title":"next_interval  <code>abstractmethod</code>","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>@abstractmethod\ndef next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n    To be called as soon as a connection is successful.\n    \"\"\"\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/","title":"component","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component","title":"frequenz.sdk.microgrid.component","text":"<p>Microgrid component abstractions.</p> <p>This package provides classes to operate con microgrid components.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData","title":"frequenz.sdk.microgrid.component.BatteryData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding battery data.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass BatteryData(ComponentData):\n\"\"\"A wrapper class for holding battery data.\"\"\"\nsoc: float\n\"\"\"Battery's overall SoC in percent (%).\"\"\"\nsoc_lower_bound: float\n\"\"\"The SoC below which discharge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\nsoc_upper_bound: float\n\"\"\"The SoC above which charge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\ncapacity: float\n\"\"\"The capacity of the battery in Wh (Watt-hour).\"\"\"\n# pylint: disable=line-too-long\npower_inclusion_lower_bound: float\n\"\"\"Lower inclusion bound for battery power in watts.\n    This is the lower limit of the range within which power requests are allowed for the\n    battery.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\npower_exclusion_lower_bound: float\n\"\"\"Lower exclusion bound for battery power in watts.\n    This is the lower limit of the range within which power requests are not allowed for\n    the battery.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\npower_inclusion_upper_bound: float\n\"\"\"Upper inclusion bound for battery power in watts.\n    This is the upper limit of the range within which power requests are allowed for the\n    battery.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\npower_exclusion_upper_bound: float\n\"\"\"Upper exclusion bound for battery power in watts.\n    This is the upper limit of the range within which power requests are not allowed for\n    the battery.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n# pylint: enable=line-too-long\ntemperature: float\n\"\"\"The (average) temperature reported by the battery, in Celsius (\u00b0C).\"\"\"\n_relay_state: battery_pb.RelayState.ValueType\n\"\"\"State of the battery relay.\"\"\"\n_component_state: battery_pb.ComponentState.ValueType\n\"\"\"State of the battery.\"\"\"\n_errors: list[battery_pb.Error]\n\"\"\"List of errors in protobuf struct.\"\"\"\n@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; BatteryData:\n\"\"\"Create BatteryData from a protobuf message.\n        Args:\n            raw: raw component data as decoded from the wire.\n        Returns:\n            Instance of BatteryData created from the protobuf message.\n        \"\"\"\nraw_power = raw.battery.data.dc.power\nbattery_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nsoc=raw.battery.data.soc.avg,\nsoc_lower_bound=raw.battery.data.soc.system_inclusion_bounds.lower,\nsoc_upper_bound=raw.battery.data.soc.system_inclusion_bounds.upper,\ncapacity=raw.battery.properties.capacity,\npower_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\npower_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\npower_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\npower_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\ntemperature=raw.battery.data.temperature.avg,\n_relay_state=raw.battery.state.relay_state,\n_component_state=raw.battery.state.component_state,\n_errors=list(raw.battery.errors),\n)\nbattery_data._set_raw(raw=raw)\nreturn battery_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.capacity","title":"capacity  <code>instance-attribute</code>","text":"<pre><code>capacity: float\n</code></pre> <p>The capacity of the battery in Wh (Watt-hour).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_exclusion_lower_bound","title":"power_exclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>power_exclusion_lower_bound: float\n</code></pre> <p>Lower exclusion bound for battery power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_exclusion_upper_bound","title":"power_exclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>power_exclusion_upper_bound: float\n</code></pre> <p>Upper exclusion bound for battery power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_inclusion_lower_bound","title":"power_inclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>power_inclusion_lower_bound: float\n</code></pre> <p>Lower inclusion bound for battery power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_inclusion_upper_bound","title":"power_inclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>power_inclusion_upper_bound: float\n</code></pre> <p>Upper inclusion bound for battery power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: microgrid_pb.ComponentData | None = field(\ndefault=None, init=False\n)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.soc","title":"soc  <code>instance-attribute</code>","text":"<pre><code>soc: float\n</code></pre> <p>Battery's overall SoC in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.soc_lower_bound","title":"soc_lower_bound  <code>instance-attribute</code>","text":"<pre><code>soc_lower_bound: float\n</code></pre> <p>The SoC below which discharge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.soc_upper_bound","title":"soc_upper_bound  <code>instance-attribute</code>","text":"<pre><code>soc_upper_bound: float\n</code></pre> <p>The SoC above which charge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature: float\n</code></pre> <p>The (average) temperature reported by the battery, in Celsius (\u00b0C).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: microgrid_pb.ComponentData) -&gt; BatteryData\n</code></pre> <p>Create BatteryData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>BatteryData</code> <p>Instance of BatteryData created from the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; BatteryData:\n\"\"\"Create BatteryData from a protobuf message.\n    Args:\n        raw: raw component data as decoded from the wire.\n    Returns:\n        Instance of BatteryData created from the protobuf message.\n    \"\"\"\nraw_power = raw.battery.data.dc.power\nbattery_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nsoc=raw.battery.data.soc.avg,\nsoc_lower_bound=raw.battery.data.soc.system_inclusion_bounds.lower,\nsoc_upper_bound=raw.battery.data.soc.system_inclusion_bounds.upper,\ncapacity=raw.battery.properties.capacity,\npower_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\npower_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\npower_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\npower_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\ntemperature=raw.battery.data.temperature.avg,\n_relay_state=raw.battery.state.relay_state,\n_component_state=raw.battery.state.component_state,\n_errors=list(raw.battery.errors),\n)\nbattery_data._set_raw(raw=raw)\nreturn battery_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component","title":"frequenz.sdk.microgrid.component.Component  <code>dataclass</code>","text":"<p>Metadata for a single microgrid component.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass Component:\n\"\"\"Metadata for a single microgrid component.\"\"\"\ncomponent_id: int\n\"\"\"The ID of this component.\"\"\"\ncategory: ComponentCategory\n\"\"\"The category of this component.\"\"\"\ntype: ComponentType | None = None\n\"\"\"The type of this component.\"\"\"\nmetadata: ComponentMetadata | None = None\n\"\"\"The metadata of this component.\"\"\"\ndef is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n        Returns:\n            `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n                == 0` and `type` is `GRID`, `False` otherwise\n        \"\"\"\nreturn (\nself.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\ndef __hash__(self) -&gt; int:\n\"\"\"Compute a hash of this instance, obtained by hashing the `component_id` field.\n        Returns:\n            Hash of this instance.\n        \"\"\"\nreturn hash(self.component_id)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: ComponentCategory\n</code></pre> <p>The category of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: ComponentMetadata | None = None\n</code></pre> <p>The metadata of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: ComponentType | None = None\n</code></pre> <p>The type of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Compute a hash of this instance, obtained by hashing the <code>component_id</code> field.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of this instance.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"Compute a hash of this instance, obtained by hashing the `component_id` field.\n    Returns:\n        Hash of this instance.\n    \"\"\"\nreturn hash(self.component_id)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.is_valid","title":"is_valid","text":"<pre><code>is_valid() -&gt; bool\n</code></pre> <p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>id &gt; 0</code> and <code>type</code> is a valid <code>ComponentCategory</code>, or if <code>id == 0</code> and <code>type</code> is <code>GRID</code>, <code>False</code> otherwise</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>def is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n    Returns:\n        `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n            == 0` and `type` is `GRID`, `False` otherwise\n    \"\"\"\nreturn (\nself.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory","title":"frequenz.sdk.microgrid.component.ComponentCategory","text":"<p>             Bases: <code>Enum</code></p> <p>Possible types of microgrid component.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class ComponentCategory(Enum):\n\"\"\"Possible types of microgrid component.\"\"\"\nNONE = components_pb.ComponentCategory.COMPONENT_CATEGORY_UNSPECIFIED\n\"\"\"Unspecified component category.\"\"\"\nGRID = components_pb.ComponentCategory.COMPONENT_CATEGORY_GRID\n\"\"\"Grid component.\"\"\"\nMETER = components_pb.ComponentCategory.COMPONENT_CATEGORY_METER\n\"\"\"Meter component.\"\"\"\nINVERTER = components_pb.ComponentCategory.COMPONENT_CATEGORY_INVERTER\n\"\"\"Inverter component.\"\"\"\nBATTERY = components_pb.ComponentCategory.COMPONENT_CATEGORY_BATTERY\n\"\"\"Battery component.\"\"\"\nEV_CHARGER = components_pb.ComponentCategory.COMPONENT_CATEGORY_EV_CHARGER\n\"\"\"EV charger component.\"\"\"\nCHP = components_pb.ComponentCategory.COMPONENT_CATEGORY_CHP\n\"\"\"CHP component.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.BATTERY","title":"BATTERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY = (\ncomponents_pb.ComponentCategory.COMPONENT_CATEGORY_BATTERY\n)\n</code></pre> <p>Battery component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.CHP","title":"CHP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHP = components_pb.ComponentCategory.COMPONENT_CATEGORY_CHP\n</code></pre> <p>CHP component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.EV_CHARGER","title":"EV_CHARGER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_CHARGER = (\ncomponents_pb.ComponentCategory.COMPONENT_CATEGORY_EV_CHARGER\n)\n</code></pre> <p>EV charger component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.GRID","title":"GRID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GRID = (\ncomponents_pb.ComponentCategory.COMPONENT_CATEGORY_GRID\n)\n</code></pre> <p>Grid component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.INVERTER","title":"INVERTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INVERTER = (\ncomponents_pb.ComponentCategory.COMPONENT_CATEGORY_INVERTER\n)\n</code></pre> <p>Inverter component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.METER","title":"METER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METER = (\ncomponents_pb.ComponentCategory.COMPONENT_CATEGORY_METER\n)\n</code></pre> <p>Meter component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = (\ncomponents_pb.ComponentCategory.COMPONENT_CATEGORY_UNSPECIFIED\n)\n</code></pre> <p>Unspecified component category.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData","title":"frequenz.sdk.microgrid.component.ComponentData  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A private base class for strongly typed component data classes.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentData(ABC):\n\"\"\"A private base class for strongly typed component data classes.\"\"\"\ncomponent_id: int\n\"\"\"The ID identifying this component in the microgrid.\"\"\"\ntimestamp: datetime\n\"\"\"The timestamp of when the data was measured.\"\"\"\n# The `raw` attribute is excluded from the constructor as it can only be provided\n# when instantiating `ComponentData` using the `from_proto` method, which reads\n# data from a protobuf message. The whole protobuf message is stored as the `raw`\n# attribute. When `ComponentData` is not instantiated from a protobuf message,\n# i.e. using the constructor, `raw` will be set to `None`.\nraw: microgrid_pb.ComponentData | None = field(default=None, init=False)\n\"\"\"Raw component data as decoded from the wire.\"\"\"\ndef _set_raw(self, raw: microgrid_pb.ComponentData) -&gt; None:\n\"\"\"Store raw protobuf message.\n        It is preferred to keep the dataclasses immutable (frozen) and make the `raw`\n            attribute read-only, which is why the approach of writing to `__dict__`\n            was used, instead of mutating the `self.raw = raw` attribute directly.\n        Args:\n            raw: raw component data as decoded from the wire.\n        \"\"\"\nself.__dict__[\"raw\"] = raw\n@classmethod\n@abstractmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; ComponentData:\n\"\"\"Create ComponentData from a protobuf message.\n        Args:\n            raw: raw component data as decoded from the wire.\n        Returns:\n            The instance created from the protobuf message.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: microgrid_pb.ComponentData | None = field(\ndefault=None, init=False\n)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.from_proto","title":"from_proto  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_proto(\nraw: microgrid_pb.ComponentData,\n) -&gt; ComponentData\n</code></pre> <p>Create ComponentData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>ComponentData</code> <p>The instance created from the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; ComponentData:\n\"\"\"Create ComponentData from a protobuf message.\n    Args:\n        raw: raw component data as decoded from the wire.\n    Returns:\n        The instance created from the protobuf message.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetadata","title":"frequenz.sdk.microgrid.component.ComponentMetadata  <code>dataclass</code>","text":"<p>Base class for component metadata classes.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentMetadata:\n\"\"\"Base class for component metadata classes.\"\"\"\nfuse: Fuse | None = None\n\"\"\"The fuse at the grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetadata.fuse","title":"fuse  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuse: Fuse | None = None\n</code></pre> <p>The fuse at the grid connection point.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId","title":"frequenz.sdk.microgrid.component.ComponentMetricId","text":"<p>             Bases: <code>Enum</code></p> <p>An enum representing the various metrics available in the microgrid.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class ComponentMetricId(Enum):\n\"\"\"An enum representing the various metrics available in the microgrid.\"\"\"\nACTIVE_POWER = \"active_power\"\n\"\"\"Active power.\"\"\"\nCURRENT_PHASE_1 = \"current_phase_1\"\n\"\"\"Current in phase 1.\"\"\"\nCURRENT_PHASE_2 = \"current_phase_2\"\n\"\"\"Current in phase 2.\"\"\"\nCURRENT_PHASE_3 = \"current_phase_3\"\n\"\"\"Current in phase 3.\"\"\"\nVOLTAGE_PHASE_1 = \"voltage_phase_1\"\n\"\"\"Voltage in phase 1.\"\"\"\nVOLTAGE_PHASE_2 = \"voltage_phase_2\"\n\"\"\"Voltage in phase 2.\"\"\"\nVOLTAGE_PHASE_3 = \"voltage_phase_3\"\n\"\"\"Voltage in phase 3.\"\"\"\nFREQUENCY = \"frequency\"\nSOC = \"soc\"\n\"\"\"State of charge.\"\"\"\nSOC_LOWER_BOUND = \"soc_lower_bound\"\n\"\"\"Lower bound of state of charge.\"\"\"\nSOC_UPPER_BOUND = \"soc_upper_bound\"\n\"\"\"Upper bound of state of charge.\"\"\"\nCAPACITY = \"capacity\"\n\"\"\"Capacity.\"\"\"\nPOWER_INCLUSION_LOWER_BOUND = \"power_inclusion_lower_bound\"\n\"\"\"Power inclusion lower bound.\"\"\"\nPOWER_EXCLUSION_LOWER_BOUND = \"power_exclusion_lower_bound\"\n\"\"\"Power exclusion lower bound.\"\"\"\nPOWER_EXCLUSION_UPPER_BOUND = \"power_exclusion_upper_bound\"\n\"\"\"Power exclusion upper bound.\"\"\"\nPOWER_INCLUSION_UPPER_BOUND = \"power_inclusion_upper_bound\"\n\"\"\"Power inclusion upper bound.\"\"\"\nACTIVE_POWER_INCLUSION_LOWER_BOUND = \"active_power_inclusion_lower_bound\"\n\"\"\"Active power inclusion lower bound.\"\"\"\nACTIVE_POWER_EXCLUSION_LOWER_BOUND = \"active_power_exclusion_lower_bound\"\n\"\"\"Active power exclusion lower bound.\"\"\"\nACTIVE_POWER_EXCLUSION_UPPER_BOUND = \"active_power_exclusion_upper_bound\"\n\"\"\"Active power exclusion upper bound.\"\"\"\nACTIVE_POWER_INCLUSION_UPPER_BOUND = \"active_power_inclusion_upper_bound\"\n\"\"\"Active power inclusion upper bound.\"\"\"\nTEMPERATURE = \"temperature\"\n\"\"\"Temperature.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER","title":"ACTIVE_POWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER = 'active_power'\n</code></pre> <p>Active power.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_EXCLUSION_LOWER_BOUND","title":"ACTIVE_POWER_EXCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_EXCLUSION_LOWER_BOUND = (\n\"active_power_exclusion_lower_bound\"\n)\n</code></pre> <p>Active power exclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_EXCLUSION_UPPER_BOUND","title":"ACTIVE_POWER_EXCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_EXCLUSION_UPPER_BOUND = (\n\"active_power_exclusion_upper_bound\"\n)\n</code></pre> <p>Active power exclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_INCLUSION_LOWER_BOUND","title":"ACTIVE_POWER_INCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_INCLUSION_LOWER_BOUND = (\n\"active_power_inclusion_lower_bound\"\n)\n</code></pre> <p>Active power inclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_INCLUSION_UPPER_BOUND","title":"ACTIVE_POWER_INCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_INCLUSION_UPPER_BOUND = (\n\"active_power_inclusion_upper_bound\"\n)\n</code></pre> <p>Active power inclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CAPACITY","title":"CAPACITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CAPACITY = 'capacity'\n</code></pre> <p>Capacity.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CURRENT_PHASE_1","title":"CURRENT_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_1 = 'current_phase_1'\n</code></pre> <p>Current in phase 1.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CURRENT_PHASE_2","title":"CURRENT_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_2 = 'current_phase_2'\n</code></pre> <p>Current in phase 2.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CURRENT_PHASE_3","title":"CURRENT_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_3 = 'current_phase_3'\n</code></pre> <p>Current in phase 3.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_EXCLUSION_LOWER_BOUND","title":"POWER_EXCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_EXCLUSION_LOWER_BOUND = 'power_exclusion_lower_bound'\n</code></pre> <p>Power exclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_EXCLUSION_UPPER_BOUND","title":"POWER_EXCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_EXCLUSION_UPPER_BOUND = 'power_exclusion_upper_bound'\n</code></pre> <p>Power exclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_INCLUSION_LOWER_BOUND","title":"POWER_INCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_INCLUSION_LOWER_BOUND = 'power_inclusion_lower_bound'\n</code></pre> <p>Power inclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_INCLUSION_UPPER_BOUND","title":"POWER_INCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_INCLUSION_UPPER_BOUND = 'power_inclusion_upper_bound'\n</code></pre> <p>Power inclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.SOC","title":"SOC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC = 'soc'\n</code></pre> <p>State of charge.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.SOC_LOWER_BOUND","title":"SOC_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC_LOWER_BOUND = 'soc_lower_bound'\n</code></pre> <p>Lower bound of state of charge.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.SOC_UPPER_BOUND","title":"SOC_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC_UPPER_BOUND = 'soc_upper_bound'\n</code></pre> <p>Upper bound of state of charge.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.TEMPERATURE","title":"TEMPERATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEMPERATURE = 'temperature'\n</code></pre> <p>Temperature.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.VOLTAGE_PHASE_1","title":"VOLTAGE_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_1 = 'voltage_phase_1'\n</code></pre> <p>Voltage in phase 1.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.VOLTAGE_PHASE_2","title":"VOLTAGE_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_2 = 'voltage_phase_2'\n</code></pre> <p>Voltage in phase 2.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.VOLTAGE_PHASE_3","title":"VOLTAGE_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_3 = 'voltage_phase_3'\n</code></pre> <p>Voltage in phase 3.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState","title":"frequenz.sdk.microgrid.component.EVChargerCableState","text":"<p>             Bases: <code>Enum</code></p> <p>Cable states of an EV Charger.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>class EVChargerCableState(Enum):\n\"\"\"Cable states of an EV Charger.\"\"\"\nUNSPECIFIED = ev_charger_pb.CableState.CABLE_STATE_UNSPECIFIED\n\"\"\"Unspecified cable state.\"\"\"\nUNPLUGGED = ev_charger_pb.CableState.CABLE_STATE_UNPLUGGED\n\"\"\"The cable is unplugged.\"\"\"\nCHARGING_STATION_PLUGGED = (\nev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_PLUGGED\n)\n\"\"\"The cable is plugged into the charging station.\"\"\"\nCHARGING_STATION_LOCKED = (\nev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_LOCKED\n)\n\"\"\"The cable is plugged into the charging station and locked.\"\"\"\nEV_PLUGGED = ev_charger_pb.CableState.CABLE_STATE_EV_PLUGGED\n\"\"\"The cable is plugged into the EV.\"\"\"\nEV_LOCKED = ev_charger_pb.CableState.CABLE_STATE_EV_LOCKED\n\"\"\"The cable is plugged into the EV and locked.\"\"\"\n@classmethod\ndef from_pb(\ncls, evc_state: ev_charger_pb.CableState.ValueType\n) -&gt; EVChargerCableState:\n\"\"\"Convert a protobuf CableState value to EVChargerCableState enum.\n        Args:\n            evc_state: protobuf cable state to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(t.value == evc_state for t in EVChargerCableState):\nreturn cls.UNSPECIFIED\nreturn EVChargerCableState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.CHARGING_STATION_LOCKED","title":"CHARGING_STATION_LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING_STATION_LOCKED = (\nev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_LOCKED\n)\n</code></pre> <p>The cable is plugged into the charging station and locked.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.CHARGING_STATION_PLUGGED","title":"CHARGING_STATION_PLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING_STATION_PLUGGED = (\nev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_PLUGGED\n)\n</code></pre> <p>The cable is plugged into the charging station.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.EV_LOCKED","title":"EV_LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_LOCKED = ev_charger_pb.CableState.CABLE_STATE_EV_LOCKED\n</code></pre> <p>The cable is plugged into the EV and locked.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.EV_PLUGGED","title":"EV_PLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_PLUGGED = ev_charger_pb.CableState.CABLE_STATE_EV_PLUGGED\n</code></pre> <p>The cable is plugged into the EV.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.UNPLUGGED","title":"UNPLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNPLUGGED = ev_charger_pb.CableState.CABLE_STATE_UNPLUGGED\n</code></pre> <p>The cable is unplugged.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = (\nev_charger_pb.CableState.CABLE_STATE_UNSPECIFIED\n)\n</code></pre> <p>Unspecified cable state.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\nevc_state: ev_charger_pb.CableState.ValueType,\n) -&gt; EVChargerCableState\n</code></pre> <p>Convert a protobuf CableState value to EVChargerCableState enum.</p> PARAMETER  DESCRIPTION <code>evc_state</code> <p>protobuf cable state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>EVChargerCableState</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, evc_state: ev_charger_pb.CableState.ValueType\n) -&gt; EVChargerCableState:\n\"\"\"Convert a protobuf CableState value to EVChargerCableState enum.\n    Args:\n        evc_state: protobuf cable state to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(t.value == evc_state for t in EVChargerCableState):\nreturn cls.UNSPECIFIED\nreturn EVChargerCableState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState","title":"frequenz.sdk.microgrid.component.EVChargerComponentState","text":"<p>             Bases: <code>Enum</code></p> <p>Component State of an EV Charger.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>class EVChargerComponentState(Enum):\n\"\"\"Component State of an EV Charger.\"\"\"\nUNSPECIFIED = ev_charger_pb.ComponentState.COMPONENT_STATE_UNSPECIFIED\n\"\"\"Unspecified component state.\"\"\"\nSTARTING = ev_charger_pb.ComponentState.COMPONENT_STATE_STARTING\n\"\"\"The component is starting.\"\"\"\nNOT_READY = ev_charger_pb.ComponentState.COMPONENT_STATE_NOT_READY\n\"\"\"The component is not ready.\"\"\"\nREADY = ev_charger_pb.ComponentState.COMPONENT_STATE_READY\n\"\"\"The component is ready.\"\"\"\nCHARGING = ev_charger_pb.ComponentState.COMPONENT_STATE_CHARGING\n\"\"\"The component is charging.\"\"\"\nDISCHARGING = ev_charger_pb.ComponentState.COMPONENT_STATE_DISCHARGING\n\"\"\"The component is discharging.\"\"\"\nERROR = ev_charger_pb.ComponentState.COMPONENT_STATE_ERROR\n\"\"\"The component is in error state.\"\"\"\nAUTHORIZATION_REJECTED = (\nev_charger_pb.ComponentState.COMPONENT_STATE_AUTHORIZATION_REJECTED\n)\n\"\"\"The component rejected authorization.\"\"\"\nINTERRUPTED = ev_charger_pb.ComponentState.COMPONENT_STATE_INTERRUPTED\n\"\"\"The component is interrupted.\"\"\"\n@classmethod\ndef from_pb(\ncls, evc_state: ev_charger_pb.ComponentState.ValueType\n) -&gt; EVChargerComponentState:\n\"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum.\n        Args:\n            evc_state: protobuf component state to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(t.value == evc_state for t in EVChargerComponentState):\nreturn cls.UNSPECIFIED\nreturn EVChargerComponentState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.AUTHORIZATION_REJECTED","title":"AUTHORIZATION_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTHORIZATION_REJECTED = (\nev_charger_pb.ComponentState.COMPONENT_STATE_AUTHORIZATION_REJECTED\n)\n</code></pre> <p>The component rejected authorization.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.CHARGING","title":"CHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING = (\nev_charger_pb.ComponentState.COMPONENT_STATE_CHARGING\n)\n</code></pre> <p>The component is charging.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.DISCHARGING","title":"DISCHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISCHARGING = (\nev_charger_pb.ComponentState.COMPONENT_STATE_DISCHARGING\n)\n</code></pre> <p>The component is discharging.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = ev_charger_pb.ComponentState.COMPONENT_STATE_ERROR\n</code></pre> <p>The component is in error state.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.INTERRUPTED","title":"INTERRUPTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERRUPTED = (\nev_charger_pb.ComponentState.COMPONENT_STATE_INTERRUPTED\n)\n</code></pre> <p>The component is interrupted.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.NOT_READY","title":"NOT_READY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT_READY = (\nev_charger_pb.ComponentState.COMPONENT_STATE_NOT_READY\n)\n</code></pre> <p>The component is not ready.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.READY","title":"READY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>READY = ev_charger_pb.ComponentState.COMPONENT_STATE_READY\n</code></pre> <p>The component is ready.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.STARTING","title":"STARTING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STARTING = (\nev_charger_pb.ComponentState.COMPONENT_STATE_STARTING\n)\n</code></pre> <p>The component is starting.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = (\nev_charger_pb.ComponentState.COMPONENT_STATE_UNSPECIFIED\n)\n</code></pre> <p>Unspecified component state.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\nevc_state: ev_charger_pb.ComponentState.ValueType,\n) -&gt; EVChargerComponentState\n</code></pre> <p>Convert a protobuf ComponentState value to EVChargerComponentState enum.</p> PARAMETER  DESCRIPTION <code>evc_state</code> <p>protobuf component state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>EVChargerComponentState</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, evc_state: ev_charger_pb.ComponentState.ValueType\n) -&gt; EVChargerComponentState:\n\"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum.\n    Args:\n        evc_state: protobuf component state to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(t.value == evc_state for t in EVChargerComponentState):\nreturn cls.UNSPECIFIED\nreturn EVChargerComponentState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData","title":"frequenz.sdk.microgrid.component.EVChargerData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding ev_charger data.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass EVChargerData(ComponentData):\n\"\"\"A wrapper class for holding ev_charger data.\"\"\"\nactive_power: float\n\"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n        +ve current means consumption, away from the grid.\n        -ve current means supply into the grid.\n    \"\"\"\ncurrent_per_phase: tuple[float, float, float]\n\"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n        +ve current means consumption, away from the grid.\n        -ve current means supply into the grid.\n    \"\"\"\nvoltage_per_phase: tuple[float, float, float]\n\"\"\"The AC voltage in Volts (V) between the line and the neutral\n        wire for phase/line 1,2 and 3 respectively.\n    \"\"\"\nfrequency: float\n\"\"\"AC frequency, in Hertz (Hz).\"\"\"\ncable_state: EVChargerCableState\n\"\"\"The state of the ev charger's cable.\"\"\"\ncomponent_state: EVChargerComponentState\n\"\"\"The state of the ev charger.\"\"\"\n@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; EVChargerData:\n\"\"\"Create EVChargerData from a protobuf message.\n        Args:\n            raw: raw component data as decoded from the wire.\n        Returns:\n            Instance of EVChargerData created from the protobuf message.\n        \"\"\"\nev_charger_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.ev_charger.data.ac.power_active.value,\ncurrent_per_phase=(\nraw.ev_charger.data.ac.phase_1.current.value,\nraw.ev_charger.data.ac.phase_2.current.value,\nraw.ev_charger.data.ac.phase_3.current.value,\n),\nvoltage_per_phase=(\nraw.ev_charger.data.ac.phase_1.voltage.value,\nraw.ev_charger.data.ac.phase_2.voltage.value,\nraw.ev_charger.data.ac.phase_3.voltage.value,\n),\ncable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\ncomponent_state=EVChargerComponentState.from_pb(\nraw.ev_charger.state.component_state\n),\nfrequency=raw.ev_charger.data.ac.frequency.value,\n)\nev_charger_data._set_raw(raw=raw)\nreturn ev_charger_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.cable_state","title":"cable_state  <code>instance-attribute</code>","text":"<pre><code>cable_state: EVChargerCableState\n</code></pre> <p>The state of the ev charger's cable.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.component_state","title":"component_state  <code>instance-attribute</code>","text":"<pre><code>component_state: EVChargerComponentState\n</code></pre> <p>The state of the ev charger.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>AC frequency, in Hertz (Hz).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: microgrid_pb.ComponentData | None = field(\ndefault=None, init=False\n)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.voltage_per_phase","title":"voltage_per_phase  <code>instance-attribute</code>","text":"<pre><code>voltage_per_phase: tuple[float, float, float]\n</code></pre> <p>The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(\nraw: microgrid_pb.ComponentData,\n) -&gt; EVChargerData\n</code></pre> <p>Create EVChargerData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>EVChargerData</code> <p>Instance of EVChargerData created from the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; EVChargerData:\n\"\"\"Create EVChargerData from a protobuf message.\n    Args:\n        raw: raw component data as decoded from the wire.\n    Returns:\n        Instance of EVChargerData created from the protobuf message.\n    \"\"\"\nev_charger_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.ev_charger.data.ac.power_active.value,\ncurrent_per_phase=(\nraw.ev_charger.data.ac.phase_1.current.value,\nraw.ev_charger.data.ac.phase_2.current.value,\nraw.ev_charger.data.ac.phase_3.current.value,\n),\nvoltage_per_phase=(\nraw.ev_charger.data.ac.phase_1.voltage.value,\nraw.ev_charger.data.ac.phase_2.voltage.value,\nraw.ev_charger.data.ac.phase_3.voltage.value,\n),\ncable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\ncomponent_state=EVChargerComponentState.from_pb(\nraw.ev_charger.state.component_state\n),\nfrequency=raw.ev_charger.data.ac.frequency.value,\n)\nev_charger_data._set_raw(raw=raw)\nreturn ev_charger_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.GridMetadata","title":"frequenz.sdk.microgrid.component.GridMetadata  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentMetadata</code></p> <p>Metadata for a grid connection point.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass GridMetadata(ComponentMetadata):\n\"\"\"Metadata for a grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData","title":"frequenz.sdk.microgrid.component.InverterData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding inverter data.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass InverterData(ComponentData):\n\"\"\"A wrapper class for holding inverter data.\"\"\"\nactive_power: float\n\"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\ncurrent_per_phase: tuple[float, float, float]\n\"\"\"AC current in Amperes (A) for phase/line 1, 2 and 3 respectively.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\n# pylint: disable=line-too-long\nactive_power_inclusion_lower_bound: float\n\"\"\"Lower inclusion bound for inverter power in watts.\n    This is the lower limit of the range within which power requests are allowed for the\n    inverter.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\nactive_power_exclusion_lower_bound: float\n\"\"\"Lower exclusion bound for inverter power in watts.\n    This is the lower limit of the range within which power requests are not allowed for\n    the inverter.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\nactive_power_inclusion_upper_bound: float\n\"\"\"Upper inclusion bound for inverter power in watts.\n    This is the upper limit of the range within which power requests are allowed for the\n    inverter.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\nactive_power_exclusion_upper_bound: float\n\"\"\"Upper exclusion bound for inverter power in watts.\n    This is the upper limit of the range within which power requests are not allowed for\n    the inverter.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n# pylint: enable=line-too-long\nfrequency: float\n\"\"\"AC frequency, in Hertz (Hz).\"\"\"\n_component_state: inverter_pb.ComponentState.ValueType\n\"\"\"State of the inverter.\"\"\"\n_errors: list[inverter_pb.Error]\n\"\"\"List of errors from the component.\"\"\"\n@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; InverterData:\n\"\"\"Create InverterData from a protobuf message.\n        Args:\n            raw: raw component data as decoded from the wire.\n        Returns:\n            Instance of InverterData created from the protobuf message.\n        \"\"\"\nraw_power = raw.inverter.data.ac.power_active\ninverter_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.inverter.data.ac.power_active.value,\ncurrent_per_phase=(\nraw.inverter.data.ac.phase_1.current.value,\nraw.inverter.data.ac.phase_2.current.value,\nraw.inverter.data.ac.phase_3.current.value,\n),\nactive_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\nactive_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\nactive_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\nactive_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\nfrequency=raw.inverter.data.ac.frequency.value,\n_component_state=raw.inverter.state.component_state,\n_errors=list(raw.inverter.errors),\n)\ninverter_data._set_raw(raw=raw)\nreturn inverter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_exclusion_lower_bound","title":"active_power_exclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_lower_bound: float\n</code></pre> <p>Lower exclusion bound for inverter power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_exclusion_upper_bound","title":"active_power_exclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_upper_bound: float\n</code></pre> <p>Upper exclusion bound for inverter power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_inclusion_lower_bound","title":"active_power_inclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_lower_bound: float\n</code></pre> <p>Lower inclusion bound for inverter power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_inclusion_upper_bound","title":"active_power_inclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_upper_bound: float\n</code></pre> <p>Upper inclusion bound for inverter power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1, 2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>AC frequency, in Hertz (Hz).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: microgrid_pb.ComponentData | None = field(\ndefault=None, init=False\n)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: microgrid_pb.ComponentData) -&gt; InverterData\n</code></pre> <p>Create InverterData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>InverterData</code> <p>Instance of InverterData created from the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; InverterData:\n\"\"\"Create InverterData from a protobuf message.\n    Args:\n        raw: raw component data as decoded from the wire.\n    Returns:\n        Instance of InverterData created from the protobuf message.\n    \"\"\"\nraw_power = raw.inverter.data.ac.power_active\ninverter_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.inverter.data.ac.power_active.value,\ncurrent_per_phase=(\nraw.inverter.data.ac.phase_1.current.value,\nraw.inverter.data.ac.phase_2.current.value,\nraw.inverter.data.ac.phase_3.current.value,\n),\nactive_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\nactive_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\nactive_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\nactive_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\nfrequency=raw.inverter.data.ac.frequency.value,\n_component_state=raw.inverter.state.component_state,\n_errors=list(raw.inverter.errors),\n)\ninverter_data._set_raw(raw=raw)\nreturn inverter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType","title":"frequenz.sdk.microgrid.component.InverterType","text":"<p>             Bases: <code>ComponentType</code></p> <p>Enum representing inverter types.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class InverterType(ComponentType):\n\"\"\"Enum representing inverter types.\"\"\"\nNONE = inverter_pb.Type.TYPE_UNSPECIFIED\n\"\"\"Unspecified inverter type.\"\"\"\nBATTERY = inverter_pb.Type.TYPE_BATTERY\n\"\"\"Battery inverter.\"\"\"\nSOLAR = inverter_pb.Type.TYPE_SOLAR\n\"\"\"Solar inverter.\"\"\"\nHYBRID = inverter_pb.Type.TYPE_HYBRID\n\"\"\"Hybrid inverter.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.BATTERY","title":"BATTERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY = inverter_pb.Type.TYPE_BATTERY\n</code></pre> <p>Battery inverter.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.HYBRID","title":"HYBRID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HYBRID = inverter_pb.Type.TYPE_HYBRID\n</code></pre> <p>Hybrid inverter.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = inverter_pb.Type.TYPE_UNSPECIFIED\n</code></pre> <p>Unspecified inverter type.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.SOLAR","title":"SOLAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOLAR = inverter_pb.Type.TYPE_SOLAR\n</code></pre> <p>Solar inverter.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData","title":"frequenz.sdk.microgrid.component.MeterData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding meter data.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass MeterData(ComponentData):\n\"\"\"A wrapper class for holding meter data.\"\"\"\nactive_power: float\n\"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\ncurrent_per_phase: tuple[float, float, float]\n\"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\nvoltage_per_phase: tuple[float, float, float]\n\"\"\"The ac voltage in volts (v) between the line and the neutral wire for phase/line\n        1,2 and 3 respectively.\n    \"\"\"\nfrequency: float\n\"\"\"The AC power frequency in Hertz (Hz).\"\"\"\n@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; MeterData:\n\"\"\"Create MeterData from a protobuf message.\n        Args:\n            raw: raw component data as decoded from the wire.\n        Returns:\n            Instance of MeterData created from the protobuf message.\n        \"\"\"\nmeter_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.meter.data.ac.power_active.value,\ncurrent_per_phase=(\nraw.meter.data.ac.phase_1.current.value,\nraw.meter.data.ac.phase_2.current.value,\nraw.meter.data.ac.phase_3.current.value,\n),\nvoltage_per_phase=(\nraw.meter.data.ac.phase_1.voltage.value,\nraw.meter.data.ac.phase_2.voltage.value,\nraw.meter.data.ac.phase_3.voltage.value,\n),\nfrequency=raw.meter.data.ac.frequency.value,\n)\nmeter_data._set_raw(raw=raw)\nreturn meter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>The AC power frequency in Hertz (Hz).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: microgrid_pb.ComponentData | None = field(\ndefault=None, init=False\n)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.voltage_per_phase","title":"voltage_per_phase  <code>instance-attribute</code>","text":"<pre><code>voltage_per_phase: tuple[float, float, float]\n</code></pre> <p>The ac voltage in volts (v) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: microgrid_pb.ComponentData) -&gt; MeterData\n</code></pre> <p>Create MeterData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>MeterData</code> <p>Instance of MeterData created from the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; MeterData:\n\"\"\"Create MeterData from a protobuf message.\n    Args:\n        raw: raw component data as decoded from the wire.\n    Returns:\n        Instance of MeterData created from the protobuf message.\n    \"\"\"\nmeter_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.meter.data.ac.power_active.value,\ncurrent_per_phase=(\nraw.meter.data.ac.phase_1.current.value,\nraw.meter.data.ac.phase_2.current.value,\nraw.meter.data.ac.phase_3.current.value,\n),\nvoltage_per_phase=(\nraw.meter.data.ac.phase_1.voltage.value,\nraw.meter.data.ac.phase_2.voltage.value,\nraw.meter.data.ac.phase_3.voltage.value,\n),\nfrequency=raw.meter.data.ac.frequency.value,\n)\nmeter_data._set_raw(raw=raw)\nreturn meter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/","title":"Index","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries","title":"frequenz.sdk.timeseries","text":"<p>Handling of timeseries streams.</p> <p>A timeseries is a stream (normally an async iterator) of <code>Sample</code>s.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries--periodicity-and-alignment","title":"Periodicity and alignment","text":"<p>All the data produced by this package is always periodic and aligned to the <code>UNIX_EPOCH</code> (by default).</p> <p>Classes normally take a (re)sampling period as and argument and, optionally, an <code>align_to</code> argument.</p> <p>This means timestamps are always separated exactly by a period, and that this timestamp falls always at multiples of the period, starting at the <code>align_to</code>.</p> <p>This ensures that the data is predictable and consistent among restarts.</p> Example <p>If we have a period of 10 seconds, and are aligning to the UNIX epoch. Assuming the following timeline starts in 1970-01-01 00:00:00 UTC and our current <code>now</code> is 1970-01-01 00:00:32 UTC, then the next timestamp will be at 1970-01-01 00:00:40 UTC:</p> <pre><code>align_to = 1970-01-01 00:00:00         next event = 1970-01-01 00:00:40\n|                                       |\n|---------|---------|---------|-|-------|---------|---------|---------|\n0        10        20        30 |      40        50        60        70\n                               now = 1970-01-01 00:00:32\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.UNIX_EPOCH","title":"frequenz.sdk.timeseries.UNIX_EPOCH  <code>module-attribute</code>","text":"<pre><code>UNIX_EPOCH = datetime.fromtimestamp(0.0, tz=timezone.utc)\n</code></pre> <p>The UNIX epoch (in UTC).</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds","title":"frequenz.sdk.timeseries.Bounds  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[_T]</code></p> <p>Lower and upper bound values.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Bounds(Generic[_T]):\n\"\"\"Lower and upper bound values.\"\"\"\nlower: _T\n\"\"\"Lower bound.\"\"\"\nupper: _T\n\"\"\"Upper bound.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: _T\n</code></pre> <p>Lower bound.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: _T\n</code></pre> <p>Upper bound.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current","title":"frequenz.sdk.timeseries.Current","text":"<p>             Bases: <code>Quantity</code></p> <p>A current quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Current(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={\n-3: \"mA\",\n0: \"A\",\n},\n):\n\"\"\"A current quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_amperes(cls, amperes: float) -&gt; Self:\n\"\"\"Initialize a new current quantity.\n        Args:\n            amperes: The current in amperes.\n        Returns:\n            A new current quantity.\n        \"\"\"\ncurrent = cls.__new__(cls)\ncurrent._base_value = amperes\nreturn current\n@classmethod\ndef from_milliamperes(cls, milliamperes: float) -&gt; Self:\n\"\"\"Initialize a new current quantity.\n        Args:\n            milliamperes: The current in milliamperes.\n        Returns:\n            A new current quantity.\n        \"\"\"\ncurrent = cls.__new__(cls)\ncurrent._base_value = milliamperes * 10**-3\nreturn current\ndef as_amperes(self) -&gt; float:\n\"\"\"Return the current in amperes.\n        Returns:\n            The current in amperes.\n        \"\"\"\nreturn self._base_value\ndef as_milliamperes(self) -&gt; float:\n\"\"\"Return the current in milliamperes.\n        Returns:\n            The current in milliamperes.\n        \"\"\"\nreturn self._base_value * 1e3\n@overload  # type: ignore\ndef __mul__(self, other: Percentage) -&gt; Self:\n\"\"\"Scale this current by a percentage.\n        Args:\n            other: The percentage by which to scale this current.\n        Returns:\n            The scaled current.\n        \"\"\"\n@overload\ndef __mul__(self, other: Voltage) -&gt; Power:\n\"\"\"Multiply the current by a voltage to get a power.\n        Args:\n            other: The voltage.\n        Returns:\n            The calculated power.\n        \"\"\"\ndef __mul__(self, other: Percentage | Voltage) -&gt; Self | Power:\n\"\"\"Return a current or power from multiplying this current by the given value.\n        Args:\n            other: The percentage or voltage to multiply by.\n        Returns:\n            A current or power.\n        \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, Voltage):\nreturn Power.from_watts(self._base_value * other._base_value)\nreturn NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n\"\"\"Return the absolute value of this quantity.\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\nabsolute = type(self).__new__(type(self))\nabsolute._base_value = abs(self._base_value)\nreturn absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n\"\"\"Return the sum of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nsumme = type(self).__new__(type(self))\nsumme._base_value = self._base_value + other._base_value\nreturn summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Return whether this quantity is equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\n# The above check ensures that both quantities are the exact same type, because\n# `isinstance` returns true for subclasses and superclasses.  But the above check\n# doesn't help mypy identify the type of other,  so the below line is necessary.\nassert isinstance(other, self.__class__)\nreturn self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n\"\"\"Return a formatted string representation of this quantity.\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n    Args:\n        __format_spec: The format specifier.\n    Returns:\n        A string representation of this quantity.\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\nkeep_trailing_zeros = False\nif __format_spec != \"\":\nfspec_parts = __format_spec.split(\".\")\nif (\nlen(fspec_parts) != 2\nor fspec_parts[0] not in (\"\", \"0\")\nor not fspec_parts[1].isdigit()\n):\nraise ValueError(\n\"Invalid format specifier. Must be empty or `[0].{precision}`\"\n)\nif fspec_parts[0] == \"0\":\nkeep_trailing_zeros = True\nprecision = int(fspec_parts[1])\nelse:\nprecision = 3\nif not self._exponent_unit_map:\nreturn f\"{self._base_value:.{precision}f}\"\nif math.isinf(self._base_value) or math.isnan(self._base_value):\nreturn f\"{self._base_value} {self._exponent_unit_map[0]}\"\nabs_value = abs(self._base_value)\nexponent = math.floor(math.log10(abs_value)) if abs_value else 0\nunit_place = exponent - exponent % 3\nif unit_place &lt; min(self._exponent_unit_map):\nunit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\nunit_place = min(self._exponent_unit_map)\nelif unit_place &gt; max(self._exponent_unit_map):\nunit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\nunit_place = max(self._exponent_unit_map)\nelse:\nunit = self._exponent_unit_map[unit_place]\nvalue_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\nstripped = value_str.rstrip(\"0\").rstrip(\".\")\nif not keep_trailing_zeros:\nvalue_str = stripped\nunit_str = unit if stripped != \"0\" else self._exponent_unit_map[0]\nreturn f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n\"\"\"Initialize a new quantity.\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\nself._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\nexponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n\"\"\"Initialize a new subclass of Quantity.\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\nif 0 not in exponent_unit_map:\nraise ValueError(\"Expected a base unit for the type (for exponent 0)\")\ncls._exponent_unit_map = exponent_unit_map\nsuper().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Percentage | Voltage) -&gt; Self | Power\n</code></pre> <p>Return a current or power from multiplying this current by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The percentage or voltage to multiply by.</p> <p> TYPE: <code>Percentage | Voltage</code> </p> RETURNS DESCRIPTION <code>Self | Power</code> <p>A current or power.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: Percentage | Voltage) -&gt; Self | Power:\n\"\"\"Return a current or power from multiplying this current by the given value.\n    Args:\n        other: The percentage or voltage to multiply by.\n    Returns:\n        A current or power.\n    \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, Voltage):\nreturn Power.from_watts(self._base_value * other._base_value)\nreturn NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n\"\"\"Return the negation of this quantity.\n    Returns:\n        The negation of this quantity.\n    \"\"\"\nnegation = type(self).__new__(type(self))\nnegation._base_value = -self._base_value\nreturn negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a representation of this quantity.\n    Returns:\n        A representation of this quantity.\n    \"\"\"\nreturn f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this quantity.\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\nreturn self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n\"\"\"Return the difference of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\ndifference = type(self).__new__(type(self))\ndifference._base_value = self._base_value - other._base_value\nreturn difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.as_amperes","title":"as_amperes","text":"<pre><code>as_amperes() -&gt; float\n</code></pre> <p>Return the current in amperes.</p> RETURNS DESCRIPTION <code>float</code> <p>The current in amperes.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_amperes(self) -&gt; float:\n\"\"\"Return the current in amperes.\n    Returns:\n        The current in amperes.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.as_milliamperes","title":"as_milliamperes","text":"<pre><code>as_milliamperes() -&gt; float\n</code></pre> <p>Return the current in milliamperes.</p> RETURNS DESCRIPTION <code>float</code> <p>The current in milliamperes.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_milliamperes(self) -&gt; float:\n\"\"\"Return the current in milliamperes.\n    Returns:\n        The current in milliamperes.\n    \"\"\"\nreturn self._base_value * 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.from_amperes","title":"from_amperes  <code>classmethod</code>","text":"<pre><code>from_amperes(amperes: float) -&gt; Self\n</code></pre> <p>Initialize a new current quantity.</p> PARAMETER  DESCRIPTION <code>amperes</code> <p>The current in amperes.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new current quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_amperes(cls, amperes: float) -&gt; Self:\n\"\"\"Initialize a new current quantity.\n    Args:\n        amperes: The current in amperes.\n    Returns:\n        A new current quantity.\n    \"\"\"\ncurrent = cls.__new__(cls)\ncurrent._base_value = amperes\nreturn current\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.from_milliamperes","title":"from_milliamperes  <code>classmethod</code>","text":"<pre><code>from_milliamperes(milliamperes: float) -&gt; Self\n</code></pre> <p>Initialize a new current quantity.</p> PARAMETER  DESCRIPTION <code>milliamperes</code> <p>The current in milliamperes.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new current quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_milliamperes(cls, milliamperes: float) -&gt; Self:\n\"\"\"Initialize a new current quantity.\n    Args:\n        milliamperes: The current in milliamperes.\n    Returns:\n        A new current quantity.\n    \"\"\"\ncurrent = cls.__new__(cls)\ncurrent._base_value = milliamperes * 10**-3\nreturn current\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.isclose","title":"isclose","text":"<pre><code>isclose(\nother: Self,\nrel_tol: float = 1e-09,\nabs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n\"\"\"Return whether this quantity is close to another.\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\nreturn math.isclose(\nself._base_value,\nother._base_value,  # pylint: disable=protected-access\nrel_tol=rel_tol,\nabs_tol=abs_tol,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n\"\"\"Return whether this quantity is infinite.\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\nreturn math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n\"\"\"Return whether this quantity is NaN.\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\nreturn math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n\"\"\"Return a quantity with value 0.\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n_zero = cls._zero_cache.get(cls, None)\nif _zero is None:\n_zero = cls.__new__(cls)\n_zero._base_value = 0\ncls._zero_cache[cls] = _zero\nassert isinstance(_zero, cls)\nreturn _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy","title":"frequenz.sdk.timeseries.Energy","text":"<p>             Bases: <code>Quantity</code></p> <p>An energy quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Energy(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={\n0: \"Wh\",\n3: \"kWh\",\n6: \"MWh\",\n},\n):\n\"\"\"An energy quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_watt_hours(cls, watt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n        Args:\n            watt_hours: The energy in watt hours.\n        Returns:\n            A new energy quantity.\n        \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = watt_hours\nreturn energy\n@classmethod\ndef from_kilowatt_hours(cls, kilowatt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n        Args:\n            kilowatt_hours: The energy in kilowatt hours.\n        Returns:\n            A new energy quantity.\n        \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = kilowatt_hours * 10**3\nreturn energy\n@classmethod\ndef from_megawatt_hours(cls, megawatt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n        Args:\n            megawatt_hours: The energy in megawatt hours.\n        Returns:\n            A new energy quantity.\n        \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = megawatt_hours * 10**6\nreturn energy\ndef as_watt_hours(self) -&gt; float:\n\"\"\"Return the energy in watt hours.\n        Returns:\n            The energy in watt hours.\n        \"\"\"\nreturn self._base_value\ndef as_kilowatt_hours(self) -&gt; float:\n\"\"\"Return the energy in kilowatt hours.\n        Returns:\n            The energy in kilowatt hours.\n        \"\"\"\nreturn self._base_value / 1e3\ndef as_megawatt_hours(self) -&gt; float:\n\"\"\"Return the energy in megawatt hours.\n        Returns:\n            The energy in megawatt hours.\n        \"\"\"\nreturn self._base_value / 1e6\n@overload\ndef __truediv__(self, other: timedelta) -&gt; Power:\n\"\"\"Return a power from dividing this energy by the given duration.\n        Args:\n            other: The duration to divide by.\n        Returns:\n            A power from dividing this energy by the given duration.\n        \"\"\"\n@overload\ndef __truediv__(self, other: Power) -&gt; timedelta:\n\"\"\"Return a duration from dividing this energy by the given power.\n        Args:\n            other: The power to divide by.\n        Returns:\n            A duration from dividing this energy by the given power.\n        \"\"\"\ndef __truediv__(self, other: timedelta | Power) -&gt; Power | timedelta:\n\"\"\"Return a power or duration from dividing this energy by the given value.\n        Args:\n            other: The power or duration to divide by.\n        Returns:\n            A power or duration from dividing this energy by the given value.\n        Raises:\n            TypeError: If the given value is not a power or duration.\n        \"\"\"\nif isinstance(other, timedelta):\nreturn Power.from_watts(self._base_value / (other.total_seconds() / 3600.0))\nif isinstance(other, Power):\nreturn timedelta(seconds=(self._base_value / other._base_value) * 3600.0)\nraise TypeError(\nf\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n\"\"\"Return the absolute value of this quantity.\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\nabsolute = type(self).__new__(type(self))\nabsolute._base_value = abs(self._base_value)\nreturn absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n\"\"\"Return the sum of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nsumme = type(self).__new__(type(self))\nsumme._base_value = self._base_value + other._base_value\nreturn summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Return whether this quantity is equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\n# The above check ensures that both quantities are the exact same type, because\n# `isinstance` returns true for subclasses and superclasses.  But the above check\n# doesn't help mypy identify the type of other,  so the below line is necessary.\nassert isinstance(other, self.__class__)\nreturn self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n\"\"\"Return a formatted string representation of this quantity.\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n    Args:\n        __format_spec: The format specifier.\n    Returns:\n        A string representation of this quantity.\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\nkeep_trailing_zeros = False\nif __format_spec != \"\":\nfspec_parts = __format_spec.split(\".\")\nif (\nlen(fspec_parts) != 2\nor fspec_parts[0] not in (\"\", \"0\")\nor not fspec_parts[1].isdigit()\n):\nraise ValueError(\n\"Invalid format specifier. Must be empty or `[0].{precision}`\"\n)\nif fspec_parts[0] == \"0\":\nkeep_trailing_zeros = True\nprecision = int(fspec_parts[1])\nelse:\nprecision = 3\nif not self._exponent_unit_map:\nreturn f\"{self._base_value:.{precision}f}\"\nif math.isinf(self._base_value) or math.isnan(self._base_value):\nreturn f\"{self._base_value} {self._exponent_unit_map[0]}\"\nabs_value = abs(self._base_value)\nexponent = math.floor(math.log10(abs_value)) if abs_value else 0\nunit_place = exponent - exponent % 3\nif unit_place &lt; min(self._exponent_unit_map):\nunit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\nunit_place = min(self._exponent_unit_map)\nelif unit_place &gt; max(self._exponent_unit_map):\nunit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\nunit_place = max(self._exponent_unit_map)\nelse:\nunit = self._exponent_unit_map[unit_place]\nvalue_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\nstripped = value_str.rstrip(\"0\").rstrip(\".\")\nif not keep_trailing_zeros:\nvalue_str = stripped\nunit_str = unit if stripped != \"0\" else self._exponent_unit_map[0]\nreturn f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n\"\"\"Initialize a new quantity.\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\nself._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\nexponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n\"\"\"Initialize a new subclass of Quantity.\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\nif 0 not in exponent_unit_map:\nraise ValueError(\"Expected a base unit for the type (for exponent 0)\")\ncls._exponent_unit_map = exponent_unit_map\nsuper().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__mul__","title":"__mul__","text":"<pre><code>__mul__(percent: Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a percentage.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percentage by which to scale this quantity.</p> <p> TYPE: <code>Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, percent: Percentage) -&gt; Self:\n\"\"\"Scale this quantity by a percentage.\n    Args:\n        percent: The percentage by which to scale this quantity.\n    Returns:\n        The scaled quantity.\n    \"\"\"\nif not isinstance(percent, Percentage):\nreturn NotImplemented\nproduct = type(self).__new__(type(self))\nproduct._base_value = self._base_value * percent.as_fraction()\nreturn product\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n\"\"\"Return the negation of this quantity.\n    Returns:\n        The negation of this quantity.\n    \"\"\"\nnegation = type(self).__new__(type(self))\nnegation._base_value = -self._base_value\nreturn negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a representation of this quantity.\n    Returns:\n        A representation of this quantity.\n    \"\"\"\nreturn f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this quantity.\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\nreturn self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n\"\"\"Return the difference of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\ndifference = type(self).__new__(type(self))\ndifference._base_value = self._base_value - other._base_value\nreturn difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: timedelta | Power) -&gt; Power | timedelta\n</code></pre> <p>Return a power or duration from dividing this energy by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The power or duration to divide by.</p> <p> TYPE: <code>timedelta | Power</code> </p> RETURNS DESCRIPTION <code>Power | timedelta</code> <p>A power or duration from dividing this energy by the given value.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given value is not a power or duration.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, other: timedelta | Power) -&gt; Power | timedelta:\n\"\"\"Return a power or duration from dividing this energy by the given value.\n    Args:\n        other: The power or duration to divide by.\n    Returns:\n        A power or duration from dividing this energy by the given value.\n    Raises:\n        TypeError: If the given value is not a power or duration.\n    \"\"\"\nif isinstance(other, timedelta):\nreturn Power.from_watts(self._base_value / (other.total_seconds() / 3600.0))\nif isinstance(other, Power):\nreturn timedelta(seconds=(self._base_value / other._base_value) * 3600.0)\nraise TypeError(\nf\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_kilowatt_hours","title":"as_kilowatt_hours","text":"<pre><code>as_kilowatt_hours() -&gt; float\n</code></pre> <p>Return the energy in kilowatt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in kilowatt hours.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilowatt_hours(self) -&gt; float:\n\"\"\"Return the energy in kilowatt hours.\n    Returns:\n        The energy in kilowatt hours.\n    \"\"\"\nreturn self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_megawatt_hours","title":"as_megawatt_hours","text":"<pre><code>as_megawatt_hours() -&gt; float\n</code></pre> <p>Return the energy in megawatt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in megawatt hours.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megawatt_hours(self) -&gt; float:\n\"\"\"Return the energy in megawatt hours.\n    Returns:\n        The energy in megawatt hours.\n    \"\"\"\nreturn self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_watt_hours","title":"as_watt_hours","text":"<pre><code>as_watt_hours() -&gt; float\n</code></pre> <p>Return the energy in watt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in watt hours.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_watt_hours(self) -&gt; float:\n\"\"\"Return the energy in watt hours.\n    Returns:\n        The energy in watt hours.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_kilowatt_hours","title":"from_kilowatt_hours  <code>classmethod</code>","text":"<pre><code>from_kilowatt_hours(kilowatt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER  DESCRIPTION <code>kilowatt_hours</code> <p>The energy in kilowatt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilowatt_hours(cls, kilowatt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n    Args:\n        kilowatt_hours: The energy in kilowatt hours.\n    Returns:\n        A new energy quantity.\n    \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = kilowatt_hours * 10**3\nreturn energy\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_megawatt_hours","title":"from_megawatt_hours  <code>classmethod</code>","text":"<pre><code>from_megawatt_hours(megawatt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER  DESCRIPTION <code>megawatt_hours</code> <p>The energy in megawatt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megawatt_hours(cls, megawatt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n    Args:\n        megawatt_hours: The energy in megawatt hours.\n    Returns:\n        A new energy quantity.\n    \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = megawatt_hours * 10**6\nreturn energy\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_watt_hours","title":"from_watt_hours  <code>classmethod</code>","text":"<pre><code>from_watt_hours(watt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER  DESCRIPTION <code>watt_hours</code> <p>The energy in watt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_watt_hours(cls, watt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n    Args:\n        watt_hours: The energy in watt hours.\n    Returns:\n        A new energy quantity.\n    \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = watt_hours\nreturn energy\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.isclose","title":"isclose","text":"<pre><code>isclose(\nother: Self,\nrel_tol: float = 1e-09,\nabs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n\"\"\"Return whether this quantity is close to another.\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\nreturn math.isclose(\nself._base_value,\nother._base_value,  # pylint: disable=protected-access\nrel_tol=rel_tol,\nabs_tol=abs_tol,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n\"\"\"Return whether this quantity is infinite.\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\nreturn math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n\"\"\"Return whether this quantity is NaN.\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\nreturn math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n\"\"\"Return a quantity with value 0.\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n_zero = cls._zero_cache.get(cls, None)\nif _zero is None:\n_zero = cls.__new__(cls)\n_zero._base_value = 0\ncls._zero_cache[cls] = _zero\nassert isinstance(_zero, cls)\nreturn _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency","title":"frequenz.sdk.timeseries.Frequency","text":"<p>             Bases: <code>Quantity</code></p> <p>A frequency quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Frequency(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={0: \"Hz\", 3: \"kHz\", 6: \"MHz\", 9: \"GHz\"},\n):\n\"\"\"A frequency quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_hertz(cls, hertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n        Args:\n            hertz: The frequency in hertz.\n        Returns:\n            A new frequency quantity.\n        \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = hertz\nreturn frequency\n@classmethod\ndef from_kilohertz(cls, kilohertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n        Args:\n            kilohertz: The frequency in kilohertz.\n        Returns:\n            A new frequency quantity.\n        \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = kilohertz * 10**3\nreturn frequency\n@classmethod\ndef from_megahertz(cls, megahertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n        Args:\n            megahertz: The frequency in megahertz.\n        Returns:\n            A new frequency quantity.\n        \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = megahertz * 10**6\nreturn frequency\n@classmethod\ndef from_gigahertz(cls, gigahertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n        Args:\n            gigahertz: The frequency in gigahertz.\n        Returns:\n            A new frequency quantity.\n        \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = gigahertz * 10**9\nreturn frequency\ndef as_hertz(self) -&gt; float:\n\"\"\"Return the frequency in hertz.\n        Returns:\n            The frequency in hertz.\n        \"\"\"\nreturn self._base_value\ndef as_kilohertz(self) -&gt; float:\n\"\"\"Return the frequency in kilohertz.\n        Returns:\n            The frequency in kilohertz.\n        \"\"\"\nreturn self._base_value / 1e3\ndef as_megahertz(self) -&gt; float:\n\"\"\"Return the frequency in megahertz.\n        Returns:\n            The frequency in megahertz.\n        \"\"\"\nreturn self._base_value / 1e6\ndef as_gigahertz(self) -&gt; float:\n\"\"\"Return the frequency in gigahertz.\n        Returns:\n            The frequency in gigahertz.\n        \"\"\"\nreturn self._base_value / 1e9\ndef period(self) -&gt; timedelta:\n\"\"\"Return the period of the frequency.\n        Returns:\n            The period of the frequency.\n        \"\"\"\nreturn timedelta(seconds=1.0 / self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n\"\"\"Return the absolute value of this quantity.\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\nabsolute = type(self).__new__(type(self))\nabsolute._base_value = abs(self._base_value)\nreturn absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n\"\"\"Return the sum of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nsumme = type(self).__new__(type(self))\nsumme._base_value = self._base_value + other._base_value\nreturn summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Return whether this quantity is equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\n# The above check ensures that both quantities are the exact same type, because\n# `isinstance` returns true for subclasses and superclasses.  But the above check\n# doesn't help mypy identify the type of other,  so the below line is necessary.\nassert isinstance(other, self.__class__)\nreturn self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n\"\"\"Return a formatted string representation of this quantity.\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n    Args:\n        __format_spec: The format specifier.\n    Returns:\n        A string representation of this quantity.\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\nkeep_trailing_zeros = False\nif __format_spec != \"\":\nfspec_parts = __format_spec.split(\".\")\nif (\nlen(fspec_parts) != 2\nor fspec_parts[0] not in (\"\", \"0\")\nor not fspec_parts[1].isdigit()\n):\nraise ValueError(\n\"Invalid format specifier. Must be empty or `[0].{precision}`\"\n)\nif fspec_parts[0] == \"0\":\nkeep_trailing_zeros = True\nprecision = int(fspec_parts[1])\nelse:\nprecision = 3\nif not self._exponent_unit_map:\nreturn f\"{self._base_value:.{precision}f}\"\nif math.isinf(self._base_value) or math.isnan(self._base_value):\nreturn f\"{self._base_value} {self._exponent_unit_map[0]}\"\nabs_value = abs(self._base_value)\nexponent = math.floor(math.log10(abs_value)) if abs_value else 0\nunit_place = exponent - exponent % 3\nif unit_place &lt; min(self._exponent_unit_map):\nunit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\nunit_place = min(self._exponent_unit_map)\nelif unit_place &gt; max(self._exponent_unit_map):\nunit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\nunit_place = max(self._exponent_unit_map)\nelse:\nunit = self._exponent_unit_map[unit_place]\nvalue_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\nstripped = value_str.rstrip(\"0\").rstrip(\".\")\nif not keep_trailing_zeros:\nvalue_str = stripped\nunit_str = unit if stripped != \"0\" else self._exponent_unit_map[0]\nreturn f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n\"\"\"Initialize a new quantity.\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\nself._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\nexponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n\"\"\"Initialize a new subclass of Quantity.\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\nif 0 not in exponent_unit_map:\nraise ValueError(\"Expected a base unit for the type (for exponent 0)\")\ncls._exponent_unit_map = exponent_unit_map\nsuper().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__mul__","title":"__mul__","text":"<pre><code>__mul__(percent: Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a percentage.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percentage by which to scale this quantity.</p> <p> TYPE: <code>Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, percent: Percentage) -&gt; Self:\n\"\"\"Scale this quantity by a percentage.\n    Args:\n        percent: The percentage by which to scale this quantity.\n    Returns:\n        The scaled quantity.\n    \"\"\"\nif not isinstance(percent, Percentage):\nreturn NotImplemented\nproduct = type(self).__new__(type(self))\nproduct._base_value = self._base_value * percent.as_fraction()\nreturn product\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n\"\"\"Return the negation of this quantity.\n    Returns:\n        The negation of this quantity.\n    \"\"\"\nnegation = type(self).__new__(type(self))\nnegation._base_value = -self._base_value\nreturn negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a representation of this quantity.\n    Returns:\n        A representation of this quantity.\n    \"\"\"\nreturn f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this quantity.\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\nreturn self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n\"\"\"Return the difference of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\ndifference = type(self).__new__(type(self))\ndifference._base_value = self._base_value - other._base_value\nreturn difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_gigahertz","title":"as_gigahertz","text":"<pre><code>as_gigahertz() -&gt; float\n</code></pre> <p>Return the frequency in gigahertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in gigahertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_gigahertz(self) -&gt; float:\n\"\"\"Return the frequency in gigahertz.\n    Returns:\n        The frequency in gigahertz.\n    \"\"\"\nreturn self._base_value / 1e9\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_hertz","title":"as_hertz","text":"<pre><code>as_hertz() -&gt; float\n</code></pre> <p>Return the frequency in hertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in hertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_hertz(self) -&gt; float:\n\"\"\"Return the frequency in hertz.\n    Returns:\n        The frequency in hertz.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_kilohertz","title":"as_kilohertz","text":"<pre><code>as_kilohertz() -&gt; float\n</code></pre> <p>Return the frequency in kilohertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in kilohertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilohertz(self) -&gt; float:\n\"\"\"Return the frequency in kilohertz.\n    Returns:\n        The frequency in kilohertz.\n    \"\"\"\nreturn self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_megahertz","title":"as_megahertz","text":"<pre><code>as_megahertz() -&gt; float\n</code></pre> <p>Return the frequency in megahertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in megahertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megahertz(self) -&gt; float:\n\"\"\"Return the frequency in megahertz.\n    Returns:\n        The frequency in megahertz.\n    \"\"\"\nreturn self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_gigahertz","title":"from_gigahertz  <code>classmethod</code>","text":"<pre><code>from_gigahertz(gigahertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>gigahertz</code> <p>The frequency in gigahertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_gigahertz(cls, gigahertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n    Args:\n        gigahertz: The frequency in gigahertz.\n    Returns:\n        A new frequency quantity.\n    \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = gigahertz * 10**9\nreturn frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_hertz","title":"from_hertz  <code>classmethod</code>","text":"<pre><code>from_hertz(hertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>hertz</code> <p>The frequency in hertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_hertz(cls, hertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n    Args:\n        hertz: The frequency in hertz.\n    Returns:\n        A new frequency quantity.\n    \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = hertz\nreturn frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_kilohertz","title":"from_kilohertz  <code>classmethod</code>","text":"<pre><code>from_kilohertz(kilohertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>kilohertz</code> <p>The frequency in kilohertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilohertz(cls, kilohertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n    Args:\n        kilohertz: The frequency in kilohertz.\n    Returns:\n        A new frequency quantity.\n    \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = kilohertz * 10**3\nreturn frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_megahertz","title":"from_megahertz  <code>classmethod</code>","text":"<pre><code>from_megahertz(megahertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>megahertz</code> <p>The frequency in megahertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megahertz(cls, megahertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n    Args:\n        megahertz: The frequency in megahertz.\n    Returns:\n        A new frequency quantity.\n    \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = megahertz * 10**6\nreturn frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.isclose","title":"isclose","text":"<pre><code>isclose(\nother: Self,\nrel_tol: float = 1e-09,\nabs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n\"\"\"Return whether this quantity is close to another.\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\nreturn math.isclose(\nself._base_value,\nother._base_value,  # pylint: disable=protected-access\nrel_tol=rel_tol,\nabs_tol=abs_tol,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n\"\"\"Return whether this quantity is infinite.\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\nreturn math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n\"\"\"Return whether this quantity is NaN.\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\nreturn math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.period","title":"period","text":"<pre><code>period() -&gt; timedelta\n</code></pre> <p>Return the period of the frequency.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The period of the frequency.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def period(self) -&gt; timedelta:\n\"\"\"Return the period of the frequency.\n    Returns:\n        The period of the frequency.\n    \"\"\"\nreturn timedelta(seconds=1.0 / self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n\"\"\"Return a quantity with value 0.\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n_zero = cls._zero_cache.get(cls, None)\nif _zero is None:\n_zero = cls.__new__(cls)\n_zero._base_value = 0\ncls._zero_cache[cls] = _zero\nassert isinstance(_zero, cls)\nreturn _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow","title":"frequenz.sdk.timeseries.MovingWindow","text":"<p>             Bases: <code>BackgroundService</code></p> <p>A data window that moves with the latest datapoints of a data stream.</p> <p>After initialization the <code>MovingWindow</code> can be accessed by an integer index or a timestamp. A sub window can be accessed by using a slice of integers or timestamps.</p> <p>Note that a numpy ndarray is returned and thus users can use numpys operations directly on a window.</p> <p>The window uses a ring buffer for storage and the first element is aligned to a fixed defined point in time. Since the moving nature of the window, the date of the first and the last element are constantly changing and therefore the point in time that defines the alignment can be outside of the time window. Modulo arithmetic is used to move the <code>align_to</code> timestamp into the latest window.</p> <p>If for example the <code>align_to</code> parameter is set to <code>datetime(1, 1, 1, tzinfo=timezone.utc)</code> and the window size is bigger than one day then the first element will always be aligned to midnight.</p> <p>Resampling might be required to reduce the number of samples to store, and it can be set by specifying the resampler config parameter so that the user can control the granularity of the samples to be stored in the underlying buffer.</p> <p>If resampling is not required, the resampler config parameter can be set to None in which case the MovingWindow will not perform any resampling.</p> <p>Example: Calculate the mean of a time interval</p> <pre><code>```python\nfrom datetime import datetime, timedelta, timezone\n\nasync def send_mock_data(sender: Sender[Sample]) -&gt; None:\n    while True:\n        await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n        await asyncio.sleep(1.0)\n\nasync def run() -&gt; None:\n    resampled_data_channel = Broadcast[Sample](\"sample-data\")\n    resampled_data_receiver = resampled_data_channel.new_receiver()\n    resampled_data_sender = resampled_data_channel.new_sender()\n\n    send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n    async with MovingWindow(\n        size=timedelta(seconds=5),\n        resampled_data_recv=resampled_data_receiver,\n        input_sampling_period=timedelta(seconds=1),\n    ) as window:\n        time_start = datetime.now(tz=timezone.utc)\n        time_end = time_start + timedelta(seconds=5)\n\n        # ... wait for 5 seconds until the buffer is filled\n        await asyncio.sleep(5)\n\n        # return an numpy array from the window\n        array = window[time_start:time_end]\n        # and use it to for example calculate the mean\n        mean = array.mean()\n\nasyncio.run(run())\n```\n</code></pre> <p>Example: Create a polars data frame from a <code>MovingWindow</code></p> <pre><code>```python\nimport polars as pl\nfrom datetime import datetime, timedelta, timezone\n\nasync def send_mock_data(sender: Sender[Sample]) -&gt; None:\n    while True:\n        await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n        await asyncio.sleep(1.0)\n\nasync def run() -&gt; None:\n    resampled_data_channel = Broadcast[Sample](\"sample-data\")\n    resampled_data_receiver = resampled_data_channel.new_receiver()\n    resampled_data_sender = resampled_data_channel.new_sender()\n\n    send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n    # create a window that stores two days of data\n    # starting at 1.1.23 with samplerate=1\n    async with MovingWindow(\n        size=timedelta(days=2),\n        resampled_data_recv=resampled_data_receiver,\n        input_sampling_period=timedelta(seconds=1),\n    ) as window:\n        # wait for one full day until the buffer is filled\n        await asyncio.sleep(60*60*24)\n\n        # create a polars series with one full day of data\n        time_start = datetime(2023, 1, 1, tzinfo=timezone.utc)\n        time_end = datetime(2023, 1, 2, tzinfo=timezone.utc)\n        series = pl.Series(\"Jan_1\", window[time_start:time_end])\n\nasyncio.run(run())\n```\n</code></pre> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>class MovingWindow(BackgroundService):\n\"\"\"\n    A data window that moves with the latest datapoints of a data stream.\n    After initialization the `MovingWindow` can be accessed by an integer\n    index or a timestamp. A sub window can be accessed by using a slice of\n    integers or timestamps.\n    Note that a numpy ndarray is returned and thus users can use\n    numpys operations directly on a window.\n    The window uses a ring buffer for storage and the first element is aligned to\n    a fixed defined point in time. Since the moving nature of the window, the\n    date of the first and the last element are constantly changing and therefore\n    the point in time that defines the alignment can be outside of the time window.\n    Modulo arithmetic is used to move the `align_to` timestamp into the latest\n    window.\n    If for example the `align_to` parameter is set to\n    `datetime(1, 1, 1, tzinfo=timezone.utc)` and the window size is bigger than\n    one day then the first element will always be aligned to midnight.\n    Resampling might be required to reduce the number of samples to store, and\n    it can be set by specifying the resampler config parameter so that the user\n    can control the granularity of the samples to be stored in the underlying\n    buffer.\n    If resampling is not required, the resampler config parameter can be\n    set to None in which case the MovingWindow will not perform any resampling.\n    Example: Calculate the mean of a time interval\n        ```python\n        from datetime import datetime, timedelta, timezone\n        async def send_mock_data(sender: Sender[Sample]) -&gt; None:\n            while True:\n                await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n                await asyncio.sleep(1.0)\n        async def run() -&gt; None:\n            resampled_data_channel = Broadcast[Sample](\"sample-data\")\n            resampled_data_receiver = resampled_data_channel.new_receiver()\n            resampled_data_sender = resampled_data_channel.new_sender()\n            send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n            async with MovingWindow(\n                size=timedelta(seconds=5),\n                resampled_data_recv=resampled_data_receiver,\n                input_sampling_period=timedelta(seconds=1),\n            ) as window:\n                time_start = datetime.now(tz=timezone.utc)\n                time_end = time_start + timedelta(seconds=5)\n                # ... wait for 5 seconds until the buffer is filled\n                await asyncio.sleep(5)\n                # return an numpy array from the window\n                array = window[time_start:time_end]\n                # and use it to for example calculate the mean\n                mean = array.mean()\n        asyncio.run(run())\n        ```\n    Example: Create a polars data frame from a `MovingWindow`\n        ```python\n        import polars as pl\n        from datetime import datetime, timedelta, timezone\n        async def send_mock_data(sender: Sender[Sample]) -&gt; None:\n            while True:\n                await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n                await asyncio.sleep(1.0)\n        async def run() -&gt; None:\n            resampled_data_channel = Broadcast[Sample](\"sample-data\")\n            resampled_data_receiver = resampled_data_channel.new_receiver()\n            resampled_data_sender = resampled_data_channel.new_sender()\n            send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n            # create a window that stores two days of data\n            # starting at 1.1.23 with samplerate=1\n            async with MovingWindow(\n                size=timedelta(days=2),\n                resampled_data_recv=resampled_data_receiver,\n                input_sampling_period=timedelta(seconds=1),\n            ) as window:\n                # wait for one full day until the buffer is filled\n                await asyncio.sleep(60*60*24)\n                # create a polars series with one full day of data\n                time_start = datetime(2023, 1, 1, tzinfo=timezone.utc)\n                time_end = datetime(2023, 1, 2, tzinfo=timezone.utc)\n                series = pl.Series(\"Jan_1\", window[time_start:time_end])\n        asyncio.run(run())\n        ```\n    \"\"\"\ndef __init__(  # pylint: disable=too-many-arguments\nself,\nsize: timedelta,\nresampled_data_recv: Receiver[Sample[Quantity]],\ninput_sampling_period: timedelta,\nresampler_config: ResamplerConfig | None = None,\nalign_to: datetime = UNIX_EPOCH,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"\n        Initialize the MovingWindow.\n        This method creates the underlying ring buffer and starts a\n        new task that updates the ring buffer with new incoming samples.\n        The task stops running only if the channel receiver is closed.\n        Args:\n            size: The time span of the moving window over which samples will be stored.\n            resampled_data_recv: A receiver that delivers samples with a\n                given sampling period.\n            input_sampling_period: The time interval between consecutive input samples.\n            resampler_config: The resampler configuration in case resampling is required.\n            align_to: A timestamp that defines a point in time to which\n                the window is aligned to modulo window size. For further\n                information, consult the class level documentation.\n            name: The name of this moving window. If `None`, `str(id(self))` will be\n                used. This is used mostly for debugging purposes.\n        \"\"\"\nassert (\ninput_sampling_period.total_seconds() &gt; 0\n), \"The input sampling period should be greater than zero.\"\nassert (\ninput_sampling_period &lt;= size\n), \"The input sampling period should be equal to or lower than the window size.\"\nsuper().__init__(name=name)\nself._sampling_period = input_sampling_period\nself._resampler: Resampler | None = None\nself._resampler_sender: Sender[Sample[Quantity]] | None = None\nif resampler_config:\nassert (\nresampler_config.resampling_period &lt;= size\n), \"The resampling period should be equal to or lower than the window size.\"\nself._resampler = Resampler(resampler_config)\nself._sampling_period = resampler_config.resampling_period\n# Sampling period might not fit perfectly into the window size.\nnum_samples = math.ceil(\nsize.total_seconds() / self._sampling_period.total_seconds()\n)\nself._resampled_data_recv = resampled_data_recv\nself._buffer = OrderedRingBuffer(\nnp.empty(shape=num_samples, dtype=float),\nsampling_period=self._sampling_period,\nalign_to=align_to,\n)\ndef start(self) -&gt; None:\n\"\"\"Start the MovingWindow.\n        This method starts the MovingWindow tasks.\n        \"\"\"\nif self._resampler:\nself._configure_resampler()\nself._tasks.add(asyncio.create_task(self._run_impl(), name=\"update-window\"))\n@property\ndef sampling_period(self) -&gt; timedelta:\n\"\"\"\n        Return the sampling period of the MovingWindow.\n        Returns:\n            The sampling period of the MovingWindow.\n        \"\"\"\nreturn self._sampling_period\n@property\ndef oldest_timestamp(self) -&gt; datetime | None:\n\"\"\"\n        Return the oldest timestamp of the MovingWindow.\n        Returns:\n            The oldest timestamp of the MovingWindow or None if the buffer is empty.\n        \"\"\"\nreturn self._buffer.oldest_timestamp\n@property\ndef newest_timestamp(self) -&gt; datetime | None:\n\"\"\"\n        Return the newest timestamp of the MovingWindow.\n        Returns:\n            The newest timestamp of the MovingWindow or None if the buffer is empty.\n        \"\"\"\nreturn self._buffer.newest_timestamp\n@property\ndef capacity(self) -&gt; int:\n\"\"\"\n        Return the capacity of the MovingWindow.\n        Capacity is the maximum number of samples that can be stored in the\n        MovingWindow.\n        Returns:\n            The capacity of the MovingWindow.\n        \"\"\"\nreturn self._buffer.maxlen\n# pylint before 3.0 only accepts names with 3 or more chars\ndef at(self, key: int | datetime) -&gt; float:  # pylint: disable=invalid-name\n\"\"\"\n        Return the sample at the given index or timestamp.\n        In contrast to the [`window`][frequenz.sdk.timeseries.MovingWindow.window] method,\n        which expects a slice as argument, this method expects a single index as argument\n        and returns a single value.\n        Args:\n            key: The index or timestamp of the sample to return.\n        Returns:\n            The sample at the given index or timestamp.\n        Raises:\n            IndexError: If the buffer is empty or the index is out of bounds.\n        \"\"\"\nif self._buffer.count_valid() == 0:\nraise IndexError(\"The buffer is empty.\")\nif isinstance(key, datetime):\nassert self._buffer.oldest_timestamp is not None\nassert self._buffer.newest_timestamp is not None\nif (\nkey &lt; self._buffer.oldest_timestamp\nor key &gt; self._buffer.newest_timestamp\n):\nraise IndexError(\nf\"Timestamp {key} is out of range [{self._buffer.oldest_timestamp}, \"\nf\"{self._buffer.newest_timestamp}]\"\n)\nreturn self._buffer[self._buffer.to_internal_index(key)]\nif isinstance(key, int):\n_logger.debug(\"Returning value at index %s \", key)\ntimestamp = self._buffer.get_timestamp(key)\nassert timestamp is not None\nreturn self._buffer[self._buffer.to_internal_index(timestamp)]\nraise TypeError(\"Key has to be either a timestamp or an integer.\")\ndef window(\nself,\nstart: datetime | int | None,\nend: datetime | int | None,\n*,\nforce_copy: bool = True,\nfill_value: float | None = np.nan,\n) -&gt; ArrayLike:\n\"\"\"\n        Return an array containing the samples in the given time interval.\n        In contrast to the [`at`][frequenz.sdk.timeseries.MovingWindow.at] method,\n        which expects a single index as argument, this method expects a slice as argument\n        and returns an array.\n        Args:\n            start: The start timestamp of the time interval. If `None`, the\n                start of the window is used.\n            end: The end timestamp of the time interval. If `None`, the end of\n                the window is used.\n            force_copy: If `True`, the returned array is a copy of the underlying\n                data. Otherwise, if possible, a view of the underlying data is\n                returned.\n            fill_value: If not None, will use this value to fill missing values.\n                If missing values should be set, force_copy must be True.\n                Defaults to NaN to avoid returning outdated data unexpectedly.\n        Returns:\n            An array containing the samples in the given time interval.\n        \"\"\"\nreturn self._buffer.window(\nstart, end, force_copy=force_copy, fill_value=fill_value\n)\nasync def _run_impl(self) -&gt; None:\n\"\"\"Awaits samples from the receiver and updates the underlying ring buffer.\n        Raises:\n            asyncio.CancelledError: if the MovingWindow task is cancelled.\n        \"\"\"\ntry:\nasync for sample in self._resampled_data_recv:\n_logger.debug(\"Received new sample: %s\", sample)\nif self._resampler and self._resampler_sender:\nawait self._resampler_sender.send(sample)\nelse:\nself._buffer.update(sample)\nexcept asyncio.CancelledError:\n_logger.info(\"MovingWindow task has been cancelled.\")\nraise\n_logger.error(\"Channel has been closed\")\ndef _configure_resampler(self) -&gt; None:\n\"\"\"Configure the components needed to run the resampler.\"\"\"\nassert self._resampler is not None\nasync def sink_buffer(sample: Sample[Quantity]) -&gt; None:\nif sample.value is not None:\nself._buffer.update(sample)\nresampler_channel = Broadcast[Sample[Quantity]](\"average\")\nself._resampler_sender = resampler_channel.new_sender()\nself._resampler.add_timeseries(\n\"avg\", resampler_channel.new_receiver(), sink_buffer\n)\nself._tasks.add(\nasyncio.create_task(self._resampler.resample(), name=\"resample\")\n)\ndef count_valid(self) -&gt; int:\n\"\"\"\n        Count the number of valid samples in this `MovingWindow`.\n        Returns:\n            The number of valid samples in this `MovingWindow`.\n        \"\"\"\nreturn self._buffer.count_valid()\ndef count_covered(self) -&gt; int:\n\"\"\"Count the number of samples that are covered by the oldest and newest valid samples.\n        Returns:\n            The count of samples between the oldest and newest (inclusive) valid samples\n                or 0 if there are is no time range covered.\n        \"\"\"\nreturn self._buffer.count_covered()\n@overload\ndef __getitem__(self, key: SupportsIndex) -&gt; float:\n\"\"\"See the main __getitem__ method.\n        [//]: # (# noqa: DAR101 key)\n        \"\"\"\n@overload\ndef __getitem__(self, key: datetime) -&gt; float:\n\"\"\"See the main __getitem__ method.\n        [//]: # (# noqa: DAR101 key)\n        \"\"\"\n@overload\ndef __getitem__(self, key: slice) -&gt; ArrayLike:\n\"\"\"See the main __getitem__ method.\n        [//]: # (# noqa: DAR101 key)\n        \"\"\"\ndef __getitem__(self, key: SupportsIndex | datetime | slice) -&gt; float | ArrayLike:\n\"\"\"\n        Return a sub window of the `MovingWindow`.\n        The `MovingWindow` is accessed either by timestamp or by index\n        or by a slice of timestamps or integers.\n        * If the key is an integer, the float value of that key\n          at the given position is returned.\n        * If the key is a timestamp, the float value of that key\n          that corresponds to the timestamp is returned.\n        * If the key is a slice of timestamps or integers, an ndarray is returned,\n          where the bounds correspond to the slice bounds.\n          Note that a half open interval, which is open at the end, is returned.\n        Args:\n            key: Either an integer or a timestamp or a slice of timestamps or integers.\n        Raises:\n            IndexError: when requesting an out of range timestamp or index\n            TypeError: when the key is not a datetime or slice object.\n        Returns:\n            A float if the key is a number or a timestamp.\n            an numpy array if the key is a slice.\n        \"\"\"\nif isinstance(key, slice):\nif not (key.step is None or key.step == 1):\nraise ValueError(\"Slicing with a step other than 1 is not supported.\")\nreturn self.window(key.start, key.stop)\nif isinstance(key, datetime):\nreturn self.at(key)\nif isinstance(key, SupportsIndex):\nreturn self.at(key.__index__())\nraise TypeError(\n\"Key has to be either a timestamp or an integer \"\n\"or a slice of timestamps or integers\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.capacity","title":"capacity  <code>property</code>","text":"<pre><code>capacity: int\n</code></pre> <p>Return the capacity of the MovingWindow.</p> <p>Capacity is the maximum number of samples that can be stored in the MovingWindow.</p> RETURNS DESCRIPTION <code>int</code> <p>The capacity of the MovingWindow.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.newest_timestamp","title":"newest_timestamp  <code>property</code>","text":"<pre><code>newest_timestamp: datetime | None\n</code></pre> <p>Return the newest timestamp of the MovingWindow.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The newest timestamp of the MovingWindow or None if the buffer is empty.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.oldest_timestamp","title":"oldest_timestamp  <code>property</code>","text":"<pre><code>oldest_timestamp: datetime | None\n</code></pre> <p>Return the oldest timestamp of the MovingWindow.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The oldest timestamp of the MovingWindow or None if the buffer is empty.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.sampling_period","title":"sampling_period  <code>property</code>","text":"<pre><code>sampling_period: timedelta\n</code></pre> <p>Return the sampling period of the MovingWindow.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The sampling period of the MovingWindow.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: collections.abc.Set[asyncio.Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n\"\"\"Enter an async context.\n    Start this background service.\n    Returns:\n        This background service.\n    \"\"\"\nself.start()\nreturn self\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\nself,\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Exit an async context.\n    Stop this background service.\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\nawait self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; collections.abc.Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n\"\"\"Await this background service.\n    An awaited background service will wait for all its tasks to finish.\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\nreturn self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Destroy this instance.\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\nself.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\nkey: SupportsIndex | datetime | slice,\n) -&gt; float | ArrayLike\n</code></pre> <p>Return a sub window of the <code>MovingWindow</code>.</p> <p>The <code>MovingWindow</code> is accessed either by timestamp or by index or by a slice of timestamps or integers.</p> <ul> <li>If the key is an integer, the float value of that key   at the given position is returned.</li> <li>If the key is a timestamp, the float value of that key   that corresponds to the timestamp is returned.</li> <li>If the key is a slice of timestamps or integers, an ndarray is returned,   where the bounds correspond to the slice bounds.   Note that a half open interval, which is open at the end, is returned.</li> </ul> PARAMETER  DESCRIPTION <code>key</code> <p>Either an integer or a timestamp or a slice of timestamps or integers.</p> <p> TYPE: <code>SupportsIndex | datetime | slice</code> </p> RAISES DESCRIPTION <code>IndexError</code> <p>when requesting an out of range timestamp or index</p> <code>TypeError</code> <p>when the key is not a datetime or slice object.</p> RETURNS DESCRIPTION <code>float | ArrayLike</code> <p>A float if the key is a number or a timestamp.</p> <code>float | ArrayLike</code> <p>an numpy array if the key is a slice.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __getitem__(self, key: SupportsIndex | datetime | slice) -&gt; float | ArrayLike:\n\"\"\"\n    Return a sub window of the `MovingWindow`.\n    The `MovingWindow` is accessed either by timestamp or by index\n    or by a slice of timestamps or integers.\n    * If the key is an integer, the float value of that key\n      at the given position is returned.\n    * If the key is a timestamp, the float value of that key\n      that corresponds to the timestamp is returned.\n    * If the key is a slice of timestamps or integers, an ndarray is returned,\n      where the bounds correspond to the slice bounds.\n      Note that a half open interval, which is open at the end, is returned.\n    Args:\n        key: Either an integer or a timestamp or a slice of timestamps or integers.\n    Raises:\n        IndexError: when requesting an out of range timestamp or index\n        TypeError: when the key is not a datetime or slice object.\n    Returns:\n        A float if the key is a number or a timestamp.\n        an numpy array if the key is a slice.\n    \"\"\"\nif isinstance(key, slice):\nif not (key.step is None or key.step == 1):\nraise ValueError(\"Slicing with a step other than 1 is not supported.\")\nreturn self.window(key.start, key.stop)\nif isinstance(key, datetime):\nreturn self.at(key)\nif isinstance(key, SupportsIndex):\nreturn self.at(key.__index__())\nraise TypeError(\n\"Key has to be either a timestamp or an integer \"\n\"or a slice of timestamps or integers\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__init__","title":"__init__","text":"<pre><code>__init__(\nsize: timedelta,\nresampled_data_recv: Receiver[Sample[Quantity]],\ninput_sampling_period: timedelta,\nresampler_config: ResamplerConfig | None = None,\nalign_to: datetime = UNIX_EPOCH,\n*,\nname: str | None = None\n) -&gt; None\n</code></pre> <p>Initialize the MovingWindow.</p> <p>This method creates the underlying ring buffer and starts a new task that updates the ring buffer with new incoming samples. The task stops running only if the channel receiver is closed.</p> PARAMETER  DESCRIPTION <code>size</code> <p>The time span of the moving window over which samples will be stored.</p> <p> TYPE: <code>timedelta</code> </p> <code>resampled_data_recv</code> <p>A receiver that delivers samples with a given sampling period.</p> <p> TYPE: <code>Receiver[Sample[Quantity]]</code> </p> <code>input_sampling_period</code> <p>The time interval between consecutive input samples.</p> <p> TYPE: <code>timedelta</code> </p> <code>resampler_config</code> <p>The resampler configuration in case resampling is required.</p> <p> TYPE: <code>ResamplerConfig | None</code> DEFAULT: <code>None</code> </p> <code>align_to</code> <p>A timestamp that defines a point in time to which the window is aligned to modulo window size. For further information, consult the class level documentation.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>UNIX_EPOCH</code> </p> <code>name</code> <p>The name of this moving window. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\nself,\nsize: timedelta,\nresampled_data_recv: Receiver[Sample[Quantity]],\ninput_sampling_period: timedelta,\nresampler_config: ResamplerConfig | None = None,\nalign_to: datetime = UNIX_EPOCH,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"\n    Initialize the MovingWindow.\n    This method creates the underlying ring buffer and starts a\n    new task that updates the ring buffer with new incoming samples.\n    The task stops running only if the channel receiver is closed.\n    Args:\n        size: The time span of the moving window over which samples will be stored.\n        resampled_data_recv: A receiver that delivers samples with a\n            given sampling period.\n        input_sampling_period: The time interval between consecutive input samples.\n        resampler_config: The resampler configuration in case resampling is required.\n        align_to: A timestamp that defines a point in time to which\n            the window is aligned to modulo window size. For further\n            information, consult the class level documentation.\n        name: The name of this moving window. If `None`, `str(id(self))` will be\n            used. This is used mostly for debugging purposes.\n    \"\"\"\nassert (\ninput_sampling_period.total_seconds() &gt; 0\n), \"The input sampling period should be greater than zero.\"\nassert (\ninput_sampling_period &lt;= size\n), \"The input sampling period should be equal to or lower than the window size.\"\nsuper().__init__(name=name)\nself._sampling_period = input_sampling_period\nself._resampler: Resampler | None = None\nself._resampler_sender: Sender[Sample[Quantity]] | None = None\nif resampler_config:\nassert (\nresampler_config.resampling_period &lt;= size\n), \"The resampling period should be equal to or lower than the window size.\"\nself._resampler = Resampler(resampler_config)\nself._sampling_period = resampler_config.resampling_period\n# Sampling period might not fit perfectly into the window size.\nnum_samples = math.ceil(\nsize.total_seconds() / self._sampling_period.total_seconds()\n)\nself._resampled_data_recv = resampled_data_recv\nself._buffer = OrderedRingBuffer(\nnp.empty(shape=num_samples, dtype=float),\nsampling_period=self._sampling_period,\nalign_to=align_to,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.at","title":"at","text":"<pre><code>at(key: int | datetime) -&gt; float\n</code></pre> <p>Return the sample at the given index or timestamp.</p> <p>In contrast to the <code>window</code> method, which expects a slice as argument, this method expects a single index as argument and returns a single value.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The index or timestamp of the sample to return.</p> <p> TYPE: <code>int | datetime</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The sample at the given index or timestamp.</p> RAISES DESCRIPTION <code>IndexError</code> <p>If the buffer is empty or the index is out of bounds.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def at(self, key: int | datetime) -&gt; float:  # pylint: disable=invalid-name\n\"\"\"\n    Return the sample at the given index or timestamp.\n    In contrast to the [`window`][frequenz.sdk.timeseries.MovingWindow.window] method,\n    which expects a slice as argument, this method expects a single index as argument\n    and returns a single value.\n    Args:\n        key: The index or timestamp of the sample to return.\n    Returns:\n        The sample at the given index or timestamp.\n    Raises:\n        IndexError: If the buffer is empty or the index is out of bounds.\n    \"\"\"\nif self._buffer.count_valid() == 0:\nraise IndexError(\"The buffer is empty.\")\nif isinstance(key, datetime):\nassert self._buffer.oldest_timestamp is not None\nassert self._buffer.newest_timestamp is not None\nif (\nkey &lt; self._buffer.oldest_timestamp\nor key &gt; self._buffer.newest_timestamp\n):\nraise IndexError(\nf\"Timestamp {key} is out of range [{self._buffer.oldest_timestamp}, \"\nf\"{self._buffer.newest_timestamp}]\"\n)\nreturn self._buffer[self._buffer.to_internal_index(key)]\nif isinstance(key, int):\n_logger.debug(\"Returning value at index %s \", key)\ntimestamp = self._buffer.get_timestamp(key)\nassert timestamp is not None\nreturn self._buffer[self._buffer.to_internal_index(timestamp)]\nraise TypeError(\"Key has to be either a timestamp or an integer.\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n\"\"\"Cancel all running tasks spawned by this background service.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nfor task in self._tasks:\ntask.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.count_covered","title":"count_covered","text":"<pre><code>count_covered() -&gt; int\n</code></pre> <p>Count the number of samples that are covered by the oldest and newest valid samples.</p> RETURNS DESCRIPTION <code>int</code> <p>The count of samples between the oldest and newest (inclusive) valid samples or 0 if there are is no time range covered.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def count_covered(self) -&gt; int:\n\"\"\"Count the number of samples that are covered by the oldest and newest valid samples.\n    Returns:\n        The count of samples between the oldest and newest (inclusive) valid samples\n            or 0 if there are is no time range covered.\n    \"\"\"\nreturn self._buffer.count_covered()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.count_valid","title":"count_valid","text":"<pre><code>count_valid() -&gt; int\n</code></pre> <p>Count the number of valid samples in this <code>MovingWindow</code>.</p> RETURNS DESCRIPTION <code>int</code> <p>The number of valid samples in this <code>MovingWindow</code>.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def count_valid(self) -&gt; int:\n\"\"\"\n    Count the number of valid samples in this `MovingWindow`.\n    Returns:\n        The number of valid samples in this `MovingWindow`.\n    \"\"\"\nreturn self._buffer.count_valid()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the MovingWindow.</p> <p>This method starts the MovingWindow tasks.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start the MovingWindow.\n    This method starts the MovingWindow tasks.\n    \"\"\"\nif self._resampler:\nself._configure_resampler()\nself._tasks.add(asyncio.create_task(self._run_impl(), name=\"update-window\"))\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this background service.\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\nif not self._tasks:\nreturn\nself.cancel(msg)\ntry:\nawait self.wait()\nexcept BaseExceptionGroup as exc_group:\n# We want to ignore CancelledError here as we explicitly cancelled all the\n# tasks.\n_, rest = exc_group.split(asyncio.CancelledError)\nif rest is not None:\n# We are filtering out from an exception group, we really don't want to\n# add the exceptions we just filtered by adding a from clause here.\nraise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n\"\"\"Wait this background service to finish.\n    Wait until all background service tasks are finished.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n# We need to account for tasks that were created between when we started\n# awaiting and we finished awaiting.\nwhile self._tasks:\ndone, pending = await asyncio.wait(self._tasks)\nassert not pending\n# We remove the done tasks, but there might be new ones created after we\n# started waiting.\nself._tasks = self._tasks - done\nexceptions: list[BaseException] = []\nfor task in done:\ntry:\n# This will raise a CancelledError if the task was cancelled or any\n# other exception if the task raised one.\n_ = task.result()\nexcept BaseException as error:  # pylint: disable=broad-except\nexceptions.append(error)\nif exceptions:\nraise BaseExceptionGroup(\nf\"Error while stopping background service {self}\", exceptions\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.window","title":"window","text":"<pre><code>window(\nstart: datetime | int | None,\nend: datetime | int | None,\n*,\nforce_copy: bool = True,\nfill_value: float | None = np.nan\n) -&gt; ArrayLike\n</code></pre> <p>Return an array containing the samples in the given time interval.</p> <p>In contrast to the <code>at</code> method, which expects a single index as argument, this method expects a slice as argument and returns an array.</p> PARAMETER  DESCRIPTION <code>start</code> <p>The start timestamp of the time interval. If <code>None</code>, the start of the window is used.</p> <p> TYPE: <code>datetime | int | None</code> </p> <code>end</code> <p>The end timestamp of the time interval. If <code>None</code>, the end of the window is used.</p> <p> TYPE: <code>datetime | int | None</code> </p> <code>force_copy</code> <p>If <code>True</code>, the returned array is a copy of the underlying data. Otherwise, if possible, a view of the underlying data is returned.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>fill_value</code> <p>If not None, will use this value to fill missing values. If missing values should be set, force_copy must be True. Defaults to NaN to avoid returning outdated data unexpectedly.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>nan</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>An array containing the samples in the given time interval.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def window(\nself,\nstart: datetime | int | None,\nend: datetime | int | None,\n*,\nforce_copy: bool = True,\nfill_value: float | None = np.nan,\n) -&gt; ArrayLike:\n\"\"\"\n    Return an array containing the samples in the given time interval.\n    In contrast to the [`at`][frequenz.sdk.timeseries.MovingWindow.at] method,\n    which expects a single index as argument, this method expects a slice as argument\n    and returns an array.\n    Args:\n        start: The start timestamp of the time interval. If `None`, the\n            start of the window is used.\n        end: The end timestamp of the time interval. If `None`, the end of\n            the window is used.\n        force_copy: If `True`, the returned array is a copy of the underlying\n            data. Otherwise, if possible, a view of the underlying data is\n            returned.\n        fill_value: If not None, will use this value to fill missing values.\n            If missing values should be set, force_copy must be True.\n            Defaults to NaN to avoid returning outdated data unexpectedly.\n    Returns:\n        An array containing the samples in the given time interval.\n    \"\"\"\nreturn self._buffer.window(\nstart, end, force_copy=force_copy, fill_value=fill_value\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage","title":"frequenz.sdk.timeseries.Percentage","text":"<p>             Bases: <code>Quantity</code></p> <p>A percentage quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Percentage(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={0: \"%\"},\n):\n\"\"\"A percentage quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_percent(cls, percent: float) -&gt; Self:\n\"\"\"Initialize a new percentage quantity from a percent value.\n        Args:\n            percent: The percent value, normally in the 0.0-100.0 range.\n        Returns:\n            A new percentage quantity.\n        \"\"\"\npercentage = cls.__new__(cls)\npercentage._base_value = percent\nreturn percentage\n@classmethod\ndef from_fraction(cls, fraction: float) -&gt; Self:\n\"\"\"Initialize a new percentage quantity from a fraction.\n        Args:\n            fraction: The fraction, normally in the 0.0-1.0 range.\n        Returns:\n            A new percentage quantity.\n        \"\"\"\npercentage = cls.__new__(cls)\npercentage._base_value = fraction * 100\nreturn percentage\ndef as_percent(self) -&gt; float:\n\"\"\"Return this quantity as a percentage.\n        Returns:\n            This quantity as a percentage.\n        \"\"\"\nreturn self._base_value\ndef as_fraction(self) -&gt; float:\n\"\"\"Return this quantity as a fraction.\n        Returns:\n            This quantity as a fraction.\n        \"\"\"\nreturn self._base_value / 100\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n\"\"\"Return the absolute value of this quantity.\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\nabsolute = type(self).__new__(type(self))\nabsolute._base_value = abs(self._base_value)\nreturn absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n\"\"\"Return the sum of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nsumme = type(self).__new__(type(self))\nsumme._base_value = self._base_value + other._base_value\nreturn summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Return whether this quantity is equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\n# The above check ensures that both quantities are the exact same type, because\n# `isinstance` returns true for subclasses and superclasses.  But the above check\n# doesn't help mypy identify the type of other,  so the below line is necessary.\nassert isinstance(other, self.__class__)\nreturn self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n\"\"\"Return a formatted string representation of this quantity.\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n    Args:\n        __format_spec: The format specifier.\n    Returns:\n        A string representation of this quantity.\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\nkeep_trailing_zeros = False\nif __format_spec != \"\":\nfspec_parts = __format_spec.split(\".\")\nif (\nlen(fspec_parts) != 2\nor fspec_parts[0] not in (\"\", \"0\")\nor not fspec_parts[1].isdigit()\n):\nraise ValueError(\n\"Invalid format specifier. Must be empty or `[0].{precision}`\"\n)\nif fspec_parts[0] == \"0\":\nkeep_trailing_zeros = True\nprecision = int(fspec_parts[1])\nelse:\nprecision = 3\nif not self._exponent_unit_map:\nreturn f\"{self._base_value:.{precision}f}\"\nif math.isinf(self._base_value) or math.isnan(self._base_value):\nreturn f\"{self._base_value} {self._exponent_unit_map[0]}\"\nabs_value = abs(self._base_value)\nexponent = math.floor(math.log10(abs_value)) if abs_value else 0\nunit_place = exponent - exponent % 3\nif unit_place &lt; min(self._exponent_unit_map):\nunit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\nunit_place = min(self._exponent_unit_map)\nelif unit_place &gt; max(self._exponent_unit_map):\nunit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\nunit_place = max(self._exponent_unit_map)\nelse:\nunit = self._exponent_unit_map[unit_place]\nvalue_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\nstripped = value_str.rstrip(\"0\").rstrip(\".\")\nif not keep_trailing_zeros:\nvalue_str = stripped\nunit_str = unit if stripped != \"0\" else self._exponent_unit_map[0]\nreturn f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n\"\"\"Initialize a new quantity.\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\nself._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\nexponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n\"\"\"Initialize a new subclass of Quantity.\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\nif 0 not in exponent_unit_map:\nraise ValueError(\"Expected a base unit for the type (for exponent 0)\")\ncls._exponent_unit_map = exponent_unit_map\nsuper().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__mul__","title":"__mul__","text":"<pre><code>__mul__(percent: Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a percentage.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percentage by which to scale this quantity.</p> <p> TYPE: <code>Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, percent: Percentage) -&gt; Self:\n\"\"\"Scale this quantity by a percentage.\n    Args:\n        percent: The percentage by which to scale this quantity.\n    Returns:\n        The scaled quantity.\n    \"\"\"\nif not isinstance(percent, Percentage):\nreturn NotImplemented\nproduct = type(self).__new__(type(self))\nproduct._base_value = self._base_value * percent.as_fraction()\nreturn product\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n\"\"\"Return the negation of this quantity.\n    Returns:\n        The negation of this quantity.\n    \"\"\"\nnegation = type(self).__new__(type(self))\nnegation._base_value = -self._base_value\nreturn negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a representation of this quantity.\n    Returns:\n        A representation of this quantity.\n    \"\"\"\nreturn f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this quantity.\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\nreturn self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n\"\"\"Return the difference of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\ndifference = type(self).__new__(type(self))\ndifference._base_value = self._base_value - other._base_value\nreturn difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.as_fraction","title":"as_fraction","text":"<pre><code>as_fraction() -&gt; float\n</code></pre> <p>Return this quantity as a fraction.</p> RETURNS DESCRIPTION <code>float</code> <p>This quantity as a fraction.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_fraction(self) -&gt; float:\n\"\"\"Return this quantity as a fraction.\n    Returns:\n        This quantity as a fraction.\n    \"\"\"\nreturn self._base_value / 100\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.as_percent","title":"as_percent","text":"<pre><code>as_percent() -&gt; float\n</code></pre> <p>Return this quantity as a percentage.</p> RETURNS DESCRIPTION <code>float</code> <p>This quantity as a percentage.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_percent(self) -&gt; float:\n\"\"\"Return this quantity as a percentage.\n    Returns:\n        This quantity as a percentage.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.from_fraction","title":"from_fraction  <code>classmethod</code>","text":"<pre><code>from_fraction(fraction: float) -&gt; Self\n</code></pre> <p>Initialize a new percentage quantity from a fraction.</p> PARAMETER  DESCRIPTION <code>fraction</code> <p>The fraction, normally in the 0.0-1.0 range.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new percentage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_fraction(cls, fraction: float) -&gt; Self:\n\"\"\"Initialize a new percentage quantity from a fraction.\n    Args:\n        fraction: The fraction, normally in the 0.0-1.0 range.\n    Returns:\n        A new percentage quantity.\n    \"\"\"\npercentage = cls.__new__(cls)\npercentage._base_value = fraction * 100\nreturn percentage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.from_percent","title":"from_percent  <code>classmethod</code>","text":"<pre><code>from_percent(percent: float) -&gt; Self\n</code></pre> <p>Initialize a new percentage quantity from a percent value.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percent value, normally in the 0.0-100.0 range.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new percentage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_percent(cls, percent: float) -&gt; Self:\n\"\"\"Initialize a new percentage quantity from a percent value.\n    Args:\n        percent: The percent value, normally in the 0.0-100.0 range.\n    Returns:\n        A new percentage quantity.\n    \"\"\"\npercentage = cls.__new__(cls)\npercentage._base_value = percent\nreturn percentage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.isclose","title":"isclose","text":"<pre><code>isclose(\nother: Self,\nrel_tol: float = 1e-09,\nabs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n\"\"\"Return whether this quantity is close to another.\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\nreturn math.isclose(\nself._base_value,\nother._base_value,  # pylint: disable=protected-access\nrel_tol=rel_tol,\nabs_tol=abs_tol,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n\"\"\"Return whether this quantity is infinite.\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\nreturn math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n\"\"\"Return whether this quantity is NaN.\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\nreturn math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n\"\"\"Return a quantity with value 0.\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n_zero = cls._zero_cache.get(cls, None)\nif _zero is None:\n_zero = cls.__new__(cls)\n_zero._base_value = 0\ncls._zero_cache[cls] = _zero\nassert isinstance(_zero, cls)\nreturn _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor","title":"frequenz.sdk.timeseries.PeriodicFeatureExtractor","text":"<p>A feature extractor for historical timeseries data.</p> <p>This class is creating a profile from periodically occurring windows in a buffer of historical data.</p> <p>The profile is created out of all windows that are fully contained in the underlying buffer with the same start and end time modulo a fixed period.</p> <p>Consider for example a timeseries $T$ of historical data and sub-series $S_i$ of $T$ all having the same size $l$ and the same fixed distance $p$ called period, where period of two sub-windows is defined as the distance of two points at the same position within the sub-windows.</p> <p>This class calculates a statistical profile $S$ over all $S_i$, i.e. the value of $S$ at position $i$ is calculated by performing a certain calculation, e.g. an average, over all values of $S_i$ at position $i$.</p> Note <p>The oldest window or the window that is currently overwritten in the <code>MovingWindow</code> is not considered in the profile.</p> Note <p>When constructing a <code>PeriodicFeatureExtractor</code> object the <code>MovingWindow</code> size has to be a integer multiple of the period.</p> Example <pre><code>from frequenz.sdk import microgrid\nfrom datetime import datetime, timedelta, timezone\nasync with MovingWindow(\nsize=timedelta(days=35),\nresampled_data_recv=microgrid.logical_meter().grid_power.new_receiver(),\ninput_sampling_period=timedelta(seconds=1),\n) as moving_window:\nfeature_extractor = PeriodicFeatureExtractor(\nmoving_window=moving_window,\nperiod=timedelta(days=7),\n)\nnow = datetime.now(timezone.utc)\n# create a daily weighted average for the next 24h\navg_24h = feature_extractor.avg(\nnow,\nnow + timedelta(hours=24),\nweights=[0.1, 0.2, 0.3, 0.4]\n)\n# create a daily average for Thursday March 23 2023\nth_avg_24h = feature_extractor.avg(datetime(2023, 3, 23), datetime(2023, 3, 24))\n</code></pre> Source code in <code>frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>class PeriodicFeatureExtractor:\n\"\"\"\n    A feature extractor for historical timeseries data.\n    This class is creating a profile from periodically occurring windows in a\n    buffer of historical data.\n    The profile is created out of all windows that are fully contained in the\n    underlying buffer with the same start and end time modulo a fixed period.\n    Consider for example a timeseries $T$ of historical data and sub-series\n    $S_i$ of $T$ all having the same size $l$ and the same fixed distance $p$\n    called period, where period of two sub-windows is defined as the distance\n    of two points at the same position within the sub-windows.\n    This class calculates a statistical profile $S$ over all $S_i$, i.e. the\n    value of $S$ at position $i$ is calculated by performing a certain\n    calculation, e.g. an average, over all values of $S_i$ at position $i$.\n    Note:\n        The oldest window or the window that is currently overwritten in the\n        `MovingWindow` is not considered in the profile.\n    Note:\n        When constructing a `PeriodicFeatureExtractor` object the\n        `MovingWindow` size has to be a integer multiple of the period.\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n        from datetime import datetime, timedelta, timezone\n        async with MovingWindow(\n            size=timedelta(days=35),\n            resampled_data_recv=microgrid.logical_meter().grid_power.new_receiver(),\n            input_sampling_period=timedelta(seconds=1),\n        ) as moving_window:\n            feature_extractor = PeriodicFeatureExtractor(\n                moving_window=moving_window,\n                period=timedelta(days=7),\n            )\n            now = datetime.now(timezone.utc)\n            # create a daily weighted average for the next 24h\n            avg_24h = feature_extractor.avg(\n                now,\n                now + timedelta(hours=24),\n                weights=[0.1, 0.2, 0.3, 0.4]\n            )\n            # create a daily average for Thursday March 23 2023\n            th_avg_24h = feature_extractor.avg(datetime(2023, 3, 23), datetime(2023, 3, 24))\n        ```\n    \"\"\"\ndef __init__(\nself,\nmoving_window: MovingWindow,\nperiod: timedelta,\n) -&gt; None:\n\"\"\"\n        Initialize a PeriodicFeatureExtractor object.\n        Args:\n            moving_window: The MovingWindow that is used for the average calculation.\n            period: The distance between two succeeding intervals.\n        Raises:\n            ValueError: If the MovingWindow size is not a integer multiple of the period.\n        \"\"\"\nself._moving_window = moving_window\nself._sampling_period = self._moving_window.sampling_period\n\"\"\"The sampling_period as float to use it for indexing of samples.\"\"\"\nself._period = int(period / self._sampling_period)\n\"\"\"Distance between two succeeding intervals in samples.\"\"\"\n_logger.debug(\"Initializing PeriodicFeatureExtractor!\")\n_logger.debug(\"MovingWindow size: %i\", self._moving_window.count_valid())\n_logger.debug(\n\"Period between two succeeding intervals (in samples): %i\",\nself._period,\n)\nif not self._moving_window.count_valid() % self._period == 0:\nraise ValueError(\n\"The MovingWindow size is not a integer multiple of the period.\"\n)\nif not is_close_to_zero(self._period - period / self._sampling_period):\nraise ValueError(\n\"The period is not a multiple of the sampling period. \"\n\"This might result in unexpected behaviour.\"\n)\n@property\ndef _buffer(self) -&gt; OrderedRingBuffer[NDArray[np.float64]]:\nreturn self._moving_window._buffer  # pylint: disable=protected-access\ndef _timestamp_to_rel_index(self, timestamp: datetime) -&gt; int:\n\"\"\"\n        Get the index of a timestamp relative to the oldest sample in the MovingWindow.\n        In other word consider an integer axis where the zero is defined as the\n        oldest element in the MovingWindow. This function returns the index of\n        the given timestamp an this axis.\n        This method can return negative values.\n        Args:\n            timestamp: A timestamp that we want to shift into the window.\n        Returns:\n            The index of the timestamp shifted into the MovingWindow.\n        \"\"\"\n# align timestamp to the sampling period\ntimestamp = self._buffer.normalize_timestamp(timestamp)\n# distance between the input ts and the ts of oldest known samples (in samples)\ndist_to_oldest = int(\n(timestamp - self._buffer.time_bound_oldest) / self._sampling_period\n)\n_logger.debug(\"Shifting ts: %s\", timestamp)\n_logger.debug(\"Oldest timestamp in buffer: %s\", self._buffer.time_bound_oldest)\n_logger.debug(\"Distance to the oldest sample: %i\", dist_to_oldest)\nreturn dist_to_oldest\ndef _reshape_np_array(\nself, array: NDArray[np.float_], window_size: int\n) -&gt; NDArray[np.float_]:\n\"\"\"\n        Reshape a numpy array to a 2D array where each row represents a window.\n        There are three cases to consider\n        1. The array size is a multiple of window_size + period,\n           i.e. num_windows is integer and we can simply reshape.\n        2. The array size is NOT a multiple of window_size + period and\n           it has length n * period + m, where m &lt; window_size.\n        3. The array size is NOT a multiple of window_size + period and\n           it has length n * period + m, where m &gt;= window_size.\n        Note that in the current implementation of this class we have the restriction\n        that period is a multiple integer of the size of the MovingWindow and hence\n        only case 1 can occur.\n        Args:\n            array: The numpy array to reshape.\n            window_size: The size of the window in samples.\n        Returns:\n            The reshaped 2D array.\n        Raises:\n            ValueError: If the array is smaller or equal to the given period.\n        \"\"\"\n# Not using the num_windows function here because we want to\n# differentiate between the three cases.\nif len(array) &lt; self._period:\nraise ValueError(\nf\"The array (length:{len(array)}) is too small to be reshaped.\"\n)\nnum_windows = len(array) // self._period\n# Case 1:\nif len(array) - num_windows * self._period == 0:\nresized_array = array\n# Case 2\nelif len(array) - num_windows * self._period &lt; window_size:\nresized_array = array[: num_windows * self._period]\n# Case 3\nelse:\nnum_windows += 1\nresized_array = np.resize(array, num_windows * self._period)\nreturn resized_array.reshape(num_windows, self._period)\ndef _get_relative_positions(\nself, start: datetime, window_size: int\n) -&gt; RelativePositions:\n\"\"\"\n        Return relative positions of the MovingWindow.\n        This method calculates the shifted relative positions of the start\n        timestamp, the end timestamps as well as the next position that is\n        overwritten in the ringbuffer.\n        Shifted in that context means that the positions are moved as close\n        assume possible to the oldest sample in the MovingWindow.\n        Args:\n            start: The start timestamp of the window.\n            window_size: The size of the window in samples.\n        Returns:\n            The relative positions of the start, end and next samples.\n        \"\"\"\n# The number of usable windows can change, when the current position of\n# the ringbuffer is inside one of the windows inside the MovingWindow.\n# Since this is possible, we assume that one window is always not used\n# for the average calculation.\n#\n# We are ignoring either the window that is currently overwritten if\n# the current position is inside that window or the window that would\n# be overwritten next.\n#\n# Move the window to its first appearance in the MovingWindow relative\n# to the oldest sample stored in the MovingWindow.\n#\n# In other words the oldest stored sample is considered to have index 0.\n#\n# Note that the returned value is a index not a timestamp\nrel_start_sample = self._timestamp_to_rel_index(start) % self._period\nrel_end_sample = rel_start_sample + window_size\n# check if the newest time bound, i.e. the sample that is currently written,\n# is inside the interval\nrb_current_position = self._buffer.time_bound_newest\nrel_next_position = (\nself._timestamp_to_rel_index(rb_current_position) + 1\n) % self._period\n# fix the rel_next_position if modulo period the next position\n# is smaller then the start sample position\nif rel_next_position &lt; rel_start_sample:\nrel_next_position += self._period\nrel_next_position += self._period * (window_size // self._period)\n_logger.debug(\"current position of the ringbuffer: %s\", rb_current_position)\n_logger.debug(\"relative start_sample: %s\", rel_start_sample)\n_logger.debug(\"relative end_sample: %s\", rel_end_sample)\n_logger.debug(\"relative next_position: %s\", rel_next_position)\nreturn RelativePositions(rel_start_sample, rel_end_sample, rel_next_position)\ndef _get_buffer_bounds(\nself, start: datetime, end: datetime\n) -&gt; tuple[int, int, int]:\n\"\"\"\n        Get the bounds of the ringbuffer used for further operations.\n        This method uses the given start and end timestamps to calculate the\n        part of the ringbuffer that can be used for further operations, like\n        average or min/max.\n        Here we cut out the oldest window or the window that is currently\n        overwritten in the MovingWindow such that it is not considered in any\n        further operation.\n        Args:\n            start: The start timestamp of the window.\n            end: The end timestamp of the window.\n        Returns:\n            The bounds of the to be used buffer and the window size.\n        Raises:\n            ValueError: If the start timestamp is after the end timestamp.\n        \"\"\"\nwindow_size = self._timestamp_to_rel_index(end) - self._timestamp_to_rel_index(\nstart\n)\nif window_size &lt;= 0:\nraise ValueError(\"Start timestamp must be before end timestamp\")\nif window_size &gt; self._period:\nraise ValueError(\n\"The window size must be smaller or equal than the period.\"\n)\nrel_pos = self._get_relative_positions(start, window_size)\nif window_size &gt; self._moving_window.count_valid():\nraise ValueError(\n\"The window size must be smaller than the size of the `MovingWindow`\"\n)\n# shifted distance between the next incoming sample and the start of the window\ndist_to_start = rel_pos.next - rel_pos.start\n# get the start and end position inside the ringbuffer\nend_pos = (\nself._timestamp_to_rel_index(self._buffer.time_bound_newest) + 1\n) - dist_to_start\n# Note that these check is working since we are using the positions\n# relative to the oldest sample stored in the MovingWindow.\nif rel_pos.start &lt;= rel_pos.next &lt; rel_pos.end:\n# end position is start_position of the window that is currently written\n# that's how end_pos is currently set\n_logger.debug(\"Next sample will be inside the window time interval!\")\nelse:\n_logger.debug(\"Next sample will be outside the window time interval!\")\n# end position is start_position of the window that\n# is overwritten next, hence we adding period.\nend_pos += self._period\n# add the offset to the oldest sample in the ringbuffer and wrap around\n# to get the start and end positions in the ringbuffer\nrb_offset = self._buffer.to_internal_index(self._buffer.time_bound_oldest)\nstart_pos = self._buffer.wrap(end_pos + self._period + rb_offset)\nend_pos = self._buffer.wrap(end_pos + rb_offset)\n_logger.debug(\"start_pos in ringbuffer: %s\", start_pos)\n_logger.debug(\"end_pos in ringbuffer: %s\", end_pos)\nreturn (start_pos, end_pos, window_size)\ndef _get_reshaped_np_array(\nself, start: datetime, end: datetime\n) -&gt; tuple[NDArray[np.float_], int]:\n\"\"\"\n        Create a reshaped numpy array from the MovingWindow.\n        The reshaped array is a two dimensional array, where one dimension is\n        the window_size and the other the number of windows returned by the\n        `_get_buffer_bounds` method.\n        Args:\n            start: The start timestamp of the window.\n            end: The end timestamp of the window.\n        Returns:\n            A tuple containing the reshaped numpy array and the window size.\n        \"\"\"\n(start_pos, end_pos, window_size) = self._get_buffer_bounds(start, end)\nif start_pos &gt;= end_pos:\nwindow_start = self._buffer[start_pos : self._moving_window.count_valid()]\nwindow_end = self._buffer[0:end_pos]\n# make the linter happy\nassert isinstance(window_start, np.ndarray)\nassert isinstance(window_end, np.ndarray)\nwindow_array = np.concatenate((window_start, window_end))\nelse:\nwindow_array = self._buffer[start_pos:end_pos]\nreturn (self._reshape_np_array(window_array, window_size), window_size)\ndef avg(\nself, start: datetime, end: datetime, weights: list[float] | None = None\n) -&gt; NDArray[np.float_]:\n\"\"\"\n        Create the average window out of the window defined by `start` and `end`.\n        This method calculates the average of a window by averaging over all\n        windows fully inside the MovingWindow having the period\n        `self.period`.\n        Args:\n            start: The start of the window to average over.\n            end: The end of the window to average over.\n            weights: The weights to use for the average calculation (oldest first).\n        Returns:\n            The averaged timeseries window.\n        \"\"\"\n(reshaped, window_size) = self._get_reshaped_np_array(start, end)\nreturn np.average(  # type: ignore[no-any-return]\nreshaped[:, :window_size], axis=0, weights=weights\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor.__init__","title":"__init__","text":"<pre><code>__init__(\nmoving_window: MovingWindow, period: timedelta\n) -&gt; None\n</code></pre> <p>Initialize a PeriodicFeatureExtractor object.</p> PARAMETER  DESCRIPTION <code>moving_window</code> <p>The MovingWindow that is used for the average calculation.</p> <p> TYPE: <code>MovingWindow</code> </p> <code>period</code> <p>The distance between two succeeding intervals.</p> <p> TYPE: <code>timedelta</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the MovingWindow size is not a integer multiple of the period.</p> Source code in <code>frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>def __init__(\nself,\nmoving_window: MovingWindow,\nperiod: timedelta,\n) -&gt; None:\n\"\"\"\n    Initialize a PeriodicFeatureExtractor object.\n    Args:\n        moving_window: The MovingWindow that is used for the average calculation.\n        period: The distance between two succeeding intervals.\n    Raises:\n        ValueError: If the MovingWindow size is not a integer multiple of the period.\n    \"\"\"\nself._moving_window = moving_window\nself._sampling_period = self._moving_window.sampling_period\n\"\"\"The sampling_period as float to use it for indexing of samples.\"\"\"\nself._period = int(period / self._sampling_period)\n\"\"\"Distance between two succeeding intervals in samples.\"\"\"\n_logger.debug(\"Initializing PeriodicFeatureExtractor!\")\n_logger.debug(\"MovingWindow size: %i\", self._moving_window.count_valid())\n_logger.debug(\n\"Period between two succeeding intervals (in samples): %i\",\nself._period,\n)\nif not self._moving_window.count_valid() % self._period == 0:\nraise ValueError(\n\"The MovingWindow size is not a integer multiple of the period.\"\n)\nif not is_close_to_zero(self._period - period / self._sampling_period):\nraise ValueError(\n\"The period is not a multiple of the sampling period. \"\n\"This might result in unexpected behaviour.\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor.avg","title":"avg","text":"<pre><code>avg(\nstart: datetime,\nend: datetime,\nweights: list[float] | None = None,\n) -&gt; NDArray[np.float_]\n</code></pre> <p>Create the average window out of the window defined by <code>start</code> and <code>end</code>.</p> <p>This method calculates the average of a window by averaging over all windows fully inside the MovingWindow having the period <code>self.period</code>.</p> PARAMETER  DESCRIPTION <code>start</code> <p>The start of the window to average over.</p> <p> TYPE: <code>datetime</code> </p> <code>end</code> <p>The end of the window to average over.</p> <p> TYPE: <code>datetime</code> </p> <code>weights</code> <p>The weights to use for the average calculation (oldest first).</p> <p> TYPE: <code>list[float] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>NDArray[float_]</code> <p>The averaged timeseries window.</p> Source code in <code>frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>def avg(\nself, start: datetime, end: datetime, weights: list[float] | None = None\n) -&gt; NDArray[np.float_]:\n\"\"\"\n    Create the average window out of the window defined by `start` and `end`.\n    This method calculates the average of a window by averaging over all\n    windows fully inside the MovingWindow having the period\n    `self.period`.\n    Args:\n        start: The start of the window to average over.\n        end: The end of the window to average over.\n        weights: The weights to use for the average calculation (oldest first).\n    Returns:\n        The averaged timeseries window.\n    \"\"\"\n(reshaped, window_size) = self._get_reshaped_np_array(start, end)\nreturn np.average(  # type: ignore[no-any-return]\nreshaped[:, :window_size], axis=0, weights=weights\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power","title":"frequenz.sdk.timeseries.Power","text":"<p>             Bases: <code>Quantity</code></p> <p>A power quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Power(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={\n-3: \"mW\",\n0: \"W\",\n3: \"kW\",\n6: \"MW\",\n},\n):\n\"\"\"A power quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_watts(cls, watts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n        Args:\n            watts: The power in watts.\n        Returns:\n            A new power quantity.\n        \"\"\"\npower = cls.__new__(cls)\npower._base_value = watts\nreturn power\n@classmethod\ndef from_milliwatts(cls, milliwatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n        Args:\n            milliwatts: The power in milliwatts.\n        Returns:\n            A new power quantity.\n        \"\"\"\npower = cls.__new__(cls)\npower._base_value = milliwatts * 10**-3\nreturn power\n@classmethod\ndef from_kilowatts(cls, kilowatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n        Args:\n            kilowatts: The power in kilowatts.\n        Returns:\n            A new power quantity.\n        \"\"\"\npower = cls.__new__(cls)\npower._base_value = kilowatts * 10**3\nreturn power\n@classmethod\ndef from_megawatts(cls, megawatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n        Args:\n            megawatts: The power in megawatts.\n        Returns:\n            A new power quantity.\n        \"\"\"\npower = cls.__new__(cls)\npower._base_value = megawatts * 10**6\nreturn power\ndef as_watts(self) -&gt; float:\n\"\"\"Return the power in watts.\n        Returns:\n            The power in watts.\n        \"\"\"\nreturn self._base_value\ndef as_kilowatts(self) -&gt; float:\n\"\"\"Return the power in kilowatts.\n        Returns:\n            The power in kilowatts.\n        \"\"\"\nreturn self._base_value / 1e3\ndef as_megawatts(self) -&gt; float:\n\"\"\"Return the power in megawatts.\n        Returns:\n            The power in megawatts.\n        \"\"\"\nreturn self._base_value / 1e6\n@overload  # type: ignore\ndef __mul__(self, other: Percentage) -&gt; Self:\n\"\"\"Scale this power by a percentage.\n        Args:\n            other: The percentage by which to scale this power.\n        Returns:\n            The scaled power.\n        \"\"\"\n@overload\ndef __mul__(self, other: timedelta) -&gt; Energy:\n\"\"\"Return an energy from multiplying this power by the given duration.\n        Args:\n            other: The duration to multiply by.\n        Returns:\n            The calculated energy.\n        \"\"\"\ndef __mul__(self, other: Percentage | timedelta) -&gt; Self | Energy:\n\"\"\"Return a power or energy from multiplying this power by the given value.\n        Args:\n            other: The percentage or duration to multiply by.\n        Returns:\n            A power or energy.\n        \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, timedelta):\nreturn Energy.from_watt_hours(\nself._base_value * other.total_seconds() / 3600.0\n)\nreturn NotImplemented\n@overload\ndef __truediv__(self, other: Current) -&gt; Voltage:\n\"\"\"Return a voltage from dividing this power by the given current.\n        Args:\n            other: The current to divide by.\n        Returns:\n            A voltage from dividing this power by the a current.\n        \"\"\"\n@overload\ndef __truediv__(self, other: Voltage) -&gt; Current:\n\"\"\"Return a current from dividing this power by the given voltage.\n        Args:\n            other: The voltage to divide by.\n        Returns:\n            A current from dividing this power by a voltage.\n        \"\"\"\ndef __truediv__(self, other: Current | Voltage) -&gt; Voltage | Current:\n\"\"\"Return a current or voltage from dividing this power by the given value.\n        Args:\n            other: The current or voltage to divide by.\n        Returns:\n            A current or voltage from dividing this power by the given value.\n        Raises:\n            TypeError: If the given value is not a current or voltage.\n        \"\"\"\nif isinstance(other, Current):\nreturn Voltage.from_volts(self._base_value / other._base_value)\nif isinstance(other, Voltage):\nreturn Current.from_amperes(self._base_value / other._base_value)\nraise TypeError(\nf\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n\"\"\"Return the absolute value of this quantity.\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\nabsolute = type(self).__new__(type(self))\nabsolute._base_value = abs(self._base_value)\nreturn absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n\"\"\"Return the sum of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nsumme = type(self).__new__(type(self))\nsumme._base_value = self._base_value + other._base_value\nreturn summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Return whether this quantity is equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\n# The above check ensures that both quantities are the exact same type, because\n# `isinstance` returns true for subclasses and superclasses.  But the above check\n# doesn't help mypy identify the type of other,  so the below line is necessary.\nassert isinstance(other, self.__class__)\nreturn self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n\"\"\"Return a formatted string representation of this quantity.\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n    Args:\n        __format_spec: The format specifier.\n    Returns:\n        A string representation of this quantity.\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\nkeep_trailing_zeros = False\nif __format_spec != \"\":\nfspec_parts = __format_spec.split(\".\")\nif (\nlen(fspec_parts) != 2\nor fspec_parts[0] not in (\"\", \"0\")\nor not fspec_parts[1].isdigit()\n):\nraise ValueError(\n\"Invalid format specifier. Must be empty or `[0].{precision}`\"\n)\nif fspec_parts[0] == \"0\":\nkeep_trailing_zeros = True\nprecision = int(fspec_parts[1])\nelse:\nprecision = 3\nif not self._exponent_unit_map:\nreturn f\"{self._base_value:.{precision}f}\"\nif math.isinf(self._base_value) or math.isnan(self._base_value):\nreturn f\"{self._base_value} {self._exponent_unit_map[0]}\"\nabs_value = abs(self._base_value)\nexponent = math.floor(math.log10(abs_value)) if abs_value else 0\nunit_place = exponent - exponent % 3\nif unit_place &lt; min(self._exponent_unit_map):\nunit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\nunit_place = min(self._exponent_unit_map)\nelif unit_place &gt; max(self._exponent_unit_map):\nunit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\nunit_place = max(self._exponent_unit_map)\nelse:\nunit = self._exponent_unit_map[unit_place]\nvalue_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\nstripped = value_str.rstrip(\"0\").rstrip(\".\")\nif not keep_trailing_zeros:\nvalue_str = stripped\nunit_str = unit if stripped != \"0\" else self._exponent_unit_map[0]\nreturn f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n\"\"\"Initialize a new quantity.\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\nself._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\nexponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n\"\"\"Initialize a new subclass of Quantity.\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\nif 0 not in exponent_unit_map:\nraise ValueError(\"Expected a base unit for the type (for exponent 0)\")\ncls._exponent_unit_map = exponent_unit_map\nsuper().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Percentage | timedelta) -&gt; Self | Energy\n</code></pre> <p>Return a power or energy from multiplying this power by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The percentage or duration to multiply by.</p> <p> TYPE: <code>Percentage | timedelta</code> </p> RETURNS DESCRIPTION <code>Self | Energy</code> <p>A power or energy.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: Percentage | timedelta) -&gt; Self | Energy:\n\"\"\"Return a power or energy from multiplying this power by the given value.\n    Args:\n        other: The percentage or duration to multiply by.\n    Returns:\n        A power or energy.\n    \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, timedelta):\nreturn Energy.from_watt_hours(\nself._base_value * other.total_seconds() / 3600.0\n)\nreturn NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n\"\"\"Return the negation of this quantity.\n    Returns:\n        The negation of this quantity.\n    \"\"\"\nnegation = type(self).__new__(type(self))\nnegation._base_value = -self._base_value\nreturn negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a representation of this quantity.\n    Returns:\n        A representation of this quantity.\n    \"\"\"\nreturn f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this quantity.\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\nreturn self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n\"\"\"Return the difference of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\ndifference = type(self).__new__(type(self))\ndifference._base_value = self._base_value - other._base_value\nreturn difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Current | Voltage) -&gt; Voltage | Current\n</code></pre> <p>Return a current or voltage from dividing this power by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The current or voltage to divide by.</p> <p> TYPE: <code>Current | Voltage</code> </p> RETURNS DESCRIPTION <code>Voltage | Current</code> <p>A current or voltage from dividing this power by the given value.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given value is not a current or voltage.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, other: Current | Voltage) -&gt; Voltage | Current:\n\"\"\"Return a current or voltage from dividing this power by the given value.\n    Args:\n        other: The current or voltage to divide by.\n    Returns:\n        A current or voltage from dividing this power by the given value.\n    Raises:\n        TypeError: If the given value is not a current or voltage.\n    \"\"\"\nif isinstance(other, Current):\nreturn Voltage.from_volts(self._base_value / other._base_value)\nif isinstance(other, Voltage):\nreturn Current.from_amperes(self._base_value / other._base_value)\nraise TypeError(\nf\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_kilowatts","title":"as_kilowatts","text":"<pre><code>as_kilowatts() -&gt; float\n</code></pre> <p>Return the power in kilowatts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in kilowatts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilowatts(self) -&gt; float:\n\"\"\"Return the power in kilowatts.\n    Returns:\n        The power in kilowatts.\n    \"\"\"\nreturn self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_megawatts","title":"as_megawatts","text":"<pre><code>as_megawatts() -&gt; float\n</code></pre> <p>Return the power in megawatts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in megawatts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megawatts(self) -&gt; float:\n\"\"\"Return the power in megawatts.\n    Returns:\n        The power in megawatts.\n    \"\"\"\nreturn self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_watts","title":"as_watts","text":"<pre><code>as_watts() -&gt; float\n</code></pre> <p>Return the power in watts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in watts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_watts(self) -&gt; float:\n\"\"\"Return the power in watts.\n    Returns:\n        The power in watts.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_kilowatts","title":"from_kilowatts  <code>classmethod</code>","text":"<pre><code>from_kilowatts(kilowatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>kilowatts</code> <p>The power in kilowatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilowatts(cls, kilowatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n    Args:\n        kilowatts: The power in kilowatts.\n    Returns:\n        A new power quantity.\n    \"\"\"\npower = cls.__new__(cls)\npower._base_value = kilowatts * 10**3\nreturn power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_megawatts","title":"from_megawatts  <code>classmethod</code>","text":"<pre><code>from_megawatts(megawatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>megawatts</code> <p>The power in megawatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megawatts(cls, megawatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n    Args:\n        megawatts: The power in megawatts.\n    Returns:\n        A new power quantity.\n    \"\"\"\npower = cls.__new__(cls)\npower._base_value = megawatts * 10**6\nreturn power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_milliwatts","title":"from_milliwatts  <code>classmethod</code>","text":"<pre><code>from_milliwatts(milliwatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>milliwatts</code> <p>The power in milliwatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_milliwatts(cls, milliwatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n    Args:\n        milliwatts: The power in milliwatts.\n    Returns:\n        A new power quantity.\n    \"\"\"\npower = cls.__new__(cls)\npower._base_value = milliwatts * 10**-3\nreturn power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_watts","title":"from_watts  <code>classmethod</code>","text":"<pre><code>from_watts(watts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>watts</code> <p>The power in watts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_watts(cls, watts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n    Args:\n        watts: The power in watts.\n    Returns:\n        A new power quantity.\n    \"\"\"\npower = cls.__new__(cls)\npower._base_value = watts\nreturn power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.isclose","title":"isclose","text":"<pre><code>isclose(\nother: Self,\nrel_tol: float = 1e-09,\nabs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n\"\"\"Return whether this quantity is close to another.\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\nreturn math.isclose(\nself._base_value,\nother._base_value,  # pylint: disable=protected-access\nrel_tol=rel_tol,\nabs_tol=abs_tol,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n\"\"\"Return whether this quantity is infinite.\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\nreturn math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n\"\"\"Return whether this quantity is NaN.\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\nreturn math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n\"\"\"Return a quantity with value 0.\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n_zero = cls._zero_cache.get(cls, None)\nif _zero is None:\n_zero = cls.__new__(cls)\n_zero._base_value = 0\ncls._zero_cache[cls] = _zero\nassert isinstance(_zero, cls)\nreturn _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity","title":"frequenz.sdk.timeseries.Quantity","text":"<p>A quantity with a unit.</p> <p>Quantities try to behave like float and are also immutable.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Quantity:\n\"\"\"A quantity with a unit.\n    Quantities try to behave like float and are also immutable.\n    \"\"\"\n_base_value: float\n\"\"\"The value of this quantity in the base unit.\"\"\"\n_exponent_unit_map: dict[int, str] | None = None\n\"\"\"A mapping from the exponent of the base unit to the unit symbol.\n    If None, this quantity has no unit.  None is possible only when using the base\n    class.  Sub-classes must define this.\n    \"\"\"\ndef __init__(self, value: float, exponent: int = 0) -&gt; None:\n\"\"\"Initialize a new quantity.\n        Args:\n            value: The value of this quantity in a given exponent of the base unit.\n            exponent: The exponent of the base unit the given value is in.\n        \"\"\"\nself._base_value = value * 10**exponent\ndef __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n\"\"\"Initialize a new subclass of Quantity.\n        Args:\n            exponent_unit_map: A mapping from the exponent of the base unit to the unit\n                symbol.\n        Raises:\n            TypeError: If the given exponent_unit_map is not a dict.\n            ValueError: If the given exponent_unit_map does not contain a base unit\n                (exponent 0).\n        \"\"\"\nif 0 not in exponent_unit_map:\nraise ValueError(\"Expected a base unit for the type (for exponent 0)\")\ncls._exponent_unit_map = exponent_unit_map\nsuper().__init_subclass__()\n_zero_cache: dict[type, Quantity] = {}\n\"\"\"Cache for zero singletons.\n    This is a workaround for mypy getting confused when using @functools.cache and\n    @classmethod combined with returning Self. It believes the resulting type of this\n    method is Self and complains that members of the actual class don't exist in Self,\n    so we need to implement the cache ourselves.\n    \"\"\"\n@classmethod\ndef zero(cls) -&gt; Self:\n\"\"\"Return a quantity with value 0.\n        Returns:\n            A quantity with value 0.\n        \"\"\"\n_zero = cls._zero_cache.get(cls, None)\nif _zero is None:\n_zero = cls.__new__(cls)\n_zero._base_value = 0\ncls._zero_cache[cls] = _zero\nassert isinstance(_zero, cls)\nreturn _zero\n@property\ndef base_value(self) -&gt; float:\n\"\"\"Return the value of this quantity in the base unit.\n        Returns:\n            The value of this quantity in the base unit.\n        \"\"\"\nreturn self._base_value\n@property\ndef base_unit(self) -&gt; str | None:\n\"\"\"Return the base unit of this quantity.\n        None if this quantity has no unit.\n        Returns:\n            The base unit of this quantity.\n        \"\"\"\nif not self._exponent_unit_map:\nreturn None\nreturn self._exponent_unit_map[0]\ndef isnan(self) -&gt; bool:\n\"\"\"Return whether this quantity is NaN.\n        Returns:\n            Whether this quantity is NaN.\n        \"\"\"\nreturn math.isnan(self._base_value)\ndef isinf(self) -&gt; bool:\n\"\"\"Return whether this quantity is infinite.\n        Returns:\n            Whether this quantity is infinite.\n        \"\"\"\nreturn math.isinf(self._base_value)\ndef isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n\"\"\"Return whether this quantity is close to another.\n        Args:\n            other: The quantity to compare to.\n            rel_tol: The relative tolerance.\n            abs_tol: The absolute tolerance.\n        Returns:\n            Whether this quantity is close to another.\n        \"\"\"\nreturn math.isclose(\nself._base_value,\nother._base_value,  # pylint: disable=protected-access\nrel_tol=rel_tol,\nabs_tol=abs_tol,\n)\ndef __repr__(self) -&gt; str:\n\"\"\"Return a representation of this quantity.\n        Returns:\n            A representation of this quantity.\n        \"\"\"\nreturn f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\ndef __str__(self) -&gt; str:\n\"\"\"Return a string representation of this quantity.\n        Returns:\n            A string representation of this quantity.\n        \"\"\"\nreturn self.__format__(\"\")\ndef __format__(self, __format_spec: str) -&gt; str:\n\"\"\"Return a formatted string representation of this quantity.\n        If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n        trailing zeros will be omitted.  If no precision is given, the default is 3.\n        The returned string will use the unit that will result in the maximum precision,\n        based on the magnitude of the value.\n        Example:\n            ```python\n            from frequenz.sdk.timeseries import Current\n            c = Current.from_amperes(0.2345)\n            assert f\"{c:.2}\" == \"234.5 mA\"\n            c = Current.from_amperes(1.2345)\n            assert f\"{c:.2}\" == \"1.23 A\"\n            c = Current.from_milliamperes(1.2345)\n            assert f\"{c:.6}\" == \"1.2345 mA\"\n            ```\n        Args:\n            __format_spec: The format specifier.\n        Returns:\n            A string representation of this quantity.\n        Raises:\n            ValueError: If the given format specifier is invalid.\n        \"\"\"\nkeep_trailing_zeros = False\nif __format_spec != \"\":\nfspec_parts = __format_spec.split(\".\")\nif (\nlen(fspec_parts) != 2\nor fspec_parts[0] not in (\"\", \"0\")\nor not fspec_parts[1].isdigit()\n):\nraise ValueError(\n\"Invalid format specifier. Must be empty or `[0].{precision}`\"\n)\nif fspec_parts[0] == \"0\":\nkeep_trailing_zeros = True\nprecision = int(fspec_parts[1])\nelse:\nprecision = 3\nif not self._exponent_unit_map:\nreturn f\"{self._base_value:.{precision}f}\"\nif math.isinf(self._base_value) or math.isnan(self._base_value):\nreturn f\"{self._base_value} {self._exponent_unit_map[0]}\"\nabs_value = abs(self._base_value)\nexponent = math.floor(math.log10(abs_value)) if abs_value else 0\nunit_place = exponent - exponent % 3\nif unit_place &lt; min(self._exponent_unit_map):\nunit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\nunit_place = min(self._exponent_unit_map)\nelif unit_place &gt; max(self._exponent_unit_map):\nunit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\nunit_place = max(self._exponent_unit_map)\nelse:\nunit = self._exponent_unit_map[unit_place]\nvalue_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\nstripped = value_str.rstrip(\"0\").rstrip(\".\")\nif not keep_trailing_zeros:\nvalue_str = stripped\nunit_str = unit if stripped != \"0\" else self._exponent_unit_map[0]\nreturn f\"{value_str} {unit_str}\"\ndef __add__(self, other: Self) -&gt; Self:\n\"\"\"Return the sum of this quantity and another.\n        Args:\n            other: The other quantity.\n        Returns:\n            The sum of this quantity and another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nsumme = type(self).__new__(type(self))\nsumme._base_value = self._base_value + other._base_value\nreturn summe\ndef __sub__(self, other: Self) -&gt; Self:\n\"\"\"Return the difference of this quantity and another.\n        Args:\n            other: The other quantity.\n        Returns:\n            The difference of this quantity and another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\ndifference = type(self).__new__(type(self))\ndifference._base_value = self._base_value - other._base_value\nreturn difference\ndef __mul__(self, percent: Percentage) -&gt; Self:\n\"\"\"Scale this quantity by a percentage.\n        Args:\n            percent: The percentage by which to scale this quantity.\n        Returns:\n            The scaled quantity.\n        \"\"\"\nif not isinstance(percent, Percentage):\nreturn NotImplemented\nproduct = type(self).__new__(type(self))\nproduct._base_value = self._base_value * percent.as_fraction()\nreturn product\ndef __gt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than another.\n        Args:\n            other: The other quantity.\n        Returns:\n            Whether this quantity is greater than another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt; other._base_value\ndef __ge__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than or equal to another.\n        Args:\n            other: The other quantity.\n        Returns:\n            Whether this quantity is greater than or equal to another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt;= other._base_value\ndef __lt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than another.\n        Args:\n            other: The other quantity.\n        Returns:\n            Whether this quantity is less than another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt; other._base_value\ndef __le__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than or equal to another.\n        Args:\n            other: The other quantity.\n        Returns:\n            Whether this quantity is less than or equal to another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt;= other._base_value\ndef __eq__(self, other: object) -&gt; bool:\n\"\"\"Return whether this quantity is equal to another.\n        Args:\n            other: The other quantity.\n        Returns:\n            Whether this quantity is equal to another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\n# The above check ensures that both quantities are the exact same type, because\n# `isinstance` returns true for subclasses and superclasses.  But the above check\n# doesn't help mypy identify the type of other,  so the below line is necessary.\nassert isinstance(other, self.__class__)\nreturn self._base_value == other._base_value\ndef __neg__(self) -&gt; Self:\n\"\"\"Return the negation of this quantity.\n        Returns:\n            The negation of this quantity.\n        \"\"\"\nnegation = type(self).__new__(type(self))\nnegation._base_value = -self._base_value\nreturn negation\ndef __abs__(self) -&gt; Self:\n\"\"\"Return the absolute value of this quantity.\n        Returns:\n            The absolute value of this quantity.\n        \"\"\"\nabsolute = type(self).__new__(type(self))\nabsolute._base_value = abs(self._base_value)\nreturn absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n\"\"\"Return the absolute value of this quantity.\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\nabsolute = type(self).__new__(type(self))\nabsolute._base_value = abs(self._base_value)\nreturn absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n\"\"\"Return the sum of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nsumme = type(self).__new__(type(self))\nsumme._base_value = self._base_value + other._base_value\nreturn summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Return whether this quantity is equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\n# The above check ensures that both quantities are the exact same type, because\n# `isinstance` returns true for subclasses and superclasses.  But the above check\n# doesn't help mypy identify the type of other,  so the below line is necessary.\nassert isinstance(other, self.__class__)\nreturn self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n\"\"\"Return a formatted string representation of this quantity.\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n    Args:\n        __format_spec: The format specifier.\n    Returns:\n        A string representation of this quantity.\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\nkeep_trailing_zeros = False\nif __format_spec != \"\":\nfspec_parts = __format_spec.split(\".\")\nif (\nlen(fspec_parts) != 2\nor fspec_parts[0] not in (\"\", \"0\")\nor not fspec_parts[1].isdigit()\n):\nraise ValueError(\n\"Invalid format specifier. Must be empty or `[0].{precision}`\"\n)\nif fspec_parts[0] == \"0\":\nkeep_trailing_zeros = True\nprecision = int(fspec_parts[1])\nelse:\nprecision = 3\nif not self._exponent_unit_map:\nreturn f\"{self._base_value:.{precision}f}\"\nif math.isinf(self._base_value) or math.isnan(self._base_value):\nreturn f\"{self._base_value} {self._exponent_unit_map[0]}\"\nabs_value = abs(self._base_value)\nexponent = math.floor(math.log10(abs_value)) if abs_value else 0\nunit_place = exponent - exponent % 3\nif unit_place &lt; min(self._exponent_unit_map):\nunit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\nunit_place = min(self._exponent_unit_map)\nelif unit_place &gt; max(self._exponent_unit_map):\nunit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\nunit_place = max(self._exponent_unit_map)\nelse:\nunit = self._exponent_unit_map[unit_place]\nvalue_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\nstripped = value_str.rstrip(\"0\").rstrip(\".\")\nif not keep_trailing_zeros:\nvalue_str = stripped\nunit_str = unit if stripped != \"0\" else self._exponent_unit_map[0]\nreturn f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n\"\"\"Initialize a new quantity.\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\nself._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\nexponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n\"\"\"Initialize a new subclass of Quantity.\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\nif 0 not in exponent_unit_map:\nraise ValueError(\"Expected a base unit for the type (for exponent 0)\")\ncls._exponent_unit_map = exponent_unit_map\nsuper().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__mul__","title":"__mul__","text":"<pre><code>__mul__(percent: Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a percentage.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percentage by which to scale this quantity.</p> <p> TYPE: <code>Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, percent: Percentage) -&gt; Self:\n\"\"\"Scale this quantity by a percentage.\n    Args:\n        percent: The percentage by which to scale this quantity.\n    Returns:\n        The scaled quantity.\n    \"\"\"\nif not isinstance(percent, Percentage):\nreturn NotImplemented\nproduct = type(self).__new__(type(self))\nproduct._base_value = self._base_value * percent.as_fraction()\nreturn product\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n\"\"\"Return the negation of this quantity.\n    Returns:\n        The negation of this quantity.\n    \"\"\"\nnegation = type(self).__new__(type(self))\nnegation._base_value = -self._base_value\nreturn negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a representation of this quantity.\n    Returns:\n        A representation of this quantity.\n    \"\"\"\nreturn f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this quantity.\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\nreturn self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n\"\"\"Return the difference of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\ndifference = type(self).__new__(type(self))\ndifference._base_value = self._base_value - other._base_value\nreturn difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isclose","title":"isclose","text":"<pre><code>isclose(\nother: Self,\nrel_tol: float = 1e-09,\nabs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n\"\"\"Return whether this quantity is close to another.\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\nreturn math.isclose(\nself._base_value,\nother._base_value,  # pylint: disable=protected-access\nrel_tol=rel_tol,\nabs_tol=abs_tol,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n\"\"\"Return whether this quantity is infinite.\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\nreturn math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n\"\"\"Return whether this quantity is NaN.\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\nreturn math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n\"\"\"Return a quantity with value 0.\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n_zero = cls._zero_cache.get(cls, None)\nif _zero is None:\n_zero = cls.__new__(cls)\n_zero._base_value = 0\ncls._zero_cache[cls] = _zero\nassert isinstance(_zero, cls)\nreturn _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ReceiverFetcher","title":"frequenz.sdk.timeseries.ReceiverFetcher","text":"<p>             Bases: <code>Generic[T]</code>, <code>Protocol</code></p> <p>An interface that just exposes a <code>new_receiver</code> method.</p> Source code in <code>frequenz/sdk/_internal/_channels.py</code> <pre><code>class ReceiverFetcher(typing.Generic[T], typing.Protocol):\n\"\"\"An interface that just exposes a `new_receiver` method.\"\"\"\n@abc.abstractmethod\ndef new_receiver(self, maxsize: int = 50) -&gt; Receiver[T]:\n\"\"\"Get a receiver from the channel.\n        Args:\n            maxsize: The maximum size of the receiver.\n        Returns:\n            A receiver instance.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ReceiverFetcher-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ReceiverFetcher.new_receiver","title":"new_receiver  <code>abstractmethod</code>","text":"<pre><code>new_receiver(maxsize: int = 50) -&gt; Receiver[T]\n</code></pre> <p>Get a receiver from the channel.</p> PARAMETER  DESCRIPTION <code>maxsize</code> <p>The maximum size of the receiver.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[T]</code> <p>A receiver instance.</p> Source code in <code>frequenz/sdk/_internal/_channels.py</code> <pre><code>@abc.abstractmethod\ndef new_receiver(self, maxsize: int = 50) -&gt; Receiver[T]:\n\"\"\"Get a receiver from the channel.\n    Args:\n        maxsize: The maximum size of the receiver.\n    Returns:\n        A receiver instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig","title":"frequenz.sdk.timeseries.ResamplerConfig  <code>dataclass</code>","text":"<p>Resampler configuration.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>@dataclass(frozen=True)\nclass ResamplerConfig:\n\"\"\"Resampler configuration.\"\"\"\nresampling_period: timedelta\n\"\"\"The resampling period.\n    This is the time it passes between resampled data should be calculated.\n    It must be a positive time span.\n    \"\"\"\nmax_data_age_in_periods: float = 3.0\n\"\"\"The maximum age a sample can have to be considered *relevant* for resampling.\n    Expressed in number of periods, where period is the `resampling_period`\n    if we are downsampling (resampling period bigger than the input period) or\n    the input sampling period if we are upsampling (input period bigger than\n    the resampling period).\n    It must be bigger than 1.0.\n    Example:\n        If `resampling_period` is 3 seconds, the input sampling period is\n        1 and `max_data_age_in_periods` is 2, then data older than 3*2\n        = 6 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n        If `resampling_period` is 3 seconds, the input sampling period is\n        5 and `max_data_age_in_periods` is 2, then data older than 5*2\n        = 10 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n    \"\"\"\nresampling_function: ResamplingFunction = average\n\"\"\"The resampling function.\n    This function will be applied to the sequence of relevant samples at\n    a given time. The result of the function is what is sent as the resampled\n    value.\n    \"\"\"\ninitial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n\"\"\"The initial length of the resampling buffer.\n    The buffer could grow or shrink depending on the source properties,\n    like sampling rate, to make sure all the requested past sampling periods\n    can be stored.\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\nwarn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n\"\"\"The minimum length of the resampling buffer that will emit a warning.\n    If a buffer grows bigger than this value, it will emit a warning in the\n    logs, so buffers don't grow too big inadvertently.\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\nmax_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n\"\"\"The maximum length of the resampling buffer.\n    Buffers won't be allowed to grow beyond this point even if it would be\n    needed to keep all the requested past sampling periods. An error will be\n    emitted in the logs if the buffer length needs to be truncated to this\n    value.\n    It must be at bigger than `warn_buffer_len`.\n    \"\"\"\nalign_to: datetime | None = UNIX_EPOCH\n\"\"\"The time to align the resampling period to.\n    The resampling period will be aligned to this time, so the first resampled\n    sample will be at the first multiple of `resampling_period` starting from\n    `align_to`. It must be an aware datetime and can be in the future too.\n    If `align_to` is `None`, the resampling period will be aligned to the\n    time the resampler is created.\n    \"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n        Raises:\n            ValueError: If any value is out of range.\n        \"\"\"\nif self.resampling_period.total_seconds() &lt; 0.0:\nraise ValueError(\nf\"resampling_period ({self.resampling_period}) must be positive\"\n)\nif self.max_data_age_in_periods &lt; 1.0:\nraise ValueError(\nf\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n)\nif self.warn_buffer_len &lt; 1:\nraise ValueError(\nf\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n)\nif self.max_buffer_len &lt;= self.warn_buffer_len:\nraise ValueError(\nf\"max_buffer_len ({self.max_buffer_len}) should \"\nf\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n)\nif self.initial_buffer_len &lt; 1:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n)\nif self.initial_buffer_len &gt; self.max_buffer_len:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\nf\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n\"initial_buffer_len or a bigger max_buffer_len\"\n)\nif self.initial_buffer_len &gt; self.warn_buffer_len:\n_logger.warning(\n\"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\nself.initial_buffer_len,\nself.warn_buffer_len,\n)\nif self.align_to is not None and self.align_to.tzinfo is None:\nraise ValueError(\nf\"align_to ({self.align_to}) should be a timezone aware datetime\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.align_to","title":"align_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>align_to: datetime | None = UNIX_EPOCH\n</code></pre> <p>The time to align the resampling period to.</p> <p>The resampling period will be aligned to this time, so the first resampled sample will be at the first multiple of <code>resampling_period</code> starting from <code>align_to</code>. It must be an aware datetime and can be in the future too.</p> <p>If <code>align_to</code> is <code>None</code>, the resampling period will be aligned to the time the resampler is created.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.initial_buffer_len","title":"initial_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n</code></pre> <p>The initial length of the resampling buffer.</p> <p>The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.max_buffer_len","title":"max_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n</code></pre> <p>The maximum length of the resampling buffer.</p> <p>Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value.</p> <p>It must be at bigger than <code>warn_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.max_data_age_in_periods","title":"max_data_age_in_periods  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_data_age_in_periods: float = 3.0\n</code></pre> <p>The maximum age a sample can have to be considered relevant for resampling.</p> <p>Expressed in number of periods, where period is the <code>resampling_period</code> if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period).</p> <p>It must be bigger than 1.0.</p> Example <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 1 and <code>max_data_age_in_periods</code> is 2, then data older than 3*2 = 6 seconds will be discarded when creating a new sample and never passed to the resampling function.</p> <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 5 and <code>max_data_age_in_periods</code> is 2, then data older than 5*2 = 10 seconds will be discarded when creating a new sample and never passed to the resampling function.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.resampling_function","title":"resampling_function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resampling_function: ResamplingFunction = average\n</code></pre> <p>The resampling function.</p> <p>This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.resampling_period","title":"resampling_period  <code>instance-attribute</code>","text":"<pre><code>resampling_period: timedelta\n</code></pre> <p>The resampling period.</p> <p>This is the time it passes between resampled data should be calculated.</p> <p>It must be a positive time span.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.warn_buffer_len","title":"warn_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n</code></pre> <p>The minimum length of the resampling buffer that will emit a warning.</p> <p>If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertently.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Check that config values are valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any value is out of range.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n    Raises:\n        ValueError: If any value is out of range.\n    \"\"\"\nif self.resampling_period.total_seconds() &lt; 0.0:\nraise ValueError(\nf\"resampling_period ({self.resampling_period}) must be positive\"\n)\nif self.max_data_age_in_periods &lt; 1.0:\nraise ValueError(\nf\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n)\nif self.warn_buffer_len &lt; 1:\nraise ValueError(\nf\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n)\nif self.max_buffer_len &lt;= self.warn_buffer_len:\nraise ValueError(\nf\"max_buffer_len ({self.max_buffer_len}) should \"\nf\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n)\nif self.initial_buffer_len &lt; 1:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n)\nif self.initial_buffer_len &gt; self.max_buffer_len:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\nf\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n\"initial_buffer_len or a bigger max_buffer_len\"\n)\nif self.initial_buffer_len &gt; self.warn_buffer_len:\n_logger.warning(\n\"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\nself.initial_buffer_len,\nself.warn_buffer_len,\n)\nif self.align_to is not None and self.align_to.tzinfo is None:\nraise ValueError(\nf\"align_to ({self.align_to}) should be a timezone aware datetime\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample","title":"frequenz.sdk.timeseries.Sample  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[QuantityT]</code></p> <p>A measurement taken at a particular point in time.</p> <p>The <code>value</code> could be <code>None</code> if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True, order=True)\nclass Sample(Generic[QuantityT]):\n\"\"\"A measurement taken at a particular point in time.\n    The `value` could be `None` if a component is malfunctioning or data is\n    lacking for another reason, but a sample still needs to be sent to have a\n    coherent view on a group of component metrics for a particular timestamp.\n    \"\"\"\ntimestamp: datetime\n\"\"\"The time when this sample was generated.\"\"\"\nvalue: QuantityT | None = None\n\"\"\"The value of this sample.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The time when this sample was generated.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: QuantityT | None = None\n</code></pre> <p>The value of this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase","title":"frequenz.sdk.timeseries.Sample3Phase  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[QuantityT]</code></p> <p>A 3-phase measurement made at a particular point in time.</p> <p>Each of the <code>value</code> fields could be <code>None</code> if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Sample3Phase(Generic[QuantityT]):\n\"\"\"A 3-phase measurement made at a particular point in time.\n    Each of the `value` fields could be `None` if a component is malfunctioning\n    or data is lacking for another reason, but a sample still needs to be sent\n    to have a coherent view on a group of component metrics for a particular\n    timestamp.\n    \"\"\"\ntimestamp: datetime\n\"\"\"The time when this sample was generated.\"\"\"\nvalue_p1: QuantityT | None\n\"\"\"The value of the 1st phase in this sample.\"\"\"\nvalue_p2: QuantityT | None\n\"\"\"The value of the 2nd phase in this sample.\"\"\"\nvalue_p3: QuantityT | None\n\"\"\"The value of the 3rd phase in this sample.\"\"\"\ndef __iter__(self) -&gt; Iterator[QuantityT | None]:\n\"\"\"Return an iterator that yields values from each of the phases.\n        Yields:\n            Per-phase measurements one-by-one.\n        \"\"\"\nyield self.value_p1\nyield self.value_p2\nyield self.value_p3\n@overload\ndef max(self, default: QuantityT) -&gt; QuantityT:\n...\n@overload\ndef max(self, default: None = None) -&gt; QuantityT | None:\n...\ndef max(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n\"\"\"Return the max value among all phases, or default if they are all `None`.\n        Args:\n            default: value to return if all phases are `None`.\n        Returns:\n            Max value among all phases, if available, default value otherwise.\n        \"\"\"\nif not any(self):\nreturn default\nvalue: QuantityT = functools.reduce(\nlambda x, y: x if x &gt; y else y,\nfilter(None, self),\n)\nreturn value\n@overload\ndef min(self, default: QuantityT) -&gt; QuantityT:\n...\n@overload\ndef min(self, default: None = None) -&gt; QuantityT | None:\n...\ndef min(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n\"\"\"Return the min value among all phases, or default if they are all `None`.\n        Args:\n            default: value to return if all phases are `None`.\n        Returns:\n            Min value among all phases, if available, default value otherwise.\n        \"\"\"\nif not any(self):\nreturn default\nvalue: QuantityT = functools.reduce(\nlambda x, y: x if x &lt; y else y,\nfilter(None, self),\n)\nreturn value\ndef map(\nself,\nfunction: Callable[[QuantityT], QuantityT],\ndefault: QuantityT | None = None,\n) -&gt; Self:\n\"\"\"Apply the given function on each of the phase values and return the result.\n        If a phase value is `None`, replace it with `default` instead.\n        Args:\n            function: The function to apply on each of the phase values.\n            default: The value to apply if a phase value is `None`.\n        Returns:\n            A new instance, with the given function applied on values for each of the\n                phases.\n        \"\"\"\nreturn self.__class__(\ntimestamp=self.timestamp,\nvalue_p1=default if self.value_p1 is None else function(self.value_p1),\nvalue_p2=default if self.value_p2 is None else function(self.value_p2),\nvalue_p3=default if self.value_p3 is None else function(self.value_p3),\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The time when this sample was generated.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p1","title":"value_p1  <code>instance-attribute</code>","text":"<pre><code>value_p1: QuantityT | None\n</code></pre> <p>The value of the 1st phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p2","title":"value_p2  <code>instance-attribute</code>","text":"<pre><code>value_p2: QuantityT | None\n</code></pre> <p>The value of the 2nd phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p3","title":"value_p3  <code>instance-attribute</code>","text":"<pre><code>value_p3: QuantityT | None\n</code></pre> <p>The value of the 3rd phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[QuantityT | None]\n</code></pre> <p>Return an iterator that yields values from each of the phases.</p> YIELDS DESCRIPTION <code>QuantityT | None</code> <p>Per-phase measurements one-by-one.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def __iter__(self) -&gt; Iterator[QuantityT | None]:\n\"\"\"Return an iterator that yields values from each of the phases.\n    Yields:\n        Per-phase measurements one-by-one.\n    \"\"\"\nyield self.value_p1\nyield self.value_p2\nyield self.value_p3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.map","title":"map","text":"<pre><code>map(\nfunction: Callable[[QuantityT], QuantityT],\ndefault: QuantityT | None = None,\n) -&gt; Self\n</code></pre> <p>Apply the given function on each of the phase values and return the result.</p> <p>If a phase value is <code>None</code>, replace it with <code>default</code> instead.</p> PARAMETER  DESCRIPTION <code>function</code> <p>The function to apply on each of the phase values.</p> <p> TYPE: <code>Callable[[QuantityT], QuantityT]</code> </p> <code>default</code> <p>The value to apply if a phase value is <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new instance, with the given function applied on values for each of the phases.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def map(\nself,\nfunction: Callable[[QuantityT], QuantityT],\ndefault: QuantityT | None = None,\n) -&gt; Self:\n\"\"\"Apply the given function on each of the phase values and return the result.\n    If a phase value is `None`, replace it with `default` instead.\n    Args:\n        function: The function to apply on each of the phase values.\n        default: The value to apply if a phase value is `None`.\n    Returns:\n        A new instance, with the given function applied on values for each of the\n            phases.\n    \"\"\"\nreturn self.__class__(\ntimestamp=self.timestamp,\nvalue_p1=default if self.value_p1 is None else function(self.value_p1),\nvalue_p2=default if self.value_p2 is None else function(self.value_p2),\nvalue_p3=default if self.value_p3 is None else function(self.value_p3),\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.max","title":"max","text":"<pre><code>max(default: QuantityT | None = None) -&gt; QuantityT | None\n</code></pre> <p>Return the max value among all phases, or default if they are all <code>None</code>.</p> PARAMETER  DESCRIPTION <code>default</code> <p>value to return if all phases are <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>QuantityT | None</code> <p>Max value among all phases, if available, default value otherwise.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def max(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n\"\"\"Return the max value among all phases, or default if they are all `None`.\n    Args:\n        default: value to return if all phases are `None`.\n    Returns:\n        Max value among all phases, if available, default value otherwise.\n    \"\"\"\nif not any(self):\nreturn default\nvalue: QuantityT = functools.reduce(\nlambda x, y: x if x &gt; y else y,\nfilter(None, self),\n)\nreturn value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.min","title":"min","text":"<pre><code>min(default: QuantityT | None = None) -&gt; QuantityT | None\n</code></pre> <p>Return the min value among all phases, or default if they are all <code>None</code>.</p> PARAMETER  DESCRIPTION <code>default</code> <p>value to return if all phases are <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>QuantityT | None</code> <p>Min value among all phases, if available, default value otherwise.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def min(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n\"\"\"Return the min value among all phases, or default if they are all `None`.\n    Args:\n        default: value to return if all phases are `None`.\n    Returns:\n        Min value among all phases, if available, default value otherwise.\n    \"\"\"\nif not any(self):\nreturn default\nvalue: QuantityT = functools.reduce(\nlambda x, y: x if x &lt; y else y,\nfilter(None, self),\n)\nreturn value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature","title":"frequenz.sdk.timeseries.Temperature","text":"<p>             Bases: <code>Quantity</code></p> <p>A temperature quantity (in degrees Celsius).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Temperature(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={\n0: \"\u00b0C\",\n},\n):\n\"\"\"A temperature quantity (in degrees Celsius).\"\"\"\n@classmethod\ndef from_celsius(cls, value: float) -&gt; Self:\n\"\"\"Initialize a new temperature quantity.\n        Args:\n            value: The temperature in degrees Celsius.\n        Returns:\n            A new temperature quantity.\n        \"\"\"\npower = cls.__new__(cls)\npower._base_value = value\nreturn power\ndef as_celsius(self) -&gt; float:\n\"\"\"Return the temperature in degrees Celsius.\n        Returns:\n            The temperature in degrees Celsius.\n        \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n\"\"\"Return the absolute value of this quantity.\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\nabsolute = type(self).__new__(type(self))\nabsolute._base_value = abs(self._base_value)\nreturn absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n\"\"\"Return the sum of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nsumme = type(self).__new__(type(self))\nsumme._base_value = self._base_value + other._base_value\nreturn summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Return whether this quantity is equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\n# The above check ensures that both quantities are the exact same type, because\n# `isinstance` returns true for subclasses and superclasses.  But the above check\n# doesn't help mypy identify the type of other,  so the below line is necessary.\nassert isinstance(other, self.__class__)\nreturn self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n\"\"\"Return a formatted string representation of this quantity.\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n    Args:\n        __format_spec: The format specifier.\n    Returns:\n        A string representation of this quantity.\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\nkeep_trailing_zeros = False\nif __format_spec != \"\":\nfspec_parts = __format_spec.split(\".\")\nif (\nlen(fspec_parts) != 2\nor fspec_parts[0] not in (\"\", \"0\")\nor not fspec_parts[1].isdigit()\n):\nraise ValueError(\n\"Invalid format specifier. Must be empty or `[0].{precision}`\"\n)\nif fspec_parts[0] == \"0\":\nkeep_trailing_zeros = True\nprecision = int(fspec_parts[1])\nelse:\nprecision = 3\nif not self._exponent_unit_map:\nreturn f\"{self._base_value:.{precision}f}\"\nif math.isinf(self._base_value) or math.isnan(self._base_value):\nreturn f\"{self._base_value} {self._exponent_unit_map[0]}\"\nabs_value = abs(self._base_value)\nexponent = math.floor(math.log10(abs_value)) if abs_value else 0\nunit_place = exponent - exponent % 3\nif unit_place &lt; min(self._exponent_unit_map):\nunit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\nunit_place = min(self._exponent_unit_map)\nelif unit_place &gt; max(self._exponent_unit_map):\nunit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\nunit_place = max(self._exponent_unit_map)\nelse:\nunit = self._exponent_unit_map[unit_place]\nvalue_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\nstripped = value_str.rstrip(\"0\").rstrip(\".\")\nif not keep_trailing_zeros:\nvalue_str = stripped\nunit_str = unit if stripped != \"0\" else self._exponent_unit_map[0]\nreturn f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n\"\"\"Initialize a new quantity.\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\nself._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\nexponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n\"\"\"Initialize a new subclass of Quantity.\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\nif 0 not in exponent_unit_map:\nraise ValueError(\"Expected a base unit for the type (for exponent 0)\")\ncls._exponent_unit_map = exponent_unit_map\nsuper().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__mul__","title":"__mul__","text":"<pre><code>__mul__(percent: Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a percentage.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percentage by which to scale this quantity.</p> <p> TYPE: <code>Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, percent: Percentage) -&gt; Self:\n\"\"\"Scale this quantity by a percentage.\n    Args:\n        percent: The percentage by which to scale this quantity.\n    Returns:\n        The scaled quantity.\n    \"\"\"\nif not isinstance(percent, Percentage):\nreturn NotImplemented\nproduct = type(self).__new__(type(self))\nproduct._base_value = self._base_value * percent.as_fraction()\nreturn product\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n\"\"\"Return the negation of this quantity.\n    Returns:\n        The negation of this quantity.\n    \"\"\"\nnegation = type(self).__new__(type(self))\nnegation._base_value = -self._base_value\nreturn negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a representation of this quantity.\n    Returns:\n        A representation of this quantity.\n    \"\"\"\nreturn f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this quantity.\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\nreturn self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n\"\"\"Return the difference of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\ndifference = type(self).__new__(type(self))\ndifference._base_value = self._base_value - other._base_value\nreturn difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.as_celsius","title":"as_celsius","text":"<pre><code>as_celsius() -&gt; float\n</code></pre> <p>Return the temperature in degrees Celsius.</p> RETURNS DESCRIPTION <code>float</code> <p>The temperature in degrees Celsius.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_celsius(self) -&gt; float:\n\"\"\"Return the temperature in degrees Celsius.\n    Returns:\n        The temperature in degrees Celsius.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.from_celsius","title":"from_celsius  <code>classmethod</code>","text":"<pre><code>from_celsius(value: float) -&gt; Self\n</code></pre> <p>Initialize a new temperature quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The temperature in degrees Celsius.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new temperature quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_celsius(cls, value: float) -&gt; Self:\n\"\"\"Initialize a new temperature quantity.\n    Args:\n        value: The temperature in degrees Celsius.\n    Returns:\n        A new temperature quantity.\n    \"\"\"\npower = cls.__new__(cls)\npower._base_value = value\nreturn power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.isclose","title":"isclose","text":"<pre><code>isclose(\nother: Self,\nrel_tol: float = 1e-09,\nabs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n\"\"\"Return whether this quantity is close to another.\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\nreturn math.isclose(\nself._base_value,\nother._base_value,  # pylint: disable=protected-access\nrel_tol=rel_tol,\nabs_tol=abs_tol,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n\"\"\"Return whether this quantity is infinite.\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\nreturn math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n\"\"\"Return whether this quantity is NaN.\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\nreturn math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n\"\"\"Return a quantity with value 0.\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n_zero = cls._zero_cache.get(cls, None)\nif _zero is None:\n_zero = cls.__new__(cls)\n_zero._base_value = 0\ncls._zero_cache[cls] = _zero\nassert isinstance(_zero, cls)\nreturn _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage","title":"frequenz.sdk.timeseries.Voltage","text":"<p>             Bases: <code>Quantity</code></p> <p>A voltage quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Voltage(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={0: \"V\", -3: \"mV\", 3: \"kV\"},\n):\n\"\"\"A voltage quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_volts(cls, volts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n        Args:\n            volts: The voltage in volts.\n        Returns:\n            A new voltage quantity.\n        \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = volts\nreturn voltage\n@classmethod\ndef from_millivolts(cls, millivolts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n        Args:\n            millivolts: The voltage in millivolts.\n        Returns:\n            A new voltage quantity.\n        \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = millivolts * 10**-3\nreturn voltage\n@classmethod\ndef from_kilovolts(cls, kilovolts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n        Args:\n            kilovolts: The voltage in kilovolts.\n        Returns:\n            A new voltage quantity.\n        \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = kilovolts * 10**3\nreturn voltage\ndef as_volts(self) -&gt; float:\n\"\"\"Return the voltage in volts.\n        Returns:\n            The voltage in volts.\n        \"\"\"\nreturn self._base_value\ndef as_millivolts(self) -&gt; float:\n\"\"\"Return the voltage in millivolts.\n        Returns:\n            The voltage in millivolts.\n        \"\"\"\nreturn self._base_value * 1e3\ndef as_kilovolts(self) -&gt; float:\n\"\"\"Return the voltage in kilovolts.\n        Returns:\n            The voltage in kilovolts.\n        \"\"\"\nreturn self._base_value / 1e3\n@overload  # type: ignore\ndef __mul__(self, other: Percentage) -&gt; Self:\n\"\"\"Scale this voltage by a percentage.\n        Args:\n            other: The percentage by which to scale this voltage.\n        Returns:\n            The scaled voltage.\n        \"\"\"\n@overload\ndef __mul__(self, other: Current) -&gt; Power:\n\"\"\"Multiply the voltage by the current to get the power.\n        Args:\n            other: The current to multiply the voltage with.\n        Returns:\n            The calculated power.\n        \"\"\"\ndef __mul__(self, other: Percentage | Current) -&gt; Self | Power:\n\"\"\"Return a voltage or power from multiplying this voltage by the given value.\n        Args:\n            other: The percentage or current to multiply by.\n        Returns:\n            The calculated voltage or power.\n        \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, Current):\nreturn Power.from_watts(self._base_value * other._base_value)\nreturn NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n\"\"\"Return the absolute value of this quantity.\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\nabsolute = type(self).__new__(type(self))\nabsolute._base_value = abs(self._base_value)\nreturn absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n\"\"\"Return the sum of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nsumme = type(self).__new__(type(self))\nsumme._base_value = self._base_value + other._base_value\nreturn summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Return whether this quantity is equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\n# The above check ensures that both quantities are the exact same type, because\n# `isinstance` returns true for subclasses and superclasses.  But the above check\n# doesn't help mypy identify the type of other,  so the below line is necessary.\nassert isinstance(other, self.__class__)\nreturn self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n\"\"\"Return a formatted string representation of this quantity.\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n    Args:\n        __format_spec: The format specifier.\n    Returns:\n        A string representation of this quantity.\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\nkeep_trailing_zeros = False\nif __format_spec != \"\":\nfspec_parts = __format_spec.split(\".\")\nif (\nlen(fspec_parts) != 2\nor fspec_parts[0] not in (\"\", \"0\")\nor not fspec_parts[1].isdigit()\n):\nraise ValueError(\n\"Invalid format specifier. Must be empty or `[0].{precision}`\"\n)\nif fspec_parts[0] == \"0\":\nkeep_trailing_zeros = True\nprecision = int(fspec_parts[1])\nelse:\nprecision = 3\nif not self._exponent_unit_map:\nreturn f\"{self._base_value:.{precision}f}\"\nif math.isinf(self._base_value) or math.isnan(self._base_value):\nreturn f\"{self._base_value} {self._exponent_unit_map[0]}\"\nabs_value = abs(self._base_value)\nexponent = math.floor(math.log10(abs_value)) if abs_value else 0\nunit_place = exponent - exponent % 3\nif unit_place &lt; min(self._exponent_unit_map):\nunit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\nunit_place = min(self._exponent_unit_map)\nelif unit_place &gt; max(self._exponent_unit_map):\nunit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\nunit_place = max(self._exponent_unit_map)\nelse:\nunit = self._exponent_unit_map[unit_place]\nvalue_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\nstripped = value_str.rstrip(\"0\").rstrip(\".\")\nif not keep_trailing_zeros:\nvalue_str = stripped\nunit_str = unit if stripped != \"0\" else self._exponent_unit_map[0]\nreturn f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n\"\"\"Initialize a new quantity.\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\nself._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\nexponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n\"\"\"Initialize a new subclass of Quantity.\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\nif 0 not in exponent_unit_map:\nraise ValueError(\"Expected a base unit for the type (for exponent 0)\")\ncls._exponent_unit_map = exponent_unit_map\nsuper().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Percentage | Current) -&gt; Self | Power\n</code></pre> <p>Return a voltage or power from multiplying this voltage by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The percentage or current to multiply by.</p> <p> TYPE: <code>Percentage | Current</code> </p> RETURNS DESCRIPTION <code>Self | Power</code> <p>The calculated voltage or power.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: Percentage | Current) -&gt; Self | Power:\n\"\"\"Return a voltage or power from multiplying this voltage by the given value.\n    Args:\n        other: The percentage or current to multiply by.\n    Returns:\n        The calculated voltage or power.\n    \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, Current):\nreturn Power.from_watts(self._base_value * other._base_value)\nreturn NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n\"\"\"Return the negation of this quantity.\n    Returns:\n        The negation of this quantity.\n    \"\"\"\nnegation = type(self).__new__(type(self))\nnegation._base_value = -self._base_value\nreturn negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a representation of this quantity.\n    Returns:\n        A representation of this quantity.\n    \"\"\"\nreturn f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this quantity.\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\nreturn self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n\"\"\"Return the difference of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\ndifference = type(self).__new__(type(self))\ndifference._base_value = self._base_value - other._base_value\nreturn difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_kilovolts","title":"as_kilovolts","text":"<pre><code>as_kilovolts() -&gt; float\n</code></pre> <p>Return the voltage in kilovolts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in kilovolts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilovolts(self) -&gt; float:\n\"\"\"Return the voltage in kilovolts.\n    Returns:\n        The voltage in kilovolts.\n    \"\"\"\nreturn self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_millivolts","title":"as_millivolts","text":"<pre><code>as_millivolts() -&gt; float\n</code></pre> <p>Return the voltage in millivolts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in millivolts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_millivolts(self) -&gt; float:\n\"\"\"Return the voltage in millivolts.\n    Returns:\n        The voltage in millivolts.\n    \"\"\"\nreturn self._base_value * 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_volts","title":"as_volts","text":"<pre><code>as_volts() -&gt; float\n</code></pre> <p>Return the voltage in volts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in volts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_volts(self) -&gt; float:\n\"\"\"Return the voltage in volts.\n    Returns:\n        The voltage in volts.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_kilovolts","title":"from_kilovolts  <code>classmethod</code>","text":"<pre><code>from_kilovolts(kilovolts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER  DESCRIPTION <code>kilovolts</code> <p>The voltage in kilovolts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilovolts(cls, kilovolts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n    Args:\n        kilovolts: The voltage in kilovolts.\n    Returns:\n        A new voltage quantity.\n    \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = kilovolts * 10**3\nreturn voltage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_millivolts","title":"from_millivolts  <code>classmethod</code>","text":"<pre><code>from_millivolts(millivolts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER  DESCRIPTION <code>millivolts</code> <p>The voltage in millivolts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_millivolts(cls, millivolts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n    Args:\n        millivolts: The voltage in millivolts.\n    Returns:\n        A new voltage quantity.\n    \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = millivolts * 10**-3\nreturn voltage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_volts","title":"from_volts  <code>classmethod</code>","text":"<pre><code>from_volts(volts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER  DESCRIPTION <code>volts</code> <p>The voltage in volts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_volts(cls, volts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n    Args:\n        volts: The voltage in volts.\n    Returns:\n        A new voltage quantity.\n    \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = volts\nreturn voltage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.isclose","title":"isclose","text":"<pre><code>isclose(\nother: Self,\nrel_tol: float = 1e-09,\nabs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n\"\"\"Return whether this quantity is close to another.\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\nreturn math.isclose(\nself._base_value,\nother._base_value,  # pylint: disable=protected-access\nrel_tol=rel_tol,\nabs_tol=abs_tol,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n\"\"\"Return whether this quantity is infinite.\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\nreturn math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n\"\"\"Return whether this quantity is NaN.\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\nreturn math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n\"\"\"Return a quantity with value 0.\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n_zero = cls._zero_cache.get(cls, None)\nif _zero is None:\n_zero = cls.__new__(cls)\n_zero._base_value = 0\ncls._zero_cache[cls] = _zero\nassert isinstance(_zero, cls)\nreturn _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/grid/","title":"grid","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid","title":"frequenz.sdk.timeseries.grid","text":"<p>Grid connection point.</p> <p>This module provides the <code>Grid</code> type, which represents a grid connection point in a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid","title":"frequenz.sdk.timeseries.grid.Grid  <code>dataclass</code>","text":"<p>A grid connection point.</p> Source code in <code>frequenz/sdk/timeseries/grid.py</code> <pre><code>@dataclass(frozen=True)\nclass Grid:\n\"\"\"A grid connection point.\"\"\"\nfuse: Fuse\n\"\"\"The fuse protecting the grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid.fuse","title":"fuse  <code>instance-attribute</code>","text":"<pre><code>fuse: Fuse\n</code></pre> <p>The fuse protecting the grid connection point.</p>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.get","title":"frequenz.sdk.timeseries.grid.get","text":"<pre><code>get() -&gt; Grid | None\n</code></pre> <p>Get the grid connection.</p> <p>Note that a microgrid configured as an island will not have a grid connection point. For such microgrids, this function will return <code>None</code>.</p> RETURNS DESCRIPTION <code>Grid | None</code> <p>The grid connection.</p> Source code in <code>frequenz/sdk/timeseries/grid.py</code> <pre><code>def get() -&gt; Grid | None:\n\"\"\"Get the grid connection.\n    Note that a microgrid configured as an island will not have a grid\n    connection point. For such microgrids, this function will return `None`.\n    Returns:\n        The grid connection.\n    \"\"\"\nreturn _GRID\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.initialize","title":"frequenz.sdk.timeseries.grid.initialize","text":"<pre><code>initialize(components: Iterable[Component]) -&gt; None\n</code></pre> <p>Initialize the grid connection.</p> PARAMETER  DESCRIPTION <code>components</code> <p>The components in the microgrid.</p> <p> TYPE: <code>Iterable[Component]</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If there is more than 1 grid connection point in the microgrid, or if the grid connection point is not initialized, or if the grid connection point does not have a fuse.</p> Source code in <code>frequenz/sdk/timeseries/grid.py</code> <pre><code>def initialize(components: Iterable[Component]) -&gt; None:\n\"\"\"Initialize the grid connection.\n    Args:\n        components: The components in the microgrid.\n    Raises:\n        RuntimeError: If there is more than 1 grid connection point in the\n            microgrid, or if the grid connection point is not initialized,\n            or if the grid connection point does not have a fuse.\n    \"\"\"\nglobal _GRID  # pylint: disable=global-statement\ngrid_connections = list(\ncomponent\nfor component in components\nif component.category == ComponentCategory.GRID\n)\ngrid_connections_count = len(grid_connections)\nif grid_connections_count == 0:\nlogging.info(\n\"No grid connection found for this microgrid. This is normal for an islanded microgrid.\"\n)\nelif grid_connections_count &gt; 1:\nraise RuntimeError(\nf\"Expected at most one grid connection, got {grid_connections_count}\"\n)\nelse:\nif grid_connections[0].metadata is None:\nraise RuntimeError(\"Grid metadata is None\")\nfuse = grid_connections[0].metadata.fuse\nif fuse is None:\nraise RuntimeError(\"Grid fuse is None\")\n_GRID = Grid(fuse)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/","title":"battery_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool","title":"frequenz.sdk.timeseries.battery_pool","text":"<p>Manage a pool of batteries.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool","title":"frequenz.sdk.timeseries.battery_pool.BatteryPool","text":"<p>An interface for interaction with pools of batteries.</p> <p>Note</p> <p><code>BatteryPool</code> instances are not meant to be created directly by users.  Use the <code>microgrid.battery_pool</code> method for creating <code>BatteryPool</code> instances.</p> Provides <ul> <li>properties for fetching reporting streams of instantaneous   power,   soc,   capacity values and   available power bounds and other status through   power_status.</li> <li>control methods for proposing power values, namely:   propose_power,   propose_charge and   propose_discharge.</li> </ul> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>class BatteryPool:\n\"\"\"An interface for interaction with pools of batteries.\n    !!! note\n        `BatteryPool` instances are not meant to be created directly by users.  Use the\n        [`microgrid.battery_pool`][frequenz.sdk.microgrid.battery_pool] method for\n        creating `BatteryPool` instances.\n    Provides:\n      - properties for fetching reporting streams of instantaneous\n        [power][frequenz.sdk.timeseries.battery_pool.BatteryPool.power],\n        [soc][frequenz.sdk.timeseries.battery_pool.BatteryPool.soc],\n        [capacity][frequenz.sdk.timeseries.battery_pool.BatteryPool.capacity] values and\n        available power bounds and other status through\n        [power_status][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status].\n      - control methods for proposing power values, namely:\n        [propose_power][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power],\n        [propose_charge][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_charge] and\n        [propose_discharge][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_discharge].\n    \"\"\"\ndef __init__(\nself,\nbattery_pool_ref: BatteryPoolReferenceStore,\nname: str | None,\npriority: int,\n):\n\"\"\"Create a BatteryPool instance.\n        !!! note\n            `BatteryPool` instances are not meant to be created directly by users.  Use\n            the [`microgrid.battery_pool`][frequenz.sdk.microgrid.battery_pool] method\n            for creating `BatteryPool` instances.\n        Args:\n            battery_pool_ref: The battery pool reference store instance.\n            name: An optional name used to identify this instance of the pool or a\n                corresponding actor in the logs.\n            priority: The priority of the actor using this wrapper.\n        \"\"\"\nself._battery_pool = battery_pool_ref\nunique_id = str(uuid.uuid4())\nself._source_id = unique_id if name is None else f\"{name}-{unique_id}\"\nself._priority = priority\nasync def propose_power(\nself,\npower: Power | None,\n*,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\nbounds: timeseries.Bounds[Power | None] = timeseries.Bounds(None, None),\n) -&gt; None:\n\"\"\"Send a proposal to the power manager for the pool's set of batteries.\n        Power values need to follow the Passive Sign Convention (PSC). That is, positive\n        values indicate charge power and negative values indicate discharge power.\n        If the same batteries are shared by multiple actors, the power manager will\n        consider the priority of the actors, the bounds they set, and their preferred\n        power, when calculating the target power for the batteries.\n        The preferred power of lower priority actors will take precedence as long as\n        they respect the bounds set by higher priority actors.  If lower priority actors\n        request power values outside of the bounds set by higher priority actors, the\n        target power will be the closest value to the preferred power that is within the\n        bounds.\n        When there are no other actors trying to use the same batteries, the actor's\n        preferred power would be set as the target power, as long as it falls within the\n        system power bounds for the batteries.\n        The result of the request can be accessed using the receiver returned from the\n        [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n        method, which also streams the bounds that an actor should comply with, based on\n        its priority.\n        Args:\n            power: The power to propose for the batteries in the pool.  If `None`, this\n                proposal will not have any effect on the target power, unless bounds are\n                specified.  If both are `None`, it is equivalent to not having a\n                proposal or withdrawing a previous one.\n            request_timeout: The timeout for the request.\n            bounds: The power bounds for the proposal.  These bounds will apply to\n                actors with a lower priority, and can be overridden by bounds from\n                actors with a higher priority.  If None, the power bounds will be set\n                to the maximum power of the batteries in the pool.  This is currently\n                and experimental feature.\n        \"\"\"\nawait self._battery_pool._power_manager_requests_sender.send(\n_power_managing.Proposal(\nsource_id=self._source_id,\npreferred_power=power,\nbounds=bounds,\nbattery_ids=self._battery_pool._batteries,\npriority=self._priority,\nrequest_timeout=request_timeout,\n)\n)\nasync def propose_charge(\nself,\npower: Power | None,\n*,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\n) -&gt; None:\n\"\"\"Set the given charge power for the batteries in the pool.\n        Power values need to be positive values, indicating charge power.\n        When using the Passive Sign Convention, the\n        [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n        method might be more convenient.\n        If the same batteries are shared by multiple actors, the behaviour is the same\n        as that of the `propose_power` method.  The bounds for lower priority actors\n        can't be specified with this method.  If that's required, use the\n        `propose_power` method instead.\n        The result of the request can be accessed using the receiver returned from the\n        [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n        method.\n        Args:\n            power: The unsigned charge power to propose for the batteries in the pool.\n                If None, the proposed power of higher priority actors will take\n                precedence as the target power.\n            request_timeout: The timeout for the request.\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\nif power and power &lt; Power.zero():\nraise ValueError(\"Charge power must be positive.\")\nawait self._battery_pool._power_manager_requests_sender.send(\n_power_managing.Proposal(\nsource_id=self._source_id,\npreferred_power=power,\nbounds=timeseries.Bounds(None, None),\nbattery_ids=self._battery_pool._batteries,\npriority=self._priority,\nrequest_timeout=request_timeout,\n)\n)\nasync def propose_discharge(\nself,\npower: Power | None,\n*,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\n) -&gt; None:\n\"\"\"Set the given discharge power for the batteries in the pool.\n        Power values need to be positive values, indicating discharge power.\n        When using the Passive Sign Convention, the\n        [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n        method might be more convenient.\n        If the same batteries are shared by multiple actors, the behaviour is the same\n        as that of the `propose_power` method.  The bounds for lower priority actors\n        can't be specified with this method.  If that's required, use the\n        `propose_power` method instead.\n        The result of the request can be accessed using the receiver returned from the\n        [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n        method.\n        Args:\n            power: The unsigned discharge power to propose for the batteries in the\n                pool.  If None, the proposed power of higher priority actors will take\n                precedence as the target power.\n            request_timeout: The timeout for the request.\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\nif power and power &lt; Power.zero():\nraise ValueError(\"Discharge power must be positive.\")\nawait self._battery_pool._power_manager_requests_sender.send(\n_power_managing.Proposal(\nsource_id=self._source_id,\npreferred_power=power,\nbounds=timeseries.Bounds(None, None),\nbattery_ids=self._battery_pool._batteries,\npriority=self._priority,\nrequest_timeout=request_timeout,\n)\n)\n@property\ndef battery_ids(self) -&gt; abc.Set[int]:\n\"\"\"Return ids of the batteries in the pool.\n        Returns:\n            Ids of the batteries in the pool\n        \"\"\"\nreturn self._battery_pool._batteries\n@property\ndef power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the total power of the batteries in the pool.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all\n                batteries in the pool.\n        \"\"\"\nengine = self._battery_pool._formula_pool.from_power_formula_generator(\n\"battery_pool_power\",\nBatteryPowerFormula,\nFormulaGeneratorConfig(\ncomponent_ids=self._battery_pool._batteries,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef soc(self) -&gt; ReceiverFetcher[Sample[Percentage]]:\n\"\"\"Fetch the normalized average weighted-by-capacity SoC values for the pool.\n        The SoC values are normalized to the 0-100% range and clamped if they are out\n        of bounds. Only values from working batteries with operational inverters are\n        considered in the calculation.\n        Average SoC is calculated using the formula:\n        ```\n        working_batteries: Set[BatteryData] # working batteries from the battery pool\n        soc_scaled = min(max(\n            0,\n            (soc - soc_lower_bound) / (soc_upper_bound - soc_lower_bound) * 100,\n        ), 100)\n        used_capacity = sum(\n            battery.usable_capacity * battery.soc_scaled\n            for battery in working_batteries\n        )\n        total_capacity = sum(battery.usable_capacity for battery in working_batteries)\n        average_soc = used_capacity/total_capacity\n        ```\n        `None` values will be sent if there are no working batteries with operational\n        inverters to calculate the metric with.\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n        Returns:\n            A MetricAggregator that will calculate and stream the aggregate SoC of all\n                batteries in the pool, considering only working batteries with\n                operational inverters.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + SoCCalculator.name()\nif method_name not in self._battery_pool._active_methods:\ncalculator = SoCCalculator(self._battery_pool._batteries)\nself._battery_pool._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._battery_pool._working_batteries,\nmin_update_interval=self._battery_pool._min_update_interval,\n)\nreturn self._battery_pool._active_methods[method_name]\n@property\ndef temperature(self) -&gt; ReceiverFetcher[Sample[Temperature]]:\n\"\"\"Fetch the average temperature of the batteries in the pool.\n        Returns:\n            A MetricAggregator that will calculate and stream the average temperature\n                of all batteries in the pool.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + TemperatureCalculator.name()\nif method_name not in self._battery_pool._active_methods:\ncalculator = TemperatureCalculator(self._battery_pool._batteries)\nself._battery_pool._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._battery_pool._working_batteries,\nmin_update_interval=self._battery_pool._min_update_interval,\n)\nreturn self._battery_pool._active_methods[method_name]\n@property\ndef capacity(self) -&gt; ReceiverFetcher[Sample[Energy]]:\n\"\"\"Get a receiver to receive new capacity metrics when they change.\n        The reported capacity values consider only working batteries with operational\n        inverters.\n        Calculated with the formula:\n        ```\n        working_batteries: Set[BatteryData] # working batteries from the battery pool\n        total_capacity = sum(\n            battery.capacity * (soc_upper_bound - soc_lower_bound) / 100\n            for battery in working_batteries\n        )\n        ```\n        `None` will be sent if there are no working batteries with operational\n        inverters to calculate metrics.\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n        Returns:\n            A MetricAggregator that will calculate and stream the capacity of all\n                batteries in the pool, considering only working batteries with\n                operational inverters.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + CapacityCalculator.name()\nif method_name not in self._battery_pool._active_methods:\ncalculator = CapacityCalculator(self._battery_pool._batteries)\nself._battery_pool._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._battery_pool._working_batteries,\nmin_update_interval=self._battery_pool._min_update_interval,\n)\nreturn self._battery_pool._active_methods[method_name]\n@property\ndef power_status(self) -&gt; ReceiverFetcher[_power_managing.Report]:\n\"\"\"Get a receiver to receive new power status reports when they change.\n        These include\n          - the current inclusion/exclusion bounds available for the pool's priority,\n          - the current target power for the pool's set of batteries,\n          - the result of the last distribution request for the pool's set of batteries.\n        Returns:\n            A receiver that will stream power status reports for the pool's priority.\n        \"\"\"\nsub = _power_managing.ReportRequest(\nsource_id=self._source_id,\npriority=self._priority,\nbattery_ids=self._battery_pool._batteries,\n)\nself._battery_pool._power_bounds_subs[\nsub.get_channel_name()\n] = asyncio.create_task(\nself._battery_pool._power_manager_bounds_subscription_sender.send(sub)\n)\nself._battery_pool._channel_registry.set_resend_latest(\nsub.get_channel_name(), True\n)\nreturn self._battery_pool._channel_registry.new_receiver_fetcher(\nsub.get_channel_name()\n)\n@property\ndef _system_power_bounds(self) -&gt; ReceiverFetcher[PowerMetrics]:\n\"\"\"Get receiver to receive new power bounds when they change.\n        Power bounds refer to the min and max power that a battery can\n        discharge or charge at and is also denoted as SoP.\n        Power bounds formulas are described in the receiver return type.\n        None will be send if there is no component to calculate metrics.\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n        Returns:\n            A MetricAggregator that will calculate and stream the power bounds\n                of all batteries in the pool.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + PowerBoundsCalculator.name()\nif method_name not in self._battery_pool._active_methods:\ncalculator = PowerBoundsCalculator(self._battery_pool._batteries)\nself._battery_pool._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._battery_pool._working_batteries,\nmin_update_interval=self._battery_pool._min_update_interval,\n)\nreturn self._battery_pool._active_methods[method_name]\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.battery_ids","title":"battery_ids  <code>property</code>","text":"<pre><code>battery_ids: abc.Set[int]\n</code></pre> <p>Return ids of the batteries in the pool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Ids of the batteries in the pool</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.capacity","title":"capacity  <code>property</code>","text":"<pre><code>capacity: ReceiverFetcher[Sample[Energy]]\n</code></pre> <p>Get a receiver to receive new capacity metrics when they change.</p> <p>The reported capacity values consider only working batteries with operational inverters.</p> <p>Calculated with the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\ntotal_capacity = sum(\n    battery.capacity * (soc_upper_bound - soc_lower_bound) / 100\n    for battery in working_batteries\n)\n</code></pre></p> <p><code>None</code> will be sent if there are no working batteries with operational inverters to calculate metrics.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Sample[Energy]]</code> <p>A MetricAggregator that will calculate and stream the capacity of all batteries in the pool, considering only working batteries with operational inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the total power of the batteries in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status","title":"power_status  <code>property</code>","text":"<pre><code>power_status: ReceiverFetcher[_power_managing.Report]\n</code></pre> <p>Get a receiver to receive new power status reports when they change.</p> <p>These include   - the current inclusion/exclusion bounds available for the pool's priority,   - the current target power for the pool's set of batteries,   - the result of the last distribution request for the pool's set of batteries.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Report]</code> <p>A receiver that will stream power status reports for the pool's priority.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.soc","title":"soc  <code>property</code>","text":"<pre><code>soc: ReceiverFetcher[Sample[Percentage]]\n</code></pre> <p>Fetch the normalized average weighted-by-capacity SoC values for the pool.</p> <p>The SoC values are normalized to the 0-100% range and clamped if they are out of bounds. Only values from working batteries with operational inverters are considered in the calculation.</p> <p>Average SoC is calculated using the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\n\nsoc_scaled = min(max(\n    0,\n    (soc - soc_lower_bound) / (soc_upper_bound - soc_lower_bound) * 100,\n), 100)\nused_capacity = sum(\n    battery.usable_capacity * battery.soc_scaled\n    for battery in working_batteries\n)\ntotal_capacity = sum(battery.usable_capacity for battery in working_batteries)\naverage_soc = used_capacity/total_capacity\n</code></pre></p> <p><code>None</code> values will be sent if there are no working batteries with operational inverters to calculate the metric with.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Sample[Percentage]]</code> <p>A MetricAggregator that will calculate and stream the aggregate SoC of all batteries in the pool, considering only working batteries with operational inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.temperature","title":"temperature  <code>property</code>","text":"<pre><code>temperature: ReceiverFetcher[Sample[Temperature]]\n</code></pre> <p>Fetch the average temperature of the batteries in the pool.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Sample[Temperature]]</code> <p>A MetricAggregator that will calculate and stream the average temperature of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.__init__","title":"__init__","text":"<pre><code>__init__(\nbattery_pool_ref: BatteryPoolReferenceStore,\nname: str | None,\npriority: int,\n)\n</code></pre> <p>Create a BatteryPool instance.</p> <p>Note</p> <p><code>BatteryPool</code> instances are not meant to be created directly by users.  Use the <code>microgrid.battery_pool</code> method for creating <code>BatteryPool</code> instances.</p> PARAMETER  DESCRIPTION <code>battery_pool_ref</code> <p>The battery pool reference store instance.</p> <p> TYPE: <code>BatteryPoolReferenceStore</code> </p> <code>name</code> <p>An optional name used to identify this instance of the pool or a corresponding actor in the logs.</p> <p> TYPE: <code>str | None</code> </p> <code>priority</code> <p>The priority of the actor using this wrapper.</p> <p> TYPE: <code>int</code> </p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>def __init__(\nself,\nbattery_pool_ref: BatteryPoolReferenceStore,\nname: str | None,\npriority: int,\n):\n\"\"\"Create a BatteryPool instance.\n    !!! note\n        `BatteryPool` instances are not meant to be created directly by users.  Use\n        the [`microgrid.battery_pool`][frequenz.sdk.microgrid.battery_pool] method\n        for creating `BatteryPool` instances.\n    Args:\n        battery_pool_ref: The battery pool reference store instance.\n        name: An optional name used to identify this instance of the pool or a\n            corresponding actor in the logs.\n        priority: The priority of the actor using this wrapper.\n    \"\"\"\nself._battery_pool = battery_pool_ref\nunique_id = str(uuid.uuid4())\nself._source_id = unique_id if name is None else f\"{name}-{unique_id}\"\nself._priority = priority\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_charge","title":"propose_charge  <code>async</code>","text":"<pre><code>propose_charge(\npower: Power | None,\n*,\nrequest_timeout: timedelta = timedelta(seconds=5.0)\n) -&gt; None\n</code></pre> <p>Set the given charge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating charge power.</p> <p>When using the Passive Sign Convention, the <code>propose_power</code> method might be more convenient.</p> <p>If the same batteries are shared by multiple actors, the behaviour is the same as that of the <code>propose_power</code> method.  The bounds for lower priority actors can't be specified with this method.  If that's required, use the <code>propose_power</code> method instead.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_status</code> method.</p> PARAMETER  DESCRIPTION <code>power</code> <p>The unsigned charge power to propose for the batteries in the pool. If None, the proposed power of higher priority actors will take precedence as the target power.</p> <p> TYPE: <code>Power | None</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>async def propose_charge(\nself,\npower: Power | None,\n*,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\n) -&gt; None:\n\"\"\"Set the given charge power for the batteries in the pool.\n    Power values need to be positive values, indicating charge power.\n    When using the Passive Sign Convention, the\n    [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n    method might be more convenient.\n    If the same batteries are shared by multiple actors, the behaviour is the same\n    as that of the `propose_power` method.  The bounds for lower priority actors\n    can't be specified with this method.  If that's required, use the\n    `propose_power` method instead.\n    The result of the request can be accessed using the receiver returned from the\n    [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n    method.\n    Args:\n        power: The unsigned charge power to propose for the batteries in the pool.\n            If None, the proposed power of higher priority actors will take\n            precedence as the target power.\n        request_timeout: The timeout for the request.\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\nif power and power &lt; Power.zero():\nraise ValueError(\"Charge power must be positive.\")\nawait self._battery_pool._power_manager_requests_sender.send(\n_power_managing.Proposal(\nsource_id=self._source_id,\npreferred_power=power,\nbounds=timeseries.Bounds(None, None),\nbattery_ids=self._battery_pool._batteries,\npriority=self._priority,\nrequest_timeout=request_timeout,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_discharge","title":"propose_discharge  <code>async</code>","text":"<pre><code>propose_discharge(\npower: Power | None,\n*,\nrequest_timeout: timedelta = timedelta(seconds=5.0)\n) -&gt; None\n</code></pre> <p>Set the given discharge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating discharge power.</p> <p>When using the Passive Sign Convention, the <code>propose_power</code> method might be more convenient.</p> <p>If the same batteries are shared by multiple actors, the behaviour is the same as that of the <code>propose_power</code> method.  The bounds for lower priority actors can't be specified with this method.  If that's required, use the <code>propose_power</code> method instead.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_status</code> method.</p> PARAMETER  DESCRIPTION <code>power</code> <p>The unsigned discharge power to propose for the batteries in the pool.  If None, the proposed power of higher priority actors will take precedence as the target power.</p> <p> TYPE: <code>Power | None</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>async def propose_discharge(\nself,\npower: Power | None,\n*,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\n) -&gt; None:\n\"\"\"Set the given discharge power for the batteries in the pool.\n    Power values need to be positive values, indicating discharge power.\n    When using the Passive Sign Convention, the\n    [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n    method might be more convenient.\n    If the same batteries are shared by multiple actors, the behaviour is the same\n    as that of the `propose_power` method.  The bounds for lower priority actors\n    can't be specified with this method.  If that's required, use the\n    `propose_power` method instead.\n    The result of the request can be accessed using the receiver returned from the\n    [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n    method.\n    Args:\n        power: The unsigned discharge power to propose for the batteries in the\n            pool.  If None, the proposed power of higher priority actors will take\n            precedence as the target power.\n        request_timeout: The timeout for the request.\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\nif power and power &lt; Power.zero():\nraise ValueError(\"Discharge power must be positive.\")\nawait self._battery_pool._power_manager_requests_sender.send(\n_power_managing.Proposal(\nsource_id=self._source_id,\npreferred_power=power,\nbounds=timeseries.Bounds(None, None),\nbattery_ids=self._battery_pool._batteries,\npriority=self._priority,\nrequest_timeout=request_timeout,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power","title":"propose_power  <code>async</code>","text":"<pre><code>propose_power(\npower: Power | None,\n*,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\nbounds: timeseries.Bounds[\nPower | None\n] = timeseries.Bounds(None, None)\n) -&gt; None\n</code></pre> <p>Send a proposal to the power manager for the pool's set of batteries.</p> <p>Power values need to follow the Passive Sign Convention (PSC). That is, positive values indicate charge power and negative values indicate discharge power.</p> <p>If the same batteries are shared by multiple actors, the power manager will consider the priority of the actors, the bounds they set, and their preferred power, when calculating the target power for the batteries.</p> <p>The preferred power of lower priority actors will take precedence as long as they respect the bounds set by higher priority actors.  If lower priority actors request power values outside of the bounds set by higher priority actors, the target power will be the closest value to the preferred power that is within the bounds.</p> <p>When there are no other actors trying to use the same batteries, the actor's preferred power would be set as the target power, as long as it falls within the system power bounds for the batteries.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_status</code> method, which also streams the bounds that an actor should comply with, based on its priority.</p> PARAMETER  DESCRIPTION <code>power</code> <p>The power to propose for the batteries in the pool.  If <code>None</code>, this proposal will not have any effect on the target power, unless bounds are specified.  If both are <code>None</code>, it is equivalent to not having a proposal or withdrawing a previous one.</p> <p> TYPE: <code>Power | None</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>bounds</code> <p>The power bounds for the proposal.  These bounds will apply to actors with a lower priority, and can be overridden by bounds from actors with a higher priority.  If None, the power bounds will be set to the maximum power of the batteries in the pool.  This is currently and experimental feature.</p> <p> TYPE: <code>Bounds[Power | None]</code> DEFAULT: <code>Bounds(None, None)</code> </p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>async def propose_power(\nself,\npower: Power | None,\n*,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\nbounds: timeseries.Bounds[Power | None] = timeseries.Bounds(None, None),\n) -&gt; None:\n\"\"\"Send a proposal to the power manager for the pool's set of batteries.\n    Power values need to follow the Passive Sign Convention (PSC). That is, positive\n    values indicate charge power and negative values indicate discharge power.\n    If the same batteries are shared by multiple actors, the power manager will\n    consider the priority of the actors, the bounds they set, and their preferred\n    power, when calculating the target power for the batteries.\n    The preferred power of lower priority actors will take precedence as long as\n    they respect the bounds set by higher priority actors.  If lower priority actors\n    request power values outside of the bounds set by higher priority actors, the\n    target power will be the closest value to the preferred power that is within the\n    bounds.\n    When there are no other actors trying to use the same batteries, the actor's\n    preferred power would be set as the target power, as long as it falls within the\n    system power bounds for the batteries.\n    The result of the request can be accessed using the receiver returned from the\n    [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n    method, which also streams the bounds that an actor should comply with, based on\n    its priority.\n    Args:\n        power: The power to propose for the batteries in the pool.  If `None`, this\n            proposal will not have any effect on the target power, unless bounds are\n            specified.  If both are `None`, it is equivalent to not having a\n            proposal or withdrawing a previous one.\n        request_timeout: The timeout for the request.\n        bounds: The power bounds for the proposal.  These bounds will apply to\n            actors with a lower priority, and can be overridden by bounds from\n            actors with a higher priority.  If None, the power bounds will be set\n            to the maximum power of the batteries in the pool.  This is currently\n            and experimental feature.\n    \"\"\"\nawait self._battery_pool._power_manager_requests_sender.send(\n_power_managing.Proposal(\nsource_id=self._source_id,\npreferred_power=power,\nbounds=bounds,\nbattery_ids=self._battery_pool._batteries,\npriority=self._priority,\nrequest_timeout=request_timeout,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics","title":"frequenz.sdk.timeseries.battery_pool.PowerMetrics  <code>dataclass</code>","text":"<p>Power bounds metrics.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_result_types.py</code> <pre><code>@dataclass\nclass PowerMetrics:\n\"\"\"Power bounds metrics.\"\"\"\n# compare = False tells the dataclass to not use name for comparison methods\ntimestamp: datetime = field(compare=False)\n\"\"\"Timestamp of the metrics.\"\"\"\n# pylint: disable=line-too-long\ninclusion_bounds: _base_types.Bounds[Power] | None\n\"\"\"Inclusion power bounds for all batteries in the battery pool instance.\n    This is the range within which power requests are allowed by the battery pool.\n    When exclusion bounds are present, they will exclude a subset of the inclusion\n    bounds.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\nexclusion_bounds: _base_types.Bounds[Power] | None\n\"\"\"Exclusion power bounds for all batteries in the battery pool instance.\n    This is the range within which power requests are NOT allowed by the battery pool.\n    If present, they will be a subset of the inclusion bounds.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics.exclusion_bounds","title":"exclusion_bounds  <code>instance-attribute</code>","text":"<pre><code>exclusion_bounds: _base_types.Bounds[Power] | None\n</code></pre> <p>Exclusion power bounds for all batteries in the battery pool instance.</p> <p>This is the range within which power requests are NOT allowed by the battery pool. If present, they will be a subset of the inclusion bounds.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics.inclusion_bounds","title":"inclusion_bounds  <code>instance-attribute</code>","text":"<pre><code>inclusion_bounds: _base_types.Bounds[Power] | None\n</code></pre> <p>Inclusion power bounds for all batteries in the battery pool instance.</p> <p>This is the range within which power requests are allowed by the battery pool.</p> <p>When exclusion bounds are present, they will exclude a subset of the inclusion bounds.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics.timestamp","title":"timestamp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime = field(compare=False)\n</code></pre> <p>Timestamp of the metrics.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Report","title":"frequenz.sdk.timeseries.battery_pool.Report  <code>dataclass</code>","text":"<p>Current PowerManager report for a set of batteries.</p> Source code in <code>frequenz/sdk/actor/_power_managing/_base_classes.py</code> <pre><code>@dataclasses.dataclass(frozen=True, kw_only=True)\nclass Report:\n\"\"\"Current PowerManager report for a set of batteries.\"\"\"\ntarget_power: Power | None\n\"\"\"The currently set power for the batteries.\"\"\"\ndistribution_result: power_distributing.Result | None\n\"\"\"The result of the last power distribution.\n    This is `None` if no power distribution has been performed yet.\n    \"\"\"\n_inclusion_bounds: timeseries.Bounds[Power] | None\n\"\"\"The available inclusion bounds for the batteries, for the actor's priority.\n    These bounds are adjusted to any restrictions placed by actors with higher\n    priorities.\n    \"\"\"\n_exclusion_bounds: timeseries.Bounds[Power] | None\n\"\"\"The exclusion bounds for the batteries.\n    The power manager doesn't manage exclusion bounds, so these are aggregations of\n    values reported by the microgrid API.\n    These bounds are adjusted to any restrictions placed by actors with higher\n    priorities.\n    \"\"\"\n@property\ndef bounds(self) -&gt; timeseries.Bounds[Power] | None:\n\"\"\"The bounds for the batteries.\n        These bounds are adjusted to any restrictions placed by actors with higher\n        priorities.\n        There might be exclusion zones within these bounds. If necessary, the\n        [`adjust_to_bounds`][frequenz.sdk.timeseries.battery_pool.Report.adjust_to_bounds]\n        method may be used to check if a desired power value fits the bounds, or to get\n        the closest possible power values that do fit the bounds.\n        \"\"\"\nreturn self._inclusion_bounds\ndef adjust_to_bounds(self, power: Power) -&gt; tuple[Power | None, Power | None]:\n\"\"\"Adjust a power value to the bounds.\n        This method can be used to adjust a desired power value to the power bounds\n        available to the actor.\n        If the given power value falls within the usable bounds, it will be returned\n        unchanged.\n        If it falls outside the usable bounds, the closest possible value on the\n        corresponding side will be returned.  For example, if the given power is lower\n        than the lowest usable power, only the lowest usable power will be returned, and\n        similarly for the highest usable power.\n        If the given power falls within an exclusion zone that's contained within the\n        usable bounds, the closest possible power values on both sides will be returned.\n        !!! note\n            It is completely optional to use this method to adjust power values before\n            proposing them through the battery pool, because the battery pool will do\n            this automatically.  This method is provided for convenience, and for\n            granular control when there are two possible power values, both of which\n            fall within the available bounds.\n        Example:\n            ```python\n            from frequenz.sdk import microgrid\n            power_status_rx = microgrid.battery_pool().power_status.new_receiver()\n            power_status = await power_status_rx.receive()\n            desired_power = Power.from_watts(1000.0)\n            match power_status.adjust_to_bounds(desired_power):\n                case (power, _) if power == desired_power:\n                    print(\"Desired power is available.\")\n                case (None, power) | (power, None) if power:\n                    print(f\"Closest available power is {power}.\")\n                case (lower, upper) if lower and upper:\n                    print(f\"Two options {lower}, {upper} to propose to battery pool.\")\n                case (None, None):\n                    print(\"No available power\")\n            ```\n        Args:\n            power: The power value to adjust.\n        Returns:\n            A tuple of the closest power values to the desired power that fall within\n                the available bounds for the actor.\n        \"\"\"\nif self._inclusion_bounds is None:\nreturn None, None\nreturn _bounds.clamp_to_bounds(\npower,\nself._inclusion_bounds.lower,\nself._inclusion_bounds.upper,\nself._exclusion_bounds,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Report-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Report.bounds","title":"bounds  <code>property</code>","text":"<pre><code>bounds: timeseries.Bounds[Power] | None\n</code></pre> <p>The bounds for the batteries.</p> <p>These bounds are adjusted to any restrictions placed by actors with higher priorities.</p> <p>There might be exclusion zones within these bounds. If necessary, the <code>adjust_to_bounds</code> method may be used to check if a desired power value fits the bounds, or to get the closest possible power values that do fit the bounds.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Report.distribution_result","title":"distribution_result  <code>instance-attribute</code>","text":"<pre><code>distribution_result: power_distributing.Result | None\n</code></pre> <p>The result of the last power distribution.</p> <p>This is <code>None</code> if no power distribution has been performed yet.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Report.target_power","title":"target_power  <code>instance-attribute</code>","text":"<pre><code>target_power: Power | None\n</code></pre> <p>The currently set power for the batteries.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Report-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Report.adjust_to_bounds","title":"adjust_to_bounds","text":"<pre><code>adjust_to_bounds(\npower: Power,\n) -&gt; tuple[Power | None, Power | None]\n</code></pre> <p>Adjust a power value to the bounds.</p> <p>This method can be used to adjust a desired power value to the power bounds available to the actor.</p> <p>If the given power value falls within the usable bounds, it will be returned unchanged.</p> <p>If it falls outside the usable bounds, the closest possible value on the corresponding side will be returned.  For example, if the given power is lower than the lowest usable power, only the lowest usable power will be returned, and similarly for the highest usable power.</p> <p>If the given power falls within an exclusion zone that's contained within the usable bounds, the closest possible power values on both sides will be returned.</p> <p>Note</p> <p>It is completely optional to use this method to adjust power values before proposing them through the battery pool, because the battery pool will do this automatically.  This method is provided for convenience, and for granular control when there are two possible power values, both of which fall within the available bounds.</p> Example <pre><code>from frequenz.sdk import microgrid\npower_status_rx = microgrid.battery_pool().power_status.new_receiver()\npower_status = await power_status_rx.receive()\ndesired_power = Power.from_watts(1000.0)\nmatch power_status.adjust_to_bounds(desired_power):\ncase (power, _) if power == desired_power:\nprint(\"Desired power is available.\")\ncase (None, power) | (power, None) if power:\nprint(f\"Closest available power is {power}.\")\ncase (lower, upper) if lower and upper:\nprint(f\"Two options {lower}, {upper} to propose to battery pool.\")\ncase (None, None):\nprint(\"No available power\")\n</code></pre> PARAMETER  DESCRIPTION <code>power</code> <p>The power value to adjust.</p> <p> TYPE: <code>Power</code> </p> RETURNS DESCRIPTION <code>tuple[Power | None, Power | None]</code> <p>A tuple of the closest power values to the desired power that fall within the available bounds for the actor.</p> Source code in <code>frequenz/sdk/actor/_power_managing/_base_classes.py</code> <pre><code>def adjust_to_bounds(self, power: Power) -&gt; tuple[Power | None, Power | None]:\n\"\"\"Adjust a power value to the bounds.\n    This method can be used to adjust a desired power value to the power bounds\n    available to the actor.\n    If the given power value falls within the usable bounds, it will be returned\n    unchanged.\n    If it falls outside the usable bounds, the closest possible value on the\n    corresponding side will be returned.  For example, if the given power is lower\n    than the lowest usable power, only the lowest usable power will be returned, and\n    similarly for the highest usable power.\n    If the given power falls within an exclusion zone that's contained within the\n    usable bounds, the closest possible power values on both sides will be returned.\n    !!! note\n        It is completely optional to use this method to adjust power values before\n        proposing them through the battery pool, because the battery pool will do\n        this automatically.  This method is provided for convenience, and for\n        granular control when there are two possible power values, both of which\n        fall within the available bounds.\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n        power_status_rx = microgrid.battery_pool().power_status.new_receiver()\n        power_status = await power_status_rx.receive()\n        desired_power = Power.from_watts(1000.0)\n        match power_status.adjust_to_bounds(desired_power):\n            case (power, _) if power == desired_power:\n                print(\"Desired power is available.\")\n            case (None, power) | (power, None) if power:\n                print(f\"Closest available power is {power}.\")\n            case (lower, upper) if lower and upper:\n                print(f\"Two options {lower}, {upper} to propose to battery pool.\")\n            case (None, None):\n                print(\"No available power\")\n        ```\n    Args:\n        power: The power value to adjust.\n    Returns:\n        A tuple of the closest power values to the desired power that fall within\n            the available bounds for the actor.\n    \"\"\"\nif self._inclusion_bounds is None:\nreturn None, None\nreturn _bounds.clamp_to_bounds(\npower,\nself._inclusion_bounds.lower,\nself._inclusion_bounds.upper,\nself._exclusion_bounds,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/","title":"ev_charger_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool","title":"frequenz.sdk.timeseries.ev_charger_pool","text":"<p>Interactions with EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit","title":"frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit  <code>dataclass</code>","text":"<p>A current limit, to be sent to the EV Charger.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_set_current_bounds.py</code> <pre><code>@dataclass\nclass ComponentCurrentLimit:\n\"\"\"A current limit, to be sent to the EV Charger.\"\"\"\ncomponent_id: int\n\"\"\"The component ID of the EV Charger.\"\"\"\nmax_amps: float\n\"\"\"The maximum current in amps, that an EV can draw from this EV Charger.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The component ID of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit.max_amps","title":"max_amps  <code>instance-attribute</code>","text":"<pre><code>max_amps: float\n</code></pre> <p>The maximum current in amps, that an EV can draw from this EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData","title":"frequenz.sdk.timeseries.ev_charger_pool.EVChargerData  <code>dataclass</code>","text":"<p>Data for an EV Charger, including the 3-phase current and the component state.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>@dataclass(frozen=True)\nclass EVChargerData:\n\"\"\"Data for an EV Charger, including the 3-phase current and the component state.\"\"\"\ncomponent_id: int\n\"\"\"The component ID of the EV Charger.\"\"\"\ncurrent: Sample3Phase[Current]\n\"\"\"The 3-phase current of the EV Charger.\"\"\"\nstate: EVChargerState\n\"\"\"The state of the EV Charger.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The component ID of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData.current","title":"current  <code>instance-attribute</code>","text":"<pre><code>current: Sample3Phase[Current]\n</code></pre> <p>The 3-phase current of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: EVChargerState\n</code></pre> <p>The state of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool","title":"frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool","text":"<p>An interface for interaction with pools of EV Chargers.</p> <p>Note</p> <p><code>EVChargerPool</code> instances are not meant to be created directly by users. Use the <code>microgrid.ev_charger_pool</code> method for creating <code>EVChargerPool</code> instances.</p> Provides <ul> <li>Aggregate <code>power</code>   and 3-phase   <code>current</code>   measurements of the EV Chargers in the pool.</li> <li>The   <code>component_data</code>   method for fetching the 3-phase current and state of individual EV Chargers in   the pool.</li> <li>The   <code>set_bounds</code>   method for limiting the max current of individual EV Chargers in the pool.</li> </ul> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>class EVChargerPool:\n\"\"\"An interface for interaction with pools of EV Chargers.\n    !!! note\n        `EVChargerPool` instances are not meant to be created directly by users. Use the\n        [`microgrid.ev_charger_pool`][frequenz.sdk.microgrid.ev_charger_pool] method for\n        creating `EVChargerPool` instances.\n    Provides:\n      - Aggregate [`power`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.power]\n        and 3-phase\n        [`current`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.current]\n        measurements of the EV Chargers in the pool.\n      - The\n        [`component_data`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.component_data]\n        method for fetching the 3-phase current and state of individual EV Chargers in\n        the pool.\n      - The\n        [`set_bounds`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.set_bounds]\n        method for limiting the max current of individual EV Chargers in the pool.\n    \"\"\"\ndef __init__(\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\ncomponent_ids: set[int] | None = None,\nrepeat_interval: timedelta = timedelta(seconds=3.0),\n) -&gt; None:\n\"\"\"Create an `EVChargerPool` instance.\n        !!! note\n            `EVChargerPool` instances are not meant to be created directly by users. Use\n            the [`microgrid.ev_charger_pool`][frequenz.sdk.microgrid.ev_charger_pool]\n            method for creating `EVChargerPool` instances.\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n            component_ids: An optional list of component_ids belonging to this pool.  If\n                not specified, IDs of all EV Chargers in the microgrid will be fetched\n                from the component graph.\n            repeat_interval: Interval after which to repeat the last set bounds to the\n                microgrid API, if no new calls to `set_bounds` have been made.\n        \"\"\"\nself._channel_registry: ChannelRegistry = channel_registry\nself._repeat_interval = repeat_interval\nself._resampler_subscription_sender: Sender[\nComponentMetricRequest\n] = resampler_subscription_sender\nself._component_ids: set[int] = set()\nif component_ids is not None:\nself._component_ids = component_ids\nelse:\ngraph = connection_manager.get().component_graph\nself._component_ids = {\nevc.component_id\nfor evc in graph.components(\ncomponent_category={ComponentCategory.EV_CHARGER}\n)\n}\nself._state_tracker: StateTracker | None = None\nself._status_streams: dict[\nint, tuple[Task[None], Broadcast[EVChargerData]]\n] = {}\nself._namespace: str = f\"ev-charger-pool-{uuid.uuid4()}\"\nself._formula_pool: FormulaEnginePool = FormulaEnginePool(\nself._namespace,\nself._channel_registry,\nself._resampler_subscription_sender,\n)\nself._bounds_setter: BoundsSetter | None = None\n@property\ndef component_ids(self) -&gt; abc.Set[int]:\n\"\"\"Return component IDs of all EV Chargers managed by this EVChargerPool.\n        Returns:\n            Set of managed component IDs.\n        \"\"\"\nreturn self._component_ids\n@property\ndef current(self) -&gt; FormulaEngine3Phase[Current]:\n\"\"\"Fetch the total current for the EV Chargers in the pool.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate EV Charger current is not already running, it\n        will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the total current of all EV\n                Chargers.\n        \"\"\"\nengine = self._formula_pool.from_3_phase_current_formula_generator(\n\"ev_charger_total_current\",\nEVChargerCurrentFormula,\nFormulaGeneratorConfig(component_ids=self._component_ids),\n)\nassert isinstance(engine, FormulaEngine3Phase)\nreturn engine\n@property\ndef power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the total power for the EV Chargers in the pool.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate EV Charger power is not already running, it\n        will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all EV\n                Chargers.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"ev_charger_power\",\nEVChargerPowerFormula,\nFormulaGeneratorConfig(\ncomponent_ids=self._component_ids,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\ndef component_data(self, component_id: int) -&gt; Receiver[EVChargerData]:\n\"\"\"Stream 3-phase current values and state of an EV Charger.\n        Args:\n            component_id: id of the EV Charger for which data is requested.\n        Returns:\n            A receiver that streams objects containing 3-phase current and state of\n                an EV Charger.\n        \"\"\"\nif recv := self._status_streams.get(component_id, None):\ntask, output_chan = recv\nif not task.done():\nreturn output_chan.new_receiver()\n_logger.warning(\"Restarting component_status for id: %s\", component_id)\nelse:\noutput_chan = Broadcast[EVChargerData](\nf\"evpool-component_status-{component_id}\"\n)\ntask = asyncio.create_task(\nself._stream_component_data(component_id, output_chan.new_sender())\n)\nself._status_streams[component_id] = (task, output_chan)\nreturn output_chan.new_receiver()\nasync def set_bounds(self, component_id: int, max_current: Current) -&gt; None:\n\"\"\"Send given max current bound for the given EV Charger to the microgrid API.\n        Bounds are used to limit the max current drawn by an EV, although the exact\n        value will be determined by the EV.\n        Args:\n            component_id: ID of EV Charger to set the current bounds to.\n            max_current: maximum current that an EV can draw from this EV Charger.\n        \"\"\"\nif not self._bounds_setter:\nself._bounds_setter = BoundsSetter(self._repeat_interval)\nawait self._bounds_setter.set(component_id, max_current.as_amperes())\ndef new_bounds_sender(self) -&gt; Sender[ComponentCurrentLimit]:\n\"\"\"Return a `Sender` for setting EV Charger current bounds with.\n        Bounds are used to limit the max current drawn by an EV, although the exact\n        value will be determined by the EV.\n        Returns:\n            A new `Sender`.\n        \"\"\"\nif not self._bounds_setter:\nself._bounds_setter = BoundsSetter(self._repeat_interval)\nreturn self._bounds_setter.new_bounds_sender()\nasync def stop(self) -&gt; None:\n\"\"\"Stop all tasks and channels owned by the EVChargerPool.\"\"\"\nif self._bounds_setter:\nawait self._bounds_setter.stop()\nif self._state_tracker:\nawait self._state_tracker.stop()\nawait self._formula_pool.stop()\nfor stream in self._status_streams.values():\ntask, chan = stream\nawait chan.close()\nawait cancel_and_await(task)\nasync def _get_current_streams(\nself, component_id: int\n) -&gt; tuple[\nReceiver[Sample[Quantity]],\nReceiver[Sample[Quantity]],\nReceiver[Sample[Quantity]],\n]:\n\"\"\"Fetch current streams from the resampler for each phase.\n        Args:\n            component_id: id of EV Charger for which current streams are being fetched.\n        Returns:\n            A tuple of 3 receivers stream resampled current values for the given\n                component id, one for each phase.\n        \"\"\"\nasync def resampler_subscribe(\nmetric_id: ComponentMetricId,\n) -&gt; Receiver[Sample[Quantity]]:\nrequest = ComponentMetricRequest(\nnamespace=\"ev-pool\",\ncomponent_id=component_id,\nmetric_id=metric_id,\nstart_time=None,\n)\nawait self._resampler_subscription_sender.send(request)\nreturn self._channel_registry.new_receiver(request.get_channel_name())\nreturn (\nawait resampler_subscribe(ComponentMetricId.CURRENT_PHASE_1),\nawait resampler_subscribe(ComponentMetricId.CURRENT_PHASE_2),\nawait resampler_subscribe(ComponentMetricId.CURRENT_PHASE_3),\n)\nasync def _stream_component_data(\nself,\ncomponent_id: int,\nsender: Sender[EVChargerData],\n) -&gt; None:\n\"\"\"Stream 3-phase current values and state of an EV Charger.\n        Args:\n            component_id: id of the EV Charger for which data is requested.\n            sender: A sender to stream EV Charger data to.\n        Raises:\n            ChannelClosedError: If the channels from the resampler are closed.\n        \"\"\"\nif not self._state_tracker:\nself._state_tracker = StateTracker(self._component_ids)\n(phase_1_rx, phase_2_rx, phase_3_rx) = await self._get_current_streams(\ncomponent_id\n)\nwhile True:\ntry:\n(phase_1, phase_2, phase_3) = (\nawait phase_1_rx.receive(),\nawait phase_2_rx.receive(),\nawait phase_3_rx.receive(),\n)\nexcept ChannelClosedError:\n_logger.exception(\"Streams closed for component_id=%s.\", component_id)\nraise\nsample = Sample3Phase(\ntimestamp=phase_1.timestamp,\nvalue_p1=None\nif phase_1.value is None\nelse Current.from_amperes(phase_1.value.base_value),\nvalue_p2=None\nif phase_2.value is None\nelse Current.from_amperes(phase_2.value.base_value),\nvalue_p3=None\nif phase_3.value is None\nelse Current.from_amperes(phase_3.value.base_value),\n)\nif (\nphase_1.value is None\nand phase_2.value is None\nand phase_3.value is None\n):\nstate = EVChargerState.MISSING\nelse:\nstate = self._state_tracker.get(component_id)\nawait sender.send(\nEVChargerData(\ncomponent_id=component_id,\ncurrent=sample,\nstate=state,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids: abc.Set[int]\n</code></pre> <p>Return component IDs of all EV Chargers managed by this EVChargerPool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Set of managed component IDs.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.current","title":"current  <code>property</code>","text":"<pre><code>current: FormulaEngine3Phase[Current]\n</code></pre> <p>Fetch the total current for the EV Chargers in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate EV Charger current is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine3Phase[Current]</code> <p>A FormulaEngine that will calculate and stream the total current of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the total power for the EV Chargers in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate EV Charger power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total power of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.__init__","title":"__init__","text":"<pre><code>__init__(\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[\nComponentMetricRequest\n],\ncomponent_ids: set[int] | None = None,\nrepeat_interval: timedelta = timedelta(seconds=3.0),\n) -&gt; None\n</code></pre> <p>Create an <code>EVChargerPool</code> instance.</p> <p>Note</p> <p><code>EVChargerPool</code> instances are not meant to be created directly by users. Use the <code>microgrid.ev_charger_pool</code> method for creating <code>EVChargerPool</code> instances.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>component_ids</code> <p>An optional list of component_ids belonging to this pool.  If not specified, IDs of all EV Chargers in the microgrid will be fetched from the component graph.</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>repeat_interval</code> <p>Interval after which to repeat the last set bounds to the microgrid API, if no new calls to <code>set_bounds</code> have been made.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=3.0)</code> </p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def __init__(\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\ncomponent_ids: set[int] | None = None,\nrepeat_interval: timedelta = timedelta(seconds=3.0),\n) -&gt; None:\n\"\"\"Create an `EVChargerPool` instance.\n    !!! note\n        `EVChargerPool` instances are not meant to be created directly by users. Use\n        the [`microgrid.ev_charger_pool`][frequenz.sdk.microgrid.ev_charger_pool]\n        method for creating `EVChargerPool` instances.\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n        component_ids: An optional list of component_ids belonging to this pool.  If\n            not specified, IDs of all EV Chargers in the microgrid will be fetched\n            from the component graph.\n        repeat_interval: Interval after which to repeat the last set bounds to the\n            microgrid API, if no new calls to `set_bounds` have been made.\n    \"\"\"\nself._channel_registry: ChannelRegistry = channel_registry\nself._repeat_interval = repeat_interval\nself._resampler_subscription_sender: Sender[\nComponentMetricRequest\n] = resampler_subscription_sender\nself._component_ids: set[int] = set()\nif component_ids is not None:\nself._component_ids = component_ids\nelse:\ngraph = connection_manager.get().component_graph\nself._component_ids = {\nevc.component_id\nfor evc in graph.components(\ncomponent_category={ComponentCategory.EV_CHARGER}\n)\n}\nself._state_tracker: StateTracker | None = None\nself._status_streams: dict[\nint, tuple[Task[None], Broadcast[EVChargerData]]\n] = {}\nself._namespace: str = f\"ev-charger-pool-{uuid.uuid4()}\"\nself._formula_pool: FormulaEnginePool = FormulaEnginePool(\nself._namespace,\nself._channel_registry,\nself._resampler_subscription_sender,\n)\nself._bounds_setter: BoundsSetter | None = None\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.component_data","title":"component_data","text":"<pre><code>component_data(\ncomponent_id: int,\n) -&gt; Receiver[EVChargerData]\n</code></pre> <p>Stream 3-phase current values and state of an EV Charger.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the EV Charger for which data is requested.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A receiver that streams objects containing 3-phase current and state of an EV Charger.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def component_data(self, component_id: int) -&gt; Receiver[EVChargerData]:\n\"\"\"Stream 3-phase current values and state of an EV Charger.\n    Args:\n        component_id: id of the EV Charger for which data is requested.\n    Returns:\n        A receiver that streams objects containing 3-phase current and state of\n            an EV Charger.\n    \"\"\"\nif recv := self._status_streams.get(component_id, None):\ntask, output_chan = recv\nif not task.done():\nreturn output_chan.new_receiver()\n_logger.warning(\"Restarting component_status for id: %s\", component_id)\nelse:\noutput_chan = Broadcast[EVChargerData](\nf\"evpool-component_status-{component_id}\"\n)\ntask = asyncio.create_task(\nself._stream_component_data(component_id, output_chan.new_sender())\n)\nself._status_streams[component_id] = (task, output_chan)\nreturn output_chan.new_receiver()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.new_bounds_sender","title":"new_bounds_sender","text":"<pre><code>new_bounds_sender() -&gt; Sender[ComponentCurrentLimit]\n</code></pre> <p>Return a <code>Sender</code> for setting EV Charger current bounds with.</p> <p>Bounds are used to limit the max current drawn by an EV, although the exact value will be determined by the EV.</p> RETURNS DESCRIPTION <code>Sender[ComponentCurrentLimit]</code> <p>A new <code>Sender</code>.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def new_bounds_sender(self) -&gt; Sender[ComponentCurrentLimit]:\n\"\"\"Return a `Sender` for setting EV Charger current bounds with.\n    Bounds are used to limit the max current drawn by an EV, although the exact\n    value will be determined by the EV.\n    Returns:\n        A new `Sender`.\n    \"\"\"\nif not self._bounds_setter:\nself._bounds_setter = BoundsSetter(self._repeat_interval)\nreturn self._bounds_setter.new_bounds_sender()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.set_bounds","title":"set_bounds  <code>async</code>","text":"<pre><code>set_bounds(component_id: int, max_current: Current) -&gt; None\n</code></pre> <p>Send given max current bound for the given EV Charger to the microgrid API.</p> <p>Bounds are used to limit the max current drawn by an EV, although the exact value will be determined by the EV.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>ID of EV Charger to set the current bounds to.</p> <p> TYPE: <code>int</code> </p> <code>max_current</code> <p>maximum current that an EV can draw from this EV Charger.</p> <p> TYPE: <code>Current</code> </p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>async def set_bounds(self, component_id: int, max_current: Current) -&gt; None:\n\"\"\"Send given max current bound for the given EV Charger to the microgrid API.\n    Bounds are used to limit the max current drawn by an EV, although the exact\n    value will be determined by the EV.\n    Args:\n        component_id: ID of EV Charger to set the current bounds to.\n        max_current: maximum current that an EV can draw from this EV Charger.\n    \"\"\"\nif not self._bounds_setter:\nself._bounds_setter = BoundsSetter(self._repeat_interval)\nawait self._bounds_setter.set(component_id, max_current.as_amperes())\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all tasks and channels owned by the EVChargerPool.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop all tasks and channels owned by the EVChargerPool.\"\"\"\nif self._bounds_setter:\nawait self._bounds_setter.stop()\nif self._state_tracker:\nawait self._state_tracker.stop()\nawait self._formula_pool.stop()\nfor stream in self._status_streams.values():\ntask, chan = stream\nawait chan.close()\nawait cancel_and_await(task)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolError","title":"frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolError","text":"<p>             Bases: <code>Exception</code></p> <p>An error that occurred in any of the EVChargerPool methods.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>class EVChargerPoolError(Exception):\n\"\"\"An error that occurred in any of the EVChargerPool methods.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState","title":"frequenz.sdk.timeseries.ev_charger_pool.EVChargerState","text":"<p>             Bases: <code>Enum</code></p> <p>State of individual EV charger.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>class EVChargerState(Enum):\n\"\"\"State of individual EV charger.\"\"\"\nUNSPECIFIED = \"UNSPECIFIED\"\n\"\"\"The state is unspecified.\"\"\"\nMISSING = \"MISSING\"\n\"\"\"The EV Charger is missing.\"\"\"\nIDLE = \"IDLE\"\n\"\"\"The EV Charger is idle.\"\"\"\nEV_PLUGGED = \"EV_PLUGGED\"\n\"\"\"The EV Charger has an EV plugged in.\"\"\"\nEV_LOCKED = \"EV_LOCKED\"\n\"\"\"The EV Charger has an EV plugged in and locked.\"\"\"\nERROR = \"ERROR\"\n\"\"\"The EV Charger is in an error state.\"\"\"\n@classmethod\ndef from_ev_charger_data(cls, data: EVChargerData) -&gt; EVChargerState:\n\"\"\"Create an `EVChargerState` instance from component data.\n        Args:\n            data: ev charger data coming from microgrid.\n        Returns:\n            An `EVChargerState` instance.\n        \"\"\"\nif data.component_state == EVChargerComponentState.UNSPECIFIED:\nreturn EVChargerState.UNSPECIFIED\nif data.component_state in (\nEVChargerComponentState.AUTHORIZATION_REJECTED,\nEVChargerComponentState.ERROR,\n):\nreturn EVChargerState.ERROR\nif data.cable_state == EVChargerCableState.UNSPECIFIED:\nreturn EVChargerState.UNSPECIFIED\nif data.cable_state == EVChargerCableState.EV_LOCKED:\nreturn EVChargerState.EV_LOCKED\nif data.cable_state == EVChargerCableState.EV_PLUGGED:\nreturn EVChargerState.EV_PLUGGED\nreturn EVChargerState.IDLE\ndef is_ev_connected(self) -&gt; bool:\n\"\"\"Check whether an EV is connected to the charger.\n        Returns:\n            Whether an EV is connected to the charger.\n        \"\"\"\nreturn self in (EVChargerState.EV_PLUGGED, EVChargerState.EV_LOCKED)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 'ERROR'\n</code></pre> <p>The EV Charger is in an error state.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.EV_LOCKED","title":"EV_LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_LOCKED = 'EV_LOCKED'\n</code></pre> <p>The EV Charger has an EV plugged in and locked.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.EV_PLUGGED","title":"EV_PLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_PLUGGED = 'EV_PLUGGED'\n</code></pre> <p>The EV Charger has an EV plugged in.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.IDLE","title":"IDLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IDLE = 'IDLE'\n</code></pre> <p>The EV Charger is idle.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.MISSING","title":"MISSING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MISSING = 'MISSING'\n</code></pre> <p>The EV Charger is missing.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = 'UNSPECIFIED'\n</code></pre> <p>The state is unspecified.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.from_ev_charger_data","title":"from_ev_charger_data  <code>classmethod</code>","text":"<pre><code>from_ev_charger_data(data: EVChargerData) -&gt; EVChargerState\n</code></pre> <p>Create an <code>EVChargerState</code> instance from component data.</p> PARAMETER  DESCRIPTION <code>data</code> <p>ev charger data coming from microgrid.</p> <p> TYPE: <code>EVChargerData</code> </p> RETURNS DESCRIPTION <code>EVChargerState</code> <p>An <code>EVChargerState</code> instance.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>@classmethod\ndef from_ev_charger_data(cls, data: EVChargerData) -&gt; EVChargerState:\n\"\"\"Create an `EVChargerState` instance from component data.\n    Args:\n        data: ev charger data coming from microgrid.\n    Returns:\n        An `EVChargerState` instance.\n    \"\"\"\nif data.component_state == EVChargerComponentState.UNSPECIFIED:\nreturn EVChargerState.UNSPECIFIED\nif data.component_state in (\nEVChargerComponentState.AUTHORIZATION_REJECTED,\nEVChargerComponentState.ERROR,\n):\nreturn EVChargerState.ERROR\nif data.cable_state == EVChargerCableState.UNSPECIFIED:\nreturn EVChargerState.UNSPECIFIED\nif data.cable_state == EVChargerCableState.EV_LOCKED:\nreturn EVChargerState.EV_LOCKED\nif data.cable_state == EVChargerCableState.EV_PLUGGED:\nreturn EVChargerState.EV_PLUGGED\nreturn EVChargerState.IDLE\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.is_ev_connected","title":"is_ev_connected","text":"<pre><code>is_ev_connected() -&gt; bool\n</code></pre> <p>Check whether an EV is connected to the charger.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether an EV is connected to the charger.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>def is_ev_connected(self) -&gt; bool:\n\"\"\"Check whether an EV is connected to the charger.\n    Returns:\n        Whether an EV is connected to the charger.\n    \"\"\"\nreturn self in (EVChargerState.EV_PLUGGED, EVChargerState.EV_LOCKED)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/","title":"formula_engine","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine","title":"frequenz.sdk.timeseries.formula_engine","text":"<p>The formula engine module.</p> <p>This module exposes the FormulaEngine and FormulaEngine3Phase classes.</p>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine","title":"frequenz.sdk.timeseries.formula_engine.FormulaEngine","text":"<p>             Bases: <code>Generic[QuantityT]</code>, <code>_ComposableFormulaEngine['FormulaEngine', 'HigherOrderFormulaBuilder', QuantityT]</code></p> <p><code>FormulaEngine</code>s are a part of the SDK's data pipeline, and provide a way for the SDK to apply formulas on resampled data streams.</p> <p>They are used in the SDK to calculate and stream metrics like <code>grid_power</code>, <code>consumer_power</code>, etc., which are building blocks of the Frequenz SDK Microgrid Model.</p> <p>The SDK creates the formulas by analysing the configuration of components in the Component Graph.</p>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine.new_receiver()</code> method can be used to create a Receiver that streams the Samples calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\nbattery_pool = microgrid.battery_pool()\nasync for power in battery_pool.power.new_receiver():\nprint(f\"{power=}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--composition","title":"Composition","text":"<p>Composite <code>FormulaEngine</code>s can be built using arithmetic operations on <code>FormulaEngine</code>s streaming the same type of data.</p> <p>For example, if you're interested in a particular composite metric that can be calculated by subtracting <code>battery_pool().power</code> and <code>ev_charger_pool().power</code> from the <code>logical_meter().grid_power</code>, we can build a <code>FormulaEngine</code> that provides a stream of this calculated metric as follows:</p> <pre><code>from frequenz.sdk import microgrid\nlogical_meter = microgrid.logical_meter()\nbattery_pool = microgrid.battery_pool()\nev_charger_pool = microgrid.ev_charger_pool()\n# apply operations on formula engines to create a formula engine that would\n# apply these operations on the corresponding data streams.\nnet_power = (\nlogical_meter.grid_power - (battery_pool.power + ev_charger_pool.power)\n).build(\"net_power\")\nasync for power in net_power.new_receiver():\nprint(f\"{power=}\")\n</code></pre> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>class FormulaEngine(\nGeneric[QuantityT],\n_ComposableFormulaEngine[\n\"FormulaEngine\",  # type: ignore[type-arg]\n\"HigherOrderFormulaBuilder\",  # type: ignore[type-arg]\nQuantityT,\n],\n):\n\"\"\"[`FormulaEngine`][frequenz.sdk.timeseries.formula_engine.FormulaEngine]s are a\n    part of the SDK's data pipeline, and provide a way for the SDK to apply formulas on\n    resampled data streams.\n    They are used in the SDK to calculate and stream metrics like\n    [`grid_power`][frequenz.sdk.timeseries.logical_meter.LogicalMeter.grid_power],\n    [`consumer_power`][frequenz.sdk.timeseries.logical_meter.LogicalMeter.consumer_power],\n    etc., which are building blocks of the\n    [Frequenz SDK Microgrid Model][frequenz.sdk.microgrid--frequenz-sdk-microgrid-model].\n    The SDK creates the formulas by analysing the configuration of components in the\n    {{glossary(\"Component Graph\")}}.\n    ### Streaming Interface\n    The\n    [`FormulaEngine.new_receiver()`][frequenz.sdk.timeseries.formula_engine.FormulaEngine.new_receiver]\n    method can be used to create a\n    [Receiver](https://frequenz-floss.github.io/frequenz-channels-python/latest/reference/frequenz/channels/#frequenz.channels.Receiver)\n    that streams the [Sample][frequenz.sdk.timeseries.Sample]s calculated by the formula\n    engine.\n    ```python\n    from frequenz.sdk import microgrid\n    battery_pool = microgrid.battery_pool()\n    async for power in battery_pool.power.new_receiver():\n        print(f\"{power=}\")\n    ```\n    ### Composition\n    Composite `FormulaEngine`s can be built using arithmetic operations on\n    `FormulaEngine`s streaming the same type of data.\n    For example, if you're interested in a particular composite metric that can be\n    calculated by subtracting\n    [`battery_pool().power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power] and\n    [`ev_charger_pool().power`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool]\n    from the\n    [`logical_meter().grid_power`][frequenz.sdk.timeseries.logical_meter.LogicalMeter.grid_power],\n    we can build a `FormulaEngine` that provides a stream of this calculated metric as\n    follows:\n    ```python\n    from frequenz.sdk import microgrid\n    logical_meter = microgrid.logical_meter()\n    battery_pool = microgrid.battery_pool()\n    ev_charger_pool = microgrid.ev_charger_pool()\n    # apply operations on formula engines to create a formula engine that would\n    # apply these operations on the corresponding data streams.\n    net_power = (\n        logical_meter.grid_power - (battery_pool.power + ev_charger_pool.power)\n    ).build(\"net_power\")\n    async for power in net_power.new_receiver():\n        print(f\"{power=}\")\n    ```\n    \"\"\"  # noqa: D400, D205\ndef __init__(\nself,\nbuilder: FormulaBuilder[QuantityT],\ncreate_method: Callable[[float], QuantityT],\n) -&gt; None:\n\"\"\"Create a `FormulaEngine` instance.\n        Args:\n            builder: A `FormulaBuilder` instance to get the formula steps and metric\n                fetchers from.\n            create_method: A method to generate the output `Sample` value with.  If the\n                formula is for generating power values, this would be\n                `Power.from_watts`, for example.\n        \"\"\"\nself._higher_order_builder = HigherOrderFormulaBuilder\nself._name: str = builder.name\nself._builder: FormulaBuilder[QuantityT] = builder\nself._create_method = create_method\nself._channel: Broadcast[Sample[QuantityT]] = Broadcast(self._name)\n@classmethod\ndef from_receiver(\ncls,\nname: str,\nreceiver: Receiver[Sample[QuantityT]],\ncreate_method: Callable[[float], QuantityT],\n*,\nnones_are_zeros: bool = False,\n) -&gt; FormulaEngine[QuantityT]:\n\"\"\"\n        Create a formula engine from a receiver.\n        Can be used to compose a formula engine with a receiver. When composing\n        the new engine with other engines, make sure that receiver gets data\n        from the same resampler and that the `create_method`s match.\n        Example:\n            ```python\n            from frequenz.sdk import microgrid\n            from frequenz.sdk.timeseries import Power\n            async def run() -&gt; None:\n                producer_power_engine = microgrid.logical_meter().producer_power\n                consumer_power_recv = (\n                    microgrid.logical_meter().consumer_power.new_receiver()\n                )\n                excess_power_recv = (\n                    (\n                        producer_power_engine\n                        + FormulaEngine.from_receiver(\n                            \"consumer power\",\n                            consumer_power_recv,\n                            Power.from_watts,\n                        )\n                    )\n                    .build(\"excess power\")\n                    .new_receiver()\n                )\n            asyncio.run(run())\n            ```\n        Args:\n            name: A name for the formula engine.\n            receiver: A receiver that streams `Sample`s.\n            create_method: A method to generate the output `Sample` value with,\n                e.g. `Power.from_watts`.\n            nones_are_zeros: If `True`, `None` values in the receiver are treated as 0.\n        Returns:\n            A formula engine that streams the `Sample`s from the receiver.\n        \"\"\"\nbuilder = FormulaBuilder(name, create_method)\nbuilder.push_metric(name, receiver, nones_are_zeros=nones_are_zeros)\nreturn cls(builder, create_method)\nasync def _run(self) -&gt; None:\nawait self._builder.subscribe()\nsteps, metric_fetchers = self._builder.finalize()\nevaluator = FormulaEvaluator[QuantityT](\nself._name, steps, metric_fetchers, self._create_method\n)\nsender = self._channel.new_sender()\nwhile True:\ntry:\nmsg = await evaluator.apply()\nexcept asyncio.CancelledError:\n_logger.exception(\"FormulaEngine task cancelled: %s\", self._name)\nraise\nexcept Exception as err:  # pylint: disable=broad-except\n_logger.warning(\n\"Formula application failed: %s. Error: %s\", self._name, err\n)\nelse:\nawait sender.send(msg)\ndef __str__(self) -&gt; str:\n\"\"\"Return a string representation of the formula.\n        Returns:\n            A string representation of the formula.\n        \"\"\"\nsteps = (\nself._builder._build_stack\nif len(self._builder._build_stack) &gt; 0\nelse self._builder._steps\n)\nreturn format_formula(steps)\ndef new_receiver(\nself, name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample[QuantityT]]:\n\"\"\"Create a new receiver that streams the output of the formula engine.\n        Args:\n            name: An optional name for the receiver.\n            max_size: The size of the receiver's buffer.\n        Returns:\n            A receiver that streams output `Sample`s from the formula engine.\n        \"\"\"\nif self._task is None:\nself._task = asyncio.create_task(self._run())\nrecv = self._channel.new_receiver(name, max_size)\n# This is a hack to ensure that the lifetime of the engine is tied to the\n# lifetime of the receiver.  This is necessary because the engine is a task that\n# runs forever, and in cases where higher order built for example with the below\n# idiom, the user would hold no references to the engine and it could get\n# garbage collected before the receiver.  This behaviour is explained in the\n# `asyncio.create_task` docs here:\n# https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task\n#\n#     formula = (grid_power_engine + bat_power_engine).build().new_receiver()\nrecv._engine_reference = self  # type: ignore # pylint: disable=protected-access\nreturn recv\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__add__","title":"__add__","text":"<pre><code>__add__(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| QuantityT,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that adds (data in) <code>other</code> to <code>self</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __add__(\nself,\nother: _GenericEngine | _GenericHigherOrderBuilder | QuantityT,\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula builder that adds (data in) `other` to `self`.\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method) + other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__init__","title":"__init__","text":"<pre><code>__init__(\nbuilder: FormulaBuilder[QuantityT],\ncreate_method: Callable[[float], QuantityT],\n) -&gt; None\n</code></pre> <p>Create a <code>FormulaEngine</code> instance.</p> PARAMETER  DESCRIPTION <code>builder</code> <p>A <code>FormulaBuilder</code> instance to get the formula steps and metric fetchers from.</p> <p> TYPE: <code>FormulaBuilder[QuantityT]</code> </p> <code>create_method</code> <p>A method to generate the output <code>Sample</code> value with.  If the formula is for generating power values, this would be <code>Power.from_watts</code>, for example.</p> <p> TYPE: <code>Callable[[float], QuantityT]</code> </p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __init__(\nself,\nbuilder: FormulaBuilder[QuantityT],\ncreate_method: Callable[[float], QuantityT],\n) -&gt; None:\n\"\"\"Create a `FormulaEngine` instance.\n    Args:\n        builder: A `FormulaBuilder` instance to get the formula steps and metric\n            fetchers from.\n        create_method: A method to generate the output `Sample` value with.  If the\n            formula is for generating power values, this would be\n            `Power.from_watts`, for example.\n    \"\"\"\nself._higher_order_builder = HigherOrderFormulaBuilder\nself._name: str = builder.name\nself._builder: FormulaBuilder[QuantityT] = builder\nself._create_method = create_method\nself._channel: Broadcast[Sample[QuantityT]] = Broadcast(self._name)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__mul__","title":"__mul__","text":"<pre><code>__mul__(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| float,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that multiplies (data in) <code>self</code> with <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __mul__(\nself, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula builder that multiplies (data in) `self` with `other`.\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method) * other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the formula.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of the formula.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of the formula.\n    Returns:\n        A string representation of the formula.\n    \"\"\"\nsteps = (\nself._builder._build_stack\nif len(self._builder._build_stack) &gt; 0\nelse self._builder._steps\n)\nreturn format_formula(steps)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__sub__","title":"__sub__","text":"<pre><code>__sub__(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| QuantityT,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that subtracts (data in) <code>other</code> from <code>self</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __sub__(\nself, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula builder that subtracts (data in) `other` from `self`.\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method) - other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| float,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that divides (data in) <code>self</code> by <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __truediv__(\nself, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula builder that divides (data in) `self` by `other`.\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method) / other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.consumption","title":"consumption","text":"<pre><code>consumption() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the consumption operator on <code>self</code>.</p> <p>The consumption operator returns either the identity if the power value is positive or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def consumption(self) -&gt; _GenericHigherOrderBuilder:\n\"\"\"\n    Return a formula builder that applies the consumption operator on `self`.\n    The consumption operator returns either the identity if the power value is\n    positive or 0.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method).consumption()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.from_receiver","title":"from_receiver  <code>classmethod</code>","text":"<pre><code>from_receiver(\nname: str,\nreceiver: Receiver[Sample[QuantityT]],\ncreate_method: Callable[[float], QuantityT],\n*,\nnones_are_zeros: bool = False\n) -&gt; FormulaEngine[QuantityT]\n</code></pre> <p>Create a formula engine from a receiver.</p> <p>Can be used to compose a formula engine with a receiver. When composing the new engine with other engines, make sure that receiver gets data from the same resampler and that the <code>create_method</code>s match.</p> Example <pre><code>from frequenz.sdk import microgrid\nfrom frequenz.sdk.timeseries import Power\nasync def run() -&gt; None:\nproducer_power_engine = microgrid.logical_meter().producer_power\nconsumer_power_recv = (\nmicrogrid.logical_meter().consumer_power.new_receiver()\n)\nexcess_power_recv = (\n(\nproducer_power_engine\n+ FormulaEngine.from_receiver(\n\"consumer power\",\nconsumer_power_recv,\nPower.from_watts,\n)\n)\n.build(\"excess power\")\n.new_receiver()\n)\nasyncio.run(run())\n</code></pre> PARAMETER  DESCRIPTION <code>name</code> <p>A name for the formula engine.</p> <p> TYPE: <code>str</code> </p> <code>receiver</code> <p>A receiver that streams <code>Sample</code>s.</p> <p> TYPE: <code>Receiver[Sample[QuantityT]]</code> </p> <code>create_method</code> <p>A method to generate the output <code>Sample</code> value with, e.g. <code>Power.from_watts</code>.</p> <p> TYPE: <code>Callable[[float], QuantityT]</code> </p> <code>nones_are_zeros</code> <p>If <code>True</code>, <code>None</code> values in the receiver are treated as 0.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>FormulaEngine[QuantityT]</code> <p>A formula engine that streams the <code>Sample</code>s from the receiver.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>@classmethod\ndef from_receiver(\ncls,\nname: str,\nreceiver: Receiver[Sample[QuantityT]],\ncreate_method: Callable[[float], QuantityT],\n*,\nnones_are_zeros: bool = False,\n) -&gt; FormulaEngine[QuantityT]:\n\"\"\"\n    Create a formula engine from a receiver.\n    Can be used to compose a formula engine with a receiver. When composing\n    the new engine with other engines, make sure that receiver gets data\n    from the same resampler and that the `create_method`s match.\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.timeseries import Power\n        async def run() -&gt; None:\n            producer_power_engine = microgrid.logical_meter().producer_power\n            consumer_power_recv = (\n                microgrid.logical_meter().consumer_power.new_receiver()\n            )\n            excess_power_recv = (\n                (\n                    producer_power_engine\n                    + FormulaEngine.from_receiver(\n                        \"consumer power\",\n                        consumer_power_recv,\n                        Power.from_watts,\n                    )\n                )\n                .build(\"excess power\")\n                .new_receiver()\n            )\n        asyncio.run(run())\n        ```\n    Args:\n        name: A name for the formula engine.\n        receiver: A receiver that streams `Sample`s.\n        create_method: A method to generate the output `Sample` value with,\n            e.g. `Power.from_watts`.\n        nones_are_zeros: If `True`, `None` values in the receiver are treated as 0.\n    Returns:\n        A formula engine that streams the `Sample`s from the receiver.\n    \"\"\"\nbuilder = FormulaBuilder(name, create_method)\nbuilder.push_metric(name, receiver, nones_are_zeros=nones_are_zeros)\nreturn cls(builder, create_method)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.max","title":"max","text":"<pre><code>max(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| QuantityT,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the maximum of <code>self</code> and <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def max(\nself, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula engine that outputs the maximum of `self` and `other`.\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method).max(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.min","title":"min","text":"<pre><code>min(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| QuantityT,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the minimum of <code>self</code> and <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def min(\nself, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula engine that outputs the minimum of `self` and `other`.\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method).min(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver(\nname: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample[QuantityT]]\n</code></pre> <p>Create a new receiver that streams the output of the formula engine.</p> PARAMETER  DESCRIPTION <code>name</code> <p>An optional name for the receiver.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>max_size</code> <p>The size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[Sample[QuantityT]]</code> <p>A receiver that streams output <code>Sample</code>s from the formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def new_receiver(\nself, name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample[QuantityT]]:\n\"\"\"Create a new receiver that streams the output of the formula engine.\n    Args:\n        name: An optional name for the receiver.\n        max_size: The size of the receiver's buffer.\n    Returns:\n        A receiver that streams output `Sample`s from the formula engine.\n    \"\"\"\nif self._task is None:\nself._task = asyncio.create_task(self._run())\nrecv = self._channel.new_receiver(name, max_size)\n# This is a hack to ensure that the lifetime of the engine is tied to the\n# lifetime of the receiver.  This is necessary because the engine is a task that\n# runs forever, and in cases where higher order built for example with the below\n# idiom, the user would hold no references to the engine and it could get\n# garbage collected before the receiver.  This behaviour is explained in the\n# `asyncio.create_task` docs here:\n# https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task\n#\n#     formula = (grid_power_engine + bat_power_engine).build().new_receiver()\nrecv._engine_reference = self  # type: ignore # pylint: disable=protected-access\nreturn recv\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.production","title":"production","text":"<pre><code>production() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the production operator on <code>self</code>.</p> <p>The production operator returns either the absolute value if the power value is negative or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def production(self) -&gt; _GenericHigherOrderBuilder:\n\"\"\"\n    Return a formula builder that applies the production operator on `self`.\n    The production operator returns either the absolute value if the power value is\n    negative or 0.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method).production()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase","title":"frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase","text":"<p>             Bases: <code>_ComposableFormulaEngine['FormulaEngine3Phase', 'HigherOrderFormulaBuilder3Phase', QuantityT]</code></p> <p>A <code>FormulaEngine3Phase</code> is similar to a <code>FormulaEngine</code>, except that they stream 3-phase samples.  All the current formulas (like <code>LogicalMeter.grid_current</code>, <code>EVChargerPool.current</code>, etc.) are implemented as 3-phase formulas.</p>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine3Phase.new_receiver()</code> method can be used to create a Receiver that streams the Sample3Phase values calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\nev_charger_pool = microgrid.ev_charger_pool()\nasync for sample in ev_charger_pool.current.new_receiver():\nprint(f\"Current: {sample}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--composition","title":"Composition","text":"<p><code>FormulaEngine3Phase</code> instances can be composed together, just like <code>FormulaEngine</code> instances.</p> <pre><code>from frequenz.sdk import microgrid\nlogical_meter = microgrid.logical_meter()\nev_charger_pool = microgrid.ev_charger_pool()\n# Calculate grid consumption current that's not used by the EV chargers\nother_current = (logical_meter.grid_current - ev_charger_pool.current).build(\"other_current\")\nasync for sample in other_current.new_receiver():\nprint(f\"Other current: {sample}\")\n</code></pre> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>class FormulaEngine3Phase(\n_ComposableFormulaEngine[\n\"FormulaEngine3Phase\",  # type: ignore[type-arg]\n\"HigherOrderFormulaBuilder3Phase\",  # type: ignore[type-arg]\nQuantityT,\n]\n):\n\"\"\"A\n    [`FormulaEngine3Phase`][frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase]\n    is similar to a\n    [`FormulaEngine`][frequenz.sdk.timeseries.formula_engine.FormulaEngine], except that\n    they stream [3-phase samples][frequenz.sdk.timeseries.Sample3Phase].  All the\n    current formulas (like\n    [`LogicalMeter.grid_current`][frequenz.sdk.timeseries.logical_meter.LogicalMeter.grid_current],\n    [`EVChargerPool.current`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.current],\n    etc.) are implemented as 3-phase formulas.\n    ### Streaming Interface\n    The\n    [`FormulaEngine3Phase.new_receiver()`][frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.new_receiver]\n    method can be used to create a\n    [Receiver](https://frequenz-floss.github.io/frequenz-channels-python/latest/reference/frequenz/channels/#frequenz.channels.Receiver)\n    that streams the [Sample3Phase][frequenz.sdk.timeseries.Sample3Phase] values\n    calculated by the formula engine.\n    ```python\n    from frequenz.sdk import microgrid\n    ev_charger_pool = microgrid.ev_charger_pool()\n    async for sample in ev_charger_pool.current.new_receiver():\n        print(f\"Current: {sample}\")\n    ```\n    ### Composition\n    `FormulaEngine3Phase` instances can be composed together, just like `FormulaEngine`\n    instances.\n    ```python\n    from frequenz.sdk import microgrid\n    logical_meter = microgrid.logical_meter()\n    ev_charger_pool = microgrid.ev_charger_pool()\n    # Calculate grid consumption current that's not used by the EV chargers\n    other_current = (logical_meter.grid_current - ev_charger_pool.current).build(\"other_current\")\n    async for sample in other_current.new_receiver():\n        print(f\"Other current: {sample}\")\n    ```\n    \"\"\"  # noqa: D205, D400\ndef __init__(\nself,\nname: str,\ncreate_method: Callable[[float], QuantityT],\nphase_streams: tuple[\nFormulaEngine[QuantityT],\nFormulaEngine[QuantityT],\nFormulaEngine[QuantityT],\n],\n) -&gt; None:\n\"\"\"Create a `FormulaEngine3Phase` instance.\n        Args:\n            name: A name for the formula.\n            create_method: A method to generate the output `Sample` value with.  If the\n                formula is for generating power values, this would be\n                `Power.from_watts`, for example.\n            phase_streams: output streams of formula engines running per-phase formulas.\n        \"\"\"\nself._higher_order_builder = HigherOrderFormulaBuilder3Phase\nself._name: str = name\nself._create_method = create_method\nself._channel: Broadcast[Sample3Phase[QuantityT]] = Broadcast(self._name)\nself._task: asyncio.Task[None] | None = None\nself._streams: tuple[\nFormulaEngine[QuantityT],\nFormulaEngine[QuantityT],\nFormulaEngine[QuantityT],\n] = phase_streams\nasync def _run(self) -&gt; None:\nsender = self._channel.new_sender()\nphase_1_rx = self._streams[0].new_receiver()\nphase_2_rx = self._streams[1].new_receiver()\nphase_3_rx = self._streams[2].new_receiver()\nwhile True:\ntry:\nphase_1 = await phase_1_rx.receive()\nphase_2 = await phase_2_rx.receive()\nphase_3 = await phase_3_rx.receive()\nmsg = Sample3Phase(\nphase_1.timestamp,\nphase_1.value,\nphase_2.value,\nphase_3.value,\n)\nexcept asyncio.CancelledError:\n_logger.exception(\"FormulaEngine task cancelled: %s\", self._name)\nbreak\nelse:\nawait sender.send(msg)\ndef new_receiver(\nself, name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample3Phase[QuantityT]]:\n\"\"\"Create a new receiver that streams the output of the formula engine.\n        Args:\n            name: An optional name for the receiver.\n            max_size: The size of the receiver's buffer.\n        Returns:\n            A receiver that streams output `Sample`s from the formula engine.\n        \"\"\"\nif self._task is None:\nself._task = asyncio.create_task(self._run())\nreturn self._channel.new_receiver(name, max_size)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__add__","title":"__add__","text":"<pre><code>__add__(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| QuantityT,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that adds (data in) <code>other</code> to <code>self</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __add__(\nself,\nother: _GenericEngine | _GenericHigherOrderBuilder | QuantityT,\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula builder that adds (data in) `other` to `self`.\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method) + other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__init__","title":"__init__","text":"<pre><code>__init__(\nname: str,\ncreate_method: Callable[[float], QuantityT],\nphase_streams: tuple[\nFormulaEngine[QuantityT],\nFormulaEngine[QuantityT],\nFormulaEngine[QuantityT],\n],\n) -&gt; None\n</code></pre> <p>Create a <code>FormulaEngine3Phase</code> instance.</p> PARAMETER  DESCRIPTION <code>name</code> <p>A name for the formula.</p> <p> TYPE: <code>str</code> </p> <code>create_method</code> <p>A method to generate the output <code>Sample</code> value with.  If the formula is for generating power values, this would be <code>Power.from_watts</code>, for example.</p> <p> TYPE: <code>Callable[[float], QuantityT]</code> </p> <code>phase_streams</code> <p>output streams of formula engines running per-phase formulas.</p> <p> TYPE: <code>tuple[FormulaEngine[QuantityT], FormulaEngine[QuantityT], FormulaEngine[QuantityT]]</code> </p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __init__(\nself,\nname: str,\ncreate_method: Callable[[float], QuantityT],\nphase_streams: tuple[\nFormulaEngine[QuantityT],\nFormulaEngine[QuantityT],\nFormulaEngine[QuantityT],\n],\n) -&gt; None:\n\"\"\"Create a `FormulaEngine3Phase` instance.\n    Args:\n        name: A name for the formula.\n        create_method: A method to generate the output `Sample` value with.  If the\n            formula is for generating power values, this would be\n            `Power.from_watts`, for example.\n        phase_streams: output streams of formula engines running per-phase formulas.\n    \"\"\"\nself._higher_order_builder = HigherOrderFormulaBuilder3Phase\nself._name: str = name\nself._create_method = create_method\nself._channel: Broadcast[Sample3Phase[QuantityT]] = Broadcast(self._name)\nself._task: asyncio.Task[None] | None = None\nself._streams: tuple[\nFormulaEngine[QuantityT],\nFormulaEngine[QuantityT],\nFormulaEngine[QuantityT],\n] = phase_streams\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__mul__","title":"__mul__","text":"<pre><code>__mul__(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| float,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that multiplies (data in) <code>self</code> with <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __mul__(\nself, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula builder that multiplies (data in) `self` with `other`.\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method) * other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__sub__","title":"__sub__","text":"<pre><code>__sub__(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| QuantityT,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that subtracts (data in) <code>other</code> from <code>self</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __sub__(\nself, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula builder that subtracts (data in) `other` from `self`.\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method) - other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| float,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that divides (data in) <code>self</code> by <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __truediv__(\nself, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula builder that divides (data in) `self` by `other`.\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method) / other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.consumption","title":"consumption","text":"<pre><code>consumption() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the consumption operator on <code>self</code>.</p> <p>The consumption operator returns either the identity if the power value is positive or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def consumption(self) -&gt; _GenericHigherOrderBuilder:\n\"\"\"\n    Return a formula builder that applies the consumption operator on `self`.\n    The consumption operator returns either the identity if the power value is\n    positive or 0.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method).consumption()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.max","title":"max","text":"<pre><code>max(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| QuantityT,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the maximum of <code>self</code> and <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def max(\nself, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula engine that outputs the maximum of `self` and `other`.\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method).max(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.min","title":"min","text":"<pre><code>min(\nother: _GenericEngine\n| _GenericHigherOrderBuilder\n| QuantityT,\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the minimum of <code>self</code> and <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def min(\nself, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n\"\"\"Return a formula engine that outputs the minimum of `self` and `other`.\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method).min(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver(\nname: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample3Phase[QuantityT]]\n</code></pre> <p>Create a new receiver that streams the output of the formula engine.</p> PARAMETER  DESCRIPTION <code>name</code> <p>An optional name for the receiver.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>max_size</code> <p>The size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[Sample3Phase[QuantityT]]</code> <p>A receiver that streams output <code>Sample</code>s from the formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def new_receiver(\nself, name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample3Phase[QuantityT]]:\n\"\"\"Create a new receiver that streams the output of the formula engine.\n    Args:\n        name: An optional name for the receiver.\n        max_size: The size of the receiver's buffer.\n    Returns:\n        A receiver that streams output `Sample`s from the formula engine.\n    \"\"\"\nif self._task is None:\nself._task = asyncio.create_task(self._run())\nreturn self._channel.new_receiver(name, max_size)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.production","title":"production","text":"<pre><code>production() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the production operator on <code>self</code>.</p> <p>The production operator returns either the absolute value if the power value is negative or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def production(self) -&gt; _GenericHigherOrderBuilder:\n\"\"\"\n    Return a formula builder that applies the production operator on `self`.\n    The production operator returns either the absolute value if the power value is\n    negative or 0.\n    \"\"\"\nreturn self._higher_order_builder(self, self._create_method).production()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/","title":"logical_meter","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter","title":"frequenz.sdk.timeseries.logical_meter","text":"<p>A logical meter for calculating high level metrics for a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter","title":"frequenz.sdk.timeseries.logical_meter.LogicalMeter","text":"<p>A logical meter for calculating high level metrics in a microgrid.</p> <p>LogicalMeter provides methods for fetching power values from different points in the microgrid.  These methods return <code>FormulaReceiver</code> objects, which can be used like normal <code>Receiver</code>s, but can also be composed to form higher-order formula streams.</p> <p>Note</p> <p><code>LogicalMeter</code> instances are not meant to be created directly by users.  Use the <code>microgrid.logical_meter</code> method for creating <code>LogicalMeter</code> instances.</p> Example <pre><code>from datetime import timedelta\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.timeseries import ResamplerConfig\nawait microgrid.initialize(\n\"127.0.0.1\",\n50051,\nResamplerConfig(resampling_period=timedelta(seconds=1))\n)\nlogical_meter = microgrid.logical_meter()\n# Get a receiver for a builtin formula\ngrid_power_recv = logical_meter.grid_power.new_receiver()\nasync for grid_power_sample in grid_power_recv:\nprint(grid_power_sample)\n# or compose formulas to create a new formula\nnet_power_recv = (\n(\nlogical_meter.grid_power\n- logical_meter.pv_power\n)\n.build(\"net_power\")\n.new_receiver()\n)\nasync for net_power_sample in net_power_recv:\nprint(net_power_sample)\n</code></pre> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>class LogicalMeter:\n\"\"\"A logical meter for calculating high level metrics in a microgrid.\n    LogicalMeter provides methods for fetching power values from different points in the\n    microgrid.  These methods return `FormulaReceiver` objects, which can be used like\n    normal `Receiver`s, but can also be composed to form higher-order formula streams.\n    !!! note\n        `LogicalMeter` instances are not meant to be created directly by users.  Use the\n        [`microgrid.logical_meter`][frequenz.sdk.microgrid.logical_meter] method for\n        creating `LogicalMeter` instances.\n    Example:\n        ```python\n        from datetime import timedelta\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.timeseries import ResamplerConfig\n        await microgrid.initialize(\n            \"127.0.0.1\",\n            50051,\n            ResamplerConfig(resampling_period=timedelta(seconds=1))\n        )\n        logical_meter = microgrid.logical_meter()\n        # Get a receiver for a builtin formula\n        grid_power_recv = logical_meter.grid_power.new_receiver()\n        async for grid_power_sample in grid_power_recv:\n            print(grid_power_sample)\n        # or compose formulas to create a new formula\n        net_power_recv = (\n            (\n                logical_meter.grid_power\n                - logical_meter.pv_power\n            )\n            .build(\"net_power\")\n            .new_receiver()\n        )\n        async for net_power_sample in net_power_recv:\n            print(net_power_sample)\n        ```\n    \"\"\"\ndef __init__(\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n\"\"\"Create a `LogicalMeter` instance.\n        !!! note\n            `LogicalMeter` instances are not meant to be created directly by users.  Use\n            the [`microgrid.logical_meter`][frequenz.sdk.microgrid.logical_meter] method\n            for creating `LogicalMeter` instances.\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n        \"\"\"\nself._channel_registry = channel_registry\nself._resampler_subscription_sender = resampler_subscription_sender\n# Use a randomly generated uuid to create a unique namespace name for the local\n# meter to use when communicating with the resampling actor.\nself._namespace = f\"logical-meter-{uuid.uuid4()}\"\nself._formula_pool = FormulaEnginePool(\nself._namespace,\nself._channel_registry,\nself._resampler_subscription_sender,\n)\ndef start_formula(\nself,\nformula: str,\ncomponent_metric_id: ComponentMetricId,\n*,\nnones_are_zeros: bool = False,\n) -&gt; FormulaEngine[Quantity]:\n\"\"\"Start execution of the given formula.\n        Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and\n        these operators: +, -, *, /, (, ).\n        For example, the input string: \"#20 + #5\" is a formula for adding metrics from\n        two components with ids 20 and 5.\n        Args:\n            formula: formula to execute.\n            component_metric_id: The metric ID to use when fetching receivers from the\n                resampling actor.\n            nones_are_zeros: Whether to treat None values from the stream as 0s.  If\n                False, the returned value will be a None.\n        Returns:\n            A FormulaEngine that applies the formula and streams values.\n        \"\"\"\nreturn self._formula_pool.from_string(\nformula, component_metric_id, nones_are_zeros=nones_are_zeros\n)\n@property\ndef grid_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the grid power for the microgrid.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate grid power is not already running, it will be\n        started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream grid power.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"grid_power\",\nGridPowerFormula,\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef grid_current(self) -&gt; FormulaEngine3Phase[Current]:\n\"\"\"Fetch the grid power for the microgrid.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate grid current is not already running, it will be\n        started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream grid current.\n        \"\"\"\nengine = self._formula_pool.from_3_phase_current_formula_generator(\n\"grid_current\",\nGridCurrentFormula,\n)\nassert isinstance(engine, FormulaEngine3Phase)\nreturn engine\n@property\ndef consumer_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the consumer power for the microgrid.\n        Under normal circumstances this is expected to correspond to the gross\n        consumption of the site excluding active parts and battery.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate consumer power is not already running, it will\n        be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream consumer power.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"consumer_power\",\nConsumerPowerFormula,\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef producer_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the producer power for the microgrid.\n        Under normal circumstances this is expected to correspond to the production\n        of the sites active parts excluding ev chargers and batteries.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate producer power is not already running, it will\n        be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream producer power.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"producer_power\",\nProducerPowerFormula,\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef pv_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the PV power in the microgrid.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate PV power is not already running, it will be\n        started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream PV total power.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"pv_power\",\nPVPowerFormula,\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef chp_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the CHP power production in the microgrid.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate CHP power production is not already running, it\n        will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream CHP power production.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"chp_power\",\nCHPPowerFormula,\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\nasync def stop(self) -&gt; None:\n\"\"\"Stop all formula engines.\"\"\"\nawait self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.chp_power","title":"chp_power  <code>property</code>","text":"<pre><code>chp_power: FormulaEngine[Power]\n</code></pre> <p>Fetch the CHP power production in the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate CHP power production is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream CHP power production.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.consumer_power","title":"consumer_power  <code>property</code>","text":"<pre><code>consumer_power: FormulaEngine[Power]\n</code></pre> <p>Fetch the consumer power for the microgrid.</p> <p>Under normal circumstances this is expected to correspond to the gross consumption of the site excluding active parts and battery.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate consumer power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream consumer power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.grid_current","title":"grid_current  <code>property</code>","text":"<pre><code>grid_current: FormulaEngine3Phase[Current]\n</code></pre> <p>Fetch the grid power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate grid current is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine3Phase[Current]</code> <p>A FormulaEngine that will calculate and stream grid current.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.grid_power","title":"grid_power  <code>property</code>","text":"<pre><code>grid_power: FormulaEngine[Power]\n</code></pre> <p>Fetch the grid power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate grid power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream grid power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.producer_power","title":"producer_power  <code>property</code>","text":"<pre><code>producer_power: FormulaEngine[Power]\n</code></pre> <p>Fetch the producer power for the microgrid.</p> <p>Under normal circumstances this is expected to correspond to the production of the sites active parts excluding ev chargers and batteries.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate producer power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream producer power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.pv_power","title":"pv_power  <code>property</code>","text":"<pre><code>pv_power: FormulaEngine[Power]\n</code></pre> <p>Fetch the PV power in the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate PV power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream PV total power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.__init__","title":"__init__","text":"<pre><code>__init__(\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[\nComponentMetricRequest\n],\n) -&gt; None\n</code></pre> <p>Create a <code>LogicalMeter</code> instance.</p> <p>Note</p> <p><code>LogicalMeter</code> instances are not meant to be created directly by users.  Use the <code>microgrid.logical_meter</code> method for creating <code>LogicalMeter</code> instances.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>def __init__(\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n\"\"\"Create a `LogicalMeter` instance.\n    !!! note\n        `LogicalMeter` instances are not meant to be created directly by users.  Use\n        the [`microgrid.logical_meter`][frequenz.sdk.microgrid.logical_meter] method\n        for creating `LogicalMeter` instances.\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n    \"\"\"\nself._channel_registry = channel_registry\nself._resampler_subscription_sender = resampler_subscription_sender\n# Use a randomly generated uuid to create a unique namespace name for the local\n# meter to use when communicating with the resampling actor.\nself._namespace = f\"logical-meter-{uuid.uuid4()}\"\nself._formula_pool = FormulaEnginePool(\nself._namespace,\nself._channel_registry,\nself._resampler_subscription_sender,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.start_formula","title":"start_formula","text":"<pre><code>start_formula(\nformula: str,\ncomponent_metric_id: ComponentMetricId,\n*,\nnones_are_zeros: bool = False\n) -&gt; FormulaEngine[Quantity]\n</code></pre> <p>Start execution of the given formula.</p> <p>Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and these operators: +, -, *, /, (, ).</p> <p>For example, the input string: \"#20 + #5\" is a formula for adding metrics from two components with ids 20 and 5.</p> PARAMETER  DESCRIPTION <code>formula</code> <p>formula to execute.</p> <p> TYPE: <code>str</code> </p> <code>component_metric_id</code> <p>The metric ID to use when fetching receivers from the resampling actor.</p> <p> TYPE: <code>ComponentMetricId</code> </p> <code>nones_are_zeros</code> <p>Whether to treat None values from the stream as 0s.  If False, the returned value will be a None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>FormulaEngine[Quantity]</code> <p>A FormulaEngine that applies the formula and streams values.</p> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>def start_formula(\nself,\nformula: str,\ncomponent_metric_id: ComponentMetricId,\n*,\nnones_are_zeros: bool = False,\n) -&gt; FormulaEngine[Quantity]:\n\"\"\"Start execution of the given formula.\n    Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and\n    these operators: +, -, *, /, (, ).\n    For example, the input string: \"#20 + #5\" is a formula for adding metrics from\n    two components with ids 20 and 5.\n    Args:\n        formula: formula to execute.\n        component_metric_id: The metric ID to use when fetching receivers from the\n            resampling actor.\n        nones_are_zeros: Whether to treat None values from the stream as 0s.  If\n            False, the returned value will be a None.\n    Returns:\n        A FormulaEngine that applies the formula and streams values.\n    \"\"\"\nreturn self._formula_pool.from_string(\nformula, component_metric_id, nones_are_zeros=nones_are_zeros\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all formula engines.</p> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop all formula engines.\"\"\"\nawait self._formula_pool.stop()\n</code></pre>"},{"location":"tutorials/getting_started/","title":"Getting started","text":""},{"location":"tutorials/getting_started/#prerequisites","title":"Prerequisites","text":"<ol> <li>Python 3.11 or newer installed on your system.</li> <li>Access to a microgrid system supported by the <code>frequenz.sdk</code> or you can use    the sandbox.</li> <li>Basic knowledge of microgrid concepts.</li> <li>Familiarity with Channels.</li> <li>Install the Frequenz SDK</li> </ol>"},{"location":"tutorials/getting_started/#create-a-project","title":"Create a project","text":""},{"location":"tutorials/getting_started/#create-a-python-file","title":"Create a Python file","text":"<p>You can start by simply creating a Python script (e.g., <code>pv_optimization.py</code>) using your favorite text editor.</p>"},{"location":"tutorials/getting_started/#use-frequenz-repository-configuration","title":"Use Frequenz Repository Configuration","text":"<p>As an alternative and specially for larger projects, it's recommended to set up the project using the Frequenz Repository Configuration.</p>"},{"location":"tutorials/getting_started/#import-necessary-modules","title":"Import necessary modules","text":"<p>You can now open the app's main file and start adding content. Begin by importing the necessary libraries.</p> <pre><code>import asyncio\nfrom datetime import timedelta\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.actor import ResamplerConfig\n</code></pre>"},{"location":"tutorials/getting_started/#create-the-application-skeleton","title":"Create the application skeleton","text":"<p>The main logic of your application will run within an async function. Let's create a skeleton that contains all the necessary code to initialize a microgrid.</p> <pre><code>async def run() -&gt; None:\n# This points to the default Frequenz microgrid sandbox\nmicrogrid_host = \"microgrid.sandbox.api.frequenz.io\"\nmicrogrid_port = 62060\n# Initialize the microgrid\nawait microgrid.initialize(\nmicrogrid_host,\nmicrogrid_port,\nResamplerConfig(resampling_period=timedelta(seconds=1)),\n)\n# Define your application logic here\n# ...\n</code></pre>"},{"location":"tutorials/getting_started/#define-the-main-function","title":"Define the <code>main()</code> function","text":"<p>Create a <code>main()</code> function that will set up and run the <code>run()</code> function using asyncio.</p> <pre><code>def main() -&gt; None:\nasyncio.run(run())\nif __name__ == \"__main__\":\nmain()\n</code></pre>"},{"location":"tutorials/getting_started/#implement-the-application-logic","title":"Implement the application logic","text":"<p>Inside the <code>run()</code> function, implement the core logic of your application. This will include creating receivers for data streams, processing the data, making decisions, and eventually sending control messages to the microgrid system. We will cover more details in the following tutorials. For now, let's simply read the power measurements from the microgrid's grid meter and print them on the screen. The grid meter is a meter that is directly connected to the grid connection point.</p> <pre><code>async def run() -&gt; None:\n# This points to the default Frequenz microgrid sandbox\n...\n# Define your application logic here\ngrid_meter = microgrid.logical_meter().grid_power.new_receiver()\nasync for power in grid_meter:\nprint(power.value)\n</code></pre>"},{"location":"tutorials/getting_started/#putting-it-all-together","title":"Putting it all together","text":"<p>Here is the full version of your first Frequenz SDK application.</p> <pre><code>import asyncio\nfrom datetime import timedelta\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.actor import ResamplerConfig\nasync def run() -&gt; None:\n# This points to the default Frequenz microgrid sandbox\nmicrogrid_host = \"microgrid.sandbox.api.frequenz.io\"\nmicrogrid_port = 62060\n# Initialize the microgrid\nawait microgrid.initialize(\nmicrogrid_host,\nmicrogrid_port,\nResamplerConfig(resampling_period=timedelta(seconds=1)),\n)\n# Define your application logic here\ngrid_meter = microgrid.logical_meter().grid_power.new_receiver()\nasync for power in grid_meter:\nprint(power.value)\ndef main() -&gt; None:\nasyncio.run(run())\nif __name__ == \"__main__\":\nmain()\n</code></pre>"},{"location":"tutorials/getting_started/#run-your-application","title":"Run your application","text":"<p>You're now ready to run your application. When working on an existing microgrid, make sure to update the <code>microgrid_host</code> and <code>microgrid_port</code> variables before running the script.</p> <pre><code># Example usage\npython pv_optimization.py\n</code></pre>"},{"location":"user-guide/","title":"Introduction","text":"<p>There are several fundamental concepts that one should comprehend before diving into the Frequenz SDK. These concepts encompass both general notions within the energy sector or microgrids and specific details regarding the SDK itself, such as asynchronous programming, use of channels for communication, the actor model, data pipelines, and the composition of a components graph.</p> <p>Given that users may possess diverse backgrounds and varying levels of familiarity with these subjects, the left menu is organized into sections, each dedicated to a particular topic.</p> <p>For individuals without prior knowledge, it is advisable to proceed through the sections sequentially to establish a solid foundation.</p>"},{"location":"user-guide/actors/","title":"Actors","text":"<p>Actors are a primitive unit of computation that runs autonomously.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--actor-programming-model","title":"Actor Programming Model","text":"<p>From Wikipedia</p> <p>The actor model in computer science is a mathematical model of concurrent computation that treats an actor as the basic building block of concurrent computation. In response to a message it receives, an actor can: make local decisions, create more actors, send more messages, and determine how to respond to the next message received. Actors may modify their own private state, but can only affect each other indirectly through messaging (removing the need for lock-based synchronization).</p> <p>We won't get into much more detail here because it is outside the scope of this documentation. However, if you are interested in learning more about the actor programming model, here are some useful resources:</p> <ul> <li>Actor Model (Wikipedia)</li> <li>How the Actor Model Meets the Needs of Modern, Distributed Systems   (Akka)</li> </ul>"},{"location":"user-guide/actors/#frequenz.sdk.actor--frequenz-sdk-actors","title":"Frequenz SDK Actors","text":"<p>The <code>Actor</code> class serves as the foundation for creating concurrent tasks and all actors in the SDK inherit from it. This class provides a straightforward way to implement actors. It shares similarities with the traditional actor programming model but also has some unique features:</p> <ul> <li> <p>Message Passing: Like traditional actors, our <code>Actor</code>   class communicates through message passing. Even when no particular message passing   mechanism is enforced, the SDK actors use <code>frequenz.channels</code> for communication.</p> </li> <li> <p>Automatic Restart: If an unhandled exception occurs in an actor's logic   (<code>_run()</code> method), the actor will be automatically restarted. This ensures   robustness in the face of errors.</p> </li> <li> <p>Simplified Task Management: Actors manage asynchronous tasks using   <code>asyncio</code>. You can create and manage tasks within the actor, and the   <code>Actor</code> class handles task cancellation and cleanup.</p> </li> <li> <p>Simplified lifecycle management: Actors are [async context managers] and also   a <code>run()</code> function is provided to easily run a group of   actors and wait for them to finish.</p> </li> </ul>"},{"location":"user-guide/actors/#frequenz.sdk.actor--lifecycle","title":"Lifecycle","text":"<p>Actors are not started when they are created. There are 3 main ways to start an actor (from most to least recommended):</p> <ol> <li>By using the <code>run()</code> function.</li> <li>By using the actor as an async context manager.</li> <li>By using the <code>start()</code> method.</li> </ol> <p>Warning</p> <ol> <li> <p>If an actor raises an unhandled exception, it will be restarted automatically.</p> </li> <li> <p>Actors manage <code>asyncio.Task</code> objects, so a reference to the actor object must    be held for as long as the actor is expected to be running, otherwise its tasks    will be cancelled and the actor will stop. For more information, please refer to    the Python <code>asyncio</code>    documentation.</p> </li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--the-run-function","title":"The <code>run()</code> Function","text":"<p>The <code>run()</code> function can start many actors at once and waits for them to finish. If any of the actors are stopped with errors, the errors will be logged.</p> Example <pre><code>from frequenz.sdk.actor import Actor, run\nclass MyActor(Actor):\nasync def _run(self) -&gt; None:\nprint(\"Hello World!\")\nawait run(MyActor()) # (1)!\n</code></pre> <ol> <li>This line will block until the actor is stopped.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--async-context-manager","title":"Async Context Manager","text":"<p>When an actor is used as an async context manager, it is started when the <code>async with</code> block is entered and stopped automatically when the block is exited (even if an exception is raised).</p> Example <pre><code>from frequenz.sdk.actor import Actor\nclass MyActor(Actor):\nasync def _run(self) -&gt; None:\nprint(\"Hello World!\")\nasync with MyActor() as actor: # (1)!\nprint(\"The actor is running\")\n# (2)!\n</code></pre> <ol> <li><code>start()</code> is called automatically when entering     the <code>async with</code> block.</li> <li><code>stop()</code> is called automatically when exiting     the <code>async with</code> block.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--the-start-method","title":"The <code>start()</code> Method","text":"<p>When using the <code>start()</code> method, the actor is started in the background and the method returns immediately. The actor will continue to run until it is manually stopped.</p> Example <pre><code>from frequenz.sdk.actor import Actor\nclass MyActor(Actor):\nasync def _run(self) -&gt; None:\nprint(\"Hello World!\")\nactor = MyActor() # (1)!\nactor.start() # (2)!\nprint(\"The actor is running\") # (3)!\nawait actor.stop() # (4)!\n</code></pre> <ol> <li>The actor is created but not started yet.</li> <li>The actor is started manually, it keeps running in the background.</li> <li> <p>Danger</p> <p>If this function would raise an exception, the actor will never be stopped!</p> </li> <li> <p>Until the actor is stopped manually.</p> </li> </ol> <p>Warning</p> <p>This method is not recommended because it is easy to forget to stop the actor manually, especially in error conditions.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--communication","title":"Communication","text":"<p>The <code>Actor</code> class doesn't impose any specific way to communicate between actors. However, <code>frequenz.channels</code> are always used as the communication mechanism between actors in the SDK.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--implementing-an-actor","title":"Implementing an Actor","text":"<p>To implement an actor, you must inherit from the <code>Actor</code> class and implement an initializer and the abstract <code>_run()</code> method.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--initialization","title":"Initialization","text":"<p>The initializer is called when the actor is created. The <code>Actor</code> class initializer (<code>__init__</code>) should be always called first in the class we are implementing to make sure actors are properly initialized.</p> <p>The <code>Actor.__init__()</code> takes one optional argument, a <code>name</code> that will be used to identify the actor in logs. If no name is provided, a default name will be generated, but it is recommended that <code>Actor</code> subclasses can also receive a name as an argument to make it easier to identify individual instances in logs more easily.</p> <p>The actor initializer normally also accepts as arguments the input channels receivers and output channels senders that will be used for communication. These channels should be created outside the actor and passed to it as arguments to ensure actors can be composed easily.</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\nclass EchoActor(Actor):  # (1)!\ndef __init__(\nself,\ninput: Receiver[int],  # (2)!\noutput: Sender[int],  # (3)!\nname: str | None = None,  # (4)!\n) -&gt; None:\nsuper().__init__(name=name) # (5)!\nself._input: Receiver[int] = input  # (6)!\nself._output: Sender[int] = output  # (7)!\n</code></pre> <ol> <li> <p>We define a new actor class called <code>EchoActor</code> that inherits from     <code>Actor</code>.</p> </li> <li> <p>We accept an <code>input</code> argument that will be used to receive messages from     a channel.</p> </li> <li>We accept an <code>output</code> argument that will be used to send messages to a channel.</li> <li>We accept an optional <code>name</code> argument that will be used to identify the actor in     logs.</li> <li>We call <code>Actor.__init__()</code> to make sure the     actor is properly initialized.</li> <li>We store the <code>input</code> argument in a private instance variable to use it later.</li> <li>We store the <code>output</code> argument in a private instance variable to use it later.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--the-_run-method","title":"The <code>_run()</code> Method","text":"<p>The abstract <code>_run()</code> method is called automatically by the base class when the actor is started.</p> <p>Normally an actor should run forever (or until it is stopped), so it is very common to have an infinite loop in the <code>_run()</code> method, typically receiving messages from one or more channels (receivers), processing them and sending the results to other channels (senders).</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\nclass EchoActor(Actor):\ndef __init__(\nself,\ninput: Receiver[int],\noutput: Sender[int],\nname: str | None = None,\n) -&gt; None:\nsuper().__init__(name=name)\nself._input: Receiver[int] = input\nself._output: Sender[int] = output\nasync def _run(self) -&gt; None:  # (1)!\nasync for msg in self._input:  # (2)!\nawait self._output.send(msg)  # (3)!\n</code></pre> <ol> <li>We implement the abstract <code>_run()</code> method.</li> <li>We receive messages from the <code>input</code> channel one by one.</li> <li>We send the received message to the <code>output</code> channel.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--stopping","title":"Stopping","text":"<p>By default, the <code>stop()</code> method will call the <code>cancel()</code> method (which will cancel all the tasks created by the actor) and will wait for them to finish.</p> <p>This means that when an actor is stopped, the <code>_run()</code> method will receive a <code>CancelledError</code> exception. You should have this in mind when implementing your actor and make sure to handle this exception properly if you need to do any cleanup.</p> <p>The actor will handle the <code>CancelledError</code> exception automatically if it is not handled in the <code>_run()</code> method, so if there is no need for extra cleanup, you don't need to worry about it.</p> <p>If an unhandled exception is raised in the <code>_run()</code> method, the actor will re-run the <code>_run()</code> method automatically. This ensures robustness in the face of errors, but you should also have this in mind if you need to do any cleanup to make sure the re-run doesn't cause any problems.</p> Tip <p>You could implement your own <code>stop()</code> method to, for example, send a message to a channel to notify that the actor should stop, or any other more graceful way to stop the actor if you need to make sure it can't be interrupted at any <code>await</code> point.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--spawning-extra-tasks","title":"Spawning Extra Tasks","text":"<p>Actors run at least one background task, created automatically by the <code>Actor</code> class. But <code>Actor</code> inherits from <code>BackgroundService</code>, which provides a few methods to create and manage extra tasks.</p> <p>If your actor needs to spawn extra tasks, you can use <code>BackgroundService</code> facilities to manage the tasks, so they are also automatically stopped when the actor is stopped.</p> <p>All you need to do is add the newly spawned tasks to the actor's <code>tasks</code> set.</p> Example <pre><code>import asyncio\nfrom frequenz.sdk.actor import Actor\nclass MyActor(Actor):\nasync def _run(self) -&gt; None:\nextra_task = asyncio.create_task(self._extra_task())  # (1)!\nself.tasks.add(extra_task)  # (2)!\nwhile True:  # (3)!\nprint(\"_run() running\")\nawait asyncio.sleep(1)\nasync def _extra_task(self) -&gt; None:\nwhile True:  # (4)!\nprint(\"_extra_task() running\")\nawait asyncio.sleep(1.1)\nasync with MyActor() as actor:  # (5)!\nawait asyncio.sleep(3)  # (6)!\n# (7)!\n</code></pre> <ol> <li>We create a new task using <code>asyncio.create_task()</code>.</li> <li>We add the task to the actor's <code>tasks</code> set.     This ensures the task will be cancelled and cleaned up when the actor is stopped.</li> <li>We leave the actor running forever.</li> <li>The extra task will also run forever.</li> <li>The actor is started.</li> <li>We wait for 3 seconds, the actor should print a bunch of \"_run() running\" and     \"_extra_task() running\" messages while it's running.</li> <li>The actor is stopped and the extra task is cancelled automatically.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--examples","title":"Examples","text":"<p>Here are a few simple but complete examples to demonstrate how to create actors and connect them using channels.</p> <p>Tip</p> <p>The code examples are annotated with markers (like ), you can click on them to see the step-by-step explanation of what's going on. The annotations are numbered according to the order of execution.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--composing-actors","title":"Composing actors","text":"<p>This example shows how to create two actors and connect them using broadcast channels.</p> compose.py<pre><code>import asyncio\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.sdk.actor import Actor\nclass Actor1(Actor):  # (1)!\ndef __init__(\nself,\nreceiver: Receiver[str],\noutput: Sender[str],\nname: str | None = None,\n) -&gt; None:\nsuper().__init__(name=name)\nself._receiver = receiver\nself._output = output\nasync def _run(self) -&gt; None:\nasync for msg in self._receiver:\nawait self._output.send(f\"Actor1 forwarding: {msg!r}\")  # (8)!\nclass Actor2(Actor):\ndef __init__(\nself,\nreceiver: Receiver[str],\noutput: Sender[str],\nname: str | None = None,\n) -&gt; None:\nsuper().__init__(name=name)\nself._receiver = receiver\nself._output = output\nasync def _run(self) -&gt; None:\nasync for msg in self._receiver:\nawait self._output.send(f\"Actor2 forwarding: {msg!r}\")  # (9)!\nasync def main() -&gt; None:  # (2)!\n# (4)!\ninput_channel: Broadcast[str] = Broadcast(\"Input to Actor1\")\nmiddle_channel: Broadcast[str] = Broadcast(\"Actor1 -&gt; Actor2 stream\")\noutput_channel: Broadcast[str] = Broadcast(\"Actor2 output\")\ninput_sender = input_channel.new_sender()\noutput_receiver = output_channel.new_receiver()\nasync with (  # (5)!\nActor1(input_channel.new_receiver(), middle_channel.new_sender(), \"actor1\"),\nActor2(middle_channel.new_receiver(), output_channel.new_sender(), \"actor1\"),\n):\nawait input_sender.send(\"Hello\")  # (6)!\nmsg = await output_receiver.receive()  # (7)!\nprint(msg)  # (10)!\n# (11)!\nif __name__ == \"__main__\":  # (3)!\nasyncio.run(main())\n</code></pre> <ol> <li> <p>We define 2 actors: <code>Actor1</code> and <code>Actor2</code> that will just forward a message    from an input channel to an output channel, adding some text.</p> </li> <li> <p>We define an async <code>main()</code> function with the main logic of our asyncio program.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We create a bunch of broadcast channels to connect our actors.</p> <ul> <li><code>input_channel</code> is the input channel for <code>Actor1</code>.</li> <li><code>middle_channel</code> is the channel that connects <code>Actor1</code> and <code>Actor2</code>.</li> <li><code>output_channel</code> is the output channel for <code>Actor2</code>.</li> </ul> </li> <li> <p>We create two actors and use them as async context managers, <code>Actor1</code> and     <code>Actor2</code>, and connect them by creating new     senders and     receivers from the channels.</p> <p>Note</p> <p>We don't use the <code>run()</code> function here because we want to stop the actors when we are done with them, but the actors will run forever (as long as the channel is not closed). So the async context manager is a better fit for this example.</p> </li> <li> <p>We schedule the sending of the message    <code>Hello</code> to <code>Actor1</code> via <code>input_channel</code>.</p> </li> <li> <p>We receive (await) the response from    <code>Actor2</code> via <code>output_channel</code>. Between this and the previous steps the    <code>async</code> calls in the actors will be executed.</p> </li> <li> <p><code>Actor1</code> sends the re-formatted message (<code>Actor1 forwarding: Hello</code>) to    <code>Actor2</code> via the <code>middle_channel</code>.</p> </li> <li> <p><code>Actor2</code> sends the re-formatted message (<code>Actor2 forwarding: \"Actor1    forwarding: 'Hello'\"</code>) to the <code>output_channel</code>.</p> </li> <li> <p>Finally, we print the received message, which will still be <code>Actor2     forwarding: \"Actor1 forwarding: 'Hello'\"</code>.</p> </li> <li> <p>The actors are stopped and cleaned up automatically when the <code>async with</code>     block ends.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Actor2 forwarding: \"Actor1 forwarding: 'Hello'\"\n</code></pre>"},{"location":"user-guide/actors/#frequenz.sdk.actor--receiving-from-multiple-channels","title":"Receiving from multiple channels","text":"<p>This example shows how to create an actor that receives messages from multiple broadcast channels using <code>select()</code>.</p> select.py<pre><code>import asyncio\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.channels.util import select, selected_from\nfrom frequenz.sdk.actor import Actor, run\nclass EchoActor(Actor):  # (1)!\ndef __init__(\nself,\nreceiver_1: Receiver[bool],\nreceiver_2: Receiver[bool],\noutput: Sender[bool],\nname: str | None = None,\n) -&gt; None:\nsuper().__init__(name=name)\nself._receiver_1 = receiver_1\nself._receiver_2 = receiver_2\nself._output = output\nasync def _run(self) -&gt; None:  # (2)!\nasync for selected in select(self._receiver_1, self._receiver_2):  # (10)!\nif selected_from(selected, self._receiver_1):  # (11)!\nprint(f\"Received from receiver_1: {selected.value}\")\nawait self._output.send(selected.value)\nif not selected.value:  # (12)!\nbreak\nelif selected_from(selected, self._receiver_2):  # (13)!\nprint(f\"Received from receiver_2: {selected.value}\")\nawait self._output.send(selected.value)\nif not selected.value:  # (14)!\nbreak\nelse:\nassert False, \"Unknown selected channel\"\nprint(\"EchoActor finished\")\n# (15)!\n# (3)!\ninput_channel_1 = Broadcast[bool](\"input_channel_1\")\ninput_channel_2 = Broadcast[bool](\"input_channel_2\")\necho_channel = Broadcast[bool](\"echo_channel\")\necho_actor = EchoActor(  # (4)!\ninput_channel_1.new_receiver(),\ninput_channel_2.new_receiver(),\necho_channel.new_sender(),\n\"echo-actor\",\n)\necho_receiver = echo_channel.new_receiver()  # (5)!\nasync def main() -&gt; None:  # (6)!\n# (8)!\nawait input_channel_1.new_sender().send(True)\nawait input_channel_2.new_sender().send(False)\nawait run(echo_actor)  # (9)!\nawait echo_channel.close()  # (16)!\nasync for message in echo_receiver:  # (17)!\nprint(f\"Received {message=}\")\nif __name__ == \"__main__\":  # (7)!\nasyncio.run(main())\n</code></pre> <ol> <li> <p>We define an <code>EchoActor</code> that receives messages from two channels and sends     them to another channel.</p> </li> <li> <p>We implement the <code>_run()</code> method that will receive messages from the two     channels using and send them to the output channel. The <code>run()</code> method will stop if     a <code>False</code> message is received.</p> </li> <li> <p>We create the channels that will be used with the actor.</p> </li> <li> <p>We create the actor and connect it to the channels by creating new receivers and     senders from the channels.</p> </li> <li> <p>We create a receiver for the <code>echo_channel</code> to eventually receive the messages sent     by the actor.</p> </li> <li> <p>We define the <code>main()</code> function that will run the actor.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We send a message to each of the input channels. These messages will be queued in     the channels until they are consumed by the actor.</p> </li> <li> <p>We start the actor and wait for it to finish using the     <code>run()</code> function.</p> </li> <li> <p>The <code>select()</code> function will get the first message     available from the two channels. The order in which they will be handled is     unknown, but in this example we assume that the first message will be from     <code>input_channel_1</code> (<code>True</code>) and the second from <code>input_channel_1</code> (<code>False</code>).</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>True</code> for the <code>input_channel_1</code> receiver. <code>selected.value</code> holds the received     message, so <code>\"Received from receiver_1: True\"</code> will be printed and <code>True</code> will be     sent to the <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>True</code>, the loop will continue, going back to the and the     the loop will continue, going back to the     <code>select()</code> function.</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>False</code> for the <code>input_channel_1</code> receiver and <code>True</code> for the <code>input_channel_2</code>     receiver. The message stored in <code>selected.value</code> will now be <code>False</code>, so     <code>\"Received from receiver_2: False\"</code> will be printed and <code>False</code> will be sent to the     <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>False</code>, the loop will break.</p> </li> <li> <p>The <code>_run()</code> method will finish normally and the actor will be stopped, so     the <code>run()</code> function will return.</p> </li> <li> <p>We close the <code>echo_channel</code> to make sure the <code>echo_receiver</code> will stop receiving     messages after all the queued messages are consumed (otherwise the step 17 will     never end!).</p> </li> <li> <p>We receive the messages sent by the actor to the <code>echo_channel</code> one by one and print     them, it should print first <code>Received message=True</code> and then <code>Received     message=False</code>.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Received from receiver_1: True\nReceived from receiver_2: False\nReceived message=True\nReceived message=False\n</code></pre>"},{"location":"user-guide/formula-engine/","title":"Formula Engine","text":""},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine","title":"FormulaEngine","text":"<p><code>FormulaEngine</code>s are a part of the SDK's data pipeline, and provide a way for the SDK to apply formulas on resampled data streams.</p> <p>They are used in the SDK to calculate and stream metrics like <code>grid_power</code>, <code>consumer_power</code>, etc., which are building blocks of the Frequenz SDK Microgrid Model.</p> <p>The SDK creates the formulas by analysing the configuration of components in the Component Graph.</p>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine.new_receiver()</code> method can be used to create a Receiver that streams the Samples calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\nbattery_pool = microgrid.battery_pool()\nasync for power in battery_pool.power.new_receiver():\nprint(f\"{power=}\")\n</code></pre>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--composition","title":"Composition","text":"<p>Composite <code>FormulaEngine</code>s can be built using arithmetic operations on <code>FormulaEngine</code>s streaming the same type of data.</p> <p>For example, if you're interested in a particular composite metric that can be calculated by subtracting <code>battery_pool().power</code> and <code>ev_charger_pool().power</code> from the <code>logical_meter().grid_power</code>, we can build a <code>FormulaEngine</code> that provides a stream of this calculated metric as follows:</p> <pre><code>from frequenz.sdk import microgrid\nlogical_meter = microgrid.logical_meter()\nbattery_pool = microgrid.battery_pool()\nev_charger_pool = microgrid.ev_charger_pool()\n# apply operations on formula engines to create a formula engine that would\n# apply these operations on the corresponding data streams.\nnet_power = (\nlogical_meter.grid_power - (battery_pool.power + ev_charger_pool.power)\n).build(\"net_power\")\nasync for power in net_power.new_receiver():\nprint(f\"{power=}\")\n</code></pre>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase","title":"FormulaEngine3Phase","text":"<p>A <code>FormulaEngine3Phase</code> is similar to a <code>FormulaEngine</code>, except that they stream 3-phase samples.  All the current formulas (like <code>LogicalMeter.grid_current</code>, <code>EVChargerPool.current</code>, etc.) are implemented as 3-phase formulas.</p>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine3Phase.new_receiver()</code> method can be used to create a Receiver that streams the Sample3Phase values calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\nev_charger_pool = microgrid.ev_charger_pool()\nasync for sample in ev_charger_pool.current.new_receiver():\nprint(f\"Current: {sample}\")\n</code></pre>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--composition","title":"Composition","text":"<p><code>FormulaEngine3Phase</code> instances can be composed together, just like <code>FormulaEngine</code> instances.</p> <pre><code>from frequenz.sdk import microgrid\nlogical_meter = microgrid.logical_meter()\nev_charger_pool = microgrid.ev_charger_pool()\n# Calculate grid consumption current that's not used by the EV chargers\nother_current = (logical_meter.grid_current - ev_charger_pool.current).build(\"other_current\")\nasync for sample in other_current.new_receiver():\nprint(f\"Other current: {sample}\")\n</code></pre>"},{"location":"user-guide/glossary/","title":"Glossary","text":"<p>This glossary provides definitions for common terminology used in the Frequenz SDK, focusing on microgrid components, metrics, measurements, and power-related terms.</p>"},{"location":"user-guide/glossary/#common-acronyms","title":"Common Acronyms","text":""},{"location":"user-guide/glossary/#ac","title":"AC","text":"<p>Alternating current. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#bms","title":"BMS","text":"<p>Battery management system. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#chp","title":"CHP","text":"<p>Combined heat and power. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#dc","title":"DC","text":"<p>Direct current. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#ev","title":"EV","text":"<p>Electric vehicle. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#psc","title":"PSC","text":"<p>Passive sign convention. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#pv","title":"PV","text":"<p>Photovoltaic. See the Wikipedia article for more details.</p> <p>In the SDK it is normally used as a synonym for solar panel.</p>"},{"location":"user-guide/glossary/#soc","title":"SoC","text":"<p>State of charge. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#sop","title":"SoP","text":"<p>State of power.</p>"},{"location":"user-guide/glossary/#microgrid","title":"Microgrid","text":"<p>A local electrical grid that connects a set of different types of components together. It can be connected to the public grid, or be completely isolated, in which case it is known as an island.</p>"},{"location":"user-guide/glossary/#component-category","title":"Component Category","text":"<p>The category components of a microgrid belong to.</p> <p>Components of the same category have the same characteristics (for example offer the same set of metrics).</p>"},{"location":"user-guide/glossary/#battery","title":"Battery","text":"<p>A storage system for electrical energy.</p>"},{"location":"user-guide/glossary/#chp-plant","title":"CHP Plant","text":"<p>A generator that produces combined heat and power (CHP). Usually powered via combustion of some form of fuel.</p>"},{"location":"user-guide/glossary/#converter","title":"Converter","text":"<p>Generally refers to DC-to-DC converter.</p>"},{"location":"user-guide/glossary/#dc-to-dc-converter","title":"DC-to-DC Converter","text":"<p>An electronic circuit or electromechanical device that converts a source of DC from one voltage level to another.</p>"},{"location":"user-guide/glossary/#ev-charger","title":"EV Charger","text":"<p>A station for charging EVs.</p>"},{"location":"user-guide/glossary/#electrolyzer","title":"Electrolyzer","text":"<p>A device that converts water into hydrogen and oxygen.</p>"},{"location":"user-guide/glossary/#grid","title":"Grid","text":"<p>A point where the local microgrid is connected to the public electricity grid.</p>"},{"location":"user-guide/glossary/#inverter","title":"Inverter","text":"<p>A device or circuitry that converts DC electricity to AC electricity.</p>"},{"location":"user-guide/glossary/#meter","title":"Meter","text":"<p>A device for measuring electrical metrics (for example current, voltage, etc.).</p>"},{"location":"user-guide/glossary/#pv-array","title":"PV Array","text":"<p>A collection of PV panels.</p>"},{"location":"user-guide/glossary/#pre-charge-module","title":"Pre-charge module","text":"<p>A device that gradually ramp the DC voltage up to prevent any potential damage to sensitive electrical components, like capacitors.</p> <p>While many inverters and batteries come equipped with in-built pre-charging mechanisms, some may lack this feature. In such cases, external pre-charging modules can be used.</p>"},{"location":"user-guide/glossary/#relay","title":"Relay","text":"<p>A device that generally have two states: open (connected) and closed (disconnected).</p> <p>They are generally placed in front of another component, e.g., an inverter, to control whether the component is connected to the microgrid or not.</p>"},{"location":"user-guide/glossary/#sensor","title":"Sensor","text":"<p>A device for [measuring](#measurement] ambient metrics (for example temperature, humidity, etc.).</p>"},{"location":"user-guide/glossary/#solar-panel","title":"Solar Panel","text":"<p>A panel with PV cells that generates DC electricity from sunlight.</p>"},{"location":"user-guide/glossary/#wind-turbine","title":"Wind Turbine","text":"<p>A device that converts the wind's kinetic energy into electrical energy.</p>"},{"location":"user-guide/glossary/#component","title":"Component","text":"<p>A device (of a particular category) within a microgrid.</p>"},{"location":"user-guide/glossary/#component-id","title":"Component ID","text":"<p>A numeric identifier uniquely representing an instance of a component in a particular microgrid. It is always of type <code>int</code>.</p> <p>For example, a battery with a component ID of 5.</p>"},{"location":"user-guide/glossary/#component-graph","title":"Component Graph","text":"<p>A graph representation of the configuration in which the electrical components in a microgrid are connected with each other.  Some of the ways in which the SDK uses the component graph are:</p> <ul> <li>figure out how to calculate high level metrics like <code>grid_power</code>, <code>consumer_power</code>, etc. for a microgrid, using the available components.</li> <li>identify the available batteries or     EV chargers at a site that can be controlled.</li> </ul>"},{"location":"user-guide/glossary/#island","title":"Island","text":"<p>A microgrid that is not connected to the public electricity grid.</p>"},{"location":"user-guide/glossary/#passive-sign-convention","title":"Passive Sign Convention","text":"<p>A convention for the direction of power flow in a circuit. When the electricity is flowing into a component the value is positive, and when it is flowing out of a component the value is negative.</p> <p>In microgrids that have a grid connection, power flowing away from the grid is positive, and power flowing towards the grid is negative.</p>"},{"location":"user-guide/glossary/#component-data","title":"Component Data","text":""},{"location":"user-guide/glossary/#metric","title":"Metric","text":"<p>A quantifiable attribute of a component.</p> <p>For example, the metric capacity of a battery.</p>"},{"location":"user-guide/glossary/#measurement","title":"Measurement","text":"<p>An individual numeric value obtained from a metric of a component instance. It is consistently of type <code>float</code>, but it is often expressed in specific units.</p> <p>In the context of a sample, this is commonly referred to as a sample value.</p> <p>For example, a measurement of the capacity of a battery with component ID 5 can be 400, typically measured in Watt-hours (Wh).</p>"},{"location":"user-guide/glossary/#timestamp","title":"Timestamp","text":"<p>A specific point in time, always represented as a <code>datetime</code> with a <code>timezone</code> attached.</p> <p>For example, 2022-01-01 22:00:00.000 UTC.</p>"},{"location":"user-guide/glossary/#sample","title":"Sample","text":"<p>A measurement recorded at a particular timestamp, typically represented as a tuple <code>(timestamp, value)</code>.</p> <p>For example, recording a measurement of 400 from the capacity of a battery at 2022-01-01 22:00:00.000 UTC would constitute a sample <code>(2022-01-01 22:00:00.000 UTC, 400)</code>.</p>"},{"location":"user-guide/glossary/#sample-value","title":"Sample Value","text":"<p>A measurement stored in a sample.</p>"},{"location":"user-guide/glossary/#time-series","title":"Time Series","text":"<p>A sequence of samples, often organized by timestamp and typically with regular intervals. However, irregular (event-based) time series are also possible.</p> <p>For example, a time series representing measurements of a battery's capacity at 2022-01-01 22:00:00.000 UTC every second for 5 seconds would appear as follows:</p> <pre><code>(2022-01-01 22:00:00.000 UTC, 400)\n(2022-01-01 22:00:01.000 UTC, 401)\n(2022-01-01 22:00:02.000 UTC, 403)\n(2022-01-01 22:00:03.000 UTC, 402)\n(2022-01-01 22:00:04.000 UTC, 403)\n</code></pre>"},{"location":"user-guide/glossary/#timeseries","title":"Timeseries","text":"<p>Same as time series.</p>"},{"location":"user-guide/glossary/#metric-id","title":"Metric ID","text":"<p>An identifier for a component's metric, typically a string (<code>str</code>).</p> <p>Components belonging to the same category have the same set of metric IDs.</p> <p>For example, the metric ID for the capacity of a battery is simply <code>capacity</code>.</p>"},{"location":"user-guide/glossary/#time-series-id","title":"Time Series ID","text":"<p>An identifier for a time series originating from a metric of a specific component. Typically a string (<code>str</code>) derived from the tuple (component ID, metric ID) for components.</p> <p>For example, a time series for the capacity of a battery with component ID 5 has the ID (component_id, metric_id) (or <code>f\"{component_id}_{metric_id}\"</code>).</p>"},{"location":"user-guide/glossary/#timeseries-id","title":"Timeseries ID","text":"<p>Same as time series ID.</p>"},{"location":"user-guide/glossary/#metrics","title":"Metrics","text":"<p>All metrics related to power, energy, current, etc. use the PSC to determine the sign of the value.</p>"},{"location":"user-guide/glossary/#consumption","title":"Consumption","text":"<p>The amount of electricity flowing into a component. It is the clipped positive value when using the PSC, so if the electricity is flowing out of the component instead, this will be zero.</p>"},{"location":"user-guide/glossary/#gross-consumption","title":"Gross Consumption","text":"<p>Consumption before accounting for any local generation from solar, wind or CHP.</p>"},{"location":"user-guide/glossary/#instantaneous-power","title":"Instantaneous Power","text":"<p>Same as power.</p>"},{"location":"user-guide/glossary/#load","title":"Load","text":"<p>Typically refers to a device that consumes electricity, but also to the amount of electricity consumed by such a device. In a microgrid context, it is often used to refer to all the electrical devices that are doing active work, for example a light bulb, a motor, a cooler, etc.</p> <p>When using the PSC, this is the same as consumption and it is a positive value. If a load generates electricity instead, it is a negative value but it wouldn't typically be called a load.</p>"},{"location":"user-guide/glossary/#net-consumption","title":"Net Consumption","text":"<p>This term traditionally refers to the difference between the gross consumption and the local generation (like PV production). It is the electricity consumption that needs to be provided by the battery or from the public grid.</p>"},{"location":"user-guide/glossary/#net-load","title":"Net Load","text":"<p>Same as net consumption.</p>"},{"location":"user-guide/glossary/#power","title":"Power","text":"<p>The rate of energy transfer, i.e. the amount of energy transferred per unit of time. It is typically measured in Watts (W).</p> <p>For AC electricity, there are three types of power: active, reactive, and apparent (P, Q and |S| respectively in power triangle).</p> <p>See the Wikipedia article for more information.</p>"},{"location":"user-guide/glossary/#power-triangle","title":"Power Triangle","text":"<p>The visual representation of the relationship between the three types of AC power and phase of voltage relative to current.</p> <p></p> <p>(CC-BY-SA 3.0, Wikimedia Commons)</p>"},{"location":"user-guide/glossary/#active-power","title":"Active Power","text":"<p>The AC power that is actually consumed by the load. It is the real part of the apparent power, P in the power triangle.</p>"},{"location":"user-guide/glossary/#apparent-power","title":"Apparent Power","text":"<p>The AC power that is actually supplied to the load. The magnitude of the vector sum of the active and reactive power, |S| in the power-triangle.</p>"},{"location":"user-guide/glossary/#phase-of-voltage-relative-to-current","title":"Phase of Voltage Relative to Current","text":"<p>The angle of difference (in degrees) between current and voltage in an AC circuit, \u03c6 in the power triangle.</p>"},{"location":"user-guide/glossary/#power-factor","title":"Power Factor","text":"<p>The ratio of real power to apparent power in an AC circuit. Can be obtained by computing the cosine of \u03c6, in the power triangle. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#reactive-power","title":"Reactive Power","text":"<p>The AC power that is not consumed by the load, but is alternately stored and returned to the source. It is the imaginary part of the apparent power, Q in the power triangle.</p>"},{"location":"user-guide/glossary/#real-power","title":"Real Power","text":"<p>Same as active power.</p>"},{"location":"user-guide/glossary/#production","title":"Production","text":"<p>The amount of electricity flowing out of a component. It is the clipped negative value when using the PSC, so if the electricity is flowing into the component instead, this will be zero.</p>"},{"location":"user-guide/glossary/#residual-consumption","title":"Residual Consumption","text":"<p>In microgrid context sometimes used as the remaining difference between the net consumption and the battery power, i.e. what we define as grid power.</p>"},{"location":"user-guide/glossary/#residual-load","title":"Residual Load","text":"<p>Same as residual consumption.</p>"},{"location":"user-guide/glossary/#state-of-charge","title":"State of Charge","text":"<p>The level of charge of a battery relative to its capacity, expressed in percentage points. Calculated as the ratio between the remaining energy in the battery at a given time and the maximum possible energy under similar health conditions. Source</p>"},{"location":"user-guide/glossary/#state-of-power","title":"State of Power","text":"<p>The ratio of peak power to nominal power. Peak power is the maximum power that can be sustained for a specific duration without violating preset operational design limits on battery voltage, SoC, power, or current.</p> <p>This indicator is crucial to ensure that charge or discharge power remains within specific limits, optimizing the battery's lifespan. It is particularly useful in peak power applications to define battery conditions for substantial charges or discharges.</p> <p>The state of power depends on the state of charge, battery capacity, initial characteristics, chemistry, and battery voltage, as well as external factors like temperature and humidity, which can also have a significant impact on it. Source</p>"},{"location":"user-guide/microgrid-concepts/","title":"Microgrid Concepts","text":"<p>A microgrid is a local electrical grid that connects a set of electrical components together.  They are often built around a passive power consumer, to supplement the electricity consumed from the public grid with on-site power generation or storage systems.</p> <p>Microgrids can also function in island-mode, without a grid connection, or without a local power consumer, but they have to have at least one of the two, to be meaningful.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--frequenz-sdk-microgrid-model","title":"Frequenz SDK Microgrid Model","text":"<p>The SDK aims to provide an abstract model of the microgrid that enables high-level interactions with microgrid components, without having to worry about (or even be aware of) location-specific details such as:</p> <ul> <li>where the meters are placed,</li> <li>how many batteries,</li> <li>whether there's a grid connection or a passive consumer,</li> <li>what models the inverters are, etc.</li> <li>whether components are having downtimes, because metrics and   limits get adjusted automatically when components are having downtimes.</li> </ul> <p>Users of the SDK can develop applications around this interface once and deploy anywhere, and the SDK will take care of translating the requests and instructions to correspond to the specific microgrid configurations.</p> <pre><code>flowchart LR\n\nsubgraph Left[Measurements only]\ndirection LR\n  grid[\"Grid Connection\"]\n  consumer[\"Consumer\"]\n  pv[\"PV Arrays\"]\n  chp[\"CHP\"]\nend\n\njunction(( ))\n\nsubgraph Right[Measurements and control]\ndirection LR\n  bat[\"Batteries\"]\n  ev[\"EV Chargers\"]\nend\n\ngrid --- junction\nconsumer --- junction\npv --- junction\nchp --- junction\n\njunction --- bat\njunction --- ev</code></pre>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--grid","title":"Grid","text":"<p>This refers to a microgrid's connection to the external Grid.  The power flowing through this connection can be streamed through <code>grid_power</code>.</p> <p>In locations without a grid connection, this method remains accessible, and streams zero values.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--consumer","title":"Consumer","text":"<p>This is the main power consumer at the site of a microgrid, and often the load the microgrid is built to support.  The power drawn by the consumer is available through <code>consumer_power</code></p> <p>In locations without a consumer, this method streams zero values.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--producers-pv-arrays-chp","title":"Producers: PV Arrays, CHP","text":"<p>The total PV power production in a microgrid can be streamed through <code>pv_power</code> , and similarly the total CHP production in a site can be streamed through <code>chp_power</code>.  And total producer power is available through <code>producer_power</code>.</p> <p>As is the case with the other methods, if PV Arrays or CHPs are not available in a microgrid, the corresponding methods stream zero values.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--batteries","title":"Batteries","text":"<p>The total Battery power is available through <code>battery_pool</code>'s <code>power</code>.  The battery pool by default uses all batteries available at a location, but battery pool instances can be created for subsets of batteries if necessary, by specifying the battery ids.</p> <p>The <code>battery_pool</code> also provides <code>soc</code>, <code>capacity</code>, <code>temperature</code> and available power bounds through the <code>power_status</code> method.</p> <p>The <code>battery_pool</code> also provides control methods <code>propose_power</code> (which accepts values in the Passive Sign Convention and supports both charging and discharging), or through <code>propose_charge</code>, or <code>propose_discharge</code>.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--ev-chargers","title":"EV Chargers","text":"<p>The <code>ev_charger_pool</code> offers a <code>power</code> method that streams the total power measured for all the EV Chargers at a site.</p> <p>It also offers a <code>component_data</code> method for fetching the status of individual EV Chargers, including state changes like when an EV is connected or disconnected, and a <code>set_bounds</code> method to limit the charge power of individual EV Chargers.</p>"}]}