{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Python SDK","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The Frequenz Python SDK is a development kit for interacting with the Frequenz development platform.</p>"},{"location":"#installation","title":"Installation","text":"<p>First, you need to make sure you have Python installed (at least version 3.11):</p> <pre><code>$ python3 --version\nPython 3.11.4\n</code></pre> <p>Note</p> <p>These instructions assume you are using a POSIX compatible <code>sh</code> shell.</p> <p>If that command doesn't print a version newer than 3.11.0, you'll need to download and install Python first.</p> <p>To install the SDK, you probably want to create a new virtual environment first:</p> <pre><code>mkdir my-sdk-project\ncd my-sdk-project\npython3 -m venv .venv\n. .venv/bin/activate\n</code></pre> <p>Tip</p> <p>Using <code>direnv</code> can greatly simplify this process as it automates the creation, activation, and deactivation of the virtual environment. The first time you enable <code>direnv</code>, the virtual environment will be created, and each time you enter or leave a subdirectory, it will be activated and deactivated, respectively.</p> <pre><code>sudo apt install direnv # if you use Debian/Ubuntu\nmkdir my-sdk-project\ncd my-sdk-project\necho \"layout python python3\" &gt; .envrc\ndirenv allow\n</code></pre> <p>This will create the virtual environment and activate it automatically for you.</p> <p>Now you can install the SDK by using <code>pip</code> (if you don't have <code>pip</code> installed you can follow the official instructions):</p> <pre><code>python3 -m pip install frequenz-sdk\n</code></pre> <p>To verify that the installation worked, you can invoke the Python interpreter and import the SDK:</p> <pre><code>$ python3\nPython 3.11.4 (main, Jun  7 2023, 10:13:09) [GCC 12.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import frequenz.sdk\n&gt;&gt;&gt;\n</code></pre>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Python SDK","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>User Guide</li> <li>Tutorials</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>sdk<ul> <li>actor<ul> <li>power_distributing<ul> <li>power_distributing</li> <li>request</li> <li>result</li> </ul> </li> </ul> </li> <li>config</li> <li>microgrid<ul> <li>client</li> <li>component</li> <li>component_graph</li> <li>connection_manager</li> <li>metadata</li> </ul> </li> <li>timeseries<ul> <li>battery_pool</li> <li>consumer</li> <li>ev_charger_pool</li> <li>formula_engine</li> <li>grid</li> <li>logical_meter</li> <li>producer</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/sdk/","title":"Index","text":""},{"location":"reference/frequenz/sdk/#frequenz.sdk","title":"frequenz.sdk","text":"<p>Frequenz Python SDK.</p>"},{"location":"reference/frequenz/sdk/actor/","title":"Index","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor","title":"frequenz.sdk.actor","text":"<p>Actors are a primitive unit of computation that runs autonomously.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--actor-programming-model","title":"Actor Programming Model","text":"<p>From Wikipedia</p> <p>The actor model in computer science is a mathematical model of concurrent computation that treats an actor as the basic building block of concurrent computation. In response to a message it receives, an actor can: make local decisions, create more actors, send more messages, and determine how to respond to the next message received. Actors may modify their own private state, but can only affect each other indirectly through messaging (removing the need for lock-based synchronization).</p> <p>We won't get into much more detail here because it is outside the scope of this documentation. However, if you are interested in learning more about the actor programming model, here are some useful resources:</p> <ul> <li>Actor Model (Wikipedia)</li> <li>How the Actor Model Meets the Needs of Modern, Distributed Systems   (Akka)</li> </ul>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--frequenz-sdk-actors","title":"Frequenz SDK Actors","text":"<p>The <code>Actor</code> class serves as the foundation for creating concurrent tasks and all actors in the SDK inherit from it. This class provides a straightforward way to implement actors. It shares similarities with the traditional actor programming model but also has some unique features:</p> <ul> <li> <p>Message Passing: Like traditional actors, our <code>Actor</code>   class communicates through message passing. Even when no particular message passing   mechanism is enforced, the SDK actors use <code>frequenz.channels</code> for communication.</p> </li> <li> <p>Automatic Restart: If an unhandled exception occurs in an actor's logic   (<code>_run()</code> method), the actor will be automatically restarted. This ensures   robustness in the face of errors.</p> </li> <li> <p>Simplified Task Management: Actors manage asynchronous tasks using   <code>asyncio</code>. You can create and manage tasks within the actor, and the   <code>Actor</code> class handles task cancellation and cleanup.</p> </li> <li> <p>Simplified lifecycle management: Actors are [async context managers] and also   a <code>run()</code> function is provided to easily run a group of   actors and wait for them to finish.</p> </li> </ul>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--lifecycle","title":"Lifecycle","text":"<p>Actors are not started when they are created. There are 3 main ways to start an actor (from most to least recommended):</p> <ol> <li>By using the <code>run()</code> function.</li> <li>By using the actor as an async context manager.</li> <li>By using the <code>start()</code> method.</li> </ol> <p>Warning</p> <ol> <li> <p>If an actor raises an unhandled exception, it will be restarted automatically.</p> </li> <li> <p>Actors manage <code>asyncio.Task</code> objects, so a reference to the actor object must    be held for as long as the actor is expected to be running, otherwise its tasks    will be cancelled and the actor will stop. For more information, please refer to    the Python <code>asyncio</code>    documentation.</p> </li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--the-run-function","title":"The <code>run()</code> Function","text":"<p>The <code>run()</code> function can start many actors at once and waits for them to finish. If any of the actors are stopped with errors, the errors will be logged.</p> Example <pre><code>from frequenz.sdk.actor import Actor, run\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nawait run(MyActor()) # (1)!\n</code></pre> <ol> <li>This line will block until the actor is stopped.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--async-context-manager","title":"Async Context Manager","text":"<p>When an actor is used as an async context manager, it is started when the <code>async with</code> block is entered and stopped automatically when the block is exited (even if an exception is raised).</p> Example <pre><code>from frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nasync with MyActor() as actor: # (1)!\n    print(\"The actor is running\")\n# (2)!\n</code></pre> <ol> <li><code>start()</code> is called automatically when entering     the <code>async with</code> block.</li> <li><code>stop()</code> is called automatically when exiting     the <code>async with</code> block.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--the-start-method","title":"The <code>start()</code> Method","text":"<p>When using the <code>start()</code> method, the actor is started in the background and the method returns immediately. The actor will continue to run until it is manually stopped.</p> Example <pre><code>from frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nactor = MyActor() # (1)!\nactor.start() # (2)!\nprint(\"The actor is running\") # (3)!\nawait actor.stop() # (4)!\n</code></pre> <ol> <li>The actor is created but not started yet.</li> <li>The actor is started manually, it keeps running in the background.</li> <li> <p>Danger</p> <p>If this function would raise an exception, the actor will never be stopped!</p> </li> <li> <p>Until the actor is stopped manually.</p> </li> </ol> <p>Warning</p> <p>This method is not recommended because it is easy to forget to stop the actor manually, especially in error conditions.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--communication","title":"Communication","text":"<p>The <code>Actor</code> class doesn't impose any specific way to communicate between actors. However, <code>frequenz.channels</code> are always used as the communication mechanism between actors in the SDK.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--implementing-an-actor","title":"Implementing an Actor","text":"<p>To implement an actor, you must inherit from the <code>Actor</code> class and implement an initializer and the abstract <code>_run()</code> method.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--initialization","title":"Initialization","text":"<p>The initializer is called when the actor is created. The <code>Actor</code> class initializer (<code>__init__</code>) should be always called first in the class we are implementing to make sure actors are properly initialized.</p> <p>The <code>Actor.__init__()</code> takes one optional argument, a <code>name</code> that will be used to identify the actor in logs. If no name is provided, a default name will be generated, but it is recommended that <code>Actor</code> subclasses can also receive a name as an argument to make it easier to identify individual instances in logs more easily.</p> <p>The actor initializer normally also accepts as arguments the input channels receivers and output channels senders that will be used for communication. These channels should be created outside the actor and passed to it as arguments to ensure actors can be composed easily.</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass EchoActor(Actor):  # (1)!\n    def __init__(\n            self,\n            input: Receiver[int],  # (2)!\n            output: Sender[int],  # (3)!\n            name: str | None = None,  # (4)!\n    ) -&gt; None:\n        super().__init__(name=name) # (5)!\n        self._input: Receiver[int] = input  # (6)!\n        self._output: Sender[int] = output  # (7)!\n</code></pre> <ol> <li> <p>We define a new actor class called <code>EchoActor</code> that inherits from     <code>Actor</code>.</p> </li> <li> <p>We accept an <code>input</code> argument that will be used to receive messages from     a channel.</p> </li> <li>We accept an <code>output</code> argument that will be used to send messages to a channel.</li> <li>We accept an optional <code>name</code> argument that will be used to identify the actor in     logs.</li> <li>We call <code>Actor.__init__()</code> to make sure the     actor is properly initialized.</li> <li>We store the <code>input</code> argument in a private instance variable to use it later.</li> <li>We store the <code>output</code> argument in a private instance variable to use it later.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--the-_run-method","title":"The <code>_run()</code> Method","text":"<p>The abstract <code>_run()</code> method is called automatically by the base class when the actor is started.</p> <p>Normally an actor should run forever (or until it is stopped), so it is very common to have an infinite loop in the <code>_run()</code> method, typically receiving messages from one or more channels (receivers), processing them and sending the results to other channels (senders).</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass EchoActor(Actor):\n    def __init__(\n            self,\n            input: Receiver[int],\n            output: Sender[int],\n            name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._input: Receiver[int] = input\n        self._output: Sender[int] = output\n\n    async def _run(self) -&gt; None:  # (1)!\n        async for msg in self._input:  # (2)!\n            await self._output.send(msg)  # (3)!\n</code></pre> <ol> <li>We implement the abstract <code>_run()</code> method.</li> <li>We receive messages from the <code>input</code> channel one by one.</li> <li>We send the received message to the <code>output</code> channel.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--stopping","title":"Stopping","text":"<p>By default, the <code>stop()</code> method will call the <code>cancel()</code> method (which will cancel all the tasks created by the actor) and will wait for them to finish.</p> <p>This means that when an actor is stopped, the <code>_run()</code> method will receive a <code>CancelledError</code> exception. You should have this in mind when implementing your actor and make sure to handle this exception properly if you need to do any cleanup.</p> <p>The actor will handle the <code>CancelledError</code> exception automatically if it is not handled in the <code>_run()</code> method, so if there is no need for extra cleanup, you don't need to worry about it.</p> <p>If an unhandled exception is raised in the <code>_run()</code> method, the actor will re-run the <code>_run()</code> method automatically. This ensures robustness in the face of errors, but you should also have this in mind if you need to do any cleanup to make sure the re-run doesn't cause any problems.</p> Tip <p>You could implement your own <code>stop()</code> method to, for example, send a message to a channel to notify that the actor should stop, or any other more graceful way to stop the actor if you need to make sure it can't be interrupted at any <code>await</code> point.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--spawning-extra-tasks","title":"Spawning Extra Tasks","text":"<p>Actors run at least one background task, created automatically by the <code>Actor</code> class. But <code>Actor</code> inherits from <code>BackgroundService</code>, which provides a few methods to create and manage extra tasks.</p> <p>If your actor needs to spawn extra tasks, you can use <code>BackgroundService</code> facilities to manage the tasks, so they are also automatically stopped when the actor is stopped.</p> <p>All you need to do is add the newly spawned tasks to the actor's <code>tasks</code> set.</p> Example <pre><code>import asyncio\nfrom frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        extra_task = asyncio.create_task(self._extra_task())  # (1)!\n        self.tasks.add(extra_task)  # (2)!\n        while True:  # (3)!\n            print(\"_run() running\")\n            await asyncio.sleep(1)\n\n    async def _extra_task(self) -&gt; None:\n        while True:  # (4)!\n            print(\"_extra_task() running\")\n            await asyncio.sleep(1.1)\n\nasync with MyActor() as actor:  # (5)!\n    await asyncio.sleep(3)  # (6)!\n# (7)!\n</code></pre> <ol> <li>We create a new task using <code>asyncio.create_task()</code>.</li> <li>We add the task to the actor's <code>tasks</code> set.     This ensures the task will be cancelled and cleaned up when the actor is stopped.</li> <li>We leave the actor running forever.</li> <li>The extra task will also run forever.</li> <li>The actor is started.</li> <li>We wait for 3 seconds, the actor should print a bunch of \"_run() running\" and     \"_extra_task() running\" messages while it's running.</li> <li>The actor is stopped and the extra task is cancelled automatically.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--examples","title":"Examples","text":"<p>Here are a few simple but complete examples to demonstrate how to create actors and connect them using channels.</p> <p>Tip</p> <p>The code examples are annotated with markers (like ), you can click on them to see the step-by-step explanation of what's going on. The annotations are numbered according to the order of execution.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--composing-actors","title":"Composing actors","text":"<p>This example shows how to create two actors and connect them using broadcast channels.</p> compose.py<pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass Actor1(Actor):  # (1)!\n    def __init__(\n        self,\n        receiver: Receiver[str],\n        output: Sender[str],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver = receiver\n        self._output = output\n\n    async def _run(self) -&gt; None:\n        async for msg in self._receiver:\n            await self._output.send(f\"Actor1 forwarding: {msg!r}\")  # (8)!\n\n\nclass Actor2(Actor):\n    def __init__(\n        self,\n        receiver: Receiver[str],\n        output: Sender[str],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver = receiver\n        self._output = output\n\n    async def _run(self) -&gt; None:\n        async for msg in self._receiver:\n            await self._output.send(f\"Actor2 forwarding: {msg!r}\")  # (9)!\n\n\nasync def main() -&gt; None:  # (2)!\n    # (4)!\n    input_channel: Broadcast[str] = Broadcast(\"Input to Actor1\")\n    middle_channel: Broadcast[str] = Broadcast(\"Actor1 -&gt; Actor2 stream\")\n    output_channel: Broadcast[str] = Broadcast(\"Actor2 output\")\n\n    input_sender = input_channel.new_sender()\n    output_receiver = output_channel.new_receiver()\n\n    async with (  # (5)!\n        Actor1(input_channel.new_receiver(), middle_channel.new_sender(), \"actor1\"),\n        Actor2(middle_channel.new_receiver(), output_channel.new_sender(), \"actor1\"),\n    ):\n        await input_sender.send(\"Hello\")  # (6)!\n        msg = await output_receiver.receive()  # (7)!\n        print(msg)  # (10)!\n    # (11)!\n\nif __name__ == \"__main__\":  # (3)!\n    asyncio.run(main())\n</code></pre> <ol> <li> <p>We define 2 actors: <code>Actor1</code> and <code>Actor2</code> that will just forward a message    from an input channel to an output channel, adding some text.</p> </li> <li> <p>We define an async <code>main()</code> function with the main logic of our asyncio program.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We create a bunch of broadcast channels to connect our actors.</p> <ul> <li><code>input_channel</code> is the input channel for <code>Actor1</code>.</li> <li><code>middle_channel</code> is the channel that connects <code>Actor1</code> and <code>Actor2</code>.</li> <li><code>output_channel</code> is the output channel for <code>Actor2</code>.</li> </ul> </li> <li> <p>We create two actors and use them as async context managers, <code>Actor1</code> and     <code>Actor2</code>, and connect them by creating new     senders and     receivers from the channels.</p> <p>Note</p> <p>We don't use the <code>run()</code> function here because we want to stop the actors when we are done with them, but the actors will run forever (as long as the channel is not closed). So the async context manager is a better fit for this example.</p> </li> <li> <p>We schedule the sending of the message    <code>Hello</code> to <code>Actor1</code> via <code>input_channel</code>.</p> </li> <li> <p>We receive (await) the response from    <code>Actor2</code> via <code>output_channel</code>. Between this and the previous steps the    <code>async</code> calls in the actors will be executed.</p> </li> <li> <p><code>Actor1</code> sends the re-formatted message (<code>Actor1 forwarding: Hello</code>) to    <code>Actor2</code> via the <code>middle_channel</code>.</p> </li> <li> <p><code>Actor2</code> sends the re-formatted message (<code>Actor2 forwarding: \"Actor1    forwarding: 'Hello'\"</code>) to the <code>output_channel</code>.</p> </li> <li> <p>Finally, we print the received message, which will still be <code>Actor2     forwarding: \"Actor1 forwarding: 'Hello'\"</code>.</p> </li> <li> <p>The actors are stopped and cleaned up automatically when the <code>async with</code>     block ends.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Actor2 forwarding: \"Actor1 forwarding: 'Hello'\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--receiving-from-multiple-channels","title":"Receiving from multiple channels","text":"<p>This example shows how to create an actor that receives messages from multiple broadcast channels using <code>select()</code>.</p> select.py<pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.channels.util import select, selected_from\nfrom frequenz.sdk.actor import Actor, run\n\n\nclass EchoActor(Actor):  # (1)!\n    def __init__(\n        self,\n        receiver_1: Receiver[bool],\n        receiver_2: Receiver[bool],\n        output: Sender[bool],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver_1 = receiver_1\n        self._receiver_2 = receiver_2\n        self._output = output\n\n    async def _run(self) -&gt; None:  # (2)!\n        async for selected in select(self._receiver_1, self._receiver_2):  # (10)!\n            if selected_from(selected, self._receiver_1):  # (11)!\n                print(f\"Received from receiver_1: {selected.value}\")\n                await self._output.send(selected.value)\n                if not selected.value:  # (12)!\n                    break\n            elif selected_from(selected, self._receiver_2):  # (13)!\n                print(f\"Received from receiver_2: {selected.value}\")\n                await self._output.send(selected.value)\n                if not selected.value:  # (14)!\n                    break\n            else:\n                assert False, \"Unknown selected channel\"\n        print(\"EchoActor finished\")\n    # (15)!\n\n\n# (3)!\ninput_channel_1 = Broadcast[bool](\"input_channel_1\")\ninput_channel_2 = Broadcast[bool](\"input_channel_2\")\necho_channel = Broadcast[bool](\"echo_channel\")\n\necho_actor = EchoActor(  # (4)!\n    input_channel_1.new_receiver(),\n    input_channel_2.new_receiver(),\n    echo_channel.new_sender(),\n    \"echo-actor\",\n)\n\necho_receiver = echo_channel.new_receiver()  # (5)!\n\nasync def main() -&gt; None:  # (6)!\n    # (8)!\n    await input_channel_1.new_sender().send(True)\n    await input_channel_2.new_sender().send(False)\n\n    await run(echo_actor)  # (9)!\n\n    await echo_channel.close()  # (16)!\n\n    async for message in echo_receiver:  # (17)!\n        print(f\"Received {message=}\")\n\n\nif __name__ == \"__main__\":  # (7)!\n    asyncio.run(main())\n</code></pre> <ol> <li> <p>We define an <code>EchoActor</code> that receives messages from two channels and sends     them to another channel.</p> </li> <li> <p>We implement the <code>_run()</code> method that will receive messages from the two     channels using and send them to the output channel. The <code>run()</code> method will stop if     a <code>False</code> message is received.</p> </li> <li> <p>We create the channels that will be used with the actor.</p> </li> <li> <p>We create the actor and connect it to the channels by creating new receivers and     senders from the channels.</p> </li> <li> <p>We create a receiver for the <code>echo_channel</code> to eventually receive the messages sent     by the actor.</p> </li> <li> <p>We define the <code>main()</code> function that will run the actor.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We send a message to each of the input channels. These messages will be queued in     the channels until they are consumed by the actor.</p> </li> <li> <p>We start the actor and wait for it to finish using the     <code>run()</code> function.</p> </li> <li> <p>The <code>select()</code> function will get the first message     available from the two channels. The order in which they will be handled is     unknown, but in this example we assume that the first message will be from     <code>input_channel_1</code> (<code>True</code>) and the second from <code>input_channel_1</code> (<code>False</code>).</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>True</code> for the <code>input_channel_1</code> receiver. <code>selected.value</code> holds the received     message, so <code>\"Received from receiver_1: True\"</code> will be printed and <code>True</code> will be     sent to the <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>True</code>, the loop will continue, going back to the and the     the loop will continue, going back to the     <code>select()</code> function.</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>False</code> for the <code>input_channel_1</code> receiver and <code>True</code> for the <code>input_channel_2</code>     receiver. The message stored in <code>selected.value</code> will now be <code>False</code>, so     <code>\"Received from receiver_2: False\"</code> will be printed and <code>False</code> will be sent to the     <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>False</code>, the loop will break.</p> </li> <li> <p>The <code>_run()</code> method will finish normally and the actor will be stopped, so     the <code>run()</code> function will return.</p> </li> <li> <p>We close the <code>echo_channel</code> to make sure the <code>echo_receiver</code> will stop receiving     messages after all the queued messages are consumed (otherwise the step 17 will     never end!).</p> </li> <li> <p>We receive the messages sent by the actor to the <code>echo_channel</code> one by one and print     them, it should print first <code>Received message=True</code> and then <code>Received     message=False</code>.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Received from receiver_1: True\nReceived from receiver_2: False\nReceived message=True\nReceived message=False\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor","title":"frequenz.sdk.actor.Actor","text":"<p>             Bases: <code>BackgroundService</code>, <code>ABC</code></p> <p>A primitive unit of computation that runs autonomously.</p> <p>To implement an actor, subclasses must implement the <code>_run()</code> method, which should run the actor's logic. The <code>_run()</code> method is called by the base class when the actor is started, and is expected to run until the actor is stopped.</p> <p>Info</p> <p>Please read the <code>actor</code> module documentation for more comprehensive guide on how to use and implement actors properly.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>class Actor(BackgroundService, abc.ABC):\n    \"\"\"A primitive unit of computation that runs autonomously.\n\n    To implement an actor, subclasses must implement the\n    [`_run()`][frequenz.sdk.actor--the-_run-method] method, which should run the actor's\n    logic. The [`_run()`][frequenz.sdk.actor--the-_run-method] method is called by the\n    base class when the actor is started, and is expected to run until the actor is\n    stopped.\n\n    !!! info\n\n        Please read the [`actor` module documentation][frequenz.sdk.actor] for more\n        comprehensive guide on how to use and implement actors properly.\n    \"\"\"\n\n    RESTART_DELAY: timedelta = timedelta(seconds=2)\n    \"\"\"The delay to wait between restarts of this actor.\"\"\"\n\n    _restart_limit: int | None = None\n    \"\"\"The number of times actors can be restarted when they are stopped by unhandled exceptions.\n\n    If this is bigger than 0 or `None`, the actor will be restarted when there is an\n    unhanded exception in the `_run()` method.\n\n    If `None`, the actor will be restarted an unlimited number of times.\n\n    !!! note\n\n        This is mostly used for testing purposes and shouldn't be set in production.\n    \"\"\"\n\n    def start(self) -&gt; None:\n        \"\"\"Start this actor.\n\n        If this actor is already running, this method does nothing.\n        \"\"\"\n        if self.is_running:\n            return\n        self._tasks.clear()\n        self._tasks.add(asyncio.create_task(self._run_loop()))\n\n    @abc.abstractmethod\n    async def _run(self) -&gt; None:\n        \"\"\"Run this actor's logic.\"\"\"\n\n    async def _delay_if_restart(self, iteration: int) -&gt; None:\n        \"\"\"Delay the restart of this actor's n'th iteration.\n\n        Args:\n            iteration: The current iteration of the restart.\n        \"\"\"\n        # NB: I think it makes sense (in the future) to think about deminishing returns\n        # the longer the actor has been running.\n        # Not just for the restart-delay but actually for the n_restarts counter as well.\n        if iteration &gt; 0:\n            delay = self.RESTART_DELAY.total_seconds()\n            _logger.info(\"Actor %s: Waiting %s seconds...\", self, delay)\n            await asyncio.sleep(delay)\n\n    async def _run_loop(self) -&gt; None:\n        \"\"\"Run this actor's task in a loop until `_restart_limit` is reached.\n\n        Raises:\n            asyncio.CancelledError: If this actor's `_run()` gets cancelled.\n            Exception: If this actor's `_run()` raises any other `Exception` and reached\n                the maximum number of restarts.\n            BaseException: If this actor's `_run()` raises any other `BaseException`.\n        \"\"\"\n        _logger.info(\"Actor %s: Started.\", self)\n        n_restarts = 0\n        while True:\n            try:\n                await self._delay_if_restart(n_restarts)\n                await self._run()\n                _logger.info(\"Actor %s: _run() returned without error.\", self)\n            except asyncio.CancelledError:\n                _logger.info(\"Actor %s: Cancelled.\", self)\n                raise\n            except Exception:  # pylint: disable=broad-except\n                _logger.exception(\"Actor %s: Raised an unhandled exception.\", self)\n                limit_str = \"\u221e\" if self._restart_limit is None else self._restart_limit\n                limit_str = f\"({n_restarts}/{limit_str})\"\n                if self._restart_limit is None or n_restarts &lt; self._restart_limit:\n                    n_restarts += 1\n                    _logger.info(\"Actor %s: Restarting %s...\", self._name, limit_str)\n                    continue\n                _logger.info(\n                    \"Actor %s: Maximum restarts attempted %s, bailing out...\",\n                    self,\n                    limit_str,\n                )\n                raise\n            except BaseException:  # pylint: disable=broad-except\n                _logger.exception(\"Actor %s: Raised a BaseException.\", self)\n                raise\n            break\n\n        _logger.info(\"Actor %s: Stopped.\", self)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str | None = None) -&gt; None\n</code></pre> <p>Initialize this BackgroundService.</p> PARAMETER  DESCRIPTION <code>name</code> <p>The name of this background service. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __init__(self, *, name: str | None = None) -&gt; None:\n    \"\"\"Initialize this BackgroundService.\n\n    Args:\n        name: The name of this background service. If `None`, `str(id(self))` will\n            be used. This is used mostly for debugging purposes.\n    \"\"\"\n    self._name: str = str(id(self)) if name is None else name\n    self._tasks: set[asyncio.Task[Any]] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService","title":"frequenz.sdk.actor.BackgroundService","text":"<p>             Bases: <code>ABC</code></p> <p>A background service that can be started and stopped.</p> <p>A background service is a service that runs in the background spawning one or more tasks. The service can be started and stopped and can work as an async context manager to provide deterministic cleanup.</p> <p>To implement a background service, subclasses must implement the <code>start()</code> method, which should start the background tasks needed by the service, and add them to the <code>_tasks</code> protected attribute.</p> <p>If you need to collect results or handle exceptions of the tasks when stopping the service, then you need to also override the <code>stop()</code> method, as the base implementation does not collect any results and re-raises all exceptions.</p> <p>Warning</p> <p>As background services manage <code>asyncio.Task</code> objects, a reference to them must be held for as long as the background service is expected to be running, otherwise its tasks will be cancelled and the service will stop. For more information, please refer to the Python <code>asyncio</code> documentation.</p> Example <pre><code>import datetime\nimport asyncio\n\nclass Clock(BackgroundService):\n    def __init__(self, resolution_s: float, *, name: str | None = None) -&gt; None:\n        super().__init__(name=name)\n        self._resolution_s = resolution_s\n\n    def start(self) -&gt; None:\n        self._tasks.add(asyncio.create_task(self._tick()))\n\n    async def _tick(self) -&gt; None:\n        while True:\n            await asyncio.sleep(self._resolution_s)\n            print(datetime.datetime.now())\n\nasync def main() -&gt; None:\n    # As an async context manager\n    async with Clock(resolution_s=1):\n        await asyncio.sleep(5)\n\n    # Manual start/stop (only use if necessary, as cleanup is more complicated)\n    clock = Clock(resolution_s=1)\n    clock.start()\n    await asyncio.sleep(5)\n    await clock.stop()\n\nasyncio.run(main())\n</code></pre> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>class BackgroundService(abc.ABC):\n    \"\"\"A background service that can be started and stopped.\n\n    A background service is a service that runs in the background spawning one or more\n    tasks. The service can be [started][frequenz.sdk.actor.BackgroundService.start]\n    and [stopped][frequenz.sdk.actor.BackgroundService.stop] and can work as an\n    async context manager to provide deterministic cleanup.\n\n    To implement a background service, subclasses must implement the\n    [`start()`][frequenz.sdk.actor.BackgroundService.start] method, which should\n    start the background tasks needed by the service, and add them to the `_tasks`\n    protected attribute.\n\n    If you need to collect results or handle exceptions of the tasks when stopping the\n    service, then you need to also override the\n    [`stop()`][frequenz.sdk.actor.BackgroundService.stop] method, as the base\n    implementation does not collect any results and re-raises all exceptions.\n\n    !!! warning\n\n        As background services manage [`asyncio.Task`][] objects, a reference to them\n        must be held for as long as the background service is expected to be running,\n        otherwise its tasks will be cancelled and the service will stop. For more\n        information, please refer to the [Python `asyncio`\n        documentation](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task).\n\n    Example:\n        ```python\n        import datetime\n        import asyncio\n\n        class Clock(BackgroundService):\n            def __init__(self, resolution_s: float, *, name: str | None = None) -&gt; None:\n                super().__init__(name=name)\n                self._resolution_s = resolution_s\n\n            def start(self) -&gt; None:\n                self._tasks.add(asyncio.create_task(self._tick()))\n\n            async def _tick(self) -&gt; None:\n                while True:\n                    await asyncio.sleep(self._resolution_s)\n                    print(datetime.datetime.now())\n\n        async def main() -&gt; None:\n            # As an async context manager\n            async with Clock(resolution_s=1):\n                await asyncio.sleep(5)\n\n            # Manual start/stop (only use if necessary, as cleanup is more complicated)\n            clock = Clock(resolution_s=1)\n            clock.start()\n            await asyncio.sleep(5)\n            await clock.stop()\n\n        asyncio.run(main())\n        ```\n    \"\"\"\n\n    def __init__(self, *, name: str | None = None) -&gt; None:\n        \"\"\"Initialize this BackgroundService.\n\n        Args:\n            name: The name of this background service. If `None`, `str(id(self))` will\n                be used. This is used mostly for debugging purposes.\n        \"\"\"\n        self._name: str = str(id(self)) if name is None else name\n        self._tasks: set[asyncio.Task[Any]] = set()\n\n    @abc.abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"Start this background service.\"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of this background service.\n\n        Returns:\n            The name of this background service.\n        \"\"\"\n        return self._name\n\n    @property\n    def tasks(self) -&gt; collections.abc.Set[asyncio.Task[Any]]:\n        \"\"\"Return the set of running tasks spawned by this background service.\n\n        Users typically should not modify the tasks in the returned set and only use\n        them for informational purposes.\n\n        !!! danger\n\n            Changing the returned tasks may lead to unexpected behavior, don't do it\n            unless the class explicitly documents it is safe to do so.\n\n        Returns:\n            The set of running tasks spawned by this background service.\n        \"\"\"\n        return self._tasks\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Return whether this background service is running.\n\n        A service is considered running when at least one task is running.\n\n        Returns:\n            Whether this background service is running.\n        \"\"\"\n        return any(not task.done() for task in self._tasks)\n\n    def cancel(self, msg: str | None = None) -&gt; None:\n        \"\"\"Cancel all running tasks spawned by this background service.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\n        for task in self._tasks:\n            task.cancel(msg)\n\n    async def stop(self, msg: str | None = None) -&gt; None:\n        \"\"\"Stop this background service.\n\n        This method cancels all running tasks spawned by this service and waits for them\n        to finish.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception.\n\n        [//]: # (# noqa: DAR401 rest)\n        \"\"\"\n        if not self._tasks:\n            return\n        self.cancel(msg)\n        try:\n            await self.wait()\n        except BaseExceptionGroup as exc_group:\n            # We want to ignore CancelledError here as we explicitly cancelled all the\n            # tasks.\n            _, rest = exc_group.split(asyncio.CancelledError)\n            if rest is not None:\n                # We are filtering out from an exception group, we really don't want to\n                # add the exceptions we just filtered by adding a from clause here.\n                raise rest  # pylint: disable=raise-missing-from\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"Enter an async context.\n\n        Start this background service.\n\n        Returns:\n            This background service.\n        \"\"\"\n        self.start()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit an async context.\n\n        Stop this background service.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception raised, if any.\n            exc_tb: The traceback of the exception raised, if any.\n        \"\"\"\n        await self.stop()\n\n    async def wait(self) -&gt; None:\n        \"\"\"Wait this background service to finish.\n\n        Wait until all background service tasks are finished.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception (`CancelError` is not considered an error and not returned in\n                the exception group).\n        \"\"\"\n        # We need to account for tasks that were created between when we started\n        # awaiting and we finished awaiting.\n        while self._tasks:\n            done, pending = await asyncio.wait(self._tasks)\n            assert not pending\n\n            # We remove the done tasks, but there might be new ones created after we\n            # started waiting.\n            self._tasks = self._tasks - done\n\n            exceptions: list[BaseException] = []\n            for task in done:\n                try:\n                    # This will raise a CancelledError if the task was cancelled or any\n                    # other exception if the task raised one.\n                    _ = task.result()\n                except BaseException as error:  # pylint: disable=broad-except\n                    exceptions.append(error)\n            if exceptions:\n                raise BaseExceptionGroup(\n                    f\"Error while stopping background service {self}\", exceptions\n                )\n\n    def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n        \"\"\"Await this background service.\n\n        An awaited background service will wait for all its tasks to finish.\n\n        Returns:\n            An implementation-specific generator for the awaitable.\n        \"\"\"\n        return self.wait().__await__()\n\n    def __del__(self) -&gt; None:\n        \"\"\"Destroy this instance.\n\n        Cancel all running tasks spawned by this background service.\n        \"\"\"\n        self.cancel(\"{self!r} was deleted\")\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\n\n        Returns:\n            A string representation of this instance.\n        \"\"\"\n        return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\n\n        Returns:\n            A string representation of this instance.\n        \"\"\"\n        return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str | None = None) -&gt; None\n</code></pre> <p>Initialize this BackgroundService.</p> PARAMETER  DESCRIPTION <code>name</code> <p>The name of this background service. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __init__(self, *, name: str | None = None) -&gt; None:\n    \"\"\"Initialize this BackgroundService.\n\n    Args:\n        name: The name of this background service. If `None`, `str(id(self))` will\n            be used. This is used mostly for debugging purposes.\n    \"\"\"\n    self._name: str = str(id(self)) if name is None else name\n    self._tasks: set[asyncio.Task[Any]] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.start","title":"start  <code>abstractmethod</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>@abc.abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"Start this background service.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry","title":"frequenz.sdk.actor.ChannelRegistry","text":"<p>Dynamically creates, own and provide access to broadcast channels.</p> <p>It can be used by actors to dynamically establish a communication channel between each other.</p> <p>The registry is responsible for creating channels when they are first requested via the <code>get_or_create()</code> method.</p> <p>The registry also stores type information to make sure that the same channel is not used for different message types.</p> <p>Since the registry owns the channels, it is also responsible for closing them when they are no longer needed. There is no way to remove a channel without closing it.</p> Note <p>This registry stores <code>Broadcast</code> channels.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>class ChannelRegistry:\n    \"\"\"Dynamically creates, own and provide access to broadcast channels.\n\n    It can be used by actors to dynamically establish a communication channel\n    between each other.\n\n    The registry is responsible for creating channels when they are first requested via\n    the [`get_or_create()`][frequenz.sdk.actor.ChannelRegistry.get_or_create] method.\n\n    The registry also stores type information to make sure that the same channel is not\n    used for different message types.\n\n    Since the registry owns the channels, it is also responsible for closing them when\n    they are no longer needed. There is no way to remove a channel without closing it.\n\n    Note:\n        This registry stores [`Broadcast`][frequenz.channels.Broadcast] channels.\n    \"\"\"\n\n    def __init__(self, *, name: str) -&gt; None:\n        \"\"\"Initialize this registry.\n\n        Args:\n            name: A name to identify the registry in the logs. This name is also used as\n                a prefix for the channel names.\n        \"\"\"\n        self._name = name\n        self._channels: dict[str, _Entry] = {}\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of this registry.\"\"\"\n        return self._name\n\n    def message_type(self, key: str) -&gt; type:\n        \"\"\"Get the message type of the channel for the given key.\n\n        Args:\n            key: The key to identify the channel.\n\n        Returns:\n            The message type of the channel.\n\n        Raises:\n            KeyError: If the channel does not exist.\n        \"\"\"\n        entry = self._channels.get(key)\n        if entry is None:\n            raise KeyError(f\"No channel for key {key!r} exists.\")\n        return entry.message_type\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"Check whether the channel for the given `key` exists.\"\"\"\n        return key in self._channels\n\n    def get_or_create(self, message_type: type[_T], key: str) -&gt; Broadcast[_T]:\n        \"\"\"Get or create a channel for the given key.\n\n        If a channel for the given key already exists, the message type of the existing\n        channel is checked against the requested message type. If they do not match,\n        a `ValueError` is raised.\n\n        Note:\n            The types have to match exactly, it doesn't do a subtype check due to\n            technical limitations. In the future subtype checks might be supported.\n\n        Args:\n            message_type: The type of the message that is sent through the channel.\n            key: The key to identify the channel.\n\n        Returns:\n            The channel for the given key.\n\n        Raises:\n            ValueError: If the channel exists and the message type does not match.\n        \"\"\"\n        if key not in self._channels:\n            if _logger.isEnabledFor(logging.DEBUG):\n                _logger.debug(\n                    \"Creating a new channel for key %r with type %s at:\\n%s\",\n                    key,\n                    message_type,\n                    \"\".join(traceback.format_stack(limit=10)[:9]),\n                )\n            self._channels[key] = _Entry(message_type, Broadcast(f\"{self._name}-{key}\"))\n\n        entry = self._channels[key]\n        if entry.message_type is not message_type:\n            exception = ValueError(\n                f\"Type mismatch, a channel for key {key!r} exists and the requested \"\n                f\"message type {message_type} is not the same as the existing \"\n                f\"message type {entry.message_type}.\"\n            )\n            if _logger.isEnabledFor(logging.DEBUG):\n                _logger.debug(\n                    \"%s at:\\n%s\",\n                    str(exception),\n                    # We skip the last frame because it's this method, and limit the\n                    # stack to 9 frames to avoid adding too much noise.\n                    \"\".join(traceback.format_stack(limit=10)[:9]),\n                )\n            raise exception\n\n        return cast(Broadcast[_T], entry.channel)\n\n    async def close_and_remove(self, key: str) -&gt; None:\n        \"\"\"Remove the channel for the given key.\n\n        Args:\n            key: The key to identify the channel.\n\n        Raises:\n            KeyError: If the channel does not exist.\n        \"\"\"\n        entry = self._channels.pop(key, None)\n        if entry is None:\n            raise KeyError(f\"No channel for key {key!r} exists.\")\n        await entry.channel.close()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this registry.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.__contains__","title":"__contains__","text":"<pre><code>__contains__(key: str) -&gt; bool\n</code></pre> <p>Check whether the channel for the given <code>key</code> exists.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    \"\"\"Check whether the channel for the given `key` exists.\"\"\"\n    return key in self._channels\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str) -&gt; None\n</code></pre> <p>Initialize this registry.</p> PARAMETER  DESCRIPTION <code>name</code> <p>A name to identify the registry in the logs. This name is also used as a prefix for the channel names.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def __init__(self, *, name: str) -&gt; None:\n    \"\"\"Initialize this registry.\n\n    Args:\n        name: A name to identify the registry in the logs. This name is also used as\n            a prefix for the channel names.\n    \"\"\"\n    self._name = name\n    self._channels: dict[str, _Entry] = {}\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.close_and_remove","title":"close_and_remove  <code>async</code>","text":"<pre><code>close_and_remove(key: str) -&gt; None\n</code></pre> <p>Remove the channel for the given key.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If the channel does not exist.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>async def close_and_remove(self, key: str) -&gt; None:\n    \"\"\"Remove the channel for the given key.\n\n    Args:\n        key: The key to identify the channel.\n\n    Raises:\n        KeyError: If the channel does not exist.\n    \"\"\"\n    entry = self._channels.pop(key, None)\n    if entry is None:\n        raise KeyError(f\"No channel for key {key!r} exists.\")\n    await entry.channel.close()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.get_or_create","title":"get_or_create","text":"<pre><code>get_or_create(\n    message_type: type[_T], key: str\n) -&gt; Broadcast[_T]\n</code></pre> <p>Get or create a channel for the given key.</p> <p>If a channel for the given key already exists, the message type of the existing channel is checked against the requested message type. If they do not match, a <code>ValueError</code> is raised.</p> Note <p>The types have to match exactly, it doesn't do a subtype check due to technical limitations. In the future subtype checks might be supported.</p> PARAMETER  DESCRIPTION <code>message_type</code> <p>The type of the message that is sent through the channel.</p> <p> TYPE: <code>type[_T]</code> </p> <code>key</code> <p>The key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Broadcast[_T]</code> <p>The channel for the given key.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the channel exists and the message type does not match.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def get_or_create(self, message_type: type[_T], key: str) -&gt; Broadcast[_T]:\n    \"\"\"Get or create a channel for the given key.\n\n    If a channel for the given key already exists, the message type of the existing\n    channel is checked against the requested message type. If they do not match,\n    a `ValueError` is raised.\n\n    Note:\n        The types have to match exactly, it doesn't do a subtype check due to\n        technical limitations. In the future subtype checks might be supported.\n\n    Args:\n        message_type: The type of the message that is sent through the channel.\n        key: The key to identify the channel.\n\n    Returns:\n        The channel for the given key.\n\n    Raises:\n        ValueError: If the channel exists and the message type does not match.\n    \"\"\"\n    if key not in self._channels:\n        if _logger.isEnabledFor(logging.DEBUG):\n            _logger.debug(\n                \"Creating a new channel for key %r with type %s at:\\n%s\",\n                key,\n                message_type,\n                \"\".join(traceback.format_stack(limit=10)[:9]),\n            )\n        self._channels[key] = _Entry(message_type, Broadcast(f\"{self._name}-{key}\"))\n\n    entry = self._channels[key]\n    if entry.message_type is not message_type:\n        exception = ValueError(\n            f\"Type mismatch, a channel for key {key!r} exists and the requested \"\n            f\"message type {message_type} is not the same as the existing \"\n            f\"message type {entry.message_type}.\"\n        )\n        if _logger.isEnabledFor(logging.DEBUG):\n            _logger.debug(\n                \"%s at:\\n%s\",\n                str(exception),\n                # We skip the last frame because it's this method, and limit the\n                # stack to 9 frames to avoid adding too much noise.\n                \"\".join(traceback.format_stack(limit=10)[:9]),\n            )\n        raise exception\n\n    return cast(Broadcast[_T], entry.channel)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.message_type","title":"message_type","text":"<pre><code>message_type(key: str) -&gt; type\n</code></pre> <p>Get the message type of the channel for the given key.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>type</code> <p>The message type of the channel.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the channel does not exist.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def message_type(self, key: str) -&gt; type:\n    \"\"\"Get the message type of the channel for the given key.\n\n    Args:\n        key: The key to identify the channel.\n\n    Returns:\n        The message type of the channel.\n\n    Raises:\n        KeyError: If the channel does not exist.\n    \"\"\"\n    entry = self._channels.get(key)\n    if entry is None:\n        raise KeyError(f\"No channel for key {key!r} exists.\")\n    return entry.message_type\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest","title":"frequenz.sdk.actor.ComponentMetricRequest  <code>dataclass</code>","text":"<p>A request object to start streaming a metric for a component.</p> Source code in <code>frequenz/sdk/actor/_data_sourcing/_component_metric_request.py</code> <pre><code>@dataclass\nclass ComponentMetricRequest:\n    \"\"\"A request object to start streaming a metric for a component.\"\"\"\n\n    namespace: str\n    \"\"\"The namespace that this request belongs to.\n\n    Metric requests with a shared namespace enable the reuse of channels within\n    that namespace.\n\n    If for example, an actor making a multiple requests, uses the name of the\n    actor as the namespace, then requests from the actor will get reused when\n    possible.\n    \"\"\"\n\n    component_id: int\n    \"\"\"The ID of the requested component.\"\"\"\n\n    metric_id: ComponentMetricId\n    \"\"\"The ID of the requested component's metric.\"\"\"\n\n    start_time: datetime | None\n    \"\"\"The start time from which data is required.\n\n    When None, we will stream only live data.\n    \"\"\"\n\n    def get_channel_name(self) -&gt; str:\n        \"\"\"Return a channel name constructed from Self.\n\n        This channel name can be used by the sending side and receiving sides to\n        identify the right channel from the ChannelRegistry.\n\n        Returns:\n            A string denoting a channel name.\n        \"\"\"\n        return (\n            f\"component-stream::{self.component_id}::{self.metric_id.name}::\"\n            f\"{self.start_time}::{self.namespace}\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID of the requested component.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.metric_id","title":"metric_id  <code>instance-attribute</code>","text":"<pre><code>metric_id: ComponentMetricId\n</code></pre> <p>The ID of the requested component's metric.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.namespace","title":"namespace  <code>instance-attribute</code>","text":"<pre><code>namespace: str\n</code></pre> <p>The namespace that this request belongs to.</p> <p>Metric requests with a shared namespace enable the reuse of channels within that namespace.</p> <p>If for example, an actor making a multiple requests, uses the name of the actor as the namespace, then requests from the actor will get reused when possible.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.start_time","title":"start_time  <code>instance-attribute</code>","text":"<pre><code>start_time: datetime | None\n</code></pre> <p>The start time from which data is required.</p> <p>When None, we will stream only live data.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.get_channel_name","title":"get_channel_name","text":"<pre><code>get_channel_name() -&gt; str\n</code></pre> <p>Return a channel name constructed from Self.</p> <p>This channel name can be used by the sending side and receiving sides to identify the right channel from the ChannelRegistry.</p> RETURNS DESCRIPTION <code>str</code> <p>A string denoting a channel name.</p> Source code in <code>frequenz/sdk/actor/_data_sourcing/_component_metric_request.py</code> <pre><code>def get_channel_name(self) -&gt; str:\n    \"\"\"Return a channel name constructed from Self.\n\n    This channel name can be used by the sending side and receiving sides to\n    identify the right channel from the ChannelRegistry.\n\n    Returns:\n        A string denoting a channel name.\n    \"\"\"\n    return (\n        f\"component-stream::{self.component_id}::{self.metric_id.name}::\"\n        f\"{self.start_time}::{self.namespace}\"\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor","title":"frequenz.sdk.actor.ComponentMetricsResamplingActor","text":"<p>             Bases: <code>Actor</code></p> <p>An actor to resample microgrid component metrics.</p> Source code in <code>frequenz/sdk/actor/_resampling.py</code> <pre><code>class ComponentMetricsResamplingActor(Actor):\n    \"\"\"An actor to resample microgrid component metrics.\"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        *,\n        channel_registry: ChannelRegistry,\n        data_sourcing_request_sender: Sender[ComponentMetricRequest],\n        resampling_request_receiver: Receiver[ComponentMetricRequest],\n        config: ResamplerConfig,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize an instance.\n\n        Args:\n            channel_registry: The channel registry used to get senders and\n                receivers for data sourcing subscriptions.\n            data_sourcing_request_sender: The sender used to send requests to\n                the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor]\n                to subscribe to component metrics.\n            resampling_request_receiver: The receiver to use to receive new\n                resampling subscription requests.\n            config: The configuration for the resampler.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\n        super().__init__(name=name)\n        self._channel_registry: ChannelRegistry = channel_registry\n        self._data_sourcing_request_sender: Sender[ComponentMetricRequest] = (\n            data_sourcing_request_sender\n        )\n        self._resampling_request_receiver: Receiver[ComponentMetricRequest] = (\n            resampling_request_receiver\n        )\n        self._resampler: Resampler = Resampler(config)\n        self._active_req_channels: set[str] = set()\n\n    async def _subscribe(self, request: ComponentMetricRequest) -&gt; None:\n        \"\"\"Request data for a component metric.\n\n        Args:\n            request: The request for component metric data.\n        \"\"\"\n        request_channel_name = request.get_channel_name()\n\n        # If we are already handling this request, there is nothing to do.\n        if request_channel_name in self._active_req_channels:\n            return\n\n        self._active_req_channels.add(request_channel_name)\n\n        data_source_request = dataclasses.replace(\n            request, namespace=request.namespace + \":Source\"\n        )\n        data_source_channel_name = data_source_request.get_channel_name()\n        await self._data_sourcing_request_sender.send(data_source_request)\n        receiver = self._channel_registry.get_or_create(\n            Sample[Quantity], data_source_channel_name\n        ).new_receiver()\n\n        # This is a temporary hack until the Sender implementation uses\n        # exceptions to report errors.\n        sender = self._channel_registry.get_or_create(\n            Sample[Quantity], request_channel_name\n        ).new_sender()\n\n        async def sink_adapter(sample: Sample[Quantity]) -&gt; None:\n            await sender.send(sample)\n\n        self._resampler.add_timeseries(request_channel_name, receiver, sink_adapter)\n\n    async def _process_resampling_requests(self) -&gt; None:\n        \"\"\"Process resampling data requests.\"\"\"\n        async for request in self._resampling_request_receiver:\n            await self._subscribe(request)\n\n    async def _run(self) -&gt; None:\n        \"\"\"Resample known component metrics and process resampling requests.\n\n        If there is a resampling error while resampling some component metric,\n        then that metric will be discarded and not resampled any more. Any\n        other error will be propagated (most likely ending in the actor being\n        restarted).\n\n        This method creates 2 main tasks:\n\n        - One task to process incoming subscription requests to resample new metrics.\n        - One task to run the resampler.\n\n        Raises:\n            RuntimeError: If there is some unexpected error while resampling or\n                handling requests.\n\n        [//]: # (# noqa: DAR401 error)\n        \"\"\"\n        tasks_to_cancel: set[asyncio.Task[None]] = set()\n        try:\n            subscriptions_task = asyncio.create_task(\n                self._process_resampling_requests()\n            )\n            tasks_to_cancel.add(subscriptions_task)\n\n            while True:\n                resampling_task = asyncio.create_task(self._resampler.resample())\n                tasks_to_cancel.add(resampling_task)\n                done, _ = await asyncio.wait(\n                    [resampling_task, subscriptions_task],\n                    return_when=asyncio.FIRST_COMPLETED,\n                )\n\n                if subscriptions_task in done:\n                    tasks_to_cancel.remove(subscriptions_task)\n                    raise RuntimeError(\n                        \"There was a problem with the subscriptions channel.\"\n                    )\n\n                if resampling_task in done:\n                    tasks_to_cancel.remove(resampling_task)\n                    # The resampler shouldn't end without an exception\n                    error = resampling_task.exception()\n                    assert (\n                        error is not None\n                    ), \"The resample() function shouldn't exit normally.\"\n\n                    # We don't know what to do with something other than\n                    # ResamplingError, so propagate the exception if that is the\n                    # case.\n                    if not isinstance(error, ResamplingError):\n                        raise error\n                    for source, source_error in error.exceptions.items():\n                        _logger.error(\n                            \"Error resampling source %s, removing source...\", source\n                        )\n                        removed = self._resampler.remove_timeseries(source)\n                        if not removed:\n                            _logger.warning(\n                                \"Got an exception from an unknown source: \"\n                                \"source=%r, exception=%r\",\n                                source,\n                                source_error,\n                            )\n                    # The resampling_task will be re-created if we reached this point\n        finally:\n            await asyncio.gather(*[cancel_and_await(t) for t in tasks_to_cancel])\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    channel_registry: ChannelRegistry,\n    data_sourcing_request_sender: Sender[\n        ComponentMetricRequest\n    ],\n    resampling_request_receiver: Receiver[\n        ComponentMetricRequest\n    ],\n    config: ResamplerConfig,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Initialize an instance.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>The channel registry used to get senders and receivers for data sourcing subscriptions.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>data_sourcing_request_sender</code> <p>The sender used to send requests to the <code>DataSourcingActor</code> to subscribe to component metrics.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>resampling_request_receiver</code> <p>The receiver to use to receive new resampling subscription requests.</p> <p> TYPE: <code>Receiver[ComponentMetricRequest]</code> </p> <code>config</code> <p>The configuration for the resampler.</p> <p> TYPE: <code>ResamplerConfig</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_resampling.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    *,\n    channel_registry: ChannelRegistry,\n    data_sourcing_request_sender: Sender[ComponentMetricRequest],\n    resampling_request_receiver: Receiver[ComponentMetricRequest],\n    config: ResamplerConfig,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize an instance.\n\n    Args:\n        channel_registry: The channel registry used to get senders and\n            receivers for data sourcing subscriptions.\n        data_sourcing_request_sender: The sender used to send requests to\n            the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor]\n            to subscribe to component metrics.\n        resampling_request_receiver: The receiver to use to receive new\n            resampling subscription requests.\n        config: The configuration for the resampler.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\n    super().__init__(name=name)\n    self._channel_registry: ChannelRegistry = channel_registry\n    self._data_sourcing_request_sender: Sender[ComponentMetricRequest] = (\n        data_sourcing_request_sender\n    )\n    self._resampling_request_receiver: Receiver[ComponentMetricRequest] = (\n        resampling_request_receiver\n    )\n    self._resampler: Resampler = Resampler(config)\n    self._active_req_channels: set[str] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor","title":"frequenz.sdk.actor.ConfigManagingActor","text":"<p>             Bases: <code>Actor</code></p> <p>An actor that monitors a TOML configuration file for updates.</p> <p>When the file is updated, the new configuration is sent, as a <code>dict</code>, to the <code>output</code> sender.</p> <p>When the actor is started, if a configuration file already exists, then it will be read and sent to the <code>output</code> sender before the actor starts monitoring the file for updates. This way users can rely on the actor to do the initial configuration reading too.</p> Source code in <code>frequenz/sdk/actor/_config_managing.py</code> <pre><code>class ConfigManagingActor(Actor):\n    \"\"\"An actor that monitors a TOML configuration file for updates.\n\n    When the file is updated, the new configuration is sent, as a [`dict`][], to the\n    `output` sender.\n\n    When the actor is started, if a configuration file already exists, then it will be\n    read and sent to the `output` sender before the actor starts monitoring the file\n    for updates. This way users can rely on the actor to do the initial configuration\n    reading too.\n    \"\"\"\n\n    def __init__(\n        self,\n        config_path: pathlib.Path | str,\n        output: Sender[Config],\n        event_types: abc.Set[FileWatcher.EventType] = frozenset(FileWatcher.EventType),\n        *,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize this instance.\n\n        Args:\n            config_path: The path to the TOML file with the configuration.\n            output: The sender to send the config to.\n            event_types: The set of event types to monitor.\n            name: The name of the actor. If `None`, `str(id(self))` will\n                be used. This is used mostly for debugging purposes.\n        \"\"\"\n        super().__init__(name=name)\n        self._config_path: pathlib.Path = (\n            config_path\n            if isinstance(config_path, pathlib.Path)\n            else pathlib.Path(config_path)\n        )\n        # FileWatcher can't watch for non-existing files, so we need to watch for the\n        # parent directory instead just in case a configuration file doesn't exist yet\n        # or it is deleted and recreated again.\n        self._file_watcher: FileWatcher = FileWatcher(\n            paths=[self._config_path.parent], event_types=event_types\n        )\n        self._output: Sender[Config] = output\n\n    def _read_config(self) -&gt; dict[str, Any]:\n        \"\"\"Read the contents of the configuration file.\n\n        Returns:\n            A dictionary containing configuration variables.\n\n        Raises:\n            ValueError: If config file cannot be read.\n        \"\"\"\n        try:\n            with self._config_path.open(\"rb\") as toml_file:\n                return tomllib.load(toml_file)\n        except ValueError as err:\n            _logger.error(\"%s: Can't read config file, err: %s\", self, err)\n            raise\n\n    async def send_config(self) -&gt; None:\n        \"\"\"Send the configuration to the output sender.\"\"\"\n        conf_vars = self._read_config()\n        config = Config(conf_vars)\n        await self._output.send(config)\n\n    async def _run(self) -&gt; None:\n        \"\"\"Monitor for and send configuration file updates.\n\n        At startup, the Config Manager sends the current config so that it\n        can be cache in the Broadcast channel and served to receivers even if\n        there hasn't been any change to the config file itself.\n        \"\"\"\n        await self.send_config()\n\n        async for event in self._file_watcher:\n            # Since we are watching the whole parent directory, we need to make sure\n            # we only react to events related to the configuration file.\n            if event.path != self._config_path:\n                continue\n\n            match event.type:\n                case FileWatcher.EventType.CREATE:\n                    _logger.info(\n                        \"%s: The configuration file %s was created, sending new config...\",\n                        self,\n                        self._config_path,\n                    )\n                    await self.send_config()\n                case FileWatcher.EventType.MODIFY:\n                    _logger.info(\n                        \"%s: The configuration file %s was modified, sending update...\",\n                        self,\n                        self._config_path,\n                    )\n                    await self.send_config()\n                case FileWatcher.EventType.DELETE:\n                    _logger.info(\n                        \"%s: The configuration file %s was deleted, ignoring...\",\n                        self,\n                        self._config_path,\n                    )\n                case _:\n                    assert_never(event.type)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    config_path: Path | str,\n    output: Sender[Config],\n    event_types: Set[EventType] = frozenset(\n        FileWatcher.EventType\n    ),\n    *,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Initialize this instance.</p> PARAMETER  DESCRIPTION <code>config_path</code> <p>The path to the TOML file with the configuration.</p> <p> TYPE: <code>Path | str</code> </p> <code>output</code> <p>The sender to send the config to.</p> <p> TYPE: <code>Sender[Config]</code> </p> <code>event_types</code> <p>The set of event types to monitor.</p> <p> TYPE: <code>Set[EventType]</code> DEFAULT: <code>frozenset(EventType)</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_config_managing.py</code> <pre><code>def __init__(\n    self,\n    config_path: pathlib.Path | str,\n    output: Sender[Config],\n    event_types: abc.Set[FileWatcher.EventType] = frozenset(FileWatcher.EventType),\n    *,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize this instance.\n\n    Args:\n        config_path: The path to the TOML file with the configuration.\n        output: The sender to send the config to.\n        event_types: The set of event types to monitor.\n        name: The name of the actor. If `None`, `str(id(self))` will\n            be used. This is used mostly for debugging purposes.\n    \"\"\"\n    super().__init__(name=name)\n    self._config_path: pathlib.Path = (\n        config_path\n        if isinstance(config_path, pathlib.Path)\n        else pathlib.Path(config_path)\n    )\n    # FileWatcher can't watch for non-existing files, so we need to watch for the\n    # parent directory instead just in case a configuration file doesn't exist yet\n    # or it is deleted and recreated again.\n    self._file_watcher: FileWatcher = FileWatcher(\n        paths=[self._config_path.parent], event_types=event_types\n    )\n    self._output: Sender[Config] = output\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.send_config","title":"send_config  <code>async</code>","text":"<pre><code>send_config() -&gt; None\n</code></pre> <p>Send the configuration to the output sender.</p> Source code in <code>frequenz/sdk/actor/_config_managing.py</code> <pre><code>async def send_config(self) -&gt; None:\n    \"\"\"Send the configuration to the output sender.\"\"\"\n    conf_vars = self._read_config()\n    config = Config(conf_vars)\n    await self._output.send(config)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor","title":"frequenz.sdk.actor.DataSourcingActor","text":"<p>             Bases: <code>Actor</code></p> <p>An actor that provides data streams of metrics as time series.</p> Source code in <code>frequenz/sdk/actor/_data_sourcing/data_sourcing.py</code> <pre><code>class DataSourcingActor(Actor):\n    \"\"\"An actor that provides data streams of metrics as time series.\"\"\"\n\n    def __init__(\n        self,\n        request_receiver: Receiver[ComponentMetricRequest],\n        registry: ChannelRegistry,\n        *,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Create a `DataSourcingActor` instance.\n\n        Args:\n            request_receiver: A channel receiver to accept metric requests from.\n            registry: A channel registry.  To be replaced by a singleton\n                instance.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\n        super().__init__(name=name)\n        self._request_receiver = request_receiver\n        self._microgrid_api_source = MicrogridApiSource(registry)\n\n    async def _run(self) -&gt; None:\n        \"\"\"Run the actor.\"\"\"\n        async for request in self._request_receiver:\n            await self._microgrid_api_source.add_metric(request)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    request_receiver: Receiver[ComponentMetricRequest],\n    registry: ChannelRegistry,\n    *,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Create a <code>DataSourcingActor</code> instance.</p> PARAMETER  DESCRIPTION <code>request_receiver</code> <p>A channel receiver to accept metric requests from.</p> <p> TYPE: <code>Receiver[ComponentMetricRequest]</code> </p> <code>registry</code> <p>A channel registry.  To be replaced by a singleton instance.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_data_sourcing/data_sourcing.py</code> <pre><code>def __init__(\n    self,\n    request_receiver: Receiver[ComponentMetricRequest],\n    registry: ChannelRegistry,\n    *,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Create a `DataSourcingActor` instance.\n\n    Args:\n        request_receiver: A channel receiver to accept metric requests from.\n        registry: A channel registry.  To be replaced by a singleton\n            instance.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\n    super().__init__(name=name)\n    self._request_receiver = request_receiver\n    self._microgrid_api_source = MicrogridApiSource(registry)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig","title":"frequenz.sdk.actor.ResamplerConfig  <code>dataclass</code>","text":"<p>Resampler configuration.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>@dataclass(frozen=True)\nclass ResamplerConfig:\n    \"\"\"Resampler configuration.\"\"\"\n\n    resampling_period: timedelta\n    \"\"\"The resampling period.\n\n    This is the time it passes between resampled data should be calculated.\n\n    It must be a positive time span.\n    \"\"\"\n\n    max_data_age_in_periods: float = 3.0\n    \"\"\"The maximum age a sample can have to be considered *relevant* for resampling.\n\n    Expressed in number of periods, where period is the `resampling_period`\n    if we are downsampling (resampling period bigger than the input period) or\n    the input sampling period if we are upsampling (input period bigger than\n    the resampling period).\n\n    It must be bigger than 1.0.\n\n    Example:\n        If `resampling_period` is 3 seconds, the input sampling period is\n        1 and `max_data_age_in_periods` is 2, then data older than 3*2\n        = 6 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n\n        If `resampling_period` is 3 seconds, the input sampling period is\n        5 and `max_data_age_in_periods` is 2, then data older than 5*2\n        = 10 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n    \"\"\"\n\n    resampling_function: ResamplingFunction = average\n    \"\"\"The resampling function.\n\n    This function will be applied to the sequence of relevant samples at\n    a given time. The result of the function is what is sent as the resampled\n    value.\n    \"\"\"\n\n    initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n    \"\"\"The initial length of the resampling buffer.\n\n    The buffer could grow or shrink depending on the source properties,\n    like sampling rate, to make sure all the requested past sampling periods\n    can be stored.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n    \"\"\"The minimum length of the resampling buffer that will emit a warning.\n\n    If a buffer grows bigger than this value, it will emit a warning in the\n    logs, so buffers don't grow too big inadvertently.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n    \"\"\"The maximum length of the resampling buffer.\n\n    Buffers won't be allowed to grow beyond this point even if it would be\n    needed to keep all the requested past sampling periods. An error will be\n    emitted in the logs if the buffer length needs to be truncated to this\n    value.\n\n    It must be at bigger than `warn_buffer_len`.\n    \"\"\"\n\n    align_to: datetime | None = UNIX_EPOCH\n    \"\"\"The time to align the resampling period to.\n\n    The resampling period will be aligned to this time, so the first resampled\n    sample will be at the first multiple of `resampling_period` starting from\n    `align_to`. It must be an aware datetime and can be in the future too.\n\n    If `align_to` is `None`, the resampling period will be aligned to the\n    time the resampler is created.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Check that config values are valid.\n\n        Raises:\n            ValueError: If any value is out of range.\n        \"\"\"\n        if self.resampling_period.total_seconds() &lt; 0.0:\n            raise ValueError(\n                f\"resampling_period ({self.resampling_period}) must be positive\"\n            )\n        if self.max_data_age_in_periods &lt; 1.0:\n            raise ValueError(\n                f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n            )\n        if self.warn_buffer_len &lt; 1:\n            raise ValueError(\n                f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n            )\n        if self.max_buffer_len &lt;= self.warn_buffer_len:\n            raise ValueError(\n                f\"max_buffer_len ({self.max_buffer_len}) should \"\n                f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n            )\n\n        if self.initial_buffer_len &lt; 1:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n            )\n        if self.initial_buffer_len &gt; self.max_buffer_len:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n                f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n                \"initial_buffer_len or a bigger max_buffer_len\"\n            )\n        if self.initial_buffer_len &gt; self.warn_buffer_len:\n            _logger.warning(\n                \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n                self.initial_buffer_len,\n                self.warn_buffer_len,\n            )\n        if self.align_to is not None and self.align_to.tzinfo is None:\n            raise ValueError(\n                f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.align_to","title":"align_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>align_to: datetime | None = UNIX_EPOCH\n</code></pre> <p>The time to align the resampling period to.</p> <p>The resampling period will be aligned to this time, so the first resampled sample will be at the first multiple of <code>resampling_period</code> starting from <code>align_to</code>. It must be an aware datetime and can be in the future too.</p> <p>If <code>align_to</code> is <code>None</code>, the resampling period will be aligned to the time the resampler is created.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.initial_buffer_len","title":"initial_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n</code></pre> <p>The initial length of the resampling buffer.</p> <p>The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.max_buffer_len","title":"max_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n</code></pre> <p>The maximum length of the resampling buffer.</p> <p>Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value.</p> <p>It must be at bigger than <code>warn_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.max_data_age_in_periods","title":"max_data_age_in_periods  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_data_age_in_periods: float = 3.0\n</code></pre> <p>The maximum age a sample can have to be considered relevant for resampling.</p> <p>Expressed in number of periods, where period is the <code>resampling_period</code> if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period).</p> <p>It must be bigger than 1.0.</p> Example <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 1 and <code>max_data_age_in_periods</code> is 2, then data older than 3*2 = 6 seconds will be discarded when creating a new sample and never passed to the resampling function.</p> <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 5 and <code>max_data_age_in_periods</code> is 2, then data older than 5*2 = 10 seconds will be discarded when creating a new sample and never passed to the resampling function.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.resampling_function","title":"resampling_function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resampling_function: ResamplingFunction = average\n</code></pre> <p>The resampling function.</p> <p>This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.resampling_period","title":"resampling_period  <code>instance-attribute</code>","text":"<pre><code>resampling_period: timedelta\n</code></pre> <p>The resampling period.</p> <p>This is the time it passes between resampled data should be calculated.</p> <p>It must be a positive time span.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.warn_buffer_len","title":"warn_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n</code></pre> <p>The minimum length of the resampling buffer that will emit a warning.</p> <p>If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertently.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Check that config values are valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any value is out of range.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Check that config values are valid.\n\n    Raises:\n        ValueError: If any value is out of range.\n    \"\"\"\n    if self.resampling_period.total_seconds() &lt; 0.0:\n        raise ValueError(\n            f\"resampling_period ({self.resampling_period}) must be positive\"\n        )\n    if self.max_data_age_in_periods &lt; 1.0:\n        raise ValueError(\n            f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n        )\n    if self.warn_buffer_len &lt; 1:\n        raise ValueError(\n            f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n        )\n    if self.max_buffer_len &lt;= self.warn_buffer_len:\n        raise ValueError(\n            f\"max_buffer_len ({self.max_buffer_len}) should \"\n            f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n        )\n\n    if self.initial_buffer_len &lt; 1:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n        )\n    if self.initial_buffer_len &gt; self.max_buffer_len:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n            f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n            \"initial_buffer_len or a bigger max_buffer_len\"\n        )\n    if self.initial_buffer_len &gt; self.warn_buffer_len:\n        _logger.warning(\n            \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n            self.initial_buffer_len,\n            self.warn_buffer_len,\n        )\n    if self.align_to is not None and self.align_to.tzinfo is None:\n        raise ValueError(\n            f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.run","title":"frequenz.sdk.actor.run  <code>async</code>","text":"<pre><code>run(*actors: Actor) -&gt; None\n</code></pre> <p>Await the completion of all actors.</p> <p>Info</p> <p>Please read the <code>actor</code> module documentation for more comprehensive guide on how to use and implement actors properly.</p> PARAMETER  DESCRIPTION <code>*actors</code> <p>the actors to be awaited.</p> <p> TYPE: <code>Actor</code> DEFAULT: <code>()</code> </p> Source code in <code>frequenz/sdk/actor/_run_utils.py</code> <pre><code>async def run(*actors: Actor) -&gt; None:\n    \"\"\"Await the completion of all actors.\n\n    !!! info\n\n        Please read the [`actor` module documentation][frequenz.sdk.actor] for more\n        comprehensive guide on how to use and implement actors properly.\n\n    Args:\n        *actors: the actors to be awaited.\n    \"\"\"\n    _logger.info(\"Starting %s actor(s)...\", len(actors))\n\n    for actor in actors:\n        if actor.is_running:\n            _logger.info(\"Actor %s: Already running, skipping start.\", actor)\n        else:\n            _logger.info(\"Actor %s: Starting...\", actor)\n            actor.start()\n\n    # Wait until all actors are done\n    pending_tasks = {asyncio.create_task(a.wait(), name=str(a)) for a in actors}\n    while pending_tasks:\n        done_tasks, pending_tasks = await asyncio.wait(\n            pending_tasks, return_when=asyncio.FIRST_COMPLETED\n        )\n\n        # This should always be only one task, but we handle many for extra safety\n        for task in done_tasks:\n            # Cancellation needs to be checked first, otherwise the other methods\n            # could raise a CancelledError\n            if task.cancelled():\n                _logger.info(\"Actor %s: Cancelled while running.\", task.get_name())\n            elif exception := task.exception():\n                _logger.error(\n                    \"Actor %s: Raised an exception while running.\",\n                    task.get_name(),\n                    exc_info=exception,\n                )\n            else:\n                _logger.info(\"Actor %s: Finished normally.\", task.get_name())\n\n    _logger.info(\"All %s actor(s) finished.\", len(actors))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/","title":"Index","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing","title":"frequenz.sdk.actor.power_distributing","text":"<p>This module provides feature to set power between many batteries.</p> <p>Distributing power is very important to keep the microgrid ready for the power requirements. This module provides PowerDistributingActor that knows how to distribute power. It also provides all the secondary features that should be used to communicate with PowerDistributingActor and send requests for charging or discharging power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Result","title":"frequenz.sdk.actor.power_distributing.Result  <code>module-attribute</code>","text":"<pre><code>Result = Success | PartialFailure | Error | OutOfBounds\n</code></pre> <p>Power distribution result.</p> <p>Example: Handling power distribution results</p> <pre><code>```python\nfrom typing import assert_never\n\nfrom frequenz.sdk.actor.power_distributing import (\n    Error,\n    OutOfBounds,\n    PartialFailure,\n    Result,\n    Success,\n)\nfrom frequenz.sdk.actor.power_distributing.request import Request\nfrom frequenz.sdk.actor.power_distributing.result import PowerBounds\nfrom frequenz.sdk.timeseries._quantities import Power\n\ndef handle_power_request_result(result: Result) -&gt; None:\n    match result:\n        case Success() as success:\n            print(f\"Power request was successful: {success}\")\n        case PartialFailure() as partial_failure:\n            print(f\"Power request was partially successful: {partial_failure}\")\n        case OutOfBounds() as out_of_bounds:\n            print(f\"Power request was out of bounds: {out_of_bounds}\")\n        case Error() as error:\n            print(f\"Power request failed: {error}\")\n        case _ as unreachable:\n            assert_never(unreachable)\n\nrequest = Request(\n    namespace=\"TestChannel\",\n    power=Power.from_watts(123.4),\n    component_ids={8, 18},\n)\n\nresults: list[Result] = [\n    Success(\n        request,\n        succeeded_power=Power.from_watts(123.4),\n        succeeded_components={8, 18},\n        excess_power=Power.zero(),\n    ),\n    PartialFailure(\n        request,\n        succeeded_power=Power.from_watts(103.4),\n        succeeded_components={8},\n        excess_power=Power.zero(),\n        failed_components={18},\n        failed_power=Power.from_watts(20.0),\n    ),\n    OutOfBounds(request, bounds=PowerBounds(0, 0, 0, 800)),\n    Error(request, msg=\"The components are not available\"),\n]\n\nfor r in results:\n    handle_power_request_result(r)\n```\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus","title":"frequenz.sdk.actor.power_distributing.ComponentPoolStatus  <code>dataclass</code>","text":"<p>Status of all components of a certain category in the microgrid.</p> Source code in <code>frequenz/sdk/actor/power_distributing/_component_status/_component_status.py</code> <pre><code>@dataclass\nclass ComponentPoolStatus:\n    \"\"\"Status of all components of a certain category in the microgrid.\"\"\"\n\n    working: set[int]\n    \"\"\"Set of working component ids.\"\"\"\n\n    uncertain: set[int]\n    \"\"\"Set of components to be used only when there are none known to be working.\"\"\"\n\n    def get_working_components(self, components: abc.Set[int]) -&gt; set[int]:\n        \"\"\"From the given set of components return the working ones.\n\n        Args:\n            components: Set of components.\n\n        Returns:\n            Subset with working components.\n        \"\"\"\n        working = self.working.intersection(components)\n        if len(working) &gt; 0:\n            return working\n        return self.uncertain.intersection(components)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus.uncertain","title":"uncertain  <code>instance-attribute</code>","text":"<pre><code>uncertain: set[int]\n</code></pre> <p>Set of components to be used only when there are none known to be working.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus.working","title":"working  <code>instance-attribute</code>","text":"<pre><code>working: set[int]\n</code></pre> <p>Set of working component ids.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus.get_working_components","title":"get_working_components","text":"<pre><code>get_working_components(components: Set[int]) -&gt; set[int]\n</code></pre> <p>From the given set of components return the working ones.</p> PARAMETER  DESCRIPTION <code>components</code> <p>Set of components.</p> <p> TYPE: <code>Set[int]</code> </p> RETURNS DESCRIPTION <code>set[int]</code> <p>Subset with working components.</p> Source code in <code>frequenz/sdk/actor/power_distributing/_component_status/_component_status.py</code> <pre><code>def get_working_components(self, components: abc.Set[int]) -&gt; set[int]:\n    \"\"\"From the given set of components return the working ones.\n\n    Args:\n        components: Set of components.\n\n    Returns:\n        Subset with working components.\n    \"\"\"\n    working = self.working.intersection(components)\n    if len(working) &gt; 0:\n        return working\n    return self.uncertain.intersection(components)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error","title":"frequenz.sdk.actor.power_distributing.Error  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseResultMixin</code></p> <p>Result returned when an error occurred and power was not set at all.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Error(_BaseResultMixin):\n    \"\"\"Result returned when an error occurred and power was not set at all.\"\"\"\n\n    msg: str\n    \"\"\"The error message explaining why error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg: str\n</code></pre> <p>The error message explaining why error happened.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds","title":"frequenz.sdk.actor.power_distributing.OutOfBounds  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseResultMixin</code></p> <p>Result returned when the power was not set because it was out of bounds.</p> <p>This result happens when the originating request was done with <code>adjust_power = False</code> and the requested power is not within the available bounds.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass OutOfBounds(_BaseResultMixin):\n    \"\"\"Result returned when the power was not set because it was out of bounds.\n\n    This result happens when the originating request was done with\n    `adjust_power = False` and the requested power is not within the available bounds.\n    \"\"\"\n\n    bounds: PowerBounds\n    \"\"\"The power bounds for the requested components.\n\n    If the requested power negative, then this value is the lower bound.\n    Otherwise it is upper bound.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds.bounds","title":"bounds  <code>instance-attribute</code>","text":"<pre><code>bounds: PowerBounds\n</code></pre> <p>The power bounds for the requested components.</p> <p>If the requested power negative, then this value is the lower bound. Otherwise it is upper bound.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure","title":"frequenz.sdk.actor.power_distributing.PartialFailure  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when some of the components had an error setting the power.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PartialFailure(_BaseSuccessMixin, _BaseResultMixin):\n    \"\"\"Result returned when some of the components had an error setting the power.\"\"\"\n\n    failed_power: Power\n    \"\"\"The part of the requested power that failed to be set.\"\"\"\n\n    failed_components: abc.Set[int]\n    \"\"\"The subset of batteries for which the request failed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.excess_power","title":"excess_power  <code>instance-attribute</code>","text":"<pre><code>excess_power: Power\n</code></pre> <p>The part of the requested power that could not be fulfilled.</p> <p>This happens when the requested power is outside the available power bounds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.failed_components","title":"failed_components  <code>instance-attribute</code>","text":"<pre><code>failed_components: Set[int]\n</code></pre> <p>The subset of batteries for which the request failed.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.failed_power","title":"failed_power  <code>instance-attribute</code>","text":"<pre><code>failed_power: Power\n</code></pre> <p>The part of the requested power that failed to be set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.succeeded_components","title":"succeeded_components  <code>instance-attribute</code>","text":"<pre><code>succeeded_components: Set[int]\n</code></pre> <p>The subset of components for which power was set successfully.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.succeeded_power","title":"succeeded_power  <code>instance-attribute</code>","text":"<pre><code>succeeded_power: Power\n</code></pre> <p>The part of the requested power that was successfully set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor","title":"frequenz.sdk.actor.power_distributing.PowerDistributingActor","text":"<p>             Bases: <code>Actor</code></p> <p>Actor to distribute the power between batteries in a microgrid.</p> <p>The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time.</p> <p>For each user a bidirectional channel needs to be created through which they can send and receive requests and responses.</p> <p>It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout + time for processing the request.</p> <p>Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED.</p> <ul> <li>If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed.</li> </ul> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>class PowerDistributingActor(Actor):\n    # pylint: disable=too-many-instance-attributes\n    \"\"\"Actor to distribute the power between batteries in a microgrid.\n\n    The purpose of this tool is to keep an equal SoC level in all batteries.\n    The PowerDistributingActor can have many concurrent users which at this time\n    need to be known at construction time.\n\n    For each user a bidirectional channel needs to be created through which\n    they can send and receive requests and responses.\n\n    It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if\n    the processing function fails then the response will never come.\n    The timeout should be Result:request_timeout + time for processing the request.\n\n    Edge cases:\n    * If there are 2 requests to be processed for the same subset of batteries, then\n    only the latest request will be processed. Older request will be ignored. User with\n    older request will get response with Result.Status.IGNORED.\n\n    * If there are 2 requests and their subset of batteries is different but they\n    overlap (they have at least one common battery), then then both batteries\n    will be processed. However it is not expected so the proper error log will be\n    printed.\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        requests_receiver: Receiver[Request],\n        results_sender: Sender[Result],\n        component_pool_status_sender: Sender[ComponentPoolStatus],\n        wait_for_data_sec: float = 2,\n        *,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Create class instance.\n\n        Args:\n            requests_receiver: Receiver for receiving power requests from the power\n                manager.\n            results_sender: Sender for sending results to the power manager.\n            component_pool_status_sender: Channel for sending information about which\n                components are expected to be working.\n            wait_for_data_sec: How long actor should wait before processing first\n                request. It is a time needed to collect first components data.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\n        super().__init__(name=name)\n        self._requests_receiver = requests_receiver\n        self._result_sender = results_sender\n        self._wait_for_data_sec = wait_for_data_sec\n\n        self._component_manager: ComponentManager = BatteryManager(\n            component_pool_status_sender\n        )\n\n    async def _run(self) -&gt; None:  # pylint: disable=too-many-locals\n        \"\"\"Run actor main function.\n\n        It waits for new requests in task_queue and process it, and send\n        `set_power` request with distributed power.\n        The output of the `set_power` method is processed.\n        Every battery and inverter that failed or didn't respond in time will be marked\n        as broken for some time.\n        \"\"\"\n        await self._component_manager.start()\n\n        # Wait few seconds to get data from the channels created above.\n        await asyncio.sleep(self._wait_for_data_sec)\n\n        async for request in self._requests_receiver:\n            result = await self._component_manager.distribute_power(request)\n            await self._result_sender.send(result)\n\n    async def stop(self, msg: str | None = None) -&gt; None:\n        \"\"\"Stop this actor.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\n        await self._component_manager.stop()\n        await super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    requests_receiver: Receiver[Request],\n    results_sender: Sender[Result],\n    component_pool_status_sender: Sender[\n        ComponentPoolStatus\n    ],\n    wait_for_data_sec: float = 2,\n    *,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Create class instance.</p> PARAMETER  DESCRIPTION <code>requests_receiver</code> <p>Receiver for receiving power requests from the power manager.</p> <p> TYPE: <code>Receiver[Request]</code> </p> <code>results_sender</code> <p>Sender for sending results to the power manager.</p> <p> TYPE: <code>Sender[Result]</code> </p> <code>component_pool_status_sender</code> <p>Channel for sending information about which components are expected to be working.</p> <p> TYPE: <code>Sender[ComponentPoolStatus]</code> </p> <code>wait_for_data_sec</code> <p>How long actor should wait before processing first request. It is a time needed to collect first components data.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    requests_receiver: Receiver[Request],\n    results_sender: Sender[Result],\n    component_pool_status_sender: Sender[ComponentPoolStatus],\n    wait_for_data_sec: float = 2,\n    *,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Create class instance.\n\n    Args:\n        requests_receiver: Receiver for receiving power requests from the power\n            manager.\n        results_sender: Sender for sending results to the power manager.\n        component_pool_status_sender: Channel for sending information about which\n            components are expected to be working.\n        wait_for_data_sec: How long actor should wait before processing first\n            request. It is a time needed to collect first components data.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\n    super().__init__(name=name)\n    self._requests_receiver = requests_receiver\n    self._result_sender = results_sender\n    self._wait_for_data_sec = wait_for_data_sec\n\n    self._component_manager: ComponentManager = BatteryManager(\n        component_pool_status_sender\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this actor.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this actor.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    await self._component_manager.stop()\n    await super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request","title":"frequenz.sdk.actor.power_distributing.Request  <code>dataclass</code>","text":"<p>Request to set power to the <code>PowerDistributingActor</code>.</p> Source code in <code>frequenz/sdk/actor/power_distributing/request.py</code> <pre><code>@dataclasses.dataclass\nclass Request:\n    \"\"\"Request to set power to the `PowerDistributingActor`.\"\"\"\n\n    power: Power\n    \"\"\"The requested power.\"\"\"\n\n    component_ids: abc.Set[int]\n    \"\"\"The component ids of the components to be used for this request.\"\"\"\n\n    request_timeout: timedelta = timedelta(seconds=5.0)\n    \"\"\"The maximum amount of time to wait for the request to be fulfilled.\"\"\"\n\n    adjust_power: bool = True\n    \"\"\"Whether to adjust the power to match the bounds.\n\n    If `True`, the power will be adjusted (lowered) to match the bounds, so\n    only the reduced power will be set.\n\n    If `False` and the power is outside the available bounds, the request will\n    fail and be replied to with an `OutOfBound` result.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.adjust_power","title":"adjust_power  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>adjust_power: bool = True\n</code></pre> <p>Whether to adjust the power to match the bounds.</p> <p>If <code>True</code>, the power will be adjusted (lowered) to match the bounds, so only the reduced power will be set.</p> <p>If <code>False</code> and the power is outside the available bounds, the request will fail and be replied to with an <code>OutOfBound</code> result.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.component_ids","title":"component_ids  <code>instance-attribute</code>","text":"<pre><code>component_ids: Set[int]\n</code></pre> <p>The component ids of the components to be used for this request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.power","title":"power  <code>instance-attribute</code>","text":"<pre><code>power: Power\n</code></pre> <p>The requested power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.request_timeout","title":"request_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_timeout: timedelta = timedelta(seconds=5.0)\n</code></pre> <p>The maximum amount of time to wait for the request to be fulfilled.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success","title":"frequenz.sdk.actor.power_distributing.Success  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when setting the power was successful for all components.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Success(_BaseSuccessMixin, _BaseResultMixin):  # Order matters here. See above.\n    \"\"\"Result returned when setting the power was successful for all components.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/","title":"power_distributing","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing","title":"frequenz.sdk.actor.power_distributing.power_distributing","text":"<p>Actor to distribute power between batteries.</p> <p>When charge/discharge method is called the power should be distributed so that the SoC in batteries stays at the same level. That way of distribution prevents using only one battery, increasing temperature, and maximize the total amount power to charge/discharge.</p> <p>Purpose of this actor is to keep SoC level of each component at the equal level.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor","title":"frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor","text":"<p>             Bases: <code>Actor</code></p> <p>Actor to distribute the power between batteries in a microgrid.</p> <p>The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time.</p> <p>For each user a bidirectional channel needs to be created through which they can send and receive requests and responses.</p> <p>It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout + time for processing the request.</p> <p>Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED.</p> <ul> <li>If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed.</li> </ul> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>class PowerDistributingActor(Actor):\n    # pylint: disable=too-many-instance-attributes\n    \"\"\"Actor to distribute the power between batteries in a microgrid.\n\n    The purpose of this tool is to keep an equal SoC level in all batteries.\n    The PowerDistributingActor can have many concurrent users which at this time\n    need to be known at construction time.\n\n    For each user a bidirectional channel needs to be created through which\n    they can send and receive requests and responses.\n\n    It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if\n    the processing function fails then the response will never come.\n    The timeout should be Result:request_timeout + time for processing the request.\n\n    Edge cases:\n    * If there are 2 requests to be processed for the same subset of batteries, then\n    only the latest request will be processed. Older request will be ignored. User with\n    older request will get response with Result.Status.IGNORED.\n\n    * If there are 2 requests and their subset of batteries is different but they\n    overlap (they have at least one common battery), then then both batteries\n    will be processed. However it is not expected so the proper error log will be\n    printed.\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        requests_receiver: Receiver[Request],\n        results_sender: Sender[Result],\n        component_pool_status_sender: Sender[ComponentPoolStatus],\n        wait_for_data_sec: float = 2,\n        *,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Create class instance.\n\n        Args:\n            requests_receiver: Receiver for receiving power requests from the power\n                manager.\n            results_sender: Sender for sending results to the power manager.\n            component_pool_status_sender: Channel for sending information about which\n                components are expected to be working.\n            wait_for_data_sec: How long actor should wait before processing first\n                request. It is a time needed to collect first components data.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\n        super().__init__(name=name)\n        self._requests_receiver = requests_receiver\n        self._result_sender = results_sender\n        self._wait_for_data_sec = wait_for_data_sec\n\n        self._component_manager: ComponentManager = BatteryManager(\n            component_pool_status_sender\n        )\n\n    async def _run(self) -&gt; None:  # pylint: disable=too-many-locals\n        \"\"\"Run actor main function.\n\n        It waits for new requests in task_queue and process it, and send\n        `set_power` request with distributed power.\n        The output of the `set_power` method is processed.\n        Every battery and inverter that failed or didn't respond in time will be marked\n        as broken for some time.\n        \"\"\"\n        await self._component_manager.start()\n\n        # Wait few seconds to get data from the channels created above.\n        await asyncio.sleep(self._wait_for_data_sec)\n\n        async for request in self._requests_receiver:\n            result = await self._component_manager.distribute_power(request)\n            await self._result_sender.send(result)\n\n    async def stop(self, msg: str | None = None) -&gt; None:\n        \"\"\"Stop this actor.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\n        await self._component_manager.stop()\n        await super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    requests_receiver: Receiver[Request],\n    results_sender: Sender[Result],\n    component_pool_status_sender: Sender[\n        ComponentPoolStatus\n    ],\n    wait_for_data_sec: float = 2,\n    *,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Create class instance.</p> PARAMETER  DESCRIPTION <code>requests_receiver</code> <p>Receiver for receiving power requests from the power manager.</p> <p> TYPE: <code>Receiver[Request]</code> </p> <code>results_sender</code> <p>Sender for sending results to the power manager.</p> <p> TYPE: <code>Sender[Result]</code> </p> <code>component_pool_status_sender</code> <p>Channel for sending information about which components are expected to be working.</p> <p> TYPE: <code>Sender[ComponentPoolStatus]</code> </p> <code>wait_for_data_sec</code> <p>How long actor should wait before processing first request. It is a time needed to collect first components data.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    requests_receiver: Receiver[Request],\n    results_sender: Sender[Result],\n    component_pool_status_sender: Sender[ComponentPoolStatus],\n    wait_for_data_sec: float = 2,\n    *,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Create class instance.\n\n    Args:\n        requests_receiver: Receiver for receiving power requests from the power\n            manager.\n        results_sender: Sender for sending results to the power manager.\n        component_pool_status_sender: Channel for sending information about which\n            components are expected to be working.\n        wait_for_data_sec: How long actor should wait before processing first\n            request. It is a time needed to collect first components data.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\n    super().__init__(name=name)\n    self._requests_receiver = requests_receiver\n    self._result_sender = results_sender\n    self._wait_for_data_sec = wait_for_data_sec\n\n    self._component_manager: ComponentManager = BatteryManager(\n        component_pool_status_sender\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this actor.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this actor.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    await self._component_manager.stop()\n    await super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/","title":"request","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request","title":"frequenz.sdk.actor.power_distributing.request","text":"<p>Definition of the user request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request","title":"frequenz.sdk.actor.power_distributing.request.Request  <code>dataclass</code>","text":"<p>Request to set power to the <code>PowerDistributingActor</code>.</p> Source code in <code>frequenz/sdk/actor/power_distributing/request.py</code> <pre><code>@dataclasses.dataclass\nclass Request:\n    \"\"\"Request to set power to the `PowerDistributingActor`.\"\"\"\n\n    power: Power\n    \"\"\"The requested power.\"\"\"\n\n    component_ids: abc.Set[int]\n    \"\"\"The component ids of the components to be used for this request.\"\"\"\n\n    request_timeout: timedelta = timedelta(seconds=5.0)\n    \"\"\"The maximum amount of time to wait for the request to be fulfilled.\"\"\"\n\n    adjust_power: bool = True\n    \"\"\"Whether to adjust the power to match the bounds.\n\n    If `True`, the power will be adjusted (lowered) to match the bounds, so\n    only the reduced power will be set.\n\n    If `False` and the power is outside the available bounds, the request will\n    fail and be replied to with an `OutOfBound` result.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.adjust_power","title":"adjust_power  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>adjust_power: bool = True\n</code></pre> <p>Whether to adjust the power to match the bounds.</p> <p>If <code>True</code>, the power will be adjusted (lowered) to match the bounds, so only the reduced power will be set.</p> <p>If <code>False</code> and the power is outside the available bounds, the request will fail and be replied to with an <code>OutOfBound</code> result.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.component_ids","title":"component_ids  <code>instance-attribute</code>","text":"<pre><code>component_ids: Set[int]\n</code></pre> <p>The component ids of the components to be used for this request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.power","title":"power  <code>instance-attribute</code>","text":"<pre><code>power: Power\n</code></pre> <p>The requested power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.request_timeout","title":"request_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>request_timeout: timedelta = timedelta(seconds=5.0)\n</code></pre> <p>The maximum amount of time to wait for the request to be fulfilled.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/","title":"result","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result","title":"frequenz.sdk.actor.power_distributing.result","text":"<p>Results from PowerDistributingActor.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Result","title":"frequenz.sdk.actor.power_distributing.result.Result  <code>module-attribute</code>","text":"<pre><code>Result = Success | PartialFailure | Error | OutOfBounds\n</code></pre> <p>Power distribution result.</p> <p>Example: Handling power distribution results</p> <pre><code>```python\nfrom typing import assert_never\n\nfrom frequenz.sdk.actor.power_distributing import (\n    Error,\n    OutOfBounds,\n    PartialFailure,\n    Result,\n    Success,\n)\nfrom frequenz.sdk.actor.power_distributing.request import Request\nfrom frequenz.sdk.actor.power_distributing.result import PowerBounds\nfrom frequenz.sdk.timeseries._quantities import Power\n\ndef handle_power_request_result(result: Result) -&gt; None:\n    match result:\n        case Success() as success:\n            print(f\"Power request was successful: {success}\")\n        case PartialFailure() as partial_failure:\n            print(f\"Power request was partially successful: {partial_failure}\")\n        case OutOfBounds() as out_of_bounds:\n            print(f\"Power request was out of bounds: {out_of_bounds}\")\n        case Error() as error:\n            print(f\"Power request failed: {error}\")\n        case _ as unreachable:\n            assert_never(unreachable)\n\nrequest = Request(\n    namespace=\"TestChannel\",\n    power=Power.from_watts(123.4),\n    component_ids={8, 18},\n)\n\nresults: list[Result] = [\n    Success(\n        request,\n        succeeded_power=Power.from_watts(123.4),\n        succeeded_components={8, 18},\n        excess_power=Power.zero(),\n    ),\n    PartialFailure(\n        request,\n        succeeded_power=Power.from_watts(103.4),\n        succeeded_components={8},\n        excess_power=Power.zero(),\n        failed_components={18},\n        failed_power=Power.from_watts(20.0),\n    ),\n    OutOfBounds(request, bounds=PowerBounds(0, 0, 0, 800)),\n    Error(request, msg=\"The components are not available\"),\n]\n\nfor r in results:\n    handle_power_request_result(r)\n```\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error","title":"frequenz.sdk.actor.power_distributing.result.Error  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseResultMixin</code></p> <p>Result returned when an error occurred and power was not set at all.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Error(_BaseResultMixin):\n    \"\"\"Result returned when an error occurred and power was not set at all.\"\"\"\n\n    msg: str\n    \"\"\"The error message explaining why error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg: str\n</code></pre> <p>The error message explaining why error happened.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds","title":"frequenz.sdk.actor.power_distributing.result.OutOfBounds  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseResultMixin</code></p> <p>Result returned when the power was not set because it was out of bounds.</p> <p>This result happens when the originating request was done with <code>adjust_power = False</code> and the requested power is not within the available bounds.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass OutOfBounds(_BaseResultMixin):\n    \"\"\"Result returned when the power was not set because it was out of bounds.\n\n    This result happens when the originating request was done with\n    `adjust_power = False` and the requested power is not within the available bounds.\n    \"\"\"\n\n    bounds: PowerBounds\n    \"\"\"The power bounds for the requested components.\n\n    If the requested power negative, then this value is the lower bound.\n    Otherwise it is upper bound.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds.bounds","title":"bounds  <code>instance-attribute</code>","text":"<pre><code>bounds: PowerBounds\n</code></pre> <p>The power bounds for the requested components.</p> <p>If the requested power negative, then this value is the lower bound. Otherwise it is upper bound.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure","title":"frequenz.sdk.actor.power_distributing.result.PartialFailure  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when some of the components had an error setting the power.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PartialFailure(_BaseSuccessMixin, _BaseResultMixin):\n    \"\"\"Result returned when some of the components had an error setting the power.\"\"\"\n\n    failed_power: Power\n    \"\"\"The part of the requested power that failed to be set.\"\"\"\n\n    failed_components: abc.Set[int]\n    \"\"\"The subset of batteries for which the request failed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.excess_power","title":"excess_power  <code>instance-attribute</code>","text":"<pre><code>excess_power: Power\n</code></pre> <p>The part of the requested power that could not be fulfilled.</p> <p>This happens when the requested power is outside the available power bounds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_components","title":"failed_components  <code>instance-attribute</code>","text":"<pre><code>failed_components: Set[int]\n</code></pre> <p>The subset of batteries for which the request failed.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_power","title":"failed_power  <code>instance-attribute</code>","text":"<pre><code>failed_power: Power\n</code></pre> <p>The part of the requested power that failed to be set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.succeeded_components","title":"succeeded_components  <code>instance-attribute</code>","text":"<pre><code>succeeded_components: Set[int]\n</code></pre> <p>The subset of components for which power was set successfully.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.succeeded_power","title":"succeeded_power  <code>instance-attribute</code>","text":"<pre><code>succeeded_power: Power\n</code></pre> <p>The part of the requested power that was successfully set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds","title":"frequenz.sdk.actor.power_distributing.result.PowerBounds  <code>dataclass</code>","text":"<p>Inclusion and exclusion power bounds for the requested components.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PowerBounds:\n    \"\"\"Inclusion and exclusion power bounds for the requested components.\"\"\"\n\n    inclusion_lower: float\n    \"\"\"The lower value of the inclusion power bounds for the requested components.\"\"\"\n\n    exclusion_lower: float\n    \"\"\"The lower value of the exclusion power bounds for the requested components.\"\"\"\n\n    exclusion_upper: float\n    \"\"\"The upper value of the exclusion power bounds for the requested components.\"\"\"\n\n    inclusion_upper: float\n    \"\"\"The upper value of the inclusion power bounds for the requested components.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.exclusion_lower","title":"exclusion_lower  <code>instance-attribute</code>","text":"<pre><code>exclusion_lower: float\n</code></pre> <p>The lower value of the exclusion power bounds for the requested components.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.exclusion_upper","title":"exclusion_upper  <code>instance-attribute</code>","text":"<pre><code>exclusion_upper: float\n</code></pre> <p>The upper value of the exclusion power bounds for the requested components.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.inclusion_lower","title":"inclusion_lower  <code>instance-attribute</code>","text":"<pre><code>inclusion_lower: float\n</code></pre> <p>The lower value of the inclusion power bounds for the requested components.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.inclusion_upper","title":"inclusion_upper  <code>instance-attribute</code>","text":"<pre><code>inclusion_upper: float\n</code></pre> <p>The upper value of the inclusion power bounds for the requested components.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success","title":"frequenz.sdk.actor.power_distributing.result.Success  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when setting the power was successful for all components.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Success(_BaseSuccessMixin, _BaseResultMixin):  # Order matters here. See above.\n    \"\"\"Result returned when setting the power was successful for all components.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/config/","title":"config","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config","title":"frequenz.sdk.config","text":"<p>Config interface.</p>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config","title":"frequenz.sdk.config.Config","text":"<p>Stores config variables.</p> <p>Config variables are read from a file. Only single file can be read. If new file is read, then previous configs will be forgotten.</p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>class Config:\n    \"\"\"\n    Stores config variables.\n\n    Config variables are read from a file.\n    Only single file can be read.\n    If new file is read, then previous configs will be forgotten.\n    \"\"\"\n\n    def __init__(self, conf_vars: dict[str, Any]):\n        \"\"\"Instantiate the config store and read config variables from the file.\n\n        Args:\n            conf_vars: Dict containing configuration variables\n        \"\"\"\n        self._conf_store: dict[str, Any] = conf_vars\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Get the value for the specified key.\n\n        If the key is not in the configs, then return default.\n\n        Args:\n            key: Key to be searched.\n            default: Value to be returned if the key is not found.  Defaults to\n                None.\n\n        Returns:\n            value in str format or default.\n        \"\"\"\n        return self._conf_store.get(key, default)\n\n    def get_dict(\n        self, key_prefix: str, expected_values_type: T | None\n    ) -&gt; dict[str, Any]:\n        \"\"\"Get a dictionary based on config key prefixes.\n\n        For example, if key_prefix is \"my_dict\", then the following config store:\n            {\n                'some_key': 'some_value',\n                'my_dict_key1': 'value1',\n                'my_dict_key2': 'value2',\n            }\n        Will return:\n            {\n                'key1': 'value1',\n                'key2': 'value2',\n            }\n\n        Args:\n            key_prefix: Only get configuration variables starting with this\n                prefix.\n            expected_values_type: If provided, the value will be validated against\n                this type.\n\n        Returns:\n            A dictionary containing the keys prefixed with `key_prefix` as keys\n                (but with the prefix removed) and the values as values.\n        \"\"\"\n        result: dict[str, Any] = {}\n        for key, value in self._conf_store.items():\n            if key.startswith(key_prefix):\n                new_key = key[len(key_prefix) :]\n                if expected_values_type is not None:\n                    value = self.get_as(key, expected_values_type)\n                result[new_key] = value\n        return result\n\n    def get_as(self, key: str, expected_type: Any) -&gt; Any:\n        \"\"\"Get and convert the value to specified type.\n\n        Check if type of the value is as expected.  If type is correct, then\n        return converted value.  Otherwise Raise ValueError.\n\n        Type can be:\n            * Any typing module type.\n            * Any pydantic strict types (e.g. pydantic.StrictInt)\n\n        Args:\n            key: Key to be search\n            expected_type: type for the value\n\n        Raises:\n            ValueError: If can't convert value to the expected type.\n            KeyError: If specified key is not in config.\n\n        Returns:\n            Value for the specified key, converted to specified type.\n\n        Example:\n            For `var1='[1, 2.0, 3.5]'`:\n                * `get_as(\"var1\", List[int])` -&gt; `[1,2,3]`\n                * `get_as(\"var1\", List[float])` -&gt; `[1.0,2.0,3.5]`\n                * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; [ValueError][]\n                * `get_as(\"var1\", List[pydantic.StrictFloat])` -&gt; [ValueError][]\n\n            For `var1='[1,2,3]'`:\n                * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; `[1,2,3]`\n\n        \"\"\"\n        value = self[key]\n\n        if str is expected_type:\n            return value\n\n        try:\n            obj = json.loads(value)\n            metadata = getattr(expected_type, \"__metadata__\", (None,))[0]\n            strict = metadata.strict if isinstance(metadata, Strict) else False\n            adapter = TypeAdapter(expected_type)\n            parsed_value = adapter.validate_python(obj, strict=strict)\n        except (ValidationError, ValueError) as err:\n            raise ValueError(\n                f\"Could not convert config variable: {key} = '{value}' \"\n                f\"to type {str(expected_type)}, err:\" + str(err)\n            ) from err\n\n        return parsed_value\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"Get the value for the specified key.\n\n        If the key is not in the configs, then raise KeyError.\n\n        Args:\n            key: key to be searched.\n\n        Raises:\n            KeyError: If key is not in found.\n\n        Returns:\n            Dictionary if the corresponding value is a subsection in the .toml\n                file or a primitive type it is a simple value.\n        \"\"\"\n        value = self._conf_store.get(key, None)\n        if value is None:\n            raise KeyError(f\"Unknown config name {key}\")\n\n        return value\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"Return whether the specified key is in the storage.\n\n        Args:\n            key: Config variable name.\n\n        Returns:\n            True if key is in the storage, otherwise returns False.\n        \"\"\"\n        return key in self._conf_store\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.__contains__","title":"__contains__","text":"<pre><code>__contains__(key: str) -&gt; bool\n</code></pre> <p>Return whether the specified key is in the storage.</p> PARAMETER  DESCRIPTION <code>key</code> <p>Config variable name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if key is in the storage, otherwise returns False.</p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    \"\"\"Return whether the specified key is in the storage.\n\n    Args:\n        key: Config variable name.\n\n    Returns:\n        True if key is in the storage, otherwise returns False.\n    \"\"\"\n    return key in self._conf_store\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Get the value for the specified key.</p> <p>If the key is not in the configs, then raise KeyError.</p> PARAMETER  DESCRIPTION <code>key</code> <p>key to be searched.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If key is not in found.</p> RETURNS DESCRIPTION <code>Any</code> <p>Dictionary if the corresponding value is a subsection in the .toml file or a primitive type it is a simple value.</p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Get the value for the specified key.\n\n    If the key is not in the configs, then raise KeyError.\n\n    Args:\n        key: key to be searched.\n\n    Raises:\n        KeyError: If key is not in found.\n\n    Returns:\n        Dictionary if the corresponding value is a subsection in the .toml\n            file or a primitive type it is a simple value.\n    \"\"\"\n    value = self._conf_store.get(key, None)\n    if value is None:\n        raise KeyError(f\"Unknown config name {key}\")\n\n    return value\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.__init__","title":"__init__","text":"<pre><code>__init__(conf_vars: dict[str, Any])\n</code></pre> <p>Instantiate the config store and read config variables from the file.</p> PARAMETER  DESCRIPTION <code>conf_vars</code> <p>Dict containing configuration variables</p> <p> TYPE: <code>dict[str, Any]</code> </p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def __init__(self, conf_vars: dict[str, Any]):\n    \"\"\"Instantiate the config store and read config variables from the file.\n\n    Args:\n        conf_vars: Dict containing configuration variables\n    \"\"\"\n    self._conf_store: dict[str, Any] = conf_vars\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.get","title":"get","text":"<pre><code>get(key: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value for the specified key.</p> <p>If the key is not in the configs, then return default.</p> PARAMETER  DESCRIPTION <code>key</code> <p>Key to be searched.</p> <p> TYPE: <code>str</code> </p> <code>default</code> <p>Value to be returned if the key is not found.  Defaults to None.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>value in str format or default.</p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Get the value for the specified key.\n\n    If the key is not in the configs, then return default.\n\n    Args:\n        key: Key to be searched.\n        default: Value to be returned if the key is not found.  Defaults to\n            None.\n\n    Returns:\n        value in str format or default.\n    \"\"\"\n    return self._conf_store.get(key, default)\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.get_as","title":"get_as","text":"<pre><code>get_as(key: str, expected_type: Any) -&gt; Any\n</code></pre> <p>Get and convert the value to specified type.</p> <p>Check if type of the value is as expected.  If type is correct, then return converted value.  Otherwise Raise ValueError.</p> Type can be <ul> <li>Any typing module type.</li> <li>Any pydantic strict types (e.g. pydantic.StrictInt)</li> </ul> PARAMETER  DESCRIPTION <code>key</code> <p>Key to be search</p> <p> TYPE: <code>str</code> </p> <code>expected_type</code> <p>type for the value</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If can't convert value to the expected type.</p> <code>KeyError</code> <p>If specified key is not in config.</p> RETURNS DESCRIPTION <code>Any</code> <p>Value for the specified key, converted to specified type.</p> Example <p>For <code>var1='[1, 2.0, 3.5]'</code>:     * <code>get_as(\"var1\", List[int])</code> -&gt; <code>[1,2,3]</code>     * <code>get_as(\"var1\", List[float])</code> -&gt; <code>[1.0,2.0,3.5]</code>     * <code>get_as(\"var1\", List[pydantic.StrictInt])</code> -&gt; ValueError     * <code>get_as(\"var1\", List[pydantic.StrictFloat])</code> -&gt; ValueError</p> <p>For <code>var1='[1,2,3]'</code>:     * <code>get_as(\"var1\", List[pydantic.StrictInt])</code> -&gt; <code>[1,2,3]</code></p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def get_as(self, key: str, expected_type: Any) -&gt; Any:\n    \"\"\"Get and convert the value to specified type.\n\n    Check if type of the value is as expected.  If type is correct, then\n    return converted value.  Otherwise Raise ValueError.\n\n    Type can be:\n        * Any typing module type.\n        * Any pydantic strict types (e.g. pydantic.StrictInt)\n\n    Args:\n        key: Key to be search\n        expected_type: type for the value\n\n    Raises:\n        ValueError: If can't convert value to the expected type.\n        KeyError: If specified key is not in config.\n\n    Returns:\n        Value for the specified key, converted to specified type.\n\n    Example:\n        For `var1='[1, 2.0, 3.5]'`:\n            * `get_as(\"var1\", List[int])` -&gt; `[1,2,3]`\n            * `get_as(\"var1\", List[float])` -&gt; `[1.0,2.0,3.5]`\n            * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; [ValueError][]\n            * `get_as(\"var1\", List[pydantic.StrictFloat])` -&gt; [ValueError][]\n\n        For `var1='[1,2,3]'`:\n            * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; `[1,2,3]`\n\n    \"\"\"\n    value = self[key]\n\n    if str is expected_type:\n        return value\n\n    try:\n        obj = json.loads(value)\n        metadata = getattr(expected_type, \"__metadata__\", (None,))[0]\n        strict = metadata.strict if isinstance(metadata, Strict) else False\n        adapter = TypeAdapter(expected_type)\n        parsed_value = adapter.validate_python(obj, strict=strict)\n    except (ValidationError, ValueError) as err:\n        raise ValueError(\n            f\"Could not convert config variable: {key} = '{value}' \"\n            f\"to type {str(expected_type)}, err:\" + str(err)\n        ) from err\n\n    return parsed_value\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.get_dict","title":"get_dict","text":"<pre><code>get_dict(\n    key_prefix: str, expected_values_type: T | None\n) -&gt; dict[str, Any]\n</code></pre> <p>Get a dictionary based on config key prefixes.</p> <p>For example, if key_prefix is \"my_dict\", then the following config store:     {         'some_key': 'some_value',         'my_dict_key1': 'value1',         'my_dict_key2': 'value2',     } Will return:     {         'key1': 'value1',         'key2': 'value2',     }</p> PARAMETER  DESCRIPTION <code>key_prefix</code> <p>Only get configuration variables starting with this prefix.</p> <p> TYPE: <code>str</code> </p> <code>expected_values_type</code> <p>If provided, the value will be validated against this type.</p> <p> TYPE: <code>T | None</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A dictionary containing the keys prefixed with <code>key_prefix</code> as keys (but with the prefix removed) and the values as values.</p> Source code in <code>frequenz/sdk/config/_config.py</code> <pre><code>def get_dict(\n    self, key_prefix: str, expected_values_type: T | None\n) -&gt; dict[str, Any]:\n    \"\"\"Get a dictionary based on config key prefixes.\n\n    For example, if key_prefix is \"my_dict\", then the following config store:\n        {\n            'some_key': 'some_value',\n            'my_dict_key1': 'value1',\n            'my_dict_key2': 'value2',\n        }\n    Will return:\n        {\n            'key1': 'value1',\n            'key2': 'value2',\n        }\n\n    Args:\n        key_prefix: Only get configuration variables starting with this\n            prefix.\n        expected_values_type: If provided, the value will be validated against\n            this type.\n\n    Returns:\n        A dictionary containing the keys prefixed with `key_prefix` as keys\n            (but with the prefix removed) and the values as values.\n    \"\"\"\n    result: dict[str, Any] = {}\n    for key, value in self._conf_store.items():\n        if key.startswith(key_prefix):\n            new_key = key[len(key_prefix) :]\n            if expected_values_type is not None:\n                value = self.get_as(key, expected_values_type)\n            result[new_key] = value\n    return result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/","title":"Index","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid","title":"frequenz.sdk.microgrid","text":"<p>A microgrid is a local electrical grid that connects a set of electrical components together.  They are often built around a passive power consumer, to supplement the electricity consumed from the public grid with on-site power generation or storage systems.</p> <p>Microgrids can also function in island-mode, without a grid connection, or without a local power consumer, but they have to have at least one of the two, to be meaningful.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--frequenz-sdk-microgrid-model","title":"Frequenz SDK Microgrid Model","text":"<p>The SDK aims to provide an abstract model of the microgrid that enables high-level interactions with microgrid components, without having to worry about (or even be aware of) location-specific details such as:</p> <ul> <li>where the meters are placed,</li> <li>how many batteries,</li> <li>whether there's a grid connection or a passive consumer,</li> <li>what models the inverters are, etc.</li> <li>whether components are having downtimes, because metrics and   limits get adjusted automatically when components are having downtimes.</li> </ul> <p>Users of the SDK can develop applications around this interface once and deploy anywhere, and the SDK will take care of translating the requests and instructions to correspond to the specific microgrid configurations.</p> <pre><code>flowchart LR\n\nsubgraph Left[Measurements only]\ndirection LR\n  grid[\"Grid Connection\"]\n  consumer[\"Consumer\"]\n  pv[\"PV Arrays\"]\n  chp[\"CHP\"]\nend\n\njunction(( ))\n\nsubgraph Right[Measurements and control]\ndirection LR\n  bat[\"Batteries\"]\n  ev[\"EV Chargers\"]\nend\n\ngrid --- junction\nconsumer --- junction\npv --- junction\nchp --- junction\n\njunction --- bat\njunction --- ev</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--grid","title":"Grid","text":"<p>This refers to a microgrid's connection to the external Grid.  The power flowing through this connection can be streamed through <code>grid_power</code>.</p> <p>In locations without a grid connection, this method remains accessible, and streams zero values.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--consumer","title":"Consumer","text":"<p>This is the main power consumer at the site of a microgrid, and often the load the microgrid is built to support.  The power drawn by the consumer is available through <code>consumer_power</code></p> <p>In locations without a consumer, this method streams zero values.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--producers-pv-arrays-chp","title":"Producers: PV Arrays, CHP","text":"<p>The total PV power production in a microgrid can be streamed through <code>pv_power</code> , and similarly the total CHP production in a site can be streamed through <code>chp_power</code>.  And total producer power is available through <code>producer_power</code>.</p> <p>As is the case with the other methods, if PV Arrays or CHPs are not available in a microgrid, the corresponding methods stream zero values.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--batteries","title":"Batteries","text":"<p>The total Battery power is available through <code>battery_pool</code>'s <code>power</code>.  The battery pool by default uses all batteries available at a location, but battery pool instances can be created for subsets of batteries if necessary, by specifying the battery ids.</p> <p>The <code>battery_pool</code> also provides <code>soc</code>, <code>capacity</code>, <code>temperature</code> and available power bounds through the <code>power_status</code> method.</p> <p>The <code>battery_pool</code> also provides control methods <code>propose_power</code> (which accepts values in the Passive Sign Convention and supports both charging and discharging), or through <code>propose_charge</code>, or <code>propose_discharge</code>.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--ev-chargers","title":"EV Chargers","text":"<p>The <code>ev_charger_pool</code> offers a <code>power</code> method that streams the total power measured for all the EV Chargers at a site.</p> <p>It also offers a <code>component_data</code> method for fetching the status of individual EV Chargers, including state changes like when an EV is connected or disconnected, and a <code>set_bounds</code> method to limit the charge power of individual EV Chargers.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.battery_pool","title":"frequenz.sdk.microgrid.battery_pool","text":"<pre><code>battery_pool(\n    battery_ids: Set[int] | None = None,\n    name: str | None = None,\n    priority: int = -sys.maxsize - 1,\n) -&gt; BatteryPool\n</code></pre> <p>Return a new <code>BatteryPool</code> instance for the given parameters.</p> <p>The priority value is used to resolve conflicts when multiple actors are trying to propose different power values for the same set of batteries.</p> <p>Note</p> <p>When specifying priority, bigger values indicate higher priority. The default priority is the lowest possible value.</p> PARAMETER  DESCRIPTION <code>battery_ids</code> <p>Optional set of IDs of batteries to be managed by the <code>BatteryPool</code>. If not specified, all batteries available in the component graph are used.</p> <p> TYPE: <code>Set[int] | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>An optional name used to identify this instance of the pool or a corresponding actor in the logs.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>priority</code> <p>The priority of the actor making the call.</p> <p> TYPE: <code>int</code> DEFAULT: <code>-maxsize - 1</code> </p> RETURNS DESCRIPTION <code>BatteryPool</code> <p>A <code>BatteryPool</code> instance.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def battery_pool(\n    battery_ids: abc.Set[int] | None = None,\n    name: str | None = None,\n    priority: int = -sys.maxsize - 1,\n) -&gt; BatteryPool:\n    \"\"\"Return a new `BatteryPool` instance for the given parameters.\n\n    The priority value is used to resolve conflicts when multiple actors are trying to\n    propose different power values for the same set of batteries.\n\n    !!! note\n        When specifying priority, bigger values indicate higher priority. The default\n        priority is the lowest possible value.\n\n    Args:\n        battery_ids: Optional set of IDs of batteries to be managed by the `BatteryPool`.\n            If not specified, all batteries available in the component graph are used.\n        name: An optional name used to identify this instance of the pool or a\n            corresponding actor in the logs.\n        priority: The priority of the actor making the call.\n\n    Returns:\n        A `BatteryPool` instance.\n    \"\"\"\n    return _get().battery_pool(battery_ids, name, priority)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.consumer","title":"frequenz.sdk.microgrid.consumer","text":"<pre><code>consumer() -&gt; Consumer\n</code></pre> <p>Return the <code>Consumption</code> measuring point.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def consumer() -&gt; Consumer:\n    \"\"\"Return the [`Consumption`][frequenz.sdk.timeseries.consumer.Consumer] measuring point.\"\"\"\n    return _get().consumer()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ev_charger_pool","title":"frequenz.sdk.microgrid.ev_charger_pool","text":"<pre><code>ev_charger_pool(\n    ev_charger_ids: set[int] | None = None,\n) -&gt; EVChargerPool\n</code></pre> <p>Return the corresponding EVChargerPool instance for the given ids.</p> <p>If an EVChargerPool instance for the given ids doesn't exist, a new one is created and returned.</p> PARAMETER  DESCRIPTION <code>ev_charger_ids</code> <p>Optional set of IDs of EV Chargers to be managed by the EVChargerPool.  If not specified, all EV Chargers available in the component graph are used.</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>EVChargerPool</code> <p>An EVChargerPool instance.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def ev_charger_pool(ev_charger_ids: set[int] | None = None) -&gt; EVChargerPool:\n    \"\"\"Return the corresponding EVChargerPool instance for the given ids.\n\n    If an EVChargerPool instance for the given ids doesn't exist, a new one is\n    created and returned.\n\n    Args:\n        ev_charger_ids: Optional set of IDs of EV Chargers to be managed by the\n            EVChargerPool.  If not specified, all EV Chargers available in the\n            component graph are used.\n\n    Returns:\n        An EVChargerPool instance.\n    \"\"\"\n    return _get().ev_charger_pool(ev_charger_ids)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.frequency","title":"frequenz.sdk.microgrid.frequency","text":"<pre><code>frequency() -&gt; GridFrequency\n</code></pre> <p>Return the grid frequency measuring point.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def frequency() -&gt; GridFrequency:\n    \"\"\"Return the grid frequency measuring point.\"\"\"\n    return _get().frequency()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.grid","title":"frequenz.sdk.microgrid.grid","text":"<pre><code>grid() -&gt; Grid\n</code></pre> <p>Return the grid measuring point.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def grid() -&gt; Grid:\n    \"\"\"Return the grid measuring point.\"\"\"\n    return _get().grid()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.initialize","title":"frequenz.sdk.microgrid.initialize  <code>async</code>","text":"<pre><code>initialize(\n    host: str, port: int, resampler_config: ResamplerConfig\n) -&gt; None\n</code></pre> <p>Initialize the microgrid connection manager and the data pipeline.</p> PARAMETER  DESCRIPTION <code>host</code> <p>Host to connect to, to reach the microgrid API.</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>port to connect to.</p> <p> TYPE: <code>int</code> </p> <code>resampler_config</code> <p>Configuration for the resampling actor.</p> <p> TYPE: <code>ResamplerConfig</code> </p> Source code in <code>frequenz/sdk/microgrid/__init__.py</code> <pre><code>async def initialize(host: str, port: int, resampler_config: ResamplerConfig) -&gt; None:\n    \"\"\"Initialize the microgrid connection manager and the data pipeline.\n\n    Args:\n        host: Host to connect to, to reach the microgrid API.\n        port: port to connect to.\n        resampler_config: Configuration for the resampling actor.\n    \"\"\"\n    await connection_manager.initialize(host, port)\n    await _data_pipeline.initialize(resampler_config)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.logical_meter","title":"frequenz.sdk.microgrid.logical_meter","text":"<pre><code>logical_meter() -&gt; LogicalMeter\n</code></pre> <p>Return the logical meter of the microgrid.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def logical_meter() -&gt; LogicalMeter:\n    \"\"\"Return the logical meter of the microgrid.\"\"\"\n    return _get().logical_meter()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.producer","title":"frequenz.sdk.microgrid.producer","text":"<pre><code>producer() -&gt; Producer\n</code></pre> <p>Return the <code>Production</code> measuring point.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def producer() -&gt; Producer:\n    \"\"\"Return the [`Production`][frequenz.sdk.timeseries.producer.Producer] measuring point.\"\"\"\n    return _get().producer()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.voltage","title":"frequenz.sdk.microgrid.voltage","text":"<pre><code>voltage() -&gt; VoltageStreamer\n</code></pre> <p>Return the 3-phase voltage measuring point.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def voltage() -&gt; VoltageStreamer:\n    \"\"\"Return the 3-phase voltage measuring point.\"\"\"\n    return _get().voltage()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/","title":"component_graph","text":""},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph","title":"frequenz.sdk.microgrid.component_graph","text":"<p>Defines a graph representation of how microgrid components are connected.</p> <p>The component graph is an approximate representation of the microgrid circuit, abstracted to a level appropriate for higher-level monitoring and control. Examples of use-cases would be:</p> <ul> <li> <p>using the graph structure to infer which component measurements     need to be combined to obtain grid power or onsite load</p> </li> <li> <p>identifying which inverter(s) need to be engaged to (dis)charge     a particular battery</p> </li> <li> <p>understanding which power flows in the microgrid are derived from     green and grey sources</p> </li> </ul> <p>It deliberately does not include all pieces of hardware placed in the microgrid, instead limiting itself to just those that are needed to monitor and control the flow of power.</p>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph","title":"frequenz.sdk.microgrid.component_graph.ComponentGraph","text":"<p>             Bases: <code>ABC</code></p> <p>Interface for component graph implementations.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>class ComponentGraph(ABC):\n    \"\"\"Interface for component graph implementations.\"\"\"\n\n    @abstractmethod\n    def components(\n        self,\n        component_ids: set[int] | None = None,\n        component_categories: set[ComponentCategory] | None = None,\n    ) -&gt; set[Component]:\n        \"\"\"Fetch the components of the microgrid.\n\n        Args:\n            component_ids: filter out any components not matching one of the provided IDs\n            component_categories: filter out any components not matching one of the\n                provided types\n\n        Returns:\n            Set of the components currently connected to the microgrid, filtered by\n                the provided `component_ids` and `component_categories` values.\n        \"\"\"\n\n    @abstractmethod\n    def connections(\n        self,\n        start: set[int] | None = None,\n        end: set[int] | None = None,\n    ) -&gt; set[Connection]:\n        \"\"\"Fetch the connections between microgrid components.\n\n        Args:\n            start: filter out any connections whose `start` does not match one of these\n                component IDs\n            end: filter out any connections whose `end` does not match one of these\n                component IDs\n\n        Returns:\n            Set of the connections between components in the microgrid, filtered by\n                the provided `start`/`end` choices.\n        \"\"\"\n\n    @abstractmethod\n    def predecessors(self, component_id: int) -&gt; set[Component]:\n        \"\"\"Fetch the graph predecessors of the specified component.\n\n        Args:\n            component_id: numerical ID of the component whose predecessors should be\n                fetched\n\n        Returns:\n            Set of IDs of the components that are predecessors of `component_id`,\n                i.e. for which there is a connection from each of these components to\n                `component_id`.\n\n        Raises:\n            KeyError: if the specified `component_id` is not in the graph\n        \"\"\"\n\n    @abstractmethod\n    def successors(self, component_id: int) -&gt; set[Component]:\n        \"\"\"Fetch the graph successors of the specified component.\n\n        Args:\n            component_id: numerical ID of the component whose successors should be\n                fetched\n\n        Returns:\n            Set of IDs of the components that are successors of `component_id`,\n                i.e. for which there is a connection from `component_id` to each of\n                these components.\n\n        Raises:\n            KeyError: if the specified `component_id` is not in the graph\n        \"\"\"\n\n    @abstractmethod\n    def is_pv_inverter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a PV inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a PV inverter.\n        \"\"\"\n\n    @abstractmethod\n    def is_pv_meter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a PV meter.\n\n        This is done by checking if the component has only PV inverters as its\n        successors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a PV meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_pv_chain(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is part of a PV chain.\n\n        A component is part of a PV chain if it is a PV meter or a PV inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of a PV chain.\n        \"\"\"\n\n    @abstractmethod\n    def is_battery_inverter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a battery inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a battery inverter.\n        \"\"\"\n\n    @abstractmethod\n    def is_battery_meter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a battery meter.\n\n        This is done by checking if the component has only battery inverters as its\n        predecessors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a battery meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_battery_chain(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is part of a battery chain.\n\n        A component is part of a battery chain if it is a battery meter or a battery\n        inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of a battery chain.\n        \"\"\"\n\n    @abstractmethod\n    def is_ev_charger(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is an EV charger.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is an EV charger.\n        \"\"\"\n\n    @abstractmethod\n    def is_ev_charger_meter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is an EV charger meter.\n\n        This is done by checking if the component has only EV chargers as its\n        successors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is an EV charger meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_ev_charger_chain(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is part of an EV charger chain.\n\n        A component is part of an EV charger chain if it is an EV charger meter or an\n        EV charger.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of an EV charger chain.\n        \"\"\"\n\n    @abstractmethod\n    def is_chp(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a CHP.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a CHP.\n        \"\"\"\n\n    @abstractmethod\n    def is_chp_meter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a CHP meter.\n\n        This is done by checking if the component has only CHPs as its successors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a CHP meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_chp_chain(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is part of a CHP chain.\n\n        A component is part of a CHP chain if it is a CHP meter or a CHP.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of a CHP chain.\n        \"\"\"\n\n    @abstractmethod\n    def dfs(\n        self,\n        current_node: Component,\n        visited: set[Component],\n        condition: Callable[[Component], bool],\n    ) -&gt; set[Component]:\n        \"\"\"\n        Search for components that fulfill the condition in the Graph.\n\n        DFS is used for searching the graph. The graph traversal is stopped\n        once a component fulfills the condition.\n\n        Args:\n            current_node: The current node to search from.\n            visited: The set of visited nodes.\n            condition: The condition function to check for.\n\n        Returns:\n            A set of component ids where the corresponding components fulfill\n            the condition function.\n        \"\"\"\n\n    @abstractmethod\n    def find_first_descendant_component(\n        self,\n        *,\n        root_category: ComponentCategory,\n        descendant_categories: Iterable[ComponentCategory],\n    ) -&gt; Component:\n        \"\"\"Find the first descendant component given root and descendant categories.\n\n        This method searches for the root component within the provided root\n        category. If multiple components share the same root category, the\n        first found one is considered as the root component.\n\n        Subsequently, it looks for the first descendant component from the root\n        component, considering only the immediate descendants.\n\n        The priority of the component to search for is determined by the order\n        of the descendant categories, with the first category having the\n        highest priority.\n\n        Args:\n            root_category: The category of the root component to search for.\n            descendant_categories: The descendant categories to search for the\n                first descendant component in.\n\n        Returns:\n            The first descendant component found in the component graph,\n            considering the specified root and descendant categories.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.components","title":"components  <code>abstractmethod</code>","text":"<pre><code>components(\n    component_ids: set[int] | None = None,\n    component_categories: (\n        set[ComponentCategory] | None\n    ) = None,\n) -&gt; set[Component]\n</code></pre> <p>Fetch the components of the microgrid.</p> PARAMETER  DESCRIPTION <code>component_ids</code> <p>filter out any components not matching one of the provided IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>component_categories</code> <p>filter out any components not matching one of the provided types</p> <p> TYPE: <code>set[ComponentCategory] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>Set of the components currently connected to the microgrid, filtered by the provided <code>component_ids</code> and <code>component_categories</code> values.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef components(\n    self,\n    component_ids: set[int] | None = None,\n    component_categories: set[ComponentCategory] | None = None,\n) -&gt; set[Component]:\n    \"\"\"Fetch the components of the microgrid.\n\n    Args:\n        component_ids: filter out any components not matching one of the provided IDs\n        component_categories: filter out any components not matching one of the\n            provided types\n\n    Returns:\n        Set of the components currently connected to the microgrid, filtered by\n            the provided `component_ids` and `component_categories` values.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.connections","title":"connections  <code>abstractmethod</code>","text":"<pre><code>connections(\n    start: set[int] | None = None,\n    end: set[int] | None = None,\n) -&gt; set[Connection]\n</code></pre> <p>Fetch the connections between microgrid components.</p> PARAMETER  DESCRIPTION <code>start</code> <p>filter out any connections whose <code>start</code> does not match one of these component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>end</code> <p>filter out any connections whose <code>end</code> does not match one of these component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>set[Connection]</code> <p>Set of the connections between components in the microgrid, filtered by the provided <code>start</code>/<code>end</code> choices.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef connections(\n    self,\n    start: set[int] | None = None,\n    end: set[int] | None = None,\n) -&gt; set[Connection]:\n    \"\"\"Fetch the connections between microgrid components.\n\n    Args:\n        start: filter out any connections whose `start` does not match one of these\n            component IDs\n        end: filter out any connections whose `end` does not match one of these\n            component IDs\n\n    Returns:\n        Set of the connections between components in the microgrid, filtered by\n            the provided `start`/`end` choices.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.dfs","title":"dfs  <code>abstractmethod</code>","text":"<pre><code>dfs(\n    current_node: Component,\n    visited: set[Component],\n    condition: Callable[[Component], bool],\n) -&gt; set[Component]\n</code></pre> <p>Search for components that fulfill the condition in the Graph.</p> <p>DFS is used for searching the graph. The graph traversal is stopped once a component fulfills the condition.</p> PARAMETER  DESCRIPTION <code>current_node</code> <p>The current node to search from.</p> <p> TYPE: <code>Component</code> </p> <code>visited</code> <p>The set of visited nodes.</p> <p> TYPE: <code>set[Component]</code> </p> <code>condition</code> <p>The condition function to check for.</p> <p> TYPE: <code>Callable[[Component], bool]</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>A set of component ids where the corresponding components fulfill</p> <code>set[Component]</code> <p>the condition function.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef dfs(\n    self,\n    current_node: Component,\n    visited: set[Component],\n    condition: Callable[[Component], bool],\n) -&gt; set[Component]:\n    \"\"\"\n    Search for components that fulfill the condition in the Graph.\n\n    DFS is used for searching the graph. The graph traversal is stopped\n    once a component fulfills the condition.\n\n    Args:\n        current_node: The current node to search from.\n        visited: The set of visited nodes.\n        condition: The condition function to check for.\n\n    Returns:\n        A set of component ids where the corresponding components fulfill\n        the condition function.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.find_first_descendant_component","title":"find_first_descendant_component  <code>abstractmethod</code>","text":"<pre><code>find_first_descendant_component(\n    *,\n    root_category: ComponentCategory,\n    descendant_categories: Iterable[ComponentCategory]\n) -&gt; Component\n</code></pre> <p>Find the first descendant component given root and descendant categories.</p> <p>This method searches for the root component within the provided root category. If multiple components share the same root category, the first found one is considered as the root component.</p> <p>Subsequently, it looks for the first descendant component from the root component, considering only the immediate descendants.</p> <p>The priority of the component to search for is determined by the order of the descendant categories, with the first category having the highest priority.</p> PARAMETER  DESCRIPTION <code>root_category</code> <p>The category of the root component to search for.</p> <p> TYPE: <code>ComponentCategory</code> </p> <code>descendant_categories</code> <p>The descendant categories to search for the first descendant component in.</p> <p> TYPE: <code>Iterable[ComponentCategory]</code> </p> RETURNS DESCRIPTION <code>Component</code> <p>The first descendant component found in the component graph,</p> <code>Component</code> <p>considering the specified root and descendant categories.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef find_first_descendant_component(\n    self,\n    *,\n    root_category: ComponentCategory,\n    descendant_categories: Iterable[ComponentCategory],\n) -&gt; Component:\n    \"\"\"Find the first descendant component given root and descendant categories.\n\n    This method searches for the root component within the provided root\n    category. If multiple components share the same root category, the\n    first found one is considered as the root component.\n\n    Subsequently, it looks for the first descendant component from the root\n    component, considering only the immediate descendants.\n\n    The priority of the component to search for is determined by the order\n    of the descendant categories, with the first category having the\n    highest priority.\n\n    Args:\n        root_category: The category of the root component to search for.\n        descendant_categories: The descendant categories to search for the\n            first descendant component in.\n\n    Returns:\n        The first descendant component found in the component graph,\n        considering the specified root and descendant categories.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_battery_chain","title":"is_battery_chain  <code>abstractmethod</code>","text":"<pre><code>is_battery_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of a battery chain.</p> <p>A component is part of a battery chain if it is a battery meter or a battery inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a battery chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_chain(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is part of a battery chain.\n\n    A component is part of a battery chain if it is a battery meter or a battery\n    inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of a battery chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_battery_inverter","title":"is_battery_inverter  <code>abstractmethod</code>","text":"<pre><code>is_battery_inverter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a battery inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a battery inverter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_inverter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a battery inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a battery inverter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_battery_meter","title":"is_battery_meter  <code>abstractmethod</code>","text":"<pre><code>is_battery_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a battery meter.</p> <p>This is done by checking if the component has only battery inverters as its predecessors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a battery meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_meter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a battery meter.\n\n    This is done by checking if the component has only battery inverters as its\n    predecessors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a battery meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_chp","title":"is_chp  <code>abstractmethod</code>","text":"<pre><code>is_chp(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a CHP.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a CHP.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_chp(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a CHP.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a CHP.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_chp_chain","title":"is_chp_chain  <code>abstractmethod</code>","text":"<pre><code>is_chp_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of a CHP chain.</p> <p>A component is part of a CHP chain if it is a CHP meter or a CHP.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a CHP chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_chp_chain(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is part of a CHP chain.\n\n    A component is part of a CHP chain if it is a CHP meter or a CHP.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of a CHP chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_chp_meter","title":"is_chp_meter  <code>abstractmethod</code>","text":"<pre><code>is_chp_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a CHP meter.</p> <p>This is done by checking if the component has only CHPs as its successors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a CHP meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_chp_meter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a CHP meter.\n\n    This is done by checking if the component has only CHPs as its successors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a CHP meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_ev_charger","title":"is_ev_charger  <code>abstractmethod</code>","text":"<pre><code>is_ev_charger(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is an EV charger.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is an EV charger.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is an EV charger.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is an EV charger.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_ev_charger_chain","title":"is_ev_charger_chain  <code>abstractmethod</code>","text":"<pre><code>is_ev_charger_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of an EV charger chain.</p> <p>A component is part of an EV charger chain if it is an EV charger meter or an EV charger.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of an EV charger chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger_chain(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is part of an EV charger chain.\n\n    A component is part of an EV charger chain if it is an EV charger meter or an\n    EV charger.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of an EV charger chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_ev_charger_meter","title":"is_ev_charger_meter  <code>abstractmethod</code>","text":"<pre><code>is_ev_charger_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is an EV charger meter.</p> <p>This is done by checking if the component has only EV chargers as its successors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is an EV charger meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger_meter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is an EV charger meter.\n\n    This is done by checking if the component has only EV chargers as its\n    successors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is an EV charger meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_pv_chain","title":"is_pv_chain  <code>abstractmethod</code>","text":"<pre><code>is_pv_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of a PV chain.</p> <p>A component is part of a PV chain if it is a PV meter or a PV inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a PV chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_chain(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is part of a PV chain.\n\n    A component is part of a PV chain if it is a PV meter or a PV inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of a PV chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_pv_inverter","title":"is_pv_inverter  <code>abstractmethod</code>","text":"<pre><code>is_pv_inverter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a PV inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a PV inverter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_inverter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a PV inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a PV inverter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_pv_meter","title":"is_pv_meter  <code>abstractmethod</code>","text":"<pre><code>is_pv_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a PV meter.</p> <p>This is done by checking if the component has only PV inverters as its successors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a PV meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_meter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a PV meter.\n\n    This is done by checking if the component has only PV inverters as its\n    successors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a PV meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.predecessors","title":"predecessors  <code>abstractmethod</code>","text":"<pre><code>predecessors(component_id: int) -&gt; set[Component]\n</code></pre> <p>Fetch the graph predecessors of the specified component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>numerical ID of the component whose predecessors should be fetched</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>Set of IDs of the components that are predecessors of <code>component_id</code>, i.e. for which there is a connection from each of these components to <code>component_id</code>.</p> RAISES DESCRIPTION <code>KeyError</code> <p>if the specified <code>component_id</code> is not in the graph</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef predecessors(self, component_id: int) -&gt; set[Component]:\n    \"\"\"Fetch the graph predecessors of the specified component.\n\n    Args:\n        component_id: numerical ID of the component whose predecessors should be\n            fetched\n\n    Returns:\n        Set of IDs of the components that are predecessors of `component_id`,\n            i.e. for which there is a connection from each of these components to\n            `component_id`.\n\n    Raises:\n        KeyError: if the specified `component_id` is not in the graph\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.successors","title":"successors  <code>abstractmethod</code>","text":"<pre><code>successors(component_id: int) -&gt; set[Component]\n</code></pre> <p>Fetch the graph successors of the specified component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>numerical ID of the component whose successors should be fetched</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>Set of IDs of the components that are successors of <code>component_id</code>, i.e. for which there is a connection from <code>component_id</code> to each of these components.</p> RAISES DESCRIPTION <code>KeyError</code> <p>if the specified <code>component_id</code> is not in the graph</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef successors(self, component_id: int) -&gt; set[Component]:\n    \"\"\"Fetch the graph successors of the specified component.\n\n    Args:\n        component_id: numerical ID of the component whose successors should be\n            fetched\n\n    Returns:\n        Set of IDs of the components that are successors of `component_id`,\n            i.e. for which there is a connection from `component_id` to each of\n            these components.\n\n    Raises:\n        KeyError: if the specified `component_id` is not in the graph\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.InvalidGraphError","title":"frequenz.sdk.microgrid.component_graph.InvalidGraphError","text":"<p>             Bases: <code>Exception</code></p> <p>Exception type that will be thrown if graph data is not valid.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>class InvalidGraphError(Exception):\n    \"\"\"Exception type that will be thrown if graph data is not valid.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/","title":"connection_manager","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager","title":"frequenz.sdk.microgrid.connection_manager","text":"<p>Microgrid Connection Manager singleton abstraction.</p> <p>This module provides a singleton abstraction over the microgrid. The main purpose is to provide the connection the microgrid API client and the microgrid component graph.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager","title":"frequenz.sdk.microgrid.connection_manager.ConnectionManager","text":"<p>             Bases: <code>ABC</code></p> <p>Creates and stores core features.</p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>class ConnectionManager(ABC):\n    \"\"\"Creates and stores core features.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n        \"\"\"Create object instance.\n\n        Args:\n            host: server host\n            port: server port\n        \"\"\"\n        super().__init__()\n        self._host: str = host\n        self._port: int = port\n\n    @property\n    def host(self) -&gt; str:\n        \"\"\"Get host of the currently connected server.\n\n        Returns:\n            host\n        \"\"\"\n        return self._host\n\n    @property\n    def port(self) -&gt; int:\n        \"\"\"Get port of the currently connected server.\n\n        Returns:\n            port\n        \"\"\"\n        return self._port\n\n    @property\n    @abstractmethod\n    def api_client(self) -&gt; MicrogridApiClient:\n        \"\"\"Get MicrogridApiClient.\n\n        Returns:\n            api client\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def component_graph(self) -&gt; ComponentGraph:\n        \"\"\"Get component graph.\n\n        Returns:\n            component graph\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def microgrid_id(self) -&gt; int | None:\n        \"\"\"Get the ID of the microgrid if available.\n\n        Returns:\n            the ID of the microgrid if available, None otherwise.\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def location(self) -&gt; Location | None:\n        \"\"\"Get the location of the microgrid if available.\n\n        Returns:\n            the location of the microgrid if available, None otherwise.\n        \"\"\"\n\n    async def _update_api(self, host: str, port: int) -&gt; None:\n        self._host = host\n        self._port = port\n\n    @abstractmethod\n    async def _initialize(self) -&gt; None:\n        \"\"\"Initialize the object. This function should be called only once.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.api_client","title":"api_client  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>api_client: MicrogridApiClient\n</code></pre> <p>Get MicrogridApiClient.</p> RETURNS DESCRIPTION <code>MicrogridApiClient</code> <p>api client</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.component_graph","title":"component_graph  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>component_graph: ComponentGraph\n</code></pre> <p>Get component graph.</p> RETURNS DESCRIPTION <code>ComponentGraph</code> <p>component graph</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.host","title":"host  <code>property</code>","text":"<pre><code>host: str\n</code></pre> <p>Get host of the currently connected server.</p> RETURNS DESCRIPTION <code>str</code> <p>host</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.location","title":"location  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>location: Location | None\n</code></pre> <p>Get the location of the microgrid if available.</p> RETURNS DESCRIPTION <code>Location | None</code> <p>the location of the microgrid if available, None otherwise.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.microgrid_id","title":"microgrid_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>microgrid_id: int | None\n</code></pre> <p>Get the ID of the microgrid if available.</p> RETURNS DESCRIPTION <code>int | None</code> <p>the ID of the microgrid if available, None otherwise.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.port","title":"port  <code>property</code>","text":"<pre><code>port: int\n</code></pre> <p>Get port of the currently connected server.</p> RETURNS DESCRIPTION <code>int</code> <p>port</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.__init__","title":"__init__","text":"<pre><code>__init__(host: str, port: int) -&gt; None\n</code></pre> <p>Create object instance.</p> PARAMETER  DESCRIPTION <code>host</code> <p>server host</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>server port</p> <p> TYPE: <code>int</code> </p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n    \"\"\"Create object instance.\n\n    Args:\n        host: server host\n        port: server port\n    \"\"\"\n    super().__init__()\n    self._host: str = host\n    self._port: int = port\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.get","title":"frequenz.sdk.microgrid.connection_manager.get","text":"<pre><code>get() -&gt; ConnectionManager\n</code></pre> <p>Get the MicrogridApi instance created by initialize().</p> <p>This function should be only called after initialize().</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Raised when: * If <code>initialize()</code> method was not called before this call. * If <code>initialize()</code> methods was called but was not awaited and instance was     not created yet.</p> RETURNS DESCRIPTION <code>ConnectionManager</code> <p>MicrogridApi instance.</p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>def get() -&gt; ConnectionManager:\n    \"\"\"Get the MicrogridApi instance created by initialize().\n\n    This function should be only called after initialize().\n\n    Raises:\n        RuntimeError: Raised when:\n            * If `initialize()` method was not called before this call.\n            * If `initialize()` methods was called but was not awaited and instance was\n                not created yet.\n\n    Returns:\n        MicrogridApi instance.\n    \"\"\"\n    if _CONNECTION_MANAGER is None:\n        raise RuntimeError(\n            \"ConnectionManager is not initialized. \"\n            \"Call `await microgrid.initialize()` first.\"\n        )\n\n    return _CONNECTION_MANAGER\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.initialize","title":"frequenz.sdk.microgrid.connection_manager.initialize  <code>async</code>","text":"<pre><code>initialize(host: str, port: int) -&gt; None\n</code></pre> <p>Initialize the MicrogridApi. This function should be called only once.</p> PARAMETER  DESCRIPTION <code>host</code> <p>Microgrid host</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Microgrid port</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If method was called more then once.</p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>async def initialize(host: str, port: int) -&gt; None:\n    \"\"\"Initialize the MicrogridApi. This function should be called only once.\n\n    Args:\n        host: Microgrid host\n        port: Microgrid port\n\n    Raises:\n        AssertionError: If method was called more then once.\n    \"\"\"\n    # From Doc: pylint just try to discourage this usage.\n    # That doesn't mean you cannot use it.\n    global _CONNECTION_MANAGER  # pylint: disable=global-statement\n\n    if _CONNECTION_MANAGER is not None:\n        raise AssertionError(\"MicrogridApi was already initialized.\")\n\n    _logger.info(\"Connecting to microgrid at %s:%s\", host, port)\n\n    microgrid_api = _InsecureConnectionManager(host, port)\n    await microgrid_api._initialize()  # pylint: disable=protected-access\n\n    # Check again that _MICROGRID_API is None in case somebody had the great idea of\n    # calling initialize() twice and in parallel.\n    if _CONNECTION_MANAGER is not None:\n        raise AssertionError(\"MicrogridApi was already initialized.\")\n\n    _CONNECTION_MANAGER = microgrid_api\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/metadata/","title":"metadata","text":""},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata","title":"frequenz.sdk.microgrid.metadata","text":"<p>Metadata that describes a microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location","title":"frequenz.sdk.microgrid.metadata.Location  <code>dataclass</code>","text":"<p>Metadata for the location of microgrid.</p> Source code in <code>frequenz/sdk/microgrid/metadata.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Location:\n    \"\"\"Metadata for the location of microgrid.\"\"\"\n\n    latitude: float | None = None\n    \"\"\"The latitude of the microgrid in degree.\"\"\"\n\n    longitude: float | None = None\n    \"\"\"The longitude of the microgrid in degree.\"\"\"\n\n    timezone: ZoneInfo | None = None\n    \"\"\"The timezone of the microgrid.\n\n    The timezone will be set to None if the latitude or longitude points\n    are not set or the timezone cannot be found given the location points.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Initialize the timezone of the microgrid.\"\"\"\n        if self.latitude is None or self.longitude is None or self.timezone is not None:\n            return\n\n        timezone = _timezone_finder.timezone_at(lat=self.latitude, lng=self.longitude)\n        if timezone:\n            # The dataclass is frozen, so it needs to use __setattr__ to set the timezone.\n            object.__setattr__(self, \"timezone\", ZoneInfo(key=timezone))\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float | None = None\n</code></pre> <p>The latitude of the microgrid in degree.</p>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float | None = None\n</code></pre> <p>The longitude of the microgrid in degree.</p>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location.timezone","title":"timezone  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timezone: ZoneInfo | None = None\n</code></pre> <p>The timezone of the microgrid.</p> <p>The timezone will be set to None if the latitude or longitude points are not set or the timezone cannot be found given the location points.</p>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Location.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Initialize the timezone of the microgrid.</p> Source code in <code>frequenz/sdk/microgrid/metadata.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Initialize the timezone of the microgrid.\"\"\"\n    if self.latitude is None or self.longitude is None or self.timezone is not None:\n        return\n\n    timezone = _timezone_finder.timezone_at(lat=self.latitude, lng=self.longitude)\n    if timezone:\n        # The dataclass is frozen, so it needs to use __setattr__ to set the timezone.\n        object.__setattr__(self, \"timezone\", ZoneInfo(key=timezone))\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Metadata","title":"frequenz.sdk.microgrid.metadata.Metadata  <code>dataclass</code>","text":"<p>Metadata for the microgrid.</p> Source code in <code>frequenz/sdk/microgrid/metadata.py</code> <pre><code>@dataclass(frozen=True, kw_only=True)\nclass Metadata:\n    \"\"\"Metadata for the microgrid.\"\"\"\n\n    microgrid_id: int | None = None\n    \"\"\"The ID of the microgrid.\"\"\"\n\n    location: Location | None = None\n    \"\"\"The location of the microgrid.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Metadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Metadata.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: Location | None = None\n</code></pre> <p>The location of the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/metadata/#frequenz.sdk.microgrid.metadata.Metadata.microgrid_id","title":"microgrid_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>microgrid_id: int | None = None\n</code></pre> <p>The ID of the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/","title":"client","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client","title":"frequenz.sdk.microgrid.client","text":"<p>Microgrid API client.</p> <p>This package provides a low-level interface for interacting with the microgrid API.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection","title":"frequenz.sdk.microgrid.client.Connection","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Metadata for a connection between microgrid components.</p> Source code in <code>frequenz/sdk/microgrid/client/_connection.py</code> <pre><code>class Connection(NamedTuple):\n    \"\"\"Metadata for a connection between microgrid components.\"\"\"\n\n    start: int\n    \"\"\"The component ID that represents the start component of the connection.\"\"\"\n\n    end: int\n    \"\"\"The component ID that represents the end component of the connection.\"\"\"\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Check if this instance contains valid data.\n\n        Returns:\n            `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n                otherwise.\n        \"\"\"\n        return self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection.end","title":"end  <code>instance-attribute</code>","text":"<pre><code>end: int\n</code></pre> <p>The component ID that represents the end component of the connection.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: int\n</code></pre> <p>The component ID that represents the start component of the connection.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection.is_valid","title":"is_valid","text":"<pre><code>is_valid() -&gt; bool\n</code></pre> <p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>start &gt;= 0</code>, <code>end &gt; 0</code>, and <code>start != end</code>, <code>False</code> otherwise.</p> Source code in <code>frequenz/sdk/microgrid/client/_connection.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"Check if this instance contains valid data.\n\n    Returns:\n        `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n            otherwise.\n    \"\"\"\n    return self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff","title":"frequenz.sdk.microgrid.client.ExponentialBackoff","text":"<p>             Bases: <code>RetryStrategy</code></p> <p>Provides methods for calculating the exponential interval between retries.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class ExponentialBackoff(RetryStrategy):\n    \"\"\"Provides methods for calculating the exponential interval between retries.\"\"\"\n\n    DEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL\n    \"\"\"Default retry interval, in seconds.\"\"\"\n\n    DEFAULT_MAX_INTERVAL = 60.0\n    \"\"\"Default maximum retry interval, in seconds.\"\"\"\n\n    DEFAULT_MULTIPLIER = 2.0\n    \"\"\"Default multiplier for exponential increment.\"\"\"\n\n    # pylint: disable=too-many-arguments\n    def __init__(\n        self,\n        initial_interval: float = DEFAULT_INTERVAL,\n        max_interval: float = DEFAULT_MAX_INTERVAL,\n        multiplier: float = DEFAULT_MULTIPLIER,\n        jitter: float = DEFAULT_RETRY_JITTER,\n        limit: int | None = None,\n    ) -&gt; None:\n        \"\"\"Create a `ExponentialBackoff` instance.\n\n        Args:\n            initial_interval: time to wait for before the first retry, in\n                seconds.\n            max_interval: maximum interval, in seconds.\n            multiplier: exponential increment for interval.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\n        self._initial = initial_interval\n        self._max = max_interval\n        self._multiplier = multiplier\n        self._jitter = jitter\n        self._limit = limit\n\n        self._count = 0\n\n    def next_interval(self) -&gt; float | None:\n        \"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n        if self._limit is not None and self._count &gt;= self._limit:\n            return None\n        self._count += 1\n        exp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\n        return min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.DEFAULT_INTERVAL","title":"DEFAULT_INTERVAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL\n</code></pre> <p>Default retry interval, in seconds.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.DEFAULT_MAX_INTERVAL","title":"DEFAULT_MAX_INTERVAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_MAX_INTERVAL = 60.0\n</code></pre> <p>Default maximum retry interval, in seconds.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.DEFAULT_MULTIPLIER","title":"DEFAULT_MULTIPLIER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_MULTIPLIER = 2.0\n</code></pre> <p>Default multiplier for exponential increment.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.__init__","title":"__init__","text":"<pre><code>__init__(\n    initial_interval: float = DEFAULT_INTERVAL,\n    max_interval: float = DEFAULT_MAX_INTERVAL,\n    multiplier: float = DEFAULT_MULTIPLIER,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None\n</code></pre> <p>Create a <code>ExponentialBackoff</code> instance.</p> PARAMETER  DESCRIPTION <code>initial_interval</code> <p>time to wait for before the first retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_INTERVAL</code> </p> <code>max_interval</code> <p>maximum interval, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MAX_INTERVAL</code> </p> <code>multiplier</code> <p>exponential increment for interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MULTIPLIER</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __init__(\n    self,\n    initial_interval: float = DEFAULT_INTERVAL,\n    max_interval: float = DEFAULT_MAX_INTERVAL,\n    multiplier: float = DEFAULT_MULTIPLIER,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None:\n    \"\"\"Create a `ExponentialBackoff` instance.\n\n    Args:\n        initial_interval: time to wait for before the first retry, in\n            seconds.\n        max_interval: maximum interval, in seconds.\n        multiplier: exponential increment for interval.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\n    self._initial = initial_interval\n    self._max = max_interval\n    self._multiplier = multiplier\n    self._jitter = jitter\n    self._limit = limit\n\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n    \"\"\"Return an iterator over the retry intervals.\n\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\n    while True:\n        interval = self.next_interval()\n        if interval is None:\n            break\n        yield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.copy","title":"copy","text":"<pre><code>copy() -&gt; RetryStrategy\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>RetryStrategy</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def copy(self) -&gt; RetryStrategy:\n    \"\"\"Create a new instance of `self`.\n\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\n    ret = deepcopy(self)\n    ret.reset()\n    return ret\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n    \"\"\"Return a string denoting the retry progress.\n\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\n    if self._limit is None:\n        return f\"({self._count}/\u221e)\"\n\n    return f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.next_interval","title":"next_interval","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def next_interval(self) -&gt; float | None:\n    \"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n    if self._limit is not None and self._count &gt;= self._limit:\n        return None\n    self._count += 1\n    exp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\n    return min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the retry counter.\n\n    To be called as soon as a connection is successful.\n    \"\"\"\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff","title":"frequenz.sdk.microgrid.client.LinearBackoff","text":"<p>             Bases: <code>RetryStrategy</code></p> <p>Provides methods for calculating the interval between retries.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class LinearBackoff(RetryStrategy):\n    \"\"\"Provides methods for calculating the interval between retries.\"\"\"\n\n    def __init__(\n        self,\n        interval: float = DEFAULT_RETRY_INTERVAL,\n        jitter: float = DEFAULT_RETRY_JITTER,\n        limit: int | None = None,\n    ) -&gt; None:\n        \"\"\"Create a `LinearBackoff` instance.\n\n        Args:\n            interval: time to wait for before the next retry, in seconds.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\n        self._interval = interval\n        self._jitter = jitter\n        self._limit = limit\n\n        self._count = 0\n\n    def next_interval(self) -&gt; float | None:\n        \"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n        if self._limit is not None and self._count &gt;= self._limit:\n            return None\n        self._count += 1\n        return self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.__init__","title":"__init__","text":"<pre><code>__init__(\n    interval: float = DEFAULT_RETRY_INTERVAL,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None\n</code></pre> <p>Create a <code>LinearBackoff</code> instance.</p> PARAMETER  DESCRIPTION <code>interval</code> <p>time to wait for before the next retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_INTERVAL</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __init__(\n    self,\n    interval: float = DEFAULT_RETRY_INTERVAL,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: int | None = None,\n) -&gt; None:\n    \"\"\"Create a `LinearBackoff` instance.\n\n    Args:\n        interval: time to wait for before the next retry, in seconds.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\n    self._interval = interval\n    self._jitter = jitter\n    self._limit = limit\n\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n    \"\"\"Return an iterator over the retry intervals.\n\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\n    while True:\n        interval = self.next_interval()\n        if interval is None:\n            break\n        yield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.copy","title":"copy","text":"<pre><code>copy() -&gt; RetryStrategy\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>RetryStrategy</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def copy(self) -&gt; RetryStrategy:\n    \"\"\"Create a new instance of `self`.\n\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\n    ret = deepcopy(self)\n    ret.reset()\n    return ret\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n    \"\"\"Return a string denoting the retry progress.\n\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\n    if self._limit is None:\n        return f\"({self._count}/\u221e)\"\n\n    return f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.next_interval","title":"next_interval","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def next_interval(self) -&gt; float | None:\n    \"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n    if self._limit is not None and self._count &gt;= self._limit:\n        return None\n    self._count += 1\n    return self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the retry counter.\n\n    To be called as soon as a connection is successful.\n    \"\"\"\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient","title":"frequenz.sdk.microgrid.client.MicrogridApiClient","text":"<p>             Bases: <code>ABC</code></p> <p>Base interface for microgrid API clients to implement.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>class MicrogridApiClient(ABC):\n    \"\"\"Base interface for microgrid API clients to implement.\"\"\"\n\n    @abstractmethod\n    async def components(self) -&gt; Iterable[Component]:\n        \"\"\"Fetch all the components present in the microgrid.\n\n        Returns:\n            Iterator whose elements are all the components in the microgrid.\n        \"\"\"\n\n    @abstractmethod\n    async def metadata(self) -&gt; Metadata:\n        \"\"\"Fetch the microgrid metadata.\n\n        Returns:\n            the microgrid metadata.\n        \"\"\"\n\n    @abstractmethod\n    async def connections(\n        self,\n        starts: set[int] | None = None,\n        ends: set[int] | None = None,\n    ) -&gt; Iterable[Connection]:\n        \"\"\"Fetch the connections between components in the microgrid.\n\n        Args:\n            starts: if set and non-empty, only include connections whose start\n                value matches one of the provided component IDs\n            ends: if set and non-empty, only include connections whose end value\n                matches one of the provided component IDs\n\n        Returns:\n            Microgrid connections matching the provided start and end filters.\n        \"\"\"\n\n    @abstractmethod\n    async def meter_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[MeterData]:\n        \"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n        Args:\n            component_id: id of the meter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime meter data.\n        \"\"\"\n\n    @abstractmethod\n    async def battery_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[BatteryData]:\n        \"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n        Args:\n            component_id: id of the battery to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime battery data.\n        \"\"\"\n\n    @abstractmethod\n    async def inverter_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[InverterData]:\n        \"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n        Args:\n            component_id: id of the inverter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime inverter data.\n        \"\"\"\n\n    @abstractmethod\n    async def ev_charger_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[EVChargerData]:\n        \"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n        Args:\n            component_id: id of the ev charger to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime ev charger data.\n        \"\"\"\n\n    @abstractmethod\n    async def set_power(self, component_id: int, power_w: float) -&gt; None:\n        \"\"\"Send request to the Microgrid to set power for component.\n\n        If power &gt; 0, then component will be charged with this power.\n        If power &lt; 0, then component will be discharged with this power.\n        If power == 0, then stop charging or discharging component.\n\n\n        Args:\n            component_id: id of the component to set power.\n            power_w: power to set for the component.\n        \"\"\"\n\n    @abstractmethod\n    async def set_bounds(self, component_id: int, lower: float, upper: float) -&gt; None:\n        \"\"\"Send `SetBoundsParam`s received from a channel to the Microgrid service.\n\n        Args:\n            component_id: ID of the component to set bounds for.\n            lower: Lower bound to be set for the component.\n            upper: Upper bound to be set for the component.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.battery_data","title":"battery_data  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>battery_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[BatteryData]\n</code></pre> <p>Return a channel receiver that provides a <code>BatteryData</code> stream.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the battery to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[BatteryData]</code> <p>A channel receiver that provides realtime battery data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def battery_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n    \"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n    Args:\n        component_id: id of the battery to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime battery data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.components","title":"components  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>components() -&gt; Iterable[Component]\n</code></pre> <p>Fetch all the components present in the microgrid.</p> RETURNS DESCRIPTION <code>Iterable[Component]</code> <p>Iterator whose elements are all the components in the microgrid.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def components(self) -&gt; Iterable[Component]:\n    \"\"\"Fetch all the components present in the microgrid.\n\n    Returns:\n        Iterator whose elements are all the components in the microgrid.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.connections","title":"connections  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>connections(\n    starts: set[int] | None = None,\n    ends: set[int] | None = None,\n) -&gt; Iterable[Connection]\n</code></pre> <p>Fetch the connections between components in the microgrid.</p> PARAMETER  DESCRIPTION <code>starts</code> <p>if set and non-empty, only include connections whose start value matches one of the provided component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>ends</code> <p>if set and non-empty, only include connections whose end value matches one of the provided component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[Connection]</code> <p>Microgrid connections matching the provided start and end filters.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def connections(\n    self,\n    starts: set[int] | None = None,\n    ends: set[int] | None = None,\n) -&gt; Iterable[Connection]:\n    \"\"\"Fetch the connections between components in the microgrid.\n\n    Args:\n        starts: if set and non-empty, only include connections whose start\n            value matches one of the provided component IDs\n        ends: if set and non-empty, only include connections whose end value\n            matches one of the provided component IDs\n\n    Returns:\n        Microgrid connections matching the provided start and end filters.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.ev_charger_data","title":"ev_charger_data  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>ev_charger_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[EVChargerData]\n</code></pre> <p>Return a channel receiver that provides an <code>EvChargeData</code> stream.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the ev charger to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A channel receiver that provides realtime ev charger data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def ev_charger_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n    \"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n    Args:\n        component_id: id of the ev charger to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime ev charger data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.inverter_data","title":"inverter_data  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>inverter_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[InverterData]\n</code></pre> <p>Return a channel receiver that provides an <code>InverterData</code> stream.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the inverter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[InverterData]</code> <p>A channel receiver that provides realtime inverter data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def inverter_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n    \"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n    Args:\n        component_id: id of the inverter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime inverter data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.metadata","title":"metadata  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>metadata() -&gt; Metadata\n</code></pre> <p>Fetch the microgrid metadata.</p> RETURNS DESCRIPTION <code>Metadata</code> <p>the microgrid metadata.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def metadata(self) -&gt; Metadata:\n    \"\"\"Fetch the microgrid metadata.\n\n    Returns:\n        the microgrid metadata.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.meter_data","title":"meter_data  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>meter_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[MeterData]\n</code></pre> <p>Return a channel receiver that provides a <code>MeterData</code> stream.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the meter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[MeterData]</code> <p>A channel receiver that provides realtime meter data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def meter_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n    \"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n    Args:\n        component_id: id of the meter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime meter data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.set_bounds","title":"set_bounds  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>set_bounds(\n    component_id: int, lower: float, upper: float\n) -&gt; None\n</code></pre> <p>Send <code>SetBoundsParam</code>s received from a channel to the Microgrid service.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>ID of the component to set bounds for.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>Lower bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> <code>upper</code> <p>Upper bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def set_bounds(self, component_id: int, lower: float, upper: float) -&gt; None:\n    \"\"\"Send `SetBoundsParam`s received from a channel to the Microgrid service.\n\n    Args:\n        component_id: ID of the component to set bounds for.\n        lower: Lower bound to be set for the component.\n        upper: Upper bound to be set for the component.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.set_power","title":"set_power  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>set_power(component_id: int, power_w: float) -&gt; None\n</code></pre> <p>Send request to the Microgrid to set power for component.</p> <p>If power &gt; 0, then component will be charged with this power. If power &lt; 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the component to set power.</p> <p> TYPE: <code>int</code> </p> <code>power_w</code> <p>power to set for the component.</p> <p> TYPE: <code>float</code> </p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def set_power(self, component_id: int, power_w: float) -&gt; None:\n    \"\"\"Send request to the Microgrid to set power for component.\n\n    If power &gt; 0, then component will be charged with this power.\n    If power &lt; 0, then component will be discharged with this power.\n    If power == 0, then stop charging or discharging component.\n\n\n    Args:\n        component_id: id of the component to set power.\n        power_w: power to set for the component.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient","title":"frequenz.sdk.microgrid.client.MicrogridGrpcClient","text":"<p>             Bases: <code>MicrogridApiClient</code></p> <p>Microgrid API client implementation using gRPC as the underlying protocol.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>class MicrogridGrpcClient(MicrogridApiClient):\n    \"\"\"Microgrid API client implementation using gRPC as the underlying protocol.\"\"\"\n\n    def __init__(\n        self,\n        grpc_channel: grpc.aio.Channel,\n        target: str,\n        retry_spec: RetryStrategy = LinearBackoff(),\n    ) -&gt; None:\n        \"\"\"Initialize the class instance.\n\n        Args:\n            grpc_channel: asyncio-supporting gRPC channel\n            target: server (host:port) to be used for asyncio-supporting gRPC\n                channel that the client should use to contact the API\n            retry_spec: Specs on how to retry if the connection to a streaming\n                method gets lost.\n        \"\"\"\n        self.target = target\n        \"\"\"The location (as \"host:port\") of the microgrid API gRPC server.\"\"\"\n\n        self.api = MicrogridStub(grpc_channel)\n        \"\"\"The gRPC stub for the microgrid API.\"\"\"\n\n        self._component_streams: dict[int, Broadcast[Any]] = {}\n        self._streaming_tasks: dict[int, asyncio.Task[None]] = {}\n        self._retry_spec = retry_spec\n\n    async def components(self) -&gt; Iterable[Component]:\n        \"\"\"Fetch all the components present in the microgrid.\n\n        Returns:\n            Iterator whose elements are all the components in the microgrid.\n\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\n        try:\n            # grpc.aio is missing types and mypy thinks this is not awaitable,\n            # but it is\n            component_list = await cast(\n                Awaitable[microgrid_pb.ComponentList],\n                self.api.ListComponents(\n                    microgrid_pb.ComponentFilter(),\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            )\n\n        except grpc.aio.AioRpcError as err:\n            msg = f\"Failed to list components. Microgrid API: {self.target}. Err: {err.details()}\"\n            raise grpc.aio.AioRpcError(\n                code=err.code(),\n                initial_metadata=err.initial_metadata(),\n                trailing_metadata=err.trailing_metadata(),\n                details=msg,\n                debug_error_string=err.debug_error_string(),\n            )\n        components_only = filter(\n            lambda c: c.category\n            is not components_pb.ComponentCategory.COMPONENT_CATEGORY_SENSOR,\n            component_list.components,\n        )\n        result: Iterable[Component] = map(\n            lambda c: Component(\n                c.id,\n                _component_category_from_protobuf(c.category),\n                _component_type_from_protobuf(c.category, c.inverter),\n                _component_metadata_from_protobuf(c.category, c.grid),\n            ),\n            components_only,\n        )\n\n        return result\n\n    async def metadata(self) -&gt; Metadata:\n        \"\"\"Fetch the microgrid metadata.\n\n        If there is an error fetching the metadata, the microgrid ID and\n        location will be set to None.\n\n        Returns:\n            the microgrid metadata.\n        \"\"\"\n        microgrid_metadata: microgrid_pb.MicrogridMetadata | None = None\n        try:\n            microgrid_metadata = await cast(\n                Awaitable[microgrid_pb.MicrogridMetadata],\n                self.api.GetMicrogridMetadata(\n                    Empty(),\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            )\n        except grpc.aio.AioRpcError:\n            _logger.exception(\"The microgrid metadata is not available.\")\n\n        if not microgrid_metadata:\n            return Metadata()\n\n        location: Location | None = None\n        if microgrid_metadata.location:\n            location = Location(\n                latitude=microgrid_metadata.location.latitude,\n                longitude=microgrid_metadata.location.longitude,\n            )\n\n        return Metadata(microgrid_id=microgrid_metadata.microgrid_id, location=location)\n\n    async def connections(\n        self,\n        starts: set[int] | None = None,\n        ends: set[int] | None = None,\n    ) -&gt; Iterable[Connection]:\n        \"\"\"Fetch the connections between components in the microgrid.\n\n        Args:\n            starts: if set and non-empty, only include connections whose start\n                value matches one of the provided component IDs\n            ends: if set and non-empty, only include connections whose end value\n                matches one of the provided component IDs\n\n        Returns:\n            Microgrid connections matching the provided start and end filters.\n\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\n        connection_filter = microgrid_pb.ConnectionFilter(starts=starts, ends=ends)\n        try:\n            valid_components, all_connections = await asyncio.gather(\n                self.components(),\n                # grpc.aio is missing types and mypy thinks this is not\n                # awaitable, but it is\n                cast(\n                    Awaitable[microgrid_pb.ConnectionList],\n                    self.api.ListConnections(\n                        connection_filter,\n                        timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                    ),\n                ),\n            )\n        except grpc.aio.AioRpcError as err:\n            msg = f\"Failed to list connections. Microgrid API: {self.target}. Err: {err.details()}\"\n            raise grpc.aio.AioRpcError(\n                code=err.code(),\n                initial_metadata=err.initial_metadata(),\n                trailing_metadata=err.trailing_metadata(),\n                details=msg,\n                debug_error_string=err.debug_error_string(),\n            )\n        # Filter out the components filtered in `components` method.\n        # id=0 is an exception indicating grid component.\n        valid_ids = {c.component_id for c in valid_components}\n        valid_ids.add(0)\n\n        connections = filter(\n            lambda c: (c.start in valid_ids and c.end in valid_ids),\n            all_connections.connections,\n        )\n\n        result: Iterable[Connection] = map(\n            lambda c: Connection(c.start, c.end), connections\n        )\n\n        return result\n\n    async def _component_data_task(\n        self,\n        component_id: int,\n        transform: Callable[[microgrid_pb.ComponentData], _GenericComponentData],\n        sender: Sender[_GenericComponentData],\n    ) -&gt; None:\n        \"\"\"Read data from the microgrid API and send to a channel.\n\n        Args:\n            component_id: id of the component to get data for.\n            transform: A method for transforming raw component data into the\n                desired output type.\n            sender: A channel sender, to send the component data to.\n        \"\"\"\n        retry_spec: RetryStrategy = self._retry_spec.copy()\n        while True:\n            _logger.debug(\n                \"Making call to `GetComponentData`, for component_id=%d\", component_id\n            )\n            try:\n                call = self.api.StreamComponentData(\n                    microgrid_pb.ComponentIdParam(id=component_id),\n                )\n                # grpc.aio is missing types and mypy thinks this is not\n                # async iterable, but it is\n                async for msg in call:  # type: ignore[attr-defined]\n                    await sender.send(transform(msg))\n            except grpc.aio.AioRpcError as err:\n                api_details = f\"Microgrid API: {self.target}.\"\n                _logger.exception(\n                    \"`GetComponentData`, for component_id=%d: exception: %s api: %s\",\n                    component_id,\n                    err,\n                    api_details,\n                )\n\n            if interval := retry_spec.next_interval():\n                _logger.warning(\n                    \"`GetComponentData`, for component_id=%d: connection ended, \"\n                    \"retrying %s in %0.3f seconds.\",\n                    component_id,\n                    retry_spec.get_progress(),\n                    interval,\n                )\n                await asyncio.sleep(interval)\n            else:\n                _logger.warning(\n                    \"`GetComponentData`, for component_id=%d: connection ended, \"\n                    \"retry limit exceeded %s.\",\n                    component_id,\n                    retry_spec.get_progress(),\n                )\n                break\n\n    def _get_component_data_channel(\n        self,\n        component_id: int,\n        transform: Callable[[microgrid_pb.ComponentData], _GenericComponentData],\n    ) -&gt; Broadcast[_GenericComponentData]:\n        \"\"\"Return the broadcast channel for a given component_id.\n\n        If a broadcast channel for the given component_id doesn't exist, create\n        a new channel and a task for reading data from the microgrid api and\n        sending them to the channel.\n\n        Args:\n            component_id: id of the component to get data for.\n            transform: A method for transforming raw component data into the\n                desired output type.\n\n        Returns:\n            The channel for the given component_id.\n        \"\"\"\n        if component_id in self._component_streams:\n            return self._component_streams[component_id]\n        task_name = f\"raw-component-data-{component_id}\"\n        chan = Broadcast[_GenericComponentData](task_name, resend_latest=True)\n        self._component_streams[component_id] = chan\n\n        self._streaming_tasks[component_id] = asyncio.create_task(\n            self._component_data_task(\n                component_id,\n                transform,\n                chan.new_sender(),\n            ),\n            name=task_name,\n        )\n        return chan\n\n    async def _expect_category(\n        self,\n        component_id: int,\n        expected_category: ComponentCategory,\n    ) -&gt; None:\n        \"\"\"Check if the given component_id is of the expected type.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: Component id to check.\n            expected_category: Component category that the given id is expected\n                to have.\n        \"\"\"\n        try:\n            comp = next(\n                comp\n                for comp in await self.components()\n                if comp.component_id == component_id\n            )\n        except StopIteration as exc:\n            raise ValueError(\n                f\"Unable to find component with id {component_id}\"\n            ) from exc\n\n        if comp.category != expected_category:\n            raise ValueError(\n                f\"Component id {component_id} is a {comp.category}\"\n                f\", not a {expected_category}.\"\n            )\n\n    async def meter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[MeterData]:\n        \"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the meter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime meter data.\n        \"\"\"\n        await self._expect_category(\n            component_id,\n            ComponentCategory.METER,\n        )\n        return self._get_component_data_channel(\n            component_id,\n            MeterData.from_proto,\n        ).new_receiver(maxsize=maxsize)\n\n    async def battery_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[BatteryData]:\n        \"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the battery to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime battery data.\n        \"\"\"\n        await self._expect_category(\n            component_id,\n            ComponentCategory.BATTERY,\n        )\n        return self._get_component_data_channel(\n            component_id,\n            BatteryData.from_proto,\n        ).new_receiver(maxsize=maxsize)\n\n    async def inverter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[InverterData]:\n        \"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the inverter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime inverter data.\n        \"\"\"\n        await self._expect_category(\n            component_id,\n            ComponentCategory.INVERTER,\n        )\n        return self._get_component_data_channel(\n            component_id,\n            InverterData.from_proto,\n        ).new_receiver(maxsize=maxsize)\n\n    async def ev_charger_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[EVChargerData]:\n        \"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the ev charger to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime ev charger data.\n        \"\"\"\n        await self._expect_category(\n            component_id,\n            ComponentCategory.EV_CHARGER,\n        )\n        return self._get_component_data_channel(\n            component_id,\n            EVChargerData.from_proto,\n        ).new_receiver(maxsize=maxsize)\n\n    async def set_power(self, component_id: int, power_w: float) -&gt; None:\n        \"\"\"Send request to the Microgrid to set power for component.\n\n        If power &gt; 0, then component will be charged with this power.\n        If power &lt; 0, then component will be discharged with this power.\n        If power == 0, then stop charging or discharging component.\n\n\n        Args:\n            component_id: id of the component to set power.\n            power_w: power to set for the component.\n\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\n        try:\n            await cast(\n                Awaitable[microgrid_pb.SetPowerActiveParam],\n                self.api.SetPowerActive(\n                    microgrid_pb.SetPowerActiveParam(\n                        component_id=component_id, power=power_w\n                    ),\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            )\n        except grpc.aio.AioRpcError as err:\n            msg = f\"Failed to set power. Microgrid API: {self.target}. Err: {err.details()}\"\n            raise grpc.aio.AioRpcError(\n                code=err.code(),\n                initial_metadata=err.initial_metadata(),\n                trailing_metadata=err.trailing_metadata(),\n                details=msg,\n                debug_error_string=err.debug_error_string(),\n            )\n\n    async def set_bounds(\n        self,\n        component_id: int,\n        lower: float,\n        upper: float,\n    ) -&gt; None:\n        \"\"\"Send `SetBoundsParam`s received from a channel to the Microgrid service.\n\n        Args:\n            component_id: ID of the component to set bounds for.\n            lower: Lower bound to be set for the component.\n            upper: Upper bound to be set for the component.\n\n        Raises:\n            ValueError: when upper bound is less than 0, or when lower bound is\n                greater than 0.\n            grpc.aio.AioRpcError: if connection to Microgrid API cannot be established\n                or when the api call exceeded timeout\n        \"\"\"\n        api_details = f\"Microgrid API: {self.target}.\"\n        if upper &lt; 0:\n            raise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\n        if lower &gt; 0:\n            raise ValueError(f\"Lower bound {upper} must be less than or equal to 0.\")\n\n        target_metric = (\n            microgrid_pb.SetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE\n        )\n        try:\n            self.api.AddInclusionBounds(\n                microgrid_pb.SetBoundsParam(\n                    component_id=component_id,\n                    target_metric=target_metric,\n                    bounds=metrics_pb.Bounds(lower=lower, upper=upper),\n                ),\n            )\n        except grpc.aio.AioRpcError as err:\n            _logger.error(\n                \"set_bounds write failed: %s, for message: %s, api: %s. Err: %s\",\n                err,\n                next,\n                api_details,\n                err.details(),\n            )\n            raise\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.api","title":"api  <code>instance-attribute</code>","text":"<pre><code>api = MicrogridStub(grpc_channel)\n</code></pre> <p>The gRPC stub for the microgrid API.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target = target\n</code></pre> <p>The location (as \"host:port\") of the microgrid API gRPC server.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.__init__","title":"__init__","text":"<pre><code>__init__(\n    grpc_channel: Channel,\n    target: str,\n    retry_spec: RetryStrategy = LinearBackoff(),\n) -&gt; None\n</code></pre> <p>Initialize the class instance.</p> PARAMETER  DESCRIPTION <code>grpc_channel</code> <p>asyncio-supporting gRPC channel</p> <p> TYPE: <code>Channel</code> </p> <code>target</code> <p>server (host:port) to be used for asyncio-supporting gRPC channel that the client should use to contact the API</p> <p> TYPE: <code>str</code> </p> <code>retry_spec</code> <p>Specs on how to retry if the connection to a streaming method gets lost.</p> <p> TYPE: <code>RetryStrategy</code> DEFAULT: <code>LinearBackoff()</code> </p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>def __init__(\n    self,\n    grpc_channel: grpc.aio.Channel,\n    target: str,\n    retry_spec: RetryStrategy = LinearBackoff(),\n) -&gt; None:\n    \"\"\"Initialize the class instance.\n\n    Args:\n        grpc_channel: asyncio-supporting gRPC channel\n        target: server (host:port) to be used for asyncio-supporting gRPC\n            channel that the client should use to contact the API\n        retry_spec: Specs on how to retry if the connection to a streaming\n            method gets lost.\n    \"\"\"\n    self.target = target\n    \"\"\"The location (as \"host:port\") of the microgrid API gRPC server.\"\"\"\n\n    self.api = MicrogridStub(grpc_channel)\n    \"\"\"The gRPC stub for the microgrid API.\"\"\"\n\n    self._component_streams: dict[int, Broadcast[Any]] = {}\n    self._streaming_tasks: dict[int, asyncio.Task[None]] = {}\n    self._retry_spec = retry_spec\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.battery_data","title":"battery_data  <code>async</code>","text":"<pre><code>battery_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[BatteryData]\n</code></pre> <p>Return a channel receiver that provides a <code>BatteryData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the battery to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[BatteryData]</code> <p>A channel receiver that provides realtime battery data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def battery_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n    \"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the battery to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime battery data.\n    \"\"\"\n    await self._expect_category(\n        component_id,\n        ComponentCategory.BATTERY,\n    )\n    return self._get_component_data_channel(\n        component_id,\n        BatteryData.from_proto,\n    ).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.components","title":"components  <code>async</code>","text":"<pre><code>components() -&gt; Iterable[Component]\n</code></pre> <p>Fetch all the components present in the microgrid.</p> RETURNS DESCRIPTION <code>Iterable[Component]</code> <p>Iterator whose elements are all the components in the microgrid.</p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def components(self) -&gt; Iterable[Component]:\n    \"\"\"Fetch all the components present in the microgrid.\n\n    Returns:\n        Iterator whose elements are all the components in the microgrid.\n\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\n    try:\n        # grpc.aio is missing types and mypy thinks this is not awaitable,\n        # but it is\n        component_list = await cast(\n            Awaitable[microgrid_pb.ComponentList],\n            self.api.ListComponents(\n                microgrid_pb.ComponentFilter(),\n                timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n            ),\n        )\n\n    except grpc.aio.AioRpcError as err:\n        msg = f\"Failed to list components. Microgrid API: {self.target}. Err: {err.details()}\"\n        raise grpc.aio.AioRpcError(\n            code=err.code(),\n            initial_metadata=err.initial_metadata(),\n            trailing_metadata=err.trailing_metadata(),\n            details=msg,\n            debug_error_string=err.debug_error_string(),\n        )\n    components_only = filter(\n        lambda c: c.category\n        is not components_pb.ComponentCategory.COMPONENT_CATEGORY_SENSOR,\n        component_list.components,\n    )\n    result: Iterable[Component] = map(\n        lambda c: Component(\n            c.id,\n            _component_category_from_protobuf(c.category),\n            _component_type_from_protobuf(c.category, c.inverter),\n            _component_metadata_from_protobuf(c.category, c.grid),\n        ),\n        components_only,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.connections","title":"connections  <code>async</code>","text":"<pre><code>connections(\n    starts: set[int] | None = None,\n    ends: set[int] | None = None,\n) -&gt; Iterable[Connection]\n</code></pre> <p>Fetch the connections between components in the microgrid.</p> PARAMETER  DESCRIPTION <code>starts</code> <p>if set and non-empty, only include connections whose start value matches one of the provided component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>ends</code> <p>if set and non-empty, only include connections whose end value matches one of the provided component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[Connection]</code> <p>Microgrid connections matching the provided start and end filters.</p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def connections(\n    self,\n    starts: set[int] | None = None,\n    ends: set[int] | None = None,\n) -&gt; Iterable[Connection]:\n    \"\"\"Fetch the connections between components in the microgrid.\n\n    Args:\n        starts: if set and non-empty, only include connections whose start\n            value matches one of the provided component IDs\n        ends: if set and non-empty, only include connections whose end value\n            matches one of the provided component IDs\n\n    Returns:\n        Microgrid connections matching the provided start and end filters.\n\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\n    connection_filter = microgrid_pb.ConnectionFilter(starts=starts, ends=ends)\n    try:\n        valid_components, all_connections = await asyncio.gather(\n            self.components(),\n            # grpc.aio is missing types and mypy thinks this is not\n            # awaitable, but it is\n            cast(\n                Awaitable[microgrid_pb.ConnectionList],\n                self.api.ListConnections(\n                    connection_filter,\n                    timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n                ),\n            ),\n        )\n    except grpc.aio.AioRpcError as err:\n        msg = f\"Failed to list connections. Microgrid API: {self.target}. Err: {err.details()}\"\n        raise grpc.aio.AioRpcError(\n            code=err.code(),\n            initial_metadata=err.initial_metadata(),\n            trailing_metadata=err.trailing_metadata(),\n            details=msg,\n            debug_error_string=err.debug_error_string(),\n        )\n    # Filter out the components filtered in `components` method.\n    # id=0 is an exception indicating grid component.\n    valid_ids = {c.component_id for c in valid_components}\n    valid_ids.add(0)\n\n    connections = filter(\n        lambda c: (c.start in valid_ids and c.end in valid_ids),\n        all_connections.connections,\n    )\n\n    result: Iterable[Connection] = map(\n        lambda c: Connection(c.start, c.end), connections\n    )\n\n    return result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.ev_charger_data","title":"ev_charger_data  <code>async</code>","text":"<pre><code>ev_charger_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[EVChargerData]\n</code></pre> <p>Return a channel receiver that provides an <code>EvChargeData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the ev charger to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A channel receiver that provides realtime ev charger data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def ev_charger_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n    \"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the ev charger to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime ev charger data.\n    \"\"\"\n    await self._expect_category(\n        component_id,\n        ComponentCategory.EV_CHARGER,\n    )\n    return self._get_component_data_channel(\n        component_id,\n        EVChargerData.from_proto,\n    ).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.inverter_data","title":"inverter_data  <code>async</code>","text":"<pre><code>inverter_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[InverterData]\n</code></pre> <p>Return a channel receiver that provides an <code>InverterData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the inverter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[InverterData]</code> <p>A channel receiver that provides realtime inverter data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def inverter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n    \"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the inverter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime inverter data.\n    \"\"\"\n    await self._expect_category(\n        component_id,\n        ComponentCategory.INVERTER,\n    )\n    return self._get_component_data_channel(\n        component_id,\n        InverterData.from_proto,\n    ).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.metadata","title":"metadata  <code>async</code>","text":"<pre><code>metadata() -&gt; Metadata\n</code></pre> <p>Fetch the microgrid metadata.</p> <p>If there is an error fetching the metadata, the microgrid ID and location will be set to None.</p> RETURNS DESCRIPTION <code>Metadata</code> <p>the microgrid metadata.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def metadata(self) -&gt; Metadata:\n    \"\"\"Fetch the microgrid metadata.\n\n    If there is an error fetching the metadata, the microgrid ID and\n    location will be set to None.\n\n    Returns:\n        the microgrid metadata.\n    \"\"\"\n    microgrid_metadata: microgrid_pb.MicrogridMetadata | None = None\n    try:\n        microgrid_metadata = await cast(\n            Awaitable[microgrid_pb.MicrogridMetadata],\n            self.api.GetMicrogridMetadata(\n                Empty(),\n                timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n            ),\n        )\n    except grpc.aio.AioRpcError:\n        _logger.exception(\"The microgrid metadata is not available.\")\n\n    if not microgrid_metadata:\n        return Metadata()\n\n    location: Location | None = None\n    if microgrid_metadata.location:\n        location = Location(\n            latitude=microgrid_metadata.location.latitude,\n            longitude=microgrid_metadata.location.longitude,\n        )\n\n    return Metadata(microgrid_id=microgrid_metadata.microgrid_id, location=location)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.meter_data","title":"meter_data  <code>async</code>","text":"<pre><code>meter_data(\n    component_id: int, maxsize: int = RECEIVER_MAX_SIZE\n) -&gt; Receiver[MeterData]\n</code></pre> <p>Return a channel receiver that provides a <code>MeterData</code> stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the meter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[MeterData]</code> <p>A channel receiver that provides realtime meter data.</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def meter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n    \"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the meter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime meter data.\n    \"\"\"\n    await self._expect_category(\n        component_id,\n        ComponentCategory.METER,\n    )\n    return self._get_component_data_channel(\n        component_id,\n        MeterData.from_proto,\n    ).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.set_bounds","title":"set_bounds  <code>async</code>","text":"<pre><code>set_bounds(\n    component_id: int, lower: float, upper: float\n) -&gt; None\n</code></pre> <p>Send <code>SetBoundsParam</code>s received from a channel to the Microgrid service.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>ID of the component to set bounds for.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>Lower bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> <code>upper</code> <p>Upper bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>when upper bound is less than 0, or when lower bound is greater than 0.</p> <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def set_bounds(\n    self,\n    component_id: int,\n    lower: float,\n    upper: float,\n) -&gt; None:\n    \"\"\"Send `SetBoundsParam`s received from a channel to the Microgrid service.\n\n    Args:\n        component_id: ID of the component to set bounds for.\n        lower: Lower bound to be set for the component.\n        upper: Upper bound to be set for the component.\n\n    Raises:\n        ValueError: when upper bound is less than 0, or when lower bound is\n            greater than 0.\n        grpc.aio.AioRpcError: if connection to Microgrid API cannot be established\n            or when the api call exceeded timeout\n    \"\"\"\n    api_details = f\"Microgrid API: {self.target}.\"\n    if upper &lt; 0:\n        raise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\n    if lower &gt; 0:\n        raise ValueError(f\"Lower bound {upper} must be less than or equal to 0.\")\n\n    target_metric = (\n        microgrid_pb.SetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE\n    )\n    try:\n        self.api.AddInclusionBounds(\n            microgrid_pb.SetBoundsParam(\n                component_id=component_id,\n                target_metric=target_metric,\n                bounds=metrics_pb.Bounds(lower=lower, upper=upper),\n            ),\n        )\n    except grpc.aio.AioRpcError as err:\n        _logger.error(\n            \"set_bounds write failed: %s, for message: %s, api: %s. Err: %s\",\n            err,\n            next,\n            api_details,\n            err.details(),\n        )\n        raise\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.set_power","title":"set_power  <code>async</code>","text":"<pre><code>set_power(component_id: int, power_w: float) -&gt; None\n</code></pre> <p>Send request to the Microgrid to set power for component.</p> <p>If power &gt; 0, then component will be charged with this power. If power &lt; 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the component to set power.</p> <p> TYPE: <code>int</code> </p> <code>power_w</code> <p>power to set for the component.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def set_power(self, component_id: int, power_w: float) -&gt; None:\n    \"\"\"Send request to the Microgrid to set power for component.\n\n    If power &gt; 0, then component will be charged with this power.\n    If power &lt; 0, then component will be discharged with this power.\n    If power == 0, then stop charging or discharging component.\n\n\n    Args:\n        component_id: id of the component to set power.\n        power_w: power to set for the component.\n\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\n    try:\n        await cast(\n            Awaitable[microgrid_pb.SetPowerActiveParam],\n            self.api.SetPowerActive(\n                microgrid_pb.SetPowerActiveParam(\n                    component_id=component_id, power=power_w\n                ),\n                timeout=int(DEFAULT_GRPC_CALL_TIMEOUT),\n            ),\n        )\n    except grpc.aio.AioRpcError as err:\n        msg = f\"Failed to set power. Microgrid API: {self.target}. Err: {err.details()}\"\n        raise grpc.aio.AioRpcError(\n            code=err.code(),\n            initial_metadata=err.initial_metadata(),\n            trailing_metadata=err.trailing_metadata(),\n            details=msg,\n            debug_error_string=err.debug_error_string(),\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy","title":"frequenz.sdk.microgrid.client.RetryStrategy","text":"<p>             Bases: <code>ABC</code></p> <p>Interface for implementing retry strategies.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class RetryStrategy(ABC):\n    \"\"\"Interface for implementing retry strategies.\"\"\"\n\n    _limit: int | None\n    _count: int\n\n    @abstractmethod\n    def next_interval(self) -&gt; float | None:\n        \"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n\n    def get_progress(self) -&gt; str:\n        \"\"\"Return a string denoting the retry progress.\n\n        Returns:\n            String denoting retry progress in the form \"(count/limit)\"\n        \"\"\"\n        if self._limit is None:\n            return f\"({self._count}/\u221e)\"\n\n        return f\"({self._count}/{self._limit})\"\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the retry counter.\n\n        To be called as soon as a connection is successful.\n        \"\"\"\n        self._count = 0\n\n    def copy(self) -&gt; RetryStrategy:\n        \"\"\"Create a new instance of `self`.\n\n        Returns:\n            A deepcopy of `self`.\n        \"\"\"\n        ret = deepcopy(self)\n        ret.reset()\n        return ret\n\n    def __iter__(self) -&gt; Iterator[float]:\n        \"\"\"Return an iterator over the retry intervals.\n\n        Yields:\n            Next retry interval in seconds.\n        \"\"\"\n        while True:\n            interval = self.next_interval()\n            if interval is None:\n                break\n            yield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n    \"\"\"Return an iterator over the retry intervals.\n\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\n    while True:\n        interval = self.next_interval()\n        if interval is None:\n            break\n        yield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.copy","title":"copy","text":"<pre><code>copy() -&gt; RetryStrategy\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>RetryStrategy</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def copy(self) -&gt; RetryStrategy:\n    \"\"\"Create a new instance of `self`.\n\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\n    ret = deepcopy(self)\n    ret.reset()\n    return ret\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n    \"\"\"Return a string denoting the retry progress.\n\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\n    if self._limit is None:\n        return f\"({self._count}/\u221e)\"\n\n    return f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.next_interval","title":"next_interval  <code>abstractmethod</code>","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>@abstractmethod\ndef next_interval(self) -&gt; float | None:\n    \"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the retry counter.\n\n    To be called as soon as a connection is successful.\n    \"\"\"\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/","title":"component","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component","title":"frequenz.sdk.microgrid.component","text":"<p>Microgrid component abstractions.</p> <p>This package provides classes to operate con microgrid components.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData","title":"frequenz.sdk.microgrid.component.BatteryData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding battery data.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass BatteryData(ComponentData):\n    \"\"\"A wrapper class for holding battery data.\"\"\"\n\n    soc: float\n    \"\"\"Battery's overall SoC in percent (%).\"\"\"\n\n    soc_lower_bound: float\n    \"\"\"The SoC below which discharge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\n\n    soc_upper_bound: float\n    \"\"\"The SoC above which charge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\n\n    capacity: float\n    \"\"\"The capacity of the battery in Wh (Watt-hour).\"\"\"\n\n    # pylint: disable=line-too-long\n    power_inclusion_lower_bound: float\n    \"\"\"Lower inclusion bound for battery power in watts.\n\n    This is the lower limit of the range within which power requests are allowed for the\n    battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    power_exclusion_lower_bound: float\n    \"\"\"Lower exclusion bound for battery power in watts.\n\n    This is the lower limit of the range within which power requests are not allowed for\n    the battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    power_inclusion_upper_bound: float\n    \"\"\"Upper inclusion bound for battery power in watts.\n\n    This is the upper limit of the range within which power requests are allowed for the\n    battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    power_exclusion_upper_bound: float\n    \"\"\"Upper exclusion bound for battery power in watts.\n\n    This is the upper limit of the range within which power requests are not allowed for\n    the battery.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n    # pylint: enable=line-too-long\n\n    temperature: float\n    \"\"\"The (average) temperature reported by the battery, in Celsius (\u00b0C).\"\"\"\n\n    _relay_state: battery_pb.RelayState.ValueType\n    \"\"\"State of the battery relay.\"\"\"\n\n    _component_state: battery_pb.ComponentState.ValueType\n    \"\"\"State of the battery.\"\"\"\n\n    _errors: list[battery_pb.Error]\n    \"\"\"List of errors in protobuf struct.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; BatteryData:\n        \"\"\"Create BatteryData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of BatteryData created from the protobuf message.\n        \"\"\"\n        raw_power = raw.battery.data.dc.power\n        battery_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            soc=raw.battery.data.soc.avg,\n            soc_lower_bound=raw.battery.data.soc.system_inclusion_bounds.lower,\n            soc_upper_bound=raw.battery.data.soc.system_inclusion_bounds.upper,\n            capacity=raw.battery.properties.capacity,\n            power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n            power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n            power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n            power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n            temperature=raw.battery.data.temperature.avg,\n            _relay_state=raw.battery.state.relay_state,\n            _component_state=raw.battery.state.component_state,\n            _errors=list(raw.battery.errors),\n        )\n        battery_data._set_raw(raw=raw)\n        return battery_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.capacity","title":"capacity  <code>instance-attribute</code>","text":"<pre><code>capacity: float\n</code></pre> <p>The capacity of the battery in Wh (Watt-hour).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_exclusion_lower_bound","title":"power_exclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>power_exclusion_lower_bound: float\n</code></pre> <p>Lower exclusion bound for battery power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_exclusion_upper_bound","title":"power_exclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>power_exclusion_upper_bound: float\n</code></pre> <p>Upper exclusion bound for battery power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_inclusion_lower_bound","title":"power_inclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>power_inclusion_lower_bound: float\n</code></pre> <p>Lower inclusion bound for battery power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_inclusion_upper_bound","title":"power_inclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>power_inclusion_upper_bound: float\n</code></pre> <p>Upper inclusion bound for battery power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.soc","title":"soc  <code>instance-attribute</code>","text":"<pre><code>soc: float\n</code></pre> <p>Battery's overall SoC in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.soc_lower_bound","title":"soc_lower_bound  <code>instance-attribute</code>","text":"<pre><code>soc_lower_bound: float\n</code></pre> <p>The SoC below which discharge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.soc_upper_bound","title":"soc_upper_bound  <code>instance-attribute</code>","text":"<pre><code>soc_upper_bound: float\n</code></pre> <p>The SoC above which charge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature: float\n</code></pre> <p>The (average) temperature reported by the battery, in Celsius (\u00b0C).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; BatteryData\n</code></pre> <p>Create BatteryData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>BatteryData</code> <p>Instance of BatteryData created from the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; BatteryData:\n    \"\"\"Create BatteryData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of BatteryData created from the protobuf message.\n    \"\"\"\n    raw_power = raw.battery.data.dc.power\n    battery_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        soc=raw.battery.data.soc.avg,\n        soc_lower_bound=raw.battery.data.soc.system_inclusion_bounds.lower,\n        soc_upper_bound=raw.battery.data.soc.system_inclusion_bounds.upper,\n        capacity=raw.battery.properties.capacity,\n        power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n        power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n        power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n        power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n        temperature=raw.battery.data.temperature.avg,\n        _relay_state=raw.battery.state.relay_state,\n        _component_state=raw.battery.state.component_state,\n        _errors=list(raw.battery.errors),\n    )\n    battery_data._set_raw(raw=raw)\n    return battery_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component","title":"frequenz.sdk.microgrid.component.Component  <code>dataclass</code>","text":"<p>Metadata for a single microgrid component.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass Component:\n    \"\"\"Metadata for a single microgrid component.\"\"\"\n\n    component_id: int\n    \"\"\"The ID of this component.\"\"\"\n\n    category: ComponentCategory\n    \"\"\"The category of this component.\"\"\"\n\n    type: ComponentType | None = None\n    \"\"\"The type of this component.\"\"\"\n\n    metadata: ComponentMetadata | None = None\n    \"\"\"The metadata of this component.\"\"\"\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Check if this instance contains valid data.\n\n        Returns:\n            `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n                == 0` and `type` is `GRID`, `False` otherwise\n        \"\"\"\n        return (\n            self.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n        ) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Compute a hash of this instance, obtained by hashing the `component_id` field.\n\n        Returns:\n            Hash of this instance.\n        \"\"\"\n        return hash(self.component_id)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: ComponentCategory\n</code></pre> <p>The category of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: ComponentMetadata | None = None\n</code></pre> <p>The metadata of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: ComponentType | None = None\n</code></pre> <p>The type of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Compute a hash of this instance, obtained by hashing the <code>component_id</code> field.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of this instance.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Compute a hash of this instance, obtained by hashing the `component_id` field.\n\n    Returns:\n        Hash of this instance.\n    \"\"\"\n    return hash(self.component_id)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.is_valid","title":"is_valid","text":"<pre><code>is_valid() -&gt; bool\n</code></pre> <p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>id &gt; 0</code> and <code>type</code> is a valid <code>ComponentCategory</code>, or if <code>id == 0</code> and <code>type</code> is <code>GRID</code>, <code>False</code> otherwise</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"Check if this instance contains valid data.\n\n    Returns:\n        `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n            == 0` and `type` is `GRID`, `False` otherwise\n    \"\"\"\n    return (\n        self.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n    ) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory","title":"frequenz.sdk.microgrid.component.ComponentCategory","text":"<p>             Bases: <code>Enum</code></p> <p>Possible types of microgrid component.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class ComponentCategory(Enum):\n    \"\"\"Possible types of microgrid component.\"\"\"\n\n    NONE = components_pb.ComponentCategory.COMPONENT_CATEGORY_UNSPECIFIED\n    \"\"\"Unspecified component category.\"\"\"\n\n    GRID = components_pb.ComponentCategory.COMPONENT_CATEGORY_GRID\n    \"\"\"Grid component.\"\"\"\n\n    METER = components_pb.ComponentCategory.COMPONENT_CATEGORY_METER\n    \"\"\"Meter component.\"\"\"\n\n    INVERTER = components_pb.ComponentCategory.COMPONENT_CATEGORY_INVERTER\n    \"\"\"Inverter component.\"\"\"\n\n    BATTERY = components_pb.ComponentCategory.COMPONENT_CATEGORY_BATTERY\n    \"\"\"Battery component.\"\"\"\n\n    EV_CHARGER = components_pb.ComponentCategory.COMPONENT_CATEGORY_EV_CHARGER\n    \"\"\"EV charger component.\"\"\"\n\n    CHP = components_pb.ComponentCategory.COMPONENT_CATEGORY_CHP\n    \"\"\"CHP component.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.BATTERY","title":"BATTERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY = COMPONENT_CATEGORY_BATTERY\n</code></pre> <p>Battery component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.CHP","title":"CHP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHP = COMPONENT_CATEGORY_CHP\n</code></pre> <p>CHP component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.EV_CHARGER","title":"EV_CHARGER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_CHARGER = COMPONENT_CATEGORY_EV_CHARGER\n</code></pre> <p>EV charger component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.GRID","title":"GRID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GRID = COMPONENT_CATEGORY_GRID\n</code></pre> <p>Grid component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.INVERTER","title":"INVERTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INVERTER = COMPONENT_CATEGORY_INVERTER\n</code></pre> <p>Inverter component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.METER","title":"METER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METER = COMPONENT_CATEGORY_METER\n</code></pre> <p>Meter component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = COMPONENT_CATEGORY_UNSPECIFIED\n</code></pre> <p>Unspecified component category.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData","title":"frequenz.sdk.microgrid.component.ComponentData  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A private base class for strongly typed component data classes.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentData(ABC):\n    \"\"\"A private base class for strongly typed component data classes.\"\"\"\n\n    component_id: int\n    \"\"\"The ID identifying this component in the microgrid.\"\"\"\n\n    timestamp: datetime\n    \"\"\"The timestamp of when the data was measured.\"\"\"\n\n    # The `raw` attribute is excluded from the constructor as it can only be provided\n    # when instantiating `ComponentData` using the `from_proto` method, which reads\n    # data from a protobuf message. The whole protobuf message is stored as the `raw`\n    # attribute. When `ComponentData` is not instantiated from a protobuf message,\n    # i.e. using the constructor, `raw` will be set to `None`.\n    raw: microgrid_pb.ComponentData | None = field(default=None, init=False)\n    \"\"\"Raw component data as decoded from the wire.\"\"\"\n\n    def _set_raw(self, raw: microgrid_pb.ComponentData) -&gt; None:\n        \"\"\"Store raw protobuf message.\n\n        It is preferred to keep the dataclasses immutable (frozen) and make the `raw`\n            attribute read-only, which is why the approach of writing to `__dict__`\n            was used, instead of mutating the `self.raw = raw` attribute directly.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n        \"\"\"\n        self.__dict__[\"raw\"] = raw\n\n    @classmethod\n    @abstractmethod\n    def from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; ComponentData:\n        \"\"\"Create ComponentData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            The instance created from the protobuf message.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.from_proto","title":"from_proto  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; ComponentData\n</code></pre> <p>Create ComponentData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>ComponentData</code> <p>The instance created from the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; ComponentData:\n    \"\"\"Create ComponentData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        The instance created from the protobuf message.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetadata","title":"frequenz.sdk.microgrid.component.ComponentMetadata  <code>dataclass</code>","text":"<p>Base class for component metadata classes.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentMetadata:\n    \"\"\"Base class for component metadata classes.\"\"\"\n\n    fuse: Fuse | None = None\n    \"\"\"The fuse at the grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetadata.fuse","title":"fuse  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuse: Fuse | None = None\n</code></pre> <p>The fuse at the grid connection point.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId","title":"frequenz.sdk.microgrid.component.ComponentMetricId","text":"<p>             Bases: <code>Enum</code></p> <p>An enum representing the various metrics available in the microgrid.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class ComponentMetricId(Enum):\n    \"\"\"An enum representing the various metrics available in the microgrid.\"\"\"\n\n    ACTIVE_POWER = \"active_power\"\n    \"\"\"Active power.\"\"\"\n\n    CURRENT_PHASE_1 = \"current_phase_1\"\n    \"\"\"Current in phase 1.\"\"\"\n    CURRENT_PHASE_2 = \"current_phase_2\"\n    \"\"\"Current in phase 2.\"\"\"\n    CURRENT_PHASE_3 = \"current_phase_3\"\n    \"\"\"Current in phase 3.\"\"\"\n\n    VOLTAGE_PHASE_1 = \"voltage_phase_1\"\n    \"\"\"Voltage in phase 1.\"\"\"\n    VOLTAGE_PHASE_2 = \"voltage_phase_2\"\n    \"\"\"Voltage in phase 2.\"\"\"\n    VOLTAGE_PHASE_3 = \"voltage_phase_3\"\n    \"\"\"Voltage in phase 3.\"\"\"\n\n    FREQUENCY = \"frequency\"\n\n    SOC = \"soc\"\n    \"\"\"State of charge.\"\"\"\n    SOC_LOWER_BOUND = \"soc_lower_bound\"\n    \"\"\"Lower bound of state of charge.\"\"\"\n    SOC_UPPER_BOUND = \"soc_upper_bound\"\n    \"\"\"Upper bound of state of charge.\"\"\"\n    CAPACITY = \"capacity\"\n    \"\"\"Capacity.\"\"\"\n\n    POWER_INCLUSION_LOWER_BOUND = \"power_inclusion_lower_bound\"\n    \"\"\"Power inclusion lower bound.\"\"\"\n    POWER_EXCLUSION_LOWER_BOUND = \"power_exclusion_lower_bound\"\n    \"\"\"Power exclusion lower bound.\"\"\"\n    POWER_EXCLUSION_UPPER_BOUND = \"power_exclusion_upper_bound\"\n    \"\"\"Power exclusion upper bound.\"\"\"\n    POWER_INCLUSION_UPPER_BOUND = \"power_inclusion_upper_bound\"\n    \"\"\"Power inclusion upper bound.\"\"\"\n\n    ACTIVE_POWER_INCLUSION_LOWER_BOUND = \"active_power_inclusion_lower_bound\"\n    \"\"\"Active power inclusion lower bound.\"\"\"\n    ACTIVE_POWER_EXCLUSION_LOWER_BOUND = \"active_power_exclusion_lower_bound\"\n    \"\"\"Active power exclusion lower bound.\"\"\"\n    ACTIVE_POWER_EXCLUSION_UPPER_BOUND = \"active_power_exclusion_upper_bound\"\n    \"\"\"Active power exclusion upper bound.\"\"\"\n    ACTIVE_POWER_INCLUSION_UPPER_BOUND = \"active_power_inclusion_upper_bound\"\n    \"\"\"Active power inclusion upper bound.\"\"\"\n\n    TEMPERATURE = \"temperature\"\n    \"\"\"Temperature.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER","title":"ACTIVE_POWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER = 'active_power'\n</code></pre> <p>Active power.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_EXCLUSION_LOWER_BOUND","title":"ACTIVE_POWER_EXCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_EXCLUSION_LOWER_BOUND = (\n    \"active_power_exclusion_lower_bound\"\n)\n</code></pre> <p>Active power exclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_EXCLUSION_UPPER_BOUND","title":"ACTIVE_POWER_EXCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_EXCLUSION_UPPER_BOUND = (\n    \"active_power_exclusion_upper_bound\"\n)\n</code></pre> <p>Active power exclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_INCLUSION_LOWER_BOUND","title":"ACTIVE_POWER_INCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_INCLUSION_LOWER_BOUND = (\n    \"active_power_inclusion_lower_bound\"\n)\n</code></pre> <p>Active power inclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_INCLUSION_UPPER_BOUND","title":"ACTIVE_POWER_INCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE_POWER_INCLUSION_UPPER_BOUND = (\n    \"active_power_inclusion_upper_bound\"\n)\n</code></pre> <p>Active power inclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CAPACITY","title":"CAPACITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CAPACITY = 'capacity'\n</code></pre> <p>Capacity.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CURRENT_PHASE_1","title":"CURRENT_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_1 = 'current_phase_1'\n</code></pre> <p>Current in phase 1.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CURRENT_PHASE_2","title":"CURRENT_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_2 = 'current_phase_2'\n</code></pre> <p>Current in phase 2.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CURRENT_PHASE_3","title":"CURRENT_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT_PHASE_3 = 'current_phase_3'\n</code></pre> <p>Current in phase 3.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_EXCLUSION_LOWER_BOUND","title":"POWER_EXCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_EXCLUSION_LOWER_BOUND = 'power_exclusion_lower_bound'\n</code></pre> <p>Power exclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_EXCLUSION_UPPER_BOUND","title":"POWER_EXCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_EXCLUSION_UPPER_BOUND = 'power_exclusion_upper_bound'\n</code></pre> <p>Power exclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_INCLUSION_LOWER_BOUND","title":"POWER_INCLUSION_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_INCLUSION_LOWER_BOUND = 'power_inclusion_lower_bound'\n</code></pre> <p>Power inclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_INCLUSION_UPPER_BOUND","title":"POWER_INCLUSION_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER_INCLUSION_UPPER_BOUND = 'power_inclusion_upper_bound'\n</code></pre> <p>Power inclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.SOC","title":"SOC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC = 'soc'\n</code></pre> <p>State of charge.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.SOC_LOWER_BOUND","title":"SOC_LOWER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC_LOWER_BOUND = 'soc_lower_bound'\n</code></pre> <p>Lower bound of state of charge.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.SOC_UPPER_BOUND","title":"SOC_UPPER_BOUND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOC_UPPER_BOUND = 'soc_upper_bound'\n</code></pre> <p>Upper bound of state of charge.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.TEMPERATURE","title":"TEMPERATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEMPERATURE = 'temperature'\n</code></pre> <p>Temperature.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.VOLTAGE_PHASE_1","title":"VOLTAGE_PHASE_1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_1 = 'voltage_phase_1'\n</code></pre> <p>Voltage in phase 1.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.VOLTAGE_PHASE_2","title":"VOLTAGE_PHASE_2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_2 = 'voltage_phase_2'\n</code></pre> <p>Voltage in phase 2.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.VOLTAGE_PHASE_3","title":"VOLTAGE_PHASE_3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLTAGE_PHASE_3 = 'voltage_phase_3'\n</code></pre> <p>Voltage in phase 3.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState","title":"frequenz.sdk.microgrid.component.EVChargerCableState","text":"<p>             Bases: <code>Enum</code></p> <p>Cable states of an EV Charger.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>class EVChargerCableState(Enum):\n    \"\"\"Cable states of an EV Charger.\"\"\"\n\n    UNSPECIFIED = ev_charger_pb.CableState.CABLE_STATE_UNSPECIFIED\n    \"\"\"Unspecified cable state.\"\"\"\n\n    UNPLUGGED = ev_charger_pb.CableState.CABLE_STATE_UNPLUGGED\n    \"\"\"The cable is unplugged.\"\"\"\n\n    CHARGING_STATION_PLUGGED = (\n        ev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_PLUGGED\n    )\n    \"\"\"The cable is plugged into the charging station.\"\"\"\n\n    CHARGING_STATION_LOCKED = (\n        ev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_LOCKED\n    )\n    \"\"\"The cable is plugged into the charging station and locked.\"\"\"\n\n    EV_PLUGGED = ev_charger_pb.CableState.CABLE_STATE_EV_PLUGGED\n    \"\"\"The cable is plugged into the EV.\"\"\"\n\n    EV_LOCKED = ev_charger_pb.CableState.CABLE_STATE_EV_LOCKED\n    \"\"\"The cable is plugged into the EV and locked.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, evc_state: ev_charger_pb.CableState.ValueType\n    ) -&gt; EVChargerCableState:\n        \"\"\"Convert a protobuf CableState value to EVChargerCableState enum.\n\n        Args:\n            evc_state: protobuf cable state to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(t.value == evc_state for t in EVChargerCableState):\n            return cls.UNSPECIFIED\n\n        return EVChargerCableState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.CHARGING_STATION_LOCKED","title":"CHARGING_STATION_LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING_STATION_LOCKED = (\n    CABLE_STATE_CHARGING_STATION_LOCKED\n)\n</code></pre> <p>The cable is plugged into the charging station and locked.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.CHARGING_STATION_PLUGGED","title":"CHARGING_STATION_PLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING_STATION_PLUGGED = (\n    CABLE_STATE_CHARGING_STATION_PLUGGED\n)\n</code></pre> <p>The cable is plugged into the charging station.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.EV_LOCKED","title":"EV_LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_LOCKED = CABLE_STATE_EV_LOCKED\n</code></pre> <p>The cable is plugged into the EV and locked.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.EV_PLUGGED","title":"EV_PLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_PLUGGED = CABLE_STATE_EV_PLUGGED\n</code></pre> <p>The cable is plugged into the EV.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.UNPLUGGED","title":"UNPLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNPLUGGED = CABLE_STATE_UNPLUGGED\n</code></pre> <p>The cable is unplugged.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = CABLE_STATE_UNSPECIFIED\n</code></pre> <p>Unspecified cable state.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(evc_state: ValueType) -&gt; EVChargerCableState\n</code></pre> <p>Convert a protobuf CableState value to EVChargerCableState enum.</p> PARAMETER  DESCRIPTION <code>evc_state</code> <p>protobuf cable state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>EVChargerCableState</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, evc_state: ev_charger_pb.CableState.ValueType\n) -&gt; EVChargerCableState:\n    \"\"\"Convert a protobuf CableState value to EVChargerCableState enum.\n\n    Args:\n        evc_state: protobuf cable state to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(t.value == evc_state for t in EVChargerCableState):\n        return cls.UNSPECIFIED\n\n    return EVChargerCableState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState","title":"frequenz.sdk.microgrid.component.EVChargerComponentState","text":"<p>             Bases: <code>Enum</code></p> <p>Component State of an EV Charger.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>class EVChargerComponentState(Enum):\n    \"\"\"Component State of an EV Charger.\"\"\"\n\n    UNSPECIFIED = ev_charger_pb.ComponentState.COMPONENT_STATE_UNSPECIFIED\n    \"\"\"Unspecified component state.\"\"\"\n\n    STARTING = ev_charger_pb.ComponentState.COMPONENT_STATE_STARTING\n    \"\"\"The component is starting.\"\"\"\n\n    NOT_READY = ev_charger_pb.ComponentState.COMPONENT_STATE_NOT_READY\n    \"\"\"The component is not ready.\"\"\"\n\n    READY = ev_charger_pb.ComponentState.COMPONENT_STATE_READY\n    \"\"\"The component is ready.\"\"\"\n\n    CHARGING = ev_charger_pb.ComponentState.COMPONENT_STATE_CHARGING\n    \"\"\"The component is charging.\"\"\"\n\n    DISCHARGING = ev_charger_pb.ComponentState.COMPONENT_STATE_DISCHARGING\n    \"\"\"The component is discharging.\"\"\"\n\n    ERROR = ev_charger_pb.ComponentState.COMPONENT_STATE_ERROR\n    \"\"\"The component is in error state.\"\"\"\n\n    AUTHORIZATION_REJECTED = (\n        ev_charger_pb.ComponentState.COMPONENT_STATE_AUTHORIZATION_REJECTED\n    )\n    \"\"\"The component rejected authorization.\"\"\"\n\n    INTERRUPTED = ev_charger_pb.ComponentState.COMPONENT_STATE_INTERRUPTED\n    \"\"\"The component is interrupted.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, evc_state: ev_charger_pb.ComponentState.ValueType\n    ) -&gt; EVChargerComponentState:\n        \"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum.\n\n        Args:\n            evc_state: protobuf component state to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(t.value == evc_state for t in EVChargerComponentState):\n            return cls.UNSPECIFIED\n\n        return EVChargerComponentState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.AUTHORIZATION_REJECTED","title":"AUTHORIZATION_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AUTHORIZATION_REJECTED = (\n    COMPONENT_STATE_AUTHORIZATION_REJECTED\n)\n</code></pre> <p>The component rejected authorization.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.CHARGING","title":"CHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHARGING = COMPONENT_STATE_CHARGING\n</code></pre> <p>The component is charging.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.DISCHARGING","title":"DISCHARGING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISCHARGING = COMPONENT_STATE_DISCHARGING\n</code></pre> <p>The component is discharging.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = COMPONENT_STATE_ERROR\n</code></pre> <p>The component is in error state.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.INTERRUPTED","title":"INTERRUPTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERRUPTED = COMPONENT_STATE_INTERRUPTED\n</code></pre> <p>The component is interrupted.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.NOT_READY","title":"NOT_READY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT_READY = COMPONENT_STATE_NOT_READY\n</code></pre> <p>The component is not ready.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.READY","title":"READY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>READY = COMPONENT_STATE_READY\n</code></pre> <p>The component is ready.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.STARTING","title":"STARTING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STARTING = COMPONENT_STATE_STARTING\n</code></pre> <p>The component is starting.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = COMPONENT_STATE_UNSPECIFIED\n</code></pre> <p>Unspecified component state.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(evc_state: ValueType) -&gt; EVChargerComponentState\n</code></pre> <p>Convert a protobuf ComponentState value to EVChargerComponentState enum.</p> PARAMETER  DESCRIPTION <code>evc_state</code> <p>protobuf component state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>EVChargerComponentState</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, evc_state: ev_charger_pb.ComponentState.ValueType\n) -&gt; EVChargerComponentState:\n    \"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum.\n\n    Args:\n        evc_state: protobuf component state to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(t.value == evc_state for t in EVChargerComponentState):\n        return cls.UNSPECIFIED\n\n    return EVChargerComponentState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData","title":"frequenz.sdk.microgrid.component.EVChargerData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding ev_charger data.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass EVChargerData(ComponentData):\n    \"\"\"A wrapper class for holding ev_charger data.\"\"\"\n\n    active_power: float\n    \"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n        +ve current means consumption, away from the grid.\n        -ve current means supply into the grid.\n    \"\"\"\n\n    current_per_phase: tuple[float, float, float]\n    \"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n        +ve current means consumption, away from the grid.\n        -ve current means supply into the grid.\n    \"\"\"\n\n    voltage_per_phase: tuple[float, float, float]\n    \"\"\"The AC voltage in Volts (V) between the line and the neutral\n        wire for phase/line 1,2 and 3 respectively.\n    \"\"\"\n\n    active_power_inclusion_lower_bound: float\n    \"\"\"Lower inclusion bound for EV charger power in watts.\n\n    This is the lower limit of the range within which power requests are allowed for the\n    EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_lower_bound: float\n    \"\"\"Lower exclusion bound for EV charger power in watts.\n\n    This is the lower limit of the range within which power requests are not allowed for\n    the EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_inclusion_upper_bound: float\n    \"\"\"Upper inclusion bound for EV charger power in watts.\n\n    This is the upper limit of the range within which power requests are allowed for the\n    EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_upper_bound: float\n    \"\"\"Upper exclusion bound for EV charger power in watts.\n\n    This is the upper limit of the range within which power requests are not allowed for\n    the EV charger.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    frequency: float\n    \"\"\"AC frequency, in Hertz (Hz).\"\"\"\n\n    cable_state: EVChargerCableState\n    \"\"\"The state of the ev charger's cable.\"\"\"\n\n    component_state: EVChargerComponentState\n    \"\"\"The state of the ev charger.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; EVChargerData:\n        \"\"\"Create EVChargerData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of EVChargerData created from the protobuf message.\n        \"\"\"\n        raw_power = raw.ev_charger.data.ac.power_active\n        ev_charger_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw_power.value,\n            current_per_phase=(\n                raw.ev_charger.data.ac.phase_1.current.value,\n                raw.ev_charger.data.ac.phase_2.current.value,\n                raw.ev_charger.data.ac.phase_3.current.value,\n            ),\n            voltage_per_phase=(\n                raw.ev_charger.data.ac.phase_1.voltage.value,\n                raw.ev_charger.data.ac.phase_2.voltage.value,\n                raw.ev_charger.data.ac.phase_3.voltage.value,\n            ),\n            active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n            active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n            active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n            active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n            cable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\n            component_state=EVChargerComponentState.from_pb(\n                raw.ev_charger.state.component_state\n            ),\n            frequency=raw.ev_charger.data.ac.frequency.value,\n        )\n        ev_charger_data._set_raw(raw=raw)\n        return ev_charger_data\n\n    def is_ev_connected(self) -&gt; bool:\n        \"\"\"Check whether an EV is connected to the charger.\n\n        Returns:\n            When the charger is not in an error state, whether an EV is connected to\n                the charger.\n        \"\"\"\n        return self.component_state not in (\n            EVChargerComponentState.AUTHORIZATION_REJECTED,\n            EVChargerComponentState.ERROR,\n        ) and self.cable_state in (\n            EVChargerCableState.EV_LOCKED,\n            EVChargerCableState.EV_PLUGGED,\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.active_power_exclusion_lower_bound","title":"active_power_exclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_lower_bound: float\n</code></pre> <p>Lower exclusion bound for EV charger power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.active_power_exclusion_upper_bound","title":"active_power_exclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_upper_bound: float\n</code></pre> <p>Upper exclusion bound for EV charger power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.active_power_inclusion_lower_bound","title":"active_power_inclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_lower_bound: float\n</code></pre> <p>Lower inclusion bound for EV charger power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.active_power_inclusion_upper_bound","title":"active_power_inclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_upper_bound: float\n</code></pre> <p>Upper inclusion bound for EV charger power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the EV charger.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.cable_state","title":"cable_state  <code>instance-attribute</code>","text":"<pre><code>cable_state: EVChargerCableState\n</code></pre> <p>The state of the ev charger's cable.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.component_state","title":"component_state  <code>instance-attribute</code>","text":"<pre><code>component_state: EVChargerComponentState\n</code></pre> <p>The state of the ev charger.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>AC frequency, in Hertz (Hz).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.voltage_per_phase","title":"voltage_per_phase  <code>instance-attribute</code>","text":"<pre><code>voltage_per_phase: tuple[float, float, float]\n</code></pre> <p>The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; EVChargerData\n</code></pre> <p>Create EVChargerData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>EVChargerData</code> <p>Instance of EVChargerData created from the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; EVChargerData:\n    \"\"\"Create EVChargerData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of EVChargerData created from the protobuf message.\n    \"\"\"\n    raw_power = raw.ev_charger.data.ac.power_active\n    ev_charger_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw_power.value,\n        current_per_phase=(\n            raw.ev_charger.data.ac.phase_1.current.value,\n            raw.ev_charger.data.ac.phase_2.current.value,\n            raw.ev_charger.data.ac.phase_3.current.value,\n        ),\n        voltage_per_phase=(\n            raw.ev_charger.data.ac.phase_1.voltage.value,\n            raw.ev_charger.data.ac.phase_2.voltage.value,\n            raw.ev_charger.data.ac.phase_3.voltage.value,\n        ),\n        active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n        active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n        active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n        active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n        cable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\n        component_state=EVChargerComponentState.from_pb(\n            raw.ev_charger.state.component_state\n        ),\n        frequency=raw.ev_charger.data.ac.frequency.value,\n    )\n    ev_charger_data._set_raw(raw=raw)\n    return ev_charger_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.is_ev_connected","title":"is_ev_connected","text":"<pre><code>is_ev_connected() -&gt; bool\n</code></pre> <p>Check whether an EV is connected to the charger.</p> RETURNS DESCRIPTION <code>bool</code> <p>When the charger is not in an error state, whether an EV is connected to the charger.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>def is_ev_connected(self) -&gt; bool:\n    \"\"\"Check whether an EV is connected to the charger.\n\n    Returns:\n        When the charger is not in an error state, whether an EV is connected to\n            the charger.\n    \"\"\"\n    return self.component_state not in (\n        EVChargerComponentState.AUTHORIZATION_REJECTED,\n        EVChargerComponentState.ERROR,\n    ) and self.cable_state in (\n        EVChargerCableState.EV_LOCKED,\n        EVChargerCableState.EV_PLUGGED,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.GridMetadata","title":"frequenz.sdk.microgrid.component.GridMetadata  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentMetadata</code></p> <p>Metadata for a grid connection point.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass GridMetadata(ComponentMetadata):\n    \"\"\"Metadata for a grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData","title":"frequenz.sdk.microgrid.component.InverterData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding inverter data.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass InverterData(ComponentData):\n    \"\"\"A wrapper class for holding inverter data.\"\"\"\n\n    active_power: float\n    \"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\n\n    current_per_phase: tuple[float, float, float]\n    \"\"\"AC current in Amperes (A) for phase/line 1, 2 and 3 respectively.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\n\n    voltage_per_phase: tuple[float, float, float]\n    \"\"\"The AC voltage in Volts (V) between the line and the neutral wire for\n       phase/line 1, 2 and 3 respectively.\n    \"\"\"\n\n    # pylint: disable=line-too-long\n    active_power_inclusion_lower_bound: float\n    \"\"\"Lower inclusion bound for inverter power in watts.\n\n    This is the lower limit of the range within which power requests are allowed for the\n    inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_lower_bound: float\n    \"\"\"Lower exclusion bound for inverter power in watts.\n\n    This is the lower limit of the range within which power requests are not allowed for\n    the inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_inclusion_upper_bound: float\n    \"\"\"Upper inclusion bound for inverter power in watts.\n\n    This is the upper limit of the range within which power requests are allowed for the\n    inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n\n    active_power_exclusion_upper_bound: float\n    \"\"\"Upper exclusion bound for inverter power in watts.\n\n    This is the upper limit of the range within which power requests are not allowed for\n    the inverter.\n\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n    # pylint: enable=line-too-long\n\n    frequency: float\n    \"\"\"AC frequency, in Hertz (Hz).\"\"\"\n\n    _component_state: inverter_pb.ComponentState.ValueType\n    \"\"\"State of the inverter.\"\"\"\n\n    _errors: list[inverter_pb.Error]\n    \"\"\"List of errors from the component.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; InverterData:\n        \"\"\"Create InverterData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of InverterData created from the protobuf message.\n        \"\"\"\n        raw_power = raw.inverter.data.ac.power_active\n        inverter_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw.inverter.data.ac.power_active.value,\n            current_per_phase=(\n                raw.inverter.data.ac.phase_1.current.value,\n                raw.inverter.data.ac.phase_2.current.value,\n                raw.inverter.data.ac.phase_3.current.value,\n            ),\n            voltage_per_phase=(\n                raw.inverter.data.ac.phase_1.voltage.value,\n                raw.inverter.data.ac.phase_2.voltage.value,\n                raw.inverter.data.ac.phase_3.voltage.value,\n            ),\n            active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n            active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n            active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n            active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n            frequency=raw.inverter.data.ac.frequency.value,\n            _component_state=raw.inverter.state.component_state,\n            _errors=list(raw.inverter.errors),\n        )\n\n        inverter_data._set_raw(raw=raw)\n        return inverter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_exclusion_lower_bound","title":"active_power_exclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_lower_bound: float\n</code></pre> <p>Lower exclusion bound for inverter power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_exclusion_upper_bound","title":"active_power_exclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_exclusion_upper_bound: float\n</code></pre> <p>Upper exclusion bound for inverter power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_inclusion_lower_bound","title":"active_power_inclusion_lower_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_lower_bound: float\n</code></pre> <p>Lower inclusion bound for inverter power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_inclusion_upper_bound","title":"active_power_inclusion_upper_bound  <code>instance-attribute</code>","text":"<pre><code>active_power_inclusion_upper_bound: float\n</code></pre> <p>Upper inclusion bound for inverter power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1, 2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>AC frequency, in Hertz (Hz).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.voltage_per_phase","title":"voltage_per_phase  <code>instance-attribute</code>","text":"<pre><code>voltage_per_phase: tuple[float, float, float]\n</code></pre> <p>The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1, 2 and 3 respectively.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; InverterData\n</code></pre> <p>Create InverterData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>InverterData</code> <p>Instance of InverterData created from the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; InverterData:\n    \"\"\"Create InverterData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of InverterData created from the protobuf message.\n    \"\"\"\n    raw_power = raw.inverter.data.ac.power_active\n    inverter_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw.inverter.data.ac.power_active.value,\n        current_per_phase=(\n            raw.inverter.data.ac.phase_1.current.value,\n            raw.inverter.data.ac.phase_2.current.value,\n            raw.inverter.data.ac.phase_3.current.value,\n        ),\n        voltage_per_phase=(\n            raw.inverter.data.ac.phase_1.voltage.value,\n            raw.inverter.data.ac.phase_2.voltage.value,\n            raw.inverter.data.ac.phase_3.voltage.value,\n        ),\n        active_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\n        active_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\n        active_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\n        active_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\n        frequency=raw.inverter.data.ac.frequency.value,\n        _component_state=raw.inverter.state.component_state,\n        _errors=list(raw.inverter.errors),\n    )\n\n    inverter_data._set_raw(raw=raw)\n    return inverter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType","title":"frequenz.sdk.microgrid.component.InverterType","text":"<p>             Bases: <code>ComponentType</code></p> <p>Enum representing inverter types.</p> Source code in <code>frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class InverterType(ComponentType):\n    \"\"\"Enum representing inverter types.\"\"\"\n\n    NONE = inverter_pb.Type.TYPE_UNSPECIFIED\n    \"\"\"Unspecified inverter type.\"\"\"\n\n    BATTERY = inverter_pb.Type.TYPE_BATTERY\n    \"\"\"Battery inverter.\"\"\"\n\n    SOLAR = inverter_pb.Type.TYPE_SOLAR\n    \"\"\"Solar inverter.\"\"\"\n\n    HYBRID = inverter_pb.Type.TYPE_HYBRID\n    \"\"\"Hybrid inverter.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.BATTERY","title":"BATTERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATTERY = TYPE_BATTERY\n</code></pre> <p>Battery inverter.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.HYBRID","title":"HYBRID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HYBRID = TYPE_HYBRID\n</code></pre> <p>Hybrid inverter.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = TYPE_UNSPECIFIED\n</code></pre> <p>Unspecified inverter type.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.SOLAR","title":"SOLAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOLAR = TYPE_SOLAR\n</code></pre> <p>Solar inverter.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData","title":"frequenz.sdk.microgrid.component.MeterData  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding meter data.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass MeterData(ComponentData):\n    \"\"\"A wrapper class for holding meter data.\"\"\"\n\n    active_power: float\n    \"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\n\n    current_per_phase: tuple[float, float, float]\n    \"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\n\n    voltage_per_phase: tuple[float, float, float]\n    \"\"\"The ac voltage in volts (v) between the line and the neutral wire for phase/line\n        1,2 and 3 respectively.\n    \"\"\"\n\n    frequency: float\n    \"\"\"The AC power frequency in Hertz (Hz).\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; MeterData:\n        \"\"\"Create MeterData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of MeterData created from the protobuf message.\n        \"\"\"\n        meter_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw.meter.data.ac.power_active.value,\n            current_per_phase=(\n                raw.meter.data.ac.phase_1.current.value,\n                raw.meter.data.ac.phase_2.current.value,\n                raw.meter.data.ac.phase_3.current.value,\n            ),\n            voltage_per_phase=(\n                raw.meter.data.ac.phase_1.voltage.value,\n                raw.meter.data.ac.phase_2.voltage.value,\n                raw.meter.data.ac.phase_3.voltage.value,\n            ),\n            frequency=raw.meter.data.ac.frequency.value,\n        )\n        meter_data._set_raw(raw=raw)\n        return meter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.active_power","title":"active_power  <code>instance-attribute</code>","text":"<pre><code>active_power: float\n</code></pre> <p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.current_per_phase","title":"current_per_phase  <code>instance-attribute</code>","text":"<pre><code>current_per_phase: tuple[float, float, float]\n</code></pre> <p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.frequency","title":"frequency  <code>instance-attribute</code>","text":"<pre><code>frequency: float\n</code></pre> <p>The AC power frequency in Hertz (Hz).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.raw","title":"raw  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw: ComponentData | None = field(default=None, init=False)\n</code></pre> <p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.voltage_per_phase","title":"voltage_per_phase  <code>instance-attribute</code>","text":"<pre><code>voltage_per_phase: tuple[float, float, float]\n</code></pre> <p>The ac voltage in volts (v) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.from_proto","title":"from_proto  <code>classmethod</code>","text":"<pre><code>from_proto(raw: ComponentData) -&gt; MeterData\n</code></pre> <p>Create MeterData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>MeterData</code> <p>Instance of MeterData created from the protobuf message.</p> Source code in <code>frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; MeterData:\n    \"\"\"Create MeterData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of MeterData created from the protobuf message.\n    \"\"\"\n    meter_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw.meter.data.ac.power_active.value,\n        current_per_phase=(\n            raw.meter.data.ac.phase_1.current.value,\n            raw.meter.data.ac.phase_2.current.value,\n            raw.meter.data.ac.phase_3.current.value,\n        ),\n        voltage_per_phase=(\n            raw.meter.data.ac.phase_1.voltage.value,\n            raw.meter.data.ac.phase_2.voltage.value,\n            raw.meter.data.ac.phase_3.voltage.value,\n        ),\n        frequency=raw.meter.data.ac.frequency.value,\n    )\n    meter_data._set_raw(raw=raw)\n    return meter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/","title":"Index","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries","title":"frequenz.sdk.timeseries","text":"<p>Handling of timeseries streams.</p> <p>A timeseries is a stream (normally an async iterator) of <code>Sample</code>s.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries--periodicity-and-alignment","title":"Periodicity and alignment","text":"<p>All the data produced by this package is always periodic and aligned to the <code>UNIX_EPOCH</code> (by default).</p> <p>Classes normally take a (re)sampling period as and argument and, optionally, an <code>align_to</code> argument.</p> <p>This means timestamps are always separated exactly by a period, and that this timestamp falls always at multiples of the period, starting at the <code>align_to</code>.</p> <p>This ensures that the data is predictable and consistent among restarts.</p> Example <p>If we have a period of 10 seconds, and are aligning to the UNIX epoch. Assuming the following timeline starts in 1970-01-01 00:00:00 UTC and our current <code>now</code> is 1970-01-01 00:00:32 UTC, then the next timestamp will be at 1970-01-01 00:00:40 UTC:</p> <pre><code>align_to = 1970-01-01 00:00:00         next event = 1970-01-01 00:00:40\n|                                       |\n|---------|---------|---------|-|-------|---------|---------|---------|\n0        10        20        30 |      40        50        60        70\n                               now = 1970-01-01 00:00:32\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.UNIX_EPOCH","title":"frequenz.sdk.timeseries.UNIX_EPOCH  <code>module-attribute</code>","text":"<pre><code>UNIX_EPOCH = fromtimestamp(0.0, tz=utc)\n</code></pre> <p>The UNIX epoch (in UTC).</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds","title":"frequenz.sdk.timeseries.Bounds  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[_T]</code></p> <p>Lower and upper bound values.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Bounds(Generic[_T]):\n    \"\"\"Lower and upper bound values.\"\"\"\n\n    lower: _T\n    \"\"\"Lower bound.\"\"\"\n\n    upper: _T\n    \"\"\"Upper bound.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: _T\n</code></pre> <p>Lower bound.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: _T\n</code></pre> <p>Upper bound.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current","title":"frequenz.sdk.timeseries.Current","text":"<p>             Bases: <code>Quantity</code></p> <p>A current quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Current(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={\n        -3: \"mA\",\n        0: \"A\",\n    },\n):\n    \"\"\"A current quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_amperes(cls, amperes: float) -&gt; Self:\n        \"\"\"Initialize a new current quantity.\n\n        Args:\n            amperes: The current in amperes.\n\n        Returns:\n            A new current quantity.\n        \"\"\"\n        current = cls.__new__(cls)\n        current._base_value = amperes\n        return current\n\n    @classmethod\n    def from_milliamperes(cls, milliamperes: float) -&gt; Self:\n        \"\"\"Initialize a new current quantity.\n\n        Args:\n            milliamperes: The current in milliamperes.\n\n        Returns:\n            A new current quantity.\n        \"\"\"\n        current = cls.__new__(cls)\n        current._base_value = milliamperes * 10**-3\n        return current\n\n    def as_amperes(self) -&gt; float:\n        \"\"\"Return the current in amperes.\n\n        Returns:\n            The current in amperes.\n        \"\"\"\n        return self._base_value\n\n    def as_milliamperes(self) -&gt; float:\n        \"\"\"Return the current in milliamperes.\n\n        Returns:\n            The current in milliamperes.\n        \"\"\"\n        return self._base_value * 1e3\n\n    @overload  # type: ignore\n    def __mul__(self, other: Percentage) -&gt; Self:\n        \"\"\"Scale this current by a percentage.\n\n        Args:\n            other: The percentage by which to scale this current.\n\n        Returns:\n            The scaled current.\n        \"\"\"\n\n    @overload\n    def __mul__(self, other: Voltage) -&gt; Power:\n        \"\"\"Multiply the current by a voltage to get a power.\n\n        Args:\n            other: The voltage.\n\n        Returns:\n            The calculated power.\n        \"\"\"\n\n    def __mul__(self, other: Percentage | Voltage) -&gt; Self | Power:\n        \"\"\"Return a current or power from multiplying this current by the given value.\n\n        Args:\n            other: The percentage or voltage to multiply by.\n\n        Returns:\n            A current or power.\n        \"\"\"\n        if isinstance(other, Percentage):\n            return super().__mul__(other)\n        if isinstance(other, Voltage):\n            return Power.from_watts(self._base_value * other._base_value)\n\n        return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Percentage | Voltage) -&gt; Self | Power\n</code></pre> <p>Return a current or power from multiplying this current by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The percentage or voltage to multiply by.</p> <p> TYPE: <code>Percentage | Voltage</code> </p> RETURNS DESCRIPTION <code>Self | Power</code> <p>A current or power.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: Percentage | Voltage) -&gt; Self | Power:\n    \"\"\"Return a current or power from multiplying this current by the given value.\n\n    Args:\n        other: The percentage or voltage to multiply by.\n\n    Returns:\n        A current or power.\n    \"\"\"\n    if isinstance(other, Percentage):\n        return super().__mul__(other)\n    if isinstance(other, Voltage):\n        return Power.from_watts(self._base_value * other._base_value)\n\n    return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.as_amperes","title":"as_amperes","text":"<pre><code>as_amperes() -&gt; float\n</code></pre> <p>Return the current in amperes.</p> RETURNS DESCRIPTION <code>float</code> <p>The current in amperes.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_amperes(self) -&gt; float:\n    \"\"\"Return the current in amperes.\n\n    Returns:\n        The current in amperes.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.as_milliamperes","title":"as_milliamperes","text":"<pre><code>as_milliamperes() -&gt; float\n</code></pre> <p>Return the current in milliamperes.</p> RETURNS DESCRIPTION <code>float</code> <p>The current in milliamperes.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_milliamperes(self) -&gt; float:\n    \"\"\"Return the current in milliamperes.\n\n    Returns:\n        The current in milliamperes.\n    \"\"\"\n    return self._base_value * 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.from_amperes","title":"from_amperes  <code>classmethod</code>","text":"<pre><code>from_amperes(amperes: float) -&gt; Self\n</code></pre> <p>Initialize a new current quantity.</p> PARAMETER  DESCRIPTION <code>amperes</code> <p>The current in amperes.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new current quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_amperes(cls, amperes: float) -&gt; Self:\n    \"\"\"Initialize a new current quantity.\n\n    Args:\n        amperes: The current in amperes.\n\n    Returns:\n        A new current quantity.\n    \"\"\"\n    current = cls.__new__(cls)\n    current._base_value = amperes\n    return current\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.from_milliamperes","title":"from_milliamperes  <code>classmethod</code>","text":"<pre><code>from_milliamperes(milliamperes: float) -&gt; Self\n</code></pre> <p>Initialize a new current quantity.</p> PARAMETER  DESCRIPTION <code>milliamperes</code> <p>The current in milliamperes.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new current quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_milliamperes(cls, milliamperes: float) -&gt; Self:\n    \"\"\"Initialize a new current quantity.\n\n    Args:\n        milliamperes: The current in milliamperes.\n\n    Returns:\n        A new current quantity.\n    \"\"\"\n    current = cls.__new__(cls)\n    current._base_value = milliamperes * 10**-3\n    return current\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER  DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.\n\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy","title":"frequenz.sdk.timeseries.Energy","text":"<p>             Bases: <code>Quantity</code></p> <p>An energy quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Energy(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={\n        0: \"Wh\",\n        3: \"kWh\",\n        6: \"MWh\",\n    },\n):\n    \"\"\"An energy quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_watt_hours(cls, watt_hours: float) -&gt; Self:\n        \"\"\"Initialize a new energy quantity.\n\n        Args:\n            watt_hours: The energy in watt hours.\n\n        Returns:\n            A new energy quantity.\n        \"\"\"\n        energy = cls.__new__(cls)\n        energy._base_value = watt_hours\n        return energy\n\n    @classmethod\n    def from_kilowatt_hours(cls, kilowatt_hours: float) -&gt; Self:\n        \"\"\"Initialize a new energy quantity.\n\n        Args:\n            kilowatt_hours: The energy in kilowatt hours.\n\n        Returns:\n            A new energy quantity.\n        \"\"\"\n        energy = cls.__new__(cls)\n        energy._base_value = kilowatt_hours * 10**3\n        return energy\n\n    @classmethod\n    def from_megawatt_hours(cls, megawatt_hours: float) -&gt; Self:\n        \"\"\"Initialize a new energy quantity.\n\n        Args:\n            megawatt_hours: The energy in megawatt hours.\n\n        Returns:\n            A new energy quantity.\n        \"\"\"\n        energy = cls.__new__(cls)\n        energy._base_value = megawatt_hours * 10**6\n        return energy\n\n    def as_watt_hours(self) -&gt; float:\n        \"\"\"Return the energy in watt hours.\n\n        Returns:\n            The energy in watt hours.\n        \"\"\"\n        return self._base_value\n\n    def as_kilowatt_hours(self) -&gt; float:\n        \"\"\"Return the energy in kilowatt hours.\n\n        Returns:\n            The energy in kilowatt hours.\n        \"\"\"\n        return self._base_value / 1e3\n\n    def as_megawatt_hours(self) -&gt; float:\n        \"\"\"Return the energy in megawatt hours.\n\n        Returns:\n            The energy in megawatt hours.\n        \"\"\"\n        return self._base_value / 1e6\n\n    @overload\n    def __truediv__(self, other: timedelta) -&gt; Power:\n        \"\"\"Return a power from dividing this energy by the given duration.\n\n        Args:\n            other: The duration to divide by.\n\n        Returns:\n            A power from dividing this energy by the given duration.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, other: Power) -&gt; timedelta:\n        \"\"\"Return a duration from dividing this energy by the given power.\n\n        Args:\n            other: The power to divide by.\n\n        Returns:\n            A duration from dividing this energy by the given power.\n        \"\"\"\n\n    def __truediv__(self, other: timedelta | Power) -&gt; Power | timedelta:\n        \"\"\"Return a power or duration from dividing this energy by the given value.\n\n        Args:\n            other: The power or duration to divide by.\n\n        Returns:\n            A power or duration from dividing this energy by the given value.\n\n        Raises:\n            TypeError: If the given value is not a power or duration.\n        \"\"\"\n        if isinstance(other, timedelta):\n            return Power.from_watts(self._base_value / (other.total_seconds() / 3600.0))\n        if isinstance(other, Power):\n            return timedelta(seconds=(self._base_value / other._base_value) * 3600.0)\n        raise TypeError(\n            f\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__mul__","title":"__mul__","text":"<pre><code>__mul__(percent: Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a percentage.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percentage by which to scale this quantity.</p> <p> TYPE: <code>Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, percent: Percentage) -&gt; Self:\n    \"\"\"Scale this quantity by a percentage.\n\n    Args:\n        percent: The percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    if not isinstance(percent, Percentage):\n        return NotImplemented\n\n    product = type(self).__new__(type(self))\n    product._base_value = self._base_value * percent.as_fraction()\n    return product\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: timedelta | Power) -&gt; Power | timedelta\n</code></pre> <p>Return a power or duration from dividing this energy by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The power or duration to divide by.</p> <p> TYPE: <code>timedelta | Power</code> </p> RETURNS DESCRIPTION <code>Power | timedelta</code> <p>A power or duration from dividing this energy by the given value.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given value is not a power or duration.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, other: timedelta | Power) -&gt; Power | timedelta:\n    \"\"\"Return a power or duration from dividing this energy by the given value.\n\n    Args:\n        other: The power or duration to divide by.\n\n    Returns:\n        A power or duration from dividing this energy by the given value.\n\n    Raises:\n        TypeError: If the given value is not a power or duration.\n    \"\"\"\n    if isinstance(other, timedelta):\n        return Power.from_watts(self._base_value / (other.total_seconds() / 3600.0))\n    if isinstance(other, Power):\n        return timedelta(seconds=(self._base_value / other._base_value) * 3600.0)\n    raise TypeError(\n        f\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_kilowatt_hours","title":"as_kilowatt_hours","text":"<pre><code>as_kilowatt_hours() -&gt; float\n</code></pre> <p>Return the energy in kilowatt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in kilowatt hours.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilowatt_hours(self) -&gt; float:\n    \"\"\"Return the energy in kilowatt hours.\n\n    Returns:\n        The energy in kilowatt hours.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_megawatt_hours","title":"as_megawatt_hours","text":"<pre><code>as_megawatt_hours() -&gt; float\n</code></pre> <p>Return the energy in megawatt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in megawatt hours.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megawatt_hours(self) -&gt; float:\n    \"\"\"Return the energy in megawatt hours.\n\n    Returns:\n        The energy in megawatt hours.\n    \"\"\"\n    return self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_watt_hours","title":"as_watt_hours","text":"<pre><code>as_watt_hours() -&gt; float\n</code></pre> <p>Return the energy in watt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in watt hours.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_watt_hours(self) -&gt; float:\n    \"\"\"Return the energy in watt hours.\n\n    Returns:\n        The energy in watt hours.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_kilowatt_hours","title":"from_kilowatt_hours  <code>classmethod</code>","text":"<pre><code>from_kilowatt_hours(kilowatt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER  DESCRIPTION <code>kilowatt_hours</code> <p>The energy in kilowatt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilowatt_hours(cls, kilowatt_hours: float) -&gt; Self:\n    \"\"\"Initialize a new energy quantity.\n\n    Args:\n        kilowatt_hours: The energy in kilowatt hours.\n\n    Returns:\n        A new energy quantity.\n    \"\"\"\n    energy = cls.__new__(cls)\n    energy._base_value = kilowatt_hours * 10**3\n    return energy\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_megawatt_hours","title":"from_megawatt_hours  <code>classmethod</code>","text":"<pre><code>from_megawatt_hours(megawatt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER  DESCRIPTION <code>megawatt_hours</code> <p>The energy in megawatt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megawatt_hours(cls, megawatt_hours: float) -&gt; Self:\n    \"\"\"Initialize a new energy quantity.\n\n    Args:\n        megawatt_hours: The energy in megawatt hours.\n\n    Returns:\n        A new energy quantity.\n    \"\"\"\n    energy = cls.__new__(cls)\n    energy._base_value = megawatt_hours * 10**6\n    return energy\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER  DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_watt_hours","title":"from_watt_hours  <code>classmethod</code>","text":"<pre><code>from_watt_hours(watt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER  DESCRIPTION <code>watt_hours</code> <p>The energy in watt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_watt_hours(cls, watt_hours: float) -&gt; Self:\n    \"\"\"Initialize a new energy quantity.\n\n    Args:\n        watt_hours: The energy in watt hours.\n\n    Returns:\n        A new energy quantity.\n    \"\"\"\n    energy = cls.__new__(cls)\n    energy._base_value = watt_hours\n    return energy\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.\n\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency","title":"frequenz.sdk.timeseries.Frequency","text":"<p>             Bases: <code>Quantity</code></p> <p>A frequency quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Frequency(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={0: \"Hz\", 3: \"kHz\", 6: \"MHz\", 9: \"GHz\"},\n):\n    \"\"\"A frequency quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_hertz(cls, hertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            hertz: The frequency in hertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        frequency = cls.__new__(cls)\n        frequency._base_value = hertz\n        return frequency\n\n    @classmethod\n    def from_kilohertz(cls, kilohertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            kilohertz: The frequency in kilohertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        frequency = cls.__new__(cls)\n        frequency._base_value = kilohertz * 10**3\n        return frequency\n\n    @classmethod\n    def from_megahertz(cls, megahertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            megahertz: The frequency in megahertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        frequency = cls.__new__(cls)\n        frequency._base_value = megahertz * 10**6\n        return frequency\n\n    @classmethod\n    def from_gigahertz(cls, gigahertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            gigahertz: The frequency in gigahertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        frequency = cls.__new__(cls)\n        frequency._base_value = gigahertz * 10**9\n        return frequency\n\n    def as_hertz(self) -&gt; float:\n        \"\"\"Return the frequency in hertz.\n\n        Returns:\n            The frequency in hertz.\n        \"\"\"\n        return self._base_value\n\n    def as_kilohertz(self) -&gt; float:\n        \"\"\"Return the frequency in kilohertz.\n\n        Returns:\n            The frequency in kilohertz.\n        \"\"\"\n        return self._base_value / 1e3\n\n    def as_megahertz(self) -&gt; float:\n        \"\"\"Return the frequency in megahertz.\n\n        Returns:\n            The frequency in megahertz.\n        \"\"\"\n        return self._base_value / 1e6\n\n    def as_gigahertz(self) -&gt; float:\n        \"\"\"Return the frequency in gigahertz.\n\n        Returns:\n            The frequency in gigahertz.\n        \"\"\"\n        return self._base_value / 1e9\n\n    def period(self) -&gt; timedelta:\n        \"\"\"Return the period of the frequency.\n\n        Returns:\n            The period of the frequency.\n        \"\"\"\n        return timedelta(seconds=1.0 / self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__mul__","title":"__mul__","text":"<pre><code>__mul__(percent: Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a percentage.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percentage by which to scale this quantity.</p> <p> TYPE: <code>Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, percent: Percentage) -&gt; Self:\n    \"\"\"Scale this quantity by a percentage.\n\n    Args:\n        percent: The percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    if not isinstance(percent, Percentage):\n        return NotImplemented\n\n    product = type(self).__new__(type(self))\n    product._base_value = self._base_value * percent.as_fraction()\n    return product\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_gigahertz","title":"as_gigahertz","text":"<pre><code>as_gigahertz() -&gt; float\n</code></pre> <p>Return the frequency in gigahertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in gigahertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_gigahertz(self) -&gt; float:\n    \"\"\"Return the frequency in gigahertz.\n\n    Returns:\n        The frequency in gigahertz.\n    \"\"\"\n    return self._base_value / 1e9\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_hertz","title":"as_hertz","text":"<pre><code>as_hertz() -&gt; float\n</code></pre> <p>Return the frequency in hertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in hertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_hertz(self) -&gt; float:\n    \"\"\"Return the frequency in hertz.\n\n    Returns:\n        The frequency in hertz.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_kilohertz","title":"as_kilohertz","text":"<pre><code>as_kilohertz() -&gt; float\n</code></pre> <p>Return the frequency in kilohertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in kilohertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilohertz(self) -&gt; float:\n    \"\"\"Return the frequency in kilohertz.\n\n    Returns:\n        The frequency in kilohertz.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_megahertz","title":"as_megahertz","text":"<pre><code>as_megahertz() -&gt; float\n</code></pre> <p>Return the frequency in megahertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in megahertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megahertz(self) -&gt; float:\n    \"\"\"Return the frequency in megahertz.\n\n    Returns:\n        The frequency in megahertz.\n    \"\"\"\n    return self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_gigahertz","title":"from_gigahertz  <code>classmethod</code>","text":"<pre><code>from_gigahertz(gigahertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>gigahertz</code> <p>The frequency in gigahertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_gigahertz(cls, gigahertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        gigahertz: The frequency in gigahertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    frequency = cls.__new__(cls)\n    frequency._base_value = gigahertz * 10**9\n    return frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_hertz","title":"from_hertz  <code>classmethod</code>","text":"<pre><code>from_hertz(hertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>hertz</code> <p>The frequency in hertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_hertz(cls, hertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        hertz: The frequency in hertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    frequency = cls.__new__(cls)\n    frequency._base_value = hertz\n    return frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_kilohertz","title":"from_kilohertz  <code>classmethod</code>","text":"<pre><code>from_kilohertz(kilohertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>kilohertz</code> <p>The frequency in kilohertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilohertz(cls, kilohertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        kilohertz: The frequency in kilohertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    frequency = cls.__new__(cls)\n    frequency._base_value = kilohertz * 10**3\n    return frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_megahertz","title":"from_megahertz  <code>classmethod</code>","text":"<pre><code>from_megahertz(megahertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>megahertz</code> <p>The frequency in megahertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megahertz(cls, megahertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        megahertz: The frequency in megahertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    frequency = cls.__new__(cls)\n    frequency._base_value = megahertz * 10**6\n    return frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER  DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.period","title":"period","text":"<pre><code>period() -&gt; timedelta\n</code></pre> <p>Return the period of the frequency.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The period of the frequency.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def period(self) -&gt; timedelta:\n    \"\"\"Return the period of the frequency.\n\n    Returns:\n        The period of the frequency.\n    \"\"\"\n    return timedelta(seconds=1.0 / self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.\n\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Fuse","title":"frequenz.sdk.timeseries.Fuse  <code>dataclass</code>","text":"<p>Fuse data class.</p> Source code in <code>frequenz/sdk/timeseries/_fuse.py</code> <pre><code>@dataclass(frozen=True)\nclass Fuse:\n    \"\"\"Fuse data class.\"\"\"\n\n    max_current: Current\n    \"\"\"Rated current of the fuse.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Fuse-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Fuse.max_current","title":"max_current  <code>instance-attribute</code>","text":"<pre><code>max_current: Current\n</code></pre> <p>Rated current of the fuse.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow","title":"frequenz.sdk.timeseries.MovingWindow","text":"<p>             Bases: <code>BackgroundService</code></p> <p>A data window that moves with the latest datapoints of a data stream.</p> <p>After initialization the <code>MovingWindow</code> can be accessed by an integer index or a timestamp. A sub window can be accessed by using a slice of integers or timestamps.</p> <p>Note that a numpy ndarray is returned and thus users can use numpys operations directly on a window.</p> <p>The window uses a ring buffer for storage and the first element is aligned to a fixed defined point in time. Since the moving nature of the window, the date of the first and the last element are constantly changing and therefore the point in time that defines the alignment can be outside of the time window. Modulo arithmetic is used to move the <code>align_to</code> timestamp into the latest window.</p> <p>If for example the <code>align_to</code> parameter is set to <code>datetime(1, 1, 1, tzinfo=timezone.utc)</code> and the window size is bigger than one day then the first element will always be aligned to midnight.</p> <p>Resampling might be required to reduce the number of samples to store, and it can be set by specifying the resampler config parameter so that the user can control the granularity of the samples to be stored in the underlying buffer.</p> <p>If resampling is not required, the resampler config parameter can be set to None in which case the MovingWindow will not perform any resampling.</p> <p>Example: Calculate the mean of a time interval</p> <pre><code>```python\nfrom datetime import datetime, timedelta, timezone\n\nasync def send_mock_data(sender: Sender[Sample]) -&gt; None:\n    while True:\n        await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n        await asyncio.sleep(1.0)\n\nasync def run() -&gt; None:\n    resampled_data_channel = Broadcast[Sample](\"sample-data\")\n    resampled_data_receiver = resampled_data_channel.new_receiver()\n    resampled_data_sender = resampled_data_channel.new_sender()\n\n    send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n    async with MovingWindow(\n        size=timedelta(seconds=5),\n        resampled_data_recv=resampled_data_receiver,\n        input_sampling_period=timedelta(seconds=1),\n    ) as window:\n        time_start = datetime.now(tz=timezone.utc)\n        time_end = time_start + timedelta(seconds=5)\n\n        # ... wait for 5 seconds until the buffer is filled\n        await asyncio.sleep(5)\n\n        # return an numpy array from the window\n        array = window[time_start:time_end]\n        # and use it to for example calculate the mean\n        mean = array.mean()\n\nasyncio.run(run())\n```\n</code></pre> <p>Example: Create a polars data frame from a <code>MovingWindow</code></p> <pre><code>```python\nimport polars as pl\nfrom datetime import datetime, timedelta, timezone\n\nasync def send_mock_data(sender: Sender[Sample]) -&gt; None:\n    while True:\n        await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n        await asyncio.sleep(1.0)\n\nasync def run() -&gt; None:\n    resampled_data_channel = Broadcast[Sample](\"sample-data\")\n    resampled_data_receiver = resampled_data_channel.new_receiver()\n    resampled_data_sender = resampled_data_channel.new_sender()\n\n    send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n    # create a window that stores two days of data\n    # starting at 1.1.23 with samplerate=1\n    async with MovingWindow(\n        size=timedelta(days=2),\n        resampled_data_recv=resampled_data_receiver,\n        input_sampling_period=timedelta(seconds=1),\n    ) as window:\n        # wait for one full day until the buffer is filled\n        await asyncio.sleep(60*60*24)\n\n        # create a polars series with one full day of data\n        time_start = datetime(2023, 1, 1, tzinfo=timezone.utc)\n        time_end = datetime(2023, 1, 2, tzinfo=timezone.utc)\n        series = pl.Series(\"Jan_1\", window[time_start:time_end])\n\nasyncio.run(run())\n```\n</code></pre> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>class MovingWindow(BackgroundService):\n    \"\"\"\n    A data window that moves with the latest datapoints of a data stream.\n\n    After initialization the `MovingWindow` can be accessed by an integer\n    index or a timestamp. A sub window can be accessed by using a slice of\n    integers or timestamps.\n\n    Note that a numpy ndarray is returned and thus users can use\n    numpys operations directly on a window.\n\n    The window uses a ring buffer for storage and the first element is aligned to\n    a fixed defined point in time. Since the moving nature of the window, the\n    date of the first and the last element are constantly changing and therefore\n    the point in time that defines the alignment can be outside of the time window.\n    Modulo arithmetic is used to move the `align_to` timestamp into the latest\n    window.\n\n    If for example the `align_to` parameter is set to\n    `datetime(1, 1, 1, tzinfo=timezone.utc)` and the window size is bigger than\n    one day then the first element will always be aligned to midnight.\n\n    Resampling might be required to reduce the number of samples to store, and\n    it can be set by specifying the resampler config parameter so that the user\n    can control the granularity of the samples to be stored in the underlying\n    buffer.\n\n    If resampling is not required, the resampler config parameter can be\n    set to None in which case the MovingWindow will not perform any resampling.\n\n    Example: Calculate the mean of a time interval\n\n        ```python\n        from datetime import datetime, timedelta, timezone\n\n        async def send_mock_data(sender: Sender[Sample]) -&gt; None:\n            while True:\n                await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n                await asyncio.sleep(1.0)\n\n        async def run() -&gt; None:\n            resampled_data_channel = Broadcast[Sample](\"sample-data\")\n            resampled_data_receiver = resampled_data_channel.new_receiver()\n            resampled_data_sender = resampled_data_channel.new_sender()\n\n            send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n            async with MovingWindow(\n                size=timedelta(seconds=5),\n                resampled_data_recv=resampled_data_receiver,\n                input_sampling_period=timedelta(seconds=1),\n            ) as window:\n                time_start = datetime.now(tz=timezone.utc)\n                time_end = time_start + timedelta(seconds=5)\n\n                # ... wait for 5 seconds until the buffer is filled\n                await asyncio.sleep(5)\n\n                # return an numpy array from the window\n                array = window[time_start:time_end]\n                # and use it to for example calculate the mean\n                mean = array.mean()\n\n        asyncio.run(run())\n        ```\n\n    Example: Create a polars data frame from a `MovingWindow`\n\n        ```python\n        import polars as pl\n        from datetime import datetime, timedelta, timezone\n\n        async def send_mock_data(sender: Sender[Sample]) -&gt; None:\n            while True:\n                await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n                await asyncio.sleep(1.0)\n\n        async def run() -&gt; None:\n            resampled_data_channel = Broadcast[Sample](\"sample-data\")\n            resampled_data_receiver = resampled_data_channel.new_receiver()\n            resampled_data_sender = resampled_data_channel.new_sender()\n\n            send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n            # create a window that stores two days of data\n            # starting at 1.1.23 with samplerate=1\n            async with MovingWindow(\n                size=timedelta(days=2),\n                resampled_data_recv=resampled_data_receiver,\n                input_sampling_period=timedelta(seconds=1),\n            ) as window:\n                # wait for one full day until the buffer is filled\n                await asyncio.sleep(60*60*24)\n\n                # create a polars series with one full day of data\n                time_start = datetime(2023, 1, 1, tzinfo=timezone.utc)\n                time_end = datetime(2023, 1, 2, tzinfo=timezone.utc)\n                series = pl.Series(\"Jan_1\", window[time_start:time_end])\n\n        asyncio.run(run())\n        ```\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        size: timedelta,\n        resampled_data_recv: Receiver[Sample[Quantity]],\n        input_sampling_period: timedelta,\n        resampler_config: ResamplerConfig | None = None,\n        align_to: datetime = UNIX_EPOCH,\n        *,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the MovingWindow.\n\n        This method creates the underlying ring buffer and starts a\n        new task that updates the ring buffer with new incoming samples.\n        The task stops running only if the channel receiver is closed.\n\n        Args:\n            size: The time span of the moving window over which samples will be stored.\n            resampled_data_recv: A receiver that delivers samples with a\n                given sampling period.\n            input_sampling_period: The time interval between consecutive input samples.\n            resampler_config: The resampler configuration in case resampling is required.\n            align_to: A timestamp that defines a point in time to which\n                the window is aligned to modulo window size. For further\n                information, consult the class level documentation.\n            name: The name of this moving window. If `None`, `str(id(self))` will be\n                used. This is used mostly for debugging purposes.\n        \"\"\"\n        assert (\n            input_sampling_period.total_seconds() &gt; 0\n        ), \"The input sampling period should be greater than zero.\"\n        assert (\n            input_sampling_period &lt;= size\n        ), \"The input sampling period should be equal to or lower than the window size.\"\n        super().__init__(name=name)\n\n        self._sampling_period = input_sampling_period\n\n        self._resampler: Resampler | None = None\n        self._resampler_sender: Sender[Sample[Quantity]] | None = None\n\n        if resampler_config:\n            assert (\n                resampler_config.resampling_period &lt;= size\n            ), \"The resampling period should be equal to or lower than the window size.\"\n\n            self._resampler = Resampler(resampler_config)\n            self._sampling_period = resampler_config.resampling_period\n\n        # Sampling period might not fit perfectly into the window size.\n        num_samples = math.ceil(\n            size.total_seconds() / self._sampling_period.total_seconds()\n        )\n\n        self._resampled_data_recv = resampled_data_recv\n        self._buffer = OrderedRingBuffer(\n            np.empty(shape=num_samples, dtype=float),\n            sampling_period=self._sampling_period,\n            align_to=align_to,\n        )\n\n    def start(self) -&gt; None:\n        \"\"\"Start the MovingWindow.\n\n        This method starts the MovingWindow tasks.\n        \"\"\"\n        if self._resampler:\n            self._configure_resampler()\n        self._tasks.add(asyncio.create_task(self._run_impl(), name=\"update-window\"))\n\n    @property\n    def sampling_period(self) -&gt; timedelta:\n        \"\"\"\n        Return the sampling period of the MovingWindow.\n\n        Returns:\n            The sampling period of the MovingWindow.\n        \"\"\"\n        return self._sampling_period\n\n    @property\n    def oldest_timestamp(self) -&gt; datetime | None:\n        \"\"\"\n        Return the oldest timestamp of the MovingWindow.\n\n        Returns:\n            The oldest timestamp of the MovingWindow or None if the buffer is empty.\n        \"\"\"\n        return self._buffer.oldest_timestamp\n\n    @property\n    def newest_timestamp(self) -&gt; datetime | None:\n        \"\"\"\n        Return the newest timestamp of the MovingWindow.\n\n        Returns:\n            The newest timestamp of the MovingWindow or None if the buffer is empty.\n        \"\"\"\n        return self._buffer.newest_timestamp\n\n    @property\n    def capacity(self) -&gt; int:\n        \"\"\"\n        Return the capacity of the MovingWindow.\n\n        Capacity is the maximum number of samples that can be stored in the\n        MovingWindow.\n\n        Returns:\n            The capacity of the MovingWindow.\n        \"\"\"\n        return self._buffer.maxlen\n\n    # pylint before 3.0 only accepts names with 3 or more chars\n    def at(self, key: int | datetime) -&gt; float:  # pylint: disable=invalid-name\n        \"\"\"\n        Return the sample at the given index or timestamp.\n\n        In contrast to the [`window`][frequenz.sdk.timeseries.MovingWindow.window] method,\n        which expects a slice as argument, this method expects a single index as argument\n        and returns a single value.\n\n        Args:\n            key: The index or timestamp of the sample to return.\n\n        Returns:\n            The sample at the given index or timestamp.\n\n        Raises:\n            IndexError: If the buffer is empty or the index is out of bounds.\n        \"\"\"\n        if self._buffer.count_valid() == 0:\n            raise IndexError(\"The buffer is empty.\")\n\n        if isinstance(key, datetime):\n            assert self._buffer.oldest_timestamp is not None\n            assert self._buffer.newest_timestamp is not None\n            if (\n                key &lt; self._buffer.oldest_timestamp\n                or key &gt; self._buffer.newest_timestamp\n            ):\n                raise IndexError(\n                    f\"Timestamp {key} is out of range [{self._buffer.oldest_timestamp}, \"\n                    f\"{self._buffer.newest_timestamp}]\"\n                )\n            return self._buffer[self._buffer.to_internal_index(key)]\n\n        if isinstance(key, int):\n            _logger.debug(\"Returning value at index %s \", key)\n            timestamp = self._buffer.get_timestamp(key)\n            assert timestamp is not None\n            return self._buffer[self._buffer.to_internal_index(timestamp)]\n\n        raise TypeError(\"Key has to be either a timestamp or an integer.\")\n\n    def window(\n        self,\n        start: datetime | int | None,\n        end: datetime | int | None,\n        *,\n        force_copy: bool = True,\n        fill_value: float | None = np.nan,\n    ) -&gt; ArrayLike:\n        \"\"\"\n        Return an array containing the samples in the given time interval.\n\n        In contrast to the [`at`][frequenz.sdk.timeseries.MovingWindow.at] method,\n        which expects a single index as argument, this method expects a slice as argument\n        and returns an array.\n\n        Args:\n            start: The start timestamp of the time interval. If `None`, the\n                start of the window is used.\n            end: The end timestamp of the time interval. If `None`, the end of\n                the window is used.\n            force_copy: If `True`, the returned array is a copy of the underlying\n                data. Otherwise, if possible, a view of the underlying data is\n                returned.\n            fill_value: If not None, will use this value to fill missing values.\n                If missing values should be set, force_copy must be True.\n                Defaults to NaN to avoid returning outdated data unexpectedly.\n\n        Returns:\n            An array containing the samples in the given time interval.\n        \"\"\"\n        return self._buffer.window(\n            start, end, force_copy=force_copy, fill_value=fill_value\n        )\n\n    async def _run_impl(self) -&gt; None:\n        \"\"\"Awaits samples from the receiver and updates the underlying ring buffer.\n\n        Raises:\n            asyncio.CancelledError: if the MovingWindow task is cancelled.\n        \"\"\"\n        try:\n            async for sample in self._resampled_data_recv:\n                _logger.debug(\"Received new sample: %s\", sample)\n                if self._resampler and self._resampler_sender:\n                    await self._resampler_sender.send(sample)\n                else:\n                    self._buffer.update(sample)\n\n        except asyncio.CancelledError:\n            _logger.info(\"MovingWindow task has been cancelled.\")\n            raise\n\n        _logger.error(\"Channel has been closed\")\n\n    def _configure_resampler(self) -&gt; None:\n        \"\"\"Configure the components needed to run the resampler.\"\"\"\n        assert self._resampler is not None\n\n        async def sink_buffer(sample: Sample[Quantity]) -&gt; None:\n            if sample.value is not None:\n                self._buffer.update(sample)\n\n        resampler_channel = Broadcast[Sample[Quantity]](\"average\")\n        self._resampler_sender = resampler_channel.new_sender()\n        self._resampler.add_timeseries(\n            \"avg\", resampler_channel.new_receiver(), sink_buffer\n        )\n        self._tasks.add(\n            asyncio.create_task(self._resampler.resample(), name=\"resample\")\n        )\n\n    def count_valid(self) -&gt; int:\n        \"\"\"\n        Count the number of valid samples in this `MovingWindow`.\n\n        Returns:\n            The number of valid samples in this `MovingWindow`.\n        \"\"\"\n        return self._buffer.count_valid()\n\n    def count_covered(self) -&gt; int:\n        \"\"\"Count the number of samples that are covered by the oldest and newest valid samples.\n\n        Returns:\n            The count of samples between the oldest and newest (inclusive) valid samples\n                or 0 if there are is no time range covered.\n        \"\"\"\n        return self._buffer.count_covered()\n\n    @overload\n    def __getitem__(self, key: SupportsIndex) -&gt; float:\n        \"\"\"See the main __getitem__ method.\n\n        [//]: # (# noqa: DAR101 key)\n        \"\"\"\n\n    @overload\n    def __getitem__(self, key: datetime) -&gt; float:\n        \"\"\"See the main __getitem__ method.\n\n        [//]: # (# noqa: DAR101 key)\n        \"\"\"\n\n    @overload\n    def __getitem__(self, key: slice) -&gt; ArrayLike:\n        \"\"\"See the main __getitem__ method.\n\n        [//]: # (# noqa: DAR101 key)\n        \"\"\"\n\n    def __getitem__(self, key: SupportsIndex | datetime | slice) -&gt; float | ArrayLike:\n        \"\"\"\n        Return a sub window of the `MovingWindow`.\n\n        The `MovingWindow` is accessed either by timestamp or by index\n        or by a slice of timestamps or integers.\n\n        * If the key is an integer, the float value of that key\n          at the given position is returned.\n        * If the key is a timestamp, the float value of that key\n          that corresponds to the timestamp is returned.\n        * If the key is a slice of timestamps or integers, an ndarray is returned,\n          where the bounds correspond to the slice bounds.\n          Note that a half open interval, which is open at the end, is returned.\n\n        Args:\n            key: Either an integer or a timestamp or a slice of timestamps or integers.\n\n        Raises:\n            IndexError: when requesting an out of range timestamp or index\n            TypeError: when the key is not a datetime or slice object.\n\n        Returns:\n            A float if the key is a number or a timestamp.\n            an numpy array if the key is a slice.\n        \"\"\"\n        if isinstance(key, slice):\n            if not (key.step is None or key.step == 1):\n                raise ValueError(\"Slicing with a step other than 1 is not supported.\")\n            return self.window(key.start, key.stop)\n\n        if isinstance(key, datetime):\n            return self.at(key)\n\n        if isinstance(key, SupportsIndex):\n            return self.at(key.__index__())\n\n        raise TypeError(\n            \"Key has to be either a timestamp or an integer \"\n            \"or a slice of timestamps or integers\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.capacity","title":"capacity  <code>property</code>","text":"<pre><code>capacity: int\n</code></pre> <p>Return the capacity of the MovingWindow.</p> <p>Capacity is the maximum number of samples that can be stored in the MovingWindow.</p> RETURNS DESCRIPTION <code>int</code> <p>The capacity of the MovingWindow.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.newest_timestamp","title":"newest_timestamp  <code>property</code>","text":"<pre><code>newest_timestamp: datetime | None\n</code></pre> <p>Return the newest timestamp of the MovingWindow.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The newest timestamp of the MovingWindow or None if the buffer is empty.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.oldest_timestamp","title":"oldest_timestamp  <code>property</code>","text":"<pre><code>oldest_timestamp: datetime | None\n</code></pre> <p>Return the oldest timestamp of the MovingWindow.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The oldest timestamp of the MovingWindow or None if the buffer is empty.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.sampling_period","title":"sampling_period  <code>property</code>","text":"<pre><code>sampling_period: timedelta\n</code></pre> <p>Return the sampling period of the MovingWindow.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The sampling period of the MovingWindow.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    key: SupportsIndex | datetime | slice,\n) -&gt; float | ArrayLike\n</code></pre> <p>Return a sub window of the <code>MovingWindow</code>.</p> <p>The <code>MovingWindow</code> is accessed either by timestamp or by index or by a slice of timestamps or integers.</p> <ul> <li>If the key is an integer, the float value of that key   at the given position is returned.</li> <li>If the key is a timestamp, the float value of that key   that corresponds to the timestamp is returned.</li> <li>If the key is a slice of timestamps or integers, an ndarray is returned,   where the bounds correspond to the slice bounds.   Note that a half open interval, which is open at the end, is returned.</li> </ul> PARAMETER  DESCRIPTION <code>key</code> <p>Either an integer or a timestamp or a slice of timestamps or integers.</p> <p> TYPE: <code>SupportsIndex | datetime | slice</code> </p> RAISES DESCRIPTION <code>IndexError</code> <p>when requesting an out of range timestamp or index</p> <code>TypeError</code> <p>when the key is not a datetime or slice object.</p> RETURNS DESCRIPTION <code>float | ArrayLike</code> <p>A float if the key is a number or a timestamp.</p> <code>float | ArrayLike</code> <p>an numpy array if the key is a slice.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __getitem__(self, key: SupportsIndex | datetime | slice) -&gt; float | ArrayLike:\n    \"\"\"\n    Return a sub window of the `MovingWindow`.\n\n    The `MovingWindow` is accessed either by timestamp or by index\n    or by a slice of timestamps or integers.\n\n    * If the key is an integer, the float value of that key\n      at the given position is returned.\n    * If the key is a timestamp, the float value of that key\n      that corresponds to the timestamp is returned.\n    * If the key is a slice of timestamps or integers, an ndarray is returned,\n      where the bounds correspond to the slice bounds.\n      Note that a half open interval, which is open at the end, is returned.\n\n    Args:\n        key: Either an integer or a timestamp or a slice of timestamps or integers.\n\n    Raises:\n        IndexError: when requesting an out of range timestamp or index\n        TypeError: when the key is not a datetime or slice object.\n\n    Returns:\n        A float if the key is a number or a timestamp.\n        an numpy array if the key is a slice.\n    \"\"\"\n    if isinstance(key, slice):\n        if not (key.step is None or key.step == 1):\n            raise ValueError(\"Slicing with a step other than 1 is not supported.\")\n        return self.window(key.start, key.stop)\n\n    if isinstance(key, datetime):\n        return self.at(key)\n\n    if isinstance(key, SupportsIndex):\n        return self.at(key.__index__())\n\n    raise TypeError(\n        \"Key has to be either a timestamp or an integer \"\n        \"or a slice of timestamps or integers\"\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__init__","title":"__init__","text":"<pre><code>__init__(\n    size: timedelta,\n    resampled_data_recv: Receiver[Sample[Quantity]],\n    input_sampling_period: timedelta,\n    resampler_config: ResamplerConfig | None = None,\n    align_to: datetime = UNIX_EPOCH,\n    *,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Initialize the MovingWindow.</p> <p>This method creates the underlying ring buffer and starts a new task that updates the ring buffer with new incoming samples. The task stops running only if the channel receiver is closed.</p> PARAMETER  DESCRIPTION <code>size</code> <p>The time span of the moving window over which samples will be stored.</p> <p> TYPE: <code>timedelta</code> </p> <code>resampled_data_recv</code> <p>A receiver that delivers samples with a given sampling period.</p> <p> TYPE: <code>Receiver[Sample[Quantity]]</code> </p> <code>input_sampling_period</code> <p>The time interval between consecutive input samples.</p> <p> TYPE: <code>timedelta</code> </p> <code>resampler_config</code> <p>The resampler configuration in case resampling is required.</p> <p> TYPE: <code>ResamplerConfig | None</code> DEFAULT: <code>None</code> </p> <code>align_to</code> <p>A timestamp that defines a point in time to which the window is aligned to modulo window size. For further information, consult the class level documentation.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>UNIX_EPOCH</code> </p> <code>name</code> <p>The name of this moving window. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    size: timedelta,\n    resampled_data_recv: Receiver[Sample[Quantity]],\n    input_sampling_period: timedelta,\n    resampler_config: ResamplerConfig | None = None,\n    align_to: datetime = UNIX_EPOCH,\n    *,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the MovingWindow.\n\n    This method creates the underlying ring buffer and starts a\n    new task that updates the ring buffer with new incoming samples.\n    The task stops running only if the channel receiver is closed.\n\n    Args:\n        size: The time span of the moving window over which samples will be stored.\n        resampled_data_recv: A receiver that delivers samples with a\n            given sampling period.\n        input_sampling_period: The time interval between consecutive input samples.\n        resampler_config: The resampler configuration in case resampling is required.\n        align_to: A timestamp that defines a point in time to which\n            the window is aligned to modulo window size. For further\n            information, consult the class level documentation.\n        name: The name of this moving window. If `None`, `str(id(self))` will be\n            used. This is used mostly for debugging purposes.\n    \"\"\"\n    assert (\n        input_sampling_period.total_seconds() &gt; 0\n    ), \"The input sampling period should be greater than zero.\"\n    assert (\n        input_sampling_period &lt;= size\n    ), \"The input sampling period should be equal to or lower than the window size.\"\n    super().__init__(name=name)\n\n    self._sampling_period = input_sampling_period\n\n    self._resampler: Resampler | None = None\n    self._resampler_sender: Sender[Sample[Quantity]] | None = None\n\n    if resampler_config:\n        assert (\n            resampler_config.resampling_period &lt;= size\n        ), \"The resampling period should be equal to or lower than the window size.\"\n\n        self._resampler = Resampler(resampler_config)\n        self._sampling_period = resampler_config.resampling_period\n\n    # Sampling period might not fit perfectly into the window size.\n    num_samples = math.ceil(\n        size.total_seconds() / self._sampling_period.total_seconds()\n    )\n\n    self._resampled_data_recv = resampled_data_recv\n    self._buffer = OrderedRingBuffer(\n        np.empty(shape=num_samples, dtype=float),\n        sampling_period=self._sampling_period,\n        align_to=align_to,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.at","title":"at","text":"<pre><code>at(key: int | datetime) -&gt; float\n</code></pre> <p>Return the sample at the given index or timestamp.</p> <p>In contrast to the <code>window</code> method, which expects a slice as argument, this method expects a single index as argument and returns a single value.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The index or timestamp of the sample to return.</p> <p> TYPE: <code>int | datetime</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The sample at the given index or timestamp.</p> RAISES DESCRIPTION <code>IndexError</code> <p>If the buffer is empty or the index is out of bounds.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def at(self, key: int | datetime) -&gt; float:  # pylint: disable=invalid-name\n    \"\"\"\n    Return the sample at the given index or timestamp.\n\n    In contrast to the [`window`][frequenz.sdk.timeseries.MovingWindow.window] method,\n    which expects a slice as argument, this method expects a single index as argument\n    and returns a single value.\n\n    Args:\n        key: The index or timestamp of the sample to return.\n\n    Returns:\n        The sample at the given index or timestamp.\n\n    Raises:\n        IndexError: If the buffer is empty or the index is out of bounds.\n    \"\"\"\n    if self._buffer.count_valid() == 0:\n        raise IndexError(\"The buffer is empty.\")\n\n    if isinstance(key, datetime):\n        assert self._buffer.oldest_timestamp is not None\n        assert self._buffer.newest_timestamp is not None\n        if (\n            key &lt; self._buffer.oldest_timestamp\n            or key &gt; self._buffer.newest_timestamp\n        ):\n            raise IndexError(\n                f\"Timestamp {key} is out of range [{self._buffer.oldest_timestamp}, \"\n                f\"{self._buffer.newest_timestamp}]\"\n            )\n        return self._buffer[self._buffer.to_internal_index(key)]\n\n    if isinstance(key, int):\n        _logger.debug(\"Returning value at index %s \", key)\n        timestamp = self._buffer.get_timestamp(key)\n        assert timestamp is not None\n        return self._buffer[self._buffer.to_internal_index(timestamp)]\n\n    raise TypeError(\"Key has to be either a timestamp or an integer.\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.count_covered","title":"count_covered","text":"<pre><code>count_covered() -&gt; int\n</code></pre> <p>Count the number of samples that are covered by the oldest and newest valid samples.</p> RETURNS DESCRIPTION <code>int</code> <p>The count of samples between the oldest and newest (inclusive) valid samples or 0 if there are is no time range covered.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def count_covered(self) -&gt; int:\n    \"\"\"Count the number of samples that are covered by the oldest and newest valid samples.\n\n    Returns:\n        The count of samples between the oldest and newest (inclusive) valid samples\n            or 0 if there are is no time range covered.\n    \"\"\"\n    return self._buffer.count_covered()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.count_valid","title":"count_valid","text":"<pre><code>count_valid() -&gt; int\n</code></pre> <p>Count the number of valid samples in this <code>MovingWindow</code>.</p> RETURNS DESCRIPTION <code>int</code> <p>The number of valid samples in this <code>MovingWindow</code>.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def count_valid(self) -&gt; int:\n    \"\"\"\n    Count the number of valid samples in this `MovingWindow`.\n\n    Returns:\n        The number of valid samples in this `MovingWindow`.\n    \"\"\"\n    return self._buffer.count_valid()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the MovingWindow.</p> <p>This method starts the MovingWindow tasks.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the MovingWindow.\n\n    This method starts the MovingWindow tasks.\n    \"\"\"\n    if self._resampler:\n        self._configure_resampler()\n    self._tasks.add(asyncio.create_task(self._run_impl(), name=\"update-window\"))\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.window","title":"window","text":"<pre><code>window(\n    start: datetime | int | None,\n    end: datetime | int | None,\n    *,\n    force_copy: bool = True,\n    fill_value: float | None = np.nan\n) -&gt; ArrayLike\n</code></pre> <p>Return an array containing the samples in the given time interval.</p> <p>In contrast to the <code>at</code> method, which expects a single index as argument, this method expects a slice as argument and returns an array.</p> PARAMETER  DESCRIPTION <code>start</code> <p>The start timestamp of the time interval. If <code>None</code>, the start of the window is used.</p> <p> TYPE: <code>datetime | int | None</code> </p> <code>end</code> <p>The end timestamp of the time interval. If <code>None</code>, the end of the window is used.</p> <p> TYPE: <code>datetime | int | None</code> </p> <code>force_copy</code> <p>If <code>True</code>, the returned array is a copy of the underlying data. Otherwise, if possible, a view of the underlying data is returned.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>fill_value</code> <p>If not None, will use this value to fill missing values. If missing values should be set, force_copy must be True. Defaults to NaN to avoid returning outdated data unexpectedly.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>nan</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>An array containing the samples in the given time interval.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def window(\n    self,\n    start: datetime | int | None,\n    end: datetime | int | None,\n    *,\n    force_copy: bool = True,\n    fill_value: float | None = np.nan,\n) -&gt; ArrayLike:\n    \"\"\"\n    Return an array containing the samples in the given time interval.\n\n    In contrast to the [`at`][frequenz.sdk.timeseries.MovingWindow.at] method,\n    which expects a single index as argument, this method expects a slice as argument\n    and returns an array.\n\n    Args:\n        start: The start timestamp of the time interval. If `None`, the\n            start of the window is used.\n        end: The end timestamp of the time interval. If `None`, the end of\n            the window is used.\n        force_copy: If `True`, the returned array is a copy of the underlying\n            data. Otherwise, if possible, a view of the underlying data is\n            returned.\n        fill_value: If not None, will use this value to fill missing values.\n            If missing values should be set, force_copy must be True.\n            Defaults to NaN to avoid returning outdated data unexpectedly.\n\n    Returns:\n        An array containing the samples in the given time interval.\n    \"\"\"\n    return self._buffer.window(\n        start, end, force_copy=force_copy, fill_value=fill_value\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage","title":"frequenz.sdk.timeseries.Percentage","text":"<p>             Bases: <code>Quantity</code></p> <p>A percentage quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Percentage(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={0: \"%\"},\n):\n    \"\"\"A percentage quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_percent(cls, percent: float) -&gt; Self:\n        \"\"\"Initialize a new percentage quantity from a percent value.\n\n        Args:\n            percent: The percent value, normally in the 0.0-100.0 range.\n\n        Returns:\n            A new percentage quantity.\n        \"\"\"\n        percentage = cls.__new__(cls)\n        percentage._base_value = percent\n        return percentage\n\n    @classmethod\n    def from_fraction(cls, fraction: float) -&gt; Self:\n        \"\"\"Initialize a new percentage quantity from a fraction.\n\n        Args:\n            fraction: The fraction, normally in the 0.0-1.0 range.\n\n        Returns:\n            A new percentage quantity.\n        \"\"\"\n        percentage = cls.__new__(cls)\n        percentage._base_value = fraction * 100\n        return percentage\n\n    def as_percent(self) -&gt; float:\n        \"\"\"Return this quantity as a percentage.\n\n        Returns:\n            This quantity as a percentage.\n        \"\"\"\n        return self._base_value\n\n    def as_fraction(self) -&gt; float:\n        \"\"\"Return this quantity as a fraction.\n\n        Returns:\n            This quantity as a fraction.\n        \"\"\"\n        return self._base_value / 100\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__mul__","title":"__mul__","text":"<pre><code>__mul__(percent: Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a percentage.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percentage by which to scale this quantity.</p> <p> TYPE: <code>Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, percent: Percentage) -&gt; Self:\n    \"\"\"Scale this quantity by a percentage.\n\n    Args:\n        percent: The percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    if not isinstance(percent, Percentage):\n        return NotImplemented\n\n    product = type(self).__new__(type(self))\n    product._base_value = self._base_value * percent.as_fraction()\n    return product\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.as_fraction","title":"as_fraction","text":"<pre><code>as_fraction() -&gt; float\n</code></pre> <p>Return this quantity as a fraction.</p> RETURNS DESCRIPTION <code>float</code> <p>This quantity as a fraction.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_fraction(self) -&gt; float:\n    \"\"\"Return this quantity as a fraction.\n\n    Returns:\n        This quantity as a fraction.\n    \"\"\"\n    return self._base_value / 100\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.as_percent","title":"as_percent","text":"<pre><code>as_percent() -&gt; float\n</code></pre> <p>Return this quantity as a percentage.</p> RETURNS DESCRIPTION <code>float</code> <p>This quantity as a percentage.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_percent(self) -&gt; float:\n    \"\"\"Return this quantity as a percentage.\n\n    Returns:\n        This quantity as a percentage.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.from_fraction","title":"from_fraction  <code>classmethod</code>","text":"<pre><code>from_fraction(fraction: float) -&gt; Self\n</code></pre> <p>Initialize a new percentage quantity from a fraction.</p> PARAMETER  DESCRIPTION <code>fraction</code> <p>The fraction, normally in the 0.0-1.0 range.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new percentage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_fraction(cls, fraction: float) -&gt; Self:\n    \"\"\"Initialize a new percentage quantity from a fraction.\n\n    Args:\n        fraction: The fraction, normally in the 0.0-1.0 range.\n\n    Returns:\n        A new percentage quantity.\n    \"\"\"\n    percentage = cls.__new__(cls)\n    percentage._base_value = fraction * 100\n    return percentage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.from_percent","title":"from_percent  <code>classmethod</code>","text":"<pre><code>from_percent(percent: float) -&gt; Self\n</code></pre> <p>Initialize a new percentage quantity from a percent value.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percent value, normally in the 0.0-100.0 range.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new percentage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_percent(cls, percent: float) -&gt; Self:\n    \"\"\"Initialize a new percentage quantity from a percent value.\n\n    Args:\n        percent: The percent value, normally in the 0.0-100.0 range.\n\n    Returns:\n        A new percentage quantity.\n    \"\"\"\n    percentage = cls.__new__(cls)\n    percentage._base_value = percent\n    return percentage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER  DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.\n\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor","title":"frequenz.sdk.timeseries.PeriodicFeatureExtractor","text":"<p>A feature extractor for historical timeseries data.</p> <p>This class is creating a profile from periodically occurring windows in a buffer of historical data.</p> <p>The profile is created out of all windows that are fully contained in the underlying buffer with the same start and end time modulo a fixed period.</p> <p>Consider for example a timeseries $T$ of historical data and sub-series $S_i$ of $T$ all having the same size $l$ and the same fixed distance $p$ called period, where period of two sub-windows is defined as the distance of two points at the same position within the sub-windows.</p> <p>This class calculates a statistical profile $S$ over all $S_i$, i.e. the value of $S$ at position $i$ is calculated by performing a certain calculation, e.g. an average, over all values of $S_i$ at position $i$.</p> Note <p>The oldest window or the window that is currently overwritten in the <code>MovingWindow</code> is not considered in the profile.</p> Note <p>When constructing a <code>PeriodicFeatureExtractor</code> object the <code>MovingWindow</code> size has to be a integer multiple of the period.</p> Example <pre><code>from frequenz.sdk import microgrid\nfrom datetime import datetime, timedelta, timezone\n\nasync with MovingWindow(\n    size=timedelta(days=35),\n    resampled_data_recv=microgrid.grid().power.new_receiver(),\n    input_sampling_period=timedelta(seconds=1),\n) as moving_window:\n    feature_extractor = PeriodicFeatureExtractor(\n        moving_window=moving_window,\n        period=timedelta(days=7),\n    )\n\n    now = datetime.now(timezone.utc)\n\n    # create a daily weighted average for the next 24h\n    avg_24h = feature_extractor.avg(\n        now,\n        now + timedelta(hours=24),\n        weights=[0.1, 0.2, 0.3, 0.4]\n    )\n\n    # create a daily average for Thursday March 23 2023\n    th_avg_24h = feature_extractor.avg(datetime(2023, 3, 23), datetime(2023, 3, 24))\n</code></pre> Source code in <code>frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>class PeriodicFeatureExtractor:\n    \"\"\"\n    A feature extractor for historical timeseries data.\n\n    This class is creating a profile from periodically occurring windows in a\n    buffer of historical data.\n\n    The profile is created out of all windows that are fully contained in the\n    underlying buffer with the same start and end time modulo a fixed period.\n\n    Consider for example a timeseries $T$ of historical data and sub-series\n    $S_i$ of $T$ all having the same size $l$ and the same fixed distance $p$\n    called period, where period of two sub-windows is defined as the distance\n    of two points at the same position within the sub-windows.\n\n    This class calculates a statistical profile $S$ over all $S_i$, i.e. the\n    value of $S$ at position $i$ is calculated by performing a certain\n    calculation, e.g. an average, over all values of $S_i$ at position $i$.\n\n    Note:\n        The oldest window or the window that is currently overwritten in the\n        `MovingWindow` is not considered in the profile.\n\n    Note:\n        When constructing a `PeriodicFeatureExtractor` object the\n        `MovingWindow` size has to be a integer multiple of the period.\n\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n        from datetime import datetime, timedelta, timezone\n\n        async with MovingWindow(\n            size=timedelta(days=35),\n            resampled_data_recv=microgrid.grid().power.new_receiver(),\n            input_sampling_period=timedelta(seconds=1),\n        ) as moving_window:\n            feature_extractor = PeriodicFeatureExtractor(\n                moving_window=moving_window,\n                period=timedelta(days=7),\n            )\n\n            now = datetime.now(timezone.utc)\n\n            # create a daily weighted average for the next 24h\n            avg_24h = feature_extractor.avg(\n                now,\n                now + timedelta(hours=24),\n                weights=[0.1, 0.2, 0.3, 0.4]\n            )\n\n            # create a daily average for Thursday March 23 2023\n            th_avg_24h = feature_extractor.avg(datetime(2023, 3, 23), datetime(2023, 3, 24))\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        moving_window: MovingWindow,\n        period: timedelta,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a PeriodicFeatureExtractor object.\n\n        Args:\n            moving_window: The MovingWindow that is used for the average calculation.\n            period: The distance between two succeeding intervals.\n\n        Raises:\n            ValueError: If the MovingWindow size is not a integer multiple of the period.\n        \"\"\"\n        self._moving_window = moving_window\n\n        self._sampling_period = self._moving_window.sampling_period\n        \"\"\"The sampling_period as float to use it for indexing of samples.\"\"\"\n\n        self._period = int(period / self._sampling_period)\n        \"\"\"Distance between two succeeding intervals in samples.\"\"\"\n\n        _logger.debug(\"Initializing PeriodicFeatureExtractor!\")\n        _logger.debug(\"MovingWindow size: %i\", self._moving_window.count_valid())\n        _logger.debug(\n            \"Period between two succeeding intervals (in samples): %i\",\n            self._period,\n        )\n\n        if not self._moving_window.count_valid() % self._period == 0:\n            raise ValueError(\n                \"The MovingWindow size is not a integer multiple of the period.\"\n            )\n\n        if not is_close_to_zero(self._period - period / self._sampling_period):\n            raise ValueError(\n                \"The period is not a multiple of the sampling period. \"\n                \"This might result in unexpected behaviour.\"\n            )\n\n    @property\n    def _buffer(self) -&gt; OrderedRingBuffer[NDArray[np.float64]]:\n        return self._moving_window._buffer  # pylint: disable=protected-access\n\n    def _timestamp_to_rel_index(self, timestamp: datetime) -&gt; int:\n        \"\"\"\n        Get the index of a timestamp relative to the oldest sample in the MovingWindow.\n\n        In other word consider an integer axis where the zero is defined as the\n        oldest element in the MovingWindow. This function returns the index of\n        the given timestamp an this axis.\n\n        This method can return negative values.\n\n        Args:\n            timestamp: A timestamp that we want to shift into the window.\n\n        Returns:\n            The index of the timestamp shifted into the MovingWindow.\n        \"\"\"\n        # align timestamp to the sampling period\n        timestamp = self._buffer.normalize_timestamp(timestamp)\n\n        # distance between the input ts and the ts of oldest known samples (in samples)\n        dist_to_oldest = int(\n            (timestamp - self._buffer.time_bound_oldest) / self._sampling_period\n        )\n\n        _logger.debug(\"Shifting ts: %s\", timestamp)\n        _logger.debug(\"Oldest timestamp in buffer: %s\", self._buffer.time_bound_oldest)\n        _logger.debug(\"Distance to the oldest sample: %i\", dist_to_oldest)\n\n        return dist_to_oldest\n\n    def _reshape_np_array(\n        self, array: NDArray[np.float_], window_size: int\n    ) -&gt; NDArray[np.float_]:\n        \"\"\"\n        Reshape a numpy array to a 2D array where each row represents a window.\n\n        There are three cases to consider\n\n        1. The array size is a multiple of window_size + period,\n           i.e. num_windows is integer and we can simply reshape.\n        2. The array size is NOT a multiple of window_size + period and\n           it has length n * period + m, where m &lt; window_size.\n        3. The array size is NOT a multiple of window_size + period and\n           it has length n * period + m, where m &gt;= window_size.\n\n        Note that in the current implementation of this class we have the restriction\n        that period is a multiple integer of the size of the MovingWindow and hence\n        only case 1 can occur.\n\n        Args:\n            array: The numpy array to reshape.\n            window_size: The size of the window in samples.\n\n        Returns:\n            The reshaped 2D array.\n\n        Raises:\n            ValueError: If the array is smaller or equal to the given period.\n        \"\"\"\n        # Not using the num_windows function here because we want to\n        # differentiate between the three cases.\n        if len(array) &lt; self._period:\n            raise ValueError(\n                f\"The array (length:{len(array)}) is too small to be reshaped.\"\n            )\n\n        num_windows = len(array) // self._period\n\n        # Case 1:\n        if len(array) - num_windows * self._period == 0:\n            resized_array = array\n        # Case 2\n        elif len(array) - num_windows * self._period &lt; window_size:\n            resized_array = array[: num_windows * self._period]\n        # Case 3\n        else:\n            num_windows += 1\n            resized_array = np.resize(array, num_windows * self._period)\n\n        return resized_array.reshape(num_windows, self._period)\n\n    def _get_relative_positions(\n        self, start: datetime, window_size: int\n    ) -&gt; RelativePositions:\n        \"\"\"\n        Return relative positions of the MovingWindow.\n\n        This method calculates the shifted relative positions of the start\n        timestamp, the end timestamps as well as the next position that is\n        overwritten in the ringbuffer.\n        Shifted in that context means that the positions are moved as close\n        assume possible to the oldest sample in the MovingWindow.\n\n        Args:\n            start: The start timestamp of the window.\n            window_size: The size of the window in samples.\n\n        Returns:\n            The relative positions of the start, end and next samples.\n        \"\"\"\n        # The number of usable windows can change, when the current position of\n        # the ringbuffer is inside one of the windows inside the MovingWindow.\n        # Since this is possible, we assume that one window is always not used\n        # for the average calculation.\n        #\n        # We are ignoring either the window that is currently overwritten if\n        # the current position is inside that window or the window that would\n        # be overwritten next.\n        #\n        # Move the window to its first appearance in the MovingWindow relative\n        # to the oldest sample stored in the MovingWindow.\n        #\n        # In other words the oldest stored sample is considered to have index 0.\n        #\n        # Note that the returned value is a index not a timestamp\n        rel_start_sample = self._timestamp_to_rel_index(start) % self._period\n        rel_end_sample = rel_start_sample + window_size\n\n        # check if the newest time bound, i.e. the sample that is currently written,\n        # is inside the interval\n        rb_current_position = self._buffer.time_bound_newest\n        rel_next_position = (\n            self._timestamp_to_rel_index(rb_current_position) + 1\n        ) % self._period\n        # fix the rel_next_position if modulo period the next position\n        # is smaller then the start sample position\n        if rel_next_position &lt; rel_start_sample:\n            rel_next_position += self._period\n\n        rel_next_position += self._period * (window_size // self._period)\n\n        _logger.debug(\"current position of the ringbuffer: %s\", rb_current_position)\n        _logger.debug(\"relative start_sample: %s\", rel_start_sample)\n        _logger.debug(\"relative end_sample: %s\", rel_end_sample)\n        _logger.debug(\"relative next_position: %s\", rel_next_position)\n\n        return RelativePositions(rel_start_sample, rel_end_sample, rel_next_position)\n\n    def _get_buffer_bounds(\n        self, start: datetime, end: datetime\n    ) -&gt; tuple[int, int, int]:\n        \"\"\"\n        Get the bounds of the ringbuffer used for further operations.\n\n        This method uses the given start and end timestamps to calculate the\n        part of the ringbuffer that can be used for further operations, like\n        average or min/max.\n\n        Here we cut out the oldest window or the window that is currently\n        overwritten in the MovingWindow such that it is not considered in any\n        further operation.\n\n        Args:\n            start: The start timestamp of the window.\n            end: The end timestamp of the window.\n\n        Returns:\n            The bounds of the to be used buffer and the window size.\n\n        Raises:\n            ValueError: If the start timestamp is after the end timestamp.\n        \"\"\"\n        window_size = self._timestamp_to_rel_index(end) - self._timestamp_to_rel_index(\n            start\n        )\n        if window_size &lt;= 0:\n            raise ValueError(\"Start timestamp must be before end timestamp\")\n        if window_size &gt; self._period:\n            raise ValueError(\n                \"The window size must be smaller or equal than the period.\"\n            )\n\n        rel_pos = self._get_relative_positions(start, window_size)\n\n        if window_size &gt; self._moving_window.count_valid():\n            raise ValueError(\n                \"The window size must be smaller than the size of the `MovingWindow`\"\n            )\n\n        # shifted distance between the next incoming sample and the start of the window\n        dist_to_start = rel_pos.next - rel_pos.start\n\n        # get the start and end position inside the ringbuffer\n        end_pos = (\n            self._timestamp_to_rel_index(self._buffer.time_bound_newest) + 1\n        ) - dist_to_start\n\n        # Note that these check is working since we are using the positions\n        # relative to the oldest sample stored in the MovingWindow.\n        if rel_pos.start &lt;= rel_pos.next &lt; rel_pos.end:\n            # end position is start_position of the window that is currently written\n            # that's how end_pos is currently set\n            _logger.debug(\"Next sample will be inside the window time interval!\")\n        else:\n            _logger.debug(\"Next sample will be outside the window time interval!\")\n            # end position is start_position of the window that\n            # is overwritten next, hence we adding period.\n            end_pos += self._period\n\n        # add the offset to the oldest sample in the ringbuffer and wrap around\n        # to get the start and end positions in the ringbuffer\n        rb_offset = self._buffer.to_internal_index(self._buffer.time_bound_oldest)\n        start_pos = self._buffer.wrap(end_pos + self._period + rb_offset)\n        end_pos = self._buffer.wrap(end_pos + rb_offset)\n\n        _logger.debug(\"start_pos in ringbuffer: %s\", start_pos)\n        _logger.debug(\"end_pos in ringbuffer: %s\", end_pos)\n\n        return (start_pos, end_pos, window_size)\n\n    def _get_reshaped_np_array(\n        self, start: datetime, end: datetime\n    ) -&gt; tuple[NDArray[np.float_], int]:\n        \"\"\"\n        Create a reshaped numpy array from the MovingWindow.\n\n        The reshaped array is a two dimensional array, where one dimension is\n        the window_size and the other the number of windows returned by the\n        `_get_buffer_bounds` method.\n\n        Args:\n            start: The start timestamp of the window.\n            end: The end timestamp of the window.\n\n        Returns:\n            A tuple containing the reshaped numpy array and the window size.\n        \"\"\"\n        (start_pos, end_pos, window_size) = self._get_buffer_bounds(start, end)\n\n        if start_pos &gt;= end_pos:\n            window_start = self._buffer[start_pos : self._moving_window.count_valid()]\n            window_end = self._buffer[0:end_pos]\n            # make the linter happy\n            assert isinstance(window_start, np.ndarray)\n            assert isinstance(window_end, np.ndarray)\n            window_array = np.concatenate((window_start, window_end))\n        else:\n            window_array = self._buffer[start_pos:end_pos]\n\n        return (self._reshape_np_array(window_array, window_size), window_size)\n\n    def avg(\n        self, start: datetime, end: datetime, weights: list[float] | None = None\n    ) -&gt; NDArray[np.float_]:\n        \"\"\"\n        Create the average window out of the window defined by `start` and `end`.\n\n        This method calculates the average of a window by averaging over all\n        windows fully inside the MovingWindow having the period\n        `self.period`.\n\n        Args:\n            start: The start of the window to average over.\n            end: The end of the window to average over.\n            weights: The weights to use for the average calculation (oldest first).\n\n        Returns:\n            The averaged timeseries window.\n        \"\"\"\n        (reshaped, window_size) = self._get_reshaped_np_array(start, end)\n        return np.average(  # type: ignore[no-any-return]\n            reshaped[:, :window_size], axis=0, weights=weights\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor.__init__","title":"__init__","text":"<pre><code>__init__(\n    moving_window: MovingWindow, period: timedelta\n) -&gt; None\n</code></pre> <p>Initialize a PeriodicFeatureExtractor object.</p> PARAMETER  DESCRIPTION <code>moving_window</code> <p>The MovingWindow that is used for the average calculation.</p> <p> TYPE: <code>MovingWindow</code> </p> <code>period</code> <p>The distance between two succeeding intervals.</p> <p> TYPE: <code>timedelta</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the MovingWindow size is not a integer multiple of the period.</p> Source code in <code>frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>def __init__(\n    self,\n    moving_window: MovingWindow,\n    period: timedelta,\n) -&gt; None:\n    \"\"\"\n    Initialize a PeriodicFeatureExtractor object.\n\n    Args:\n        moving_window: The MovingWindow that is used for the average calculation.\n        period: The distance between two succeeding intervals.\n\n    Raises:\n        ValueError: If the MovingWindow size is not a integer multiple of the period.\n    \"\"\"\n    self._moving_window = moving_window\n\n    self._sampling_period = self._moving_window.sampling_period\n    \"\"\"The sampling_period as float to use it for indexing of samples.\"\"\"\n\n    self._period = int(period / self._sampling_period)\n    \"\"\"Distance between two succeeding intervals in samples.\"\"\"\n\n    _logger.debug(\"Initializing PeriodicFeatureExtractor!\")\n    _logger.debug(\"MovingWindow size: %i\", self._moving_window.count_valid())\n    _logger.debug(\n        \"Period between two succeeding intervals (in samples): %i\",\n        self._period,\n    )\n\n    if not self._moving_window.count_valid() % self._period == 0:\n        raise ValueError(\n            \"The MovingWindow size is not a integer multiple of the period.\"\n        )\n\n    if not is_close_to_zero(self._period - period / self._sampling_period):\n        raise ValueError(\n            \"The period is not a multiple of the sampling period. \"\n            \"This might result in unexpected behaviour.\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor.avg","title":"avg","text":"<pre><code>avg(\n    start: datetime,\n    end: datetime,\n    weights: list[float] | None = None,\n) -&gt; NDArray[float_]\n</code></pre> <p>Create the average window out of the window defined by <code>start</code> and <code>end</code>.</p> <p>This method calculates the average of a window by averaging over all windows fully inside the MovingWindow having the period <code>self.period</code>.</p> PARAMETER  DESCRIPTION <code>start</code> <p>The start of the window to average over.</p> <p> TYPE: <code>datetime</code> </p> <code>end</code> <p>The end of the window to average over.</p> <p> TYPE: <code>datetime</code> </p> <code>weights</code> <p>The weights to use for the average calculation (oldest first).</p> <p> TYPE: <code>list[float] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>NDArray[float_]</code> <p>The averaged timeseries window.</p> Source code in <code>frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>def avg(\n    self, start: datetime, end: datetime, weights: list[float] | None = None\n) -&gt; NDArray[np.float_]:\n    \"\"\"\n    Create the average window out of the window defined by `start` and `end`.\n\n    This method calculates the average of a window by averaging over all\n    windows fully inside the MovingWindow having the period\n    `self.period`.\n\n    Args:\n        start: The start of the window to average over.\n        end: The end of the window to average over.\n        weights: The weights to use for the average calculation (oldest first).\n\n    Returns:\n        The averaged timeseries window.\n    \"\"\"\n    (reshaped, window_size) = self._get_reshaped_np_array(start, end)\n    return np.average(  # type: ignore[no-any-return]\n        reshaped[:, :window_size], axis=0, weights=weights\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power","title":"frequenz.sdk.timeseries.Power","text":"<p>             Bases: <code>Quantity</code></p> <p>A power quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Power(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={\n        -3: \"mW\",\n        0: \"W\",\n        3: \"kW\",\n        6: \"MW\",\n    },\n):\n    \"\"\"A power quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_watts(cls, watts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            watts: The power in watts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        power = cls.__new__(cls)\n        power._base_value = watts\n        return power\n\n    @classmethod\n    def from_milliwatts(cls, milliwatts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            milliwatts: The power in milliwatts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        power = cls.__new__(cls)\n        power._base_value = milliwatts * 10**-3\n        return power\n\n    @classmethod\n    def from_kilowatts(cls, kilowatts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            kilowatts: The power in kilowatts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        power = cls.__new__(cls)\n        power._base_value = kilowatts * 10**3\n        return power\n\n    @classmethod\n    def from_megawatts(cls, megawatts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            megawatts: The power in megawatts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        power = cls.__new__(cls)\n        power._base_value = megawatts * 10**6\n        return power\n\n    def as_watts(self) -&gt; float:\n        \"\"\"Return the power in watts.\n\n        Returns:\n            The power in watts.\n        \"\"\"\n        return self._base_value\n\n    def as_kilowatts(self) -&gt; float:\n        \"\"\"Return the power in kilowatts.\n\n        Returns:\n            The power in kilowatts.\n        \"\"\"\n        return self._base_value / 1e3\n\n    def as_megawatts(self) -&gt; float:\n        \"\"\"Return the power in megawatts.\n\n        Returns:\n            The power in megawatts.\n        \"\"\"\n        return self._base_value / 1e6\n\n    @overload  # type: ignore\n    def __mul__(self, other: Percentage) -&gt; Self:\n        \"\"\"Scale this power by a percentage.\n\n        Args:\n            other: The percentage by which to scale this power.\n\n        Returns:\n            The scaled power.\n        \"\"\"\n\n    @overload\n    def __mul__(self, other: timedelta) -&gt; Energy:\n        \"\"\"Return an energy from multiplying this power by the given duration.\n\n        Args:\n            other: The duration to multiply by.\n\n        Returns:\n            The calculated energy.\n        \"\"\"\n\n    def __mul__(self, other: Percentage | timedelta) -&gt; Self | Energy:\n        \"\"\"Return a power or energy from multiplying this power by the given value.\n\n        Args:\n            other: The percentage or duration to multiply by.\n\n        Returns:\n            A power or energy.\n        \"\"\"\n        if isinstance(other, Percentage):\n            return super().__mul__(other)\n        if isinstance(other, timedelta):\n            return Energy.from_watt_hours(\n                self._base_value * other.total_seconds() / 3600.0\n            )\n\n        return NotImplemented\n\n    @overload\n    def __truediv__(self, other: Current) -&gt; Voltage:\n        \"\"\"Return a voltage from dividing this power by the given current.\n\n        Args:\n            other: The current to divide by.\n\n        Returns:\n            A voltage from dividing this power by the a current.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, other: Voltage) -&gt; Current:\n        \"\"\"Return a current from dividing this power by the given voltage.\n\n        Args:\n            other: The voltage to divide by.\n\n        Returns:\n            A current from dividing this power by a voltage.\n        \"\"\"\n\n    def __truediv__(self, other: Current | Voltage) -&gt; Voltage | Current:\n        \"\"\"Return a current or voltage from dividing this power by the given value.\n\n        Args:\n            other: The current or voltage to divide by.\n\n        Returns:\n            A current or voltage from dividing this power by the given value.\n\n        Raises:\n            TypeError: If the given value is not a current or voltage.\n        \"\"\"\n        if isinstance(other, Current):\n            return Voltage.from_volts(self._base_value / other._base_value)\n        if isinstance(other, Voltage):\n            return Current.from_amperes(self._base_value / other._base_value)\n        raise TypeError(\n            f\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Percentage | timedelta) -&gt; Self | Energy\n</code></pre> <p>Return a power or energy from multiplying this power by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The percentage or duration to multiply by.</p> <p> TYPE: <code>Percentage | timedelta</code> </p> RETURNS DESCRIPTION <code>Self | Energy</code> <p>A power or energy.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: Percentage | timedelta) -&gt; Self | Energy:\n    \"\"\"Return a power or energy from multiplying this power by the given value.\n\n    Args:\n        other: The percentage or duration to multiply by.\n\n    Returns:\n        A power or energy.\n    \"\"\"\n    if isinstance(other, Percentage):\n        return super().__mul__(other)\n    if isinstance(other, timedelta):\n        return Energy.from_watt_hours(\n            self._base_value * other.total_seconds() / 3600.0\n        )\n\n    return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Current | Voltage) -&gt; Voltage | Current\n</code></pre> <p>Return a current or voltage from dividing this power by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The current or voltage to divide by.</p> <p> TYPE: <code>Current | Voltage</code> </p> RETURNS DESCRIPTION <code>Voltage | Current</code> <p>A current or voltage from dividing this power by the given value.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given value is not a current or voltage.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, other: Current | Voltage) -&gt; Voltage | Current:\n    \"\"\"Return a current or voltage from dividing this power by the given value.\n\n    Args:\n        other: The current or voltage to divide by.\n\n    Returns:\n        A current or voltage from dividing this power by the given value.\n\n    Raises:\n        TypeError: If the given value is not a current or voltage.\n    \"\"\"\n    if isinstance(other, Current):\n        return Voltage.from_volts(self._base_value / other._base_value)\n    if isinstance(other, Voltage):\n        return Current.from_amperes(self._base_value / other._base_value)\n    raise TypeError(\n        f\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_kilowatts","title":"as_kilowatts","text":"<pre><code>as_kilowatts() -&gt; float\n</code></pre> <p>Return the power in kilowatts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in kilowatts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilowatts(self) -&gt; float:\n    \"\"\"Return the power in kilowatts.\n\n    Returns:\n        The power in kilowatts.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_megawatts","title":"as_megawatts","text":"<pre><code>as_megawatts() -&gt; float\n</code></pre> <p>Return the power in megawatts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in megawatts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megawatts(self) -&gt; float:\n    \"\"\"Return the power in megawatts.\n\n    Returns:\n        The power in megawatts.\n    \"\"\"\n    return self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_watts","title":"as_watts","text":"<pre><code>as_watts() -&gt; float\n</code></pre> <p>Return the power in watts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in watts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_watts(self) -&gt; float:\n    \"\"\"Return the power in watts.\n\n    Returns:\n        The power in watts.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_kilowatts","title":"from_kilowatts  <code>classmethod</code>","text":"<pre><code>from_kilowatts(kilowatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>kilowatts</code> <p>The power in kilowatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilowatts(cls, kilowatts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        kilowatts: The power in kilowatts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    power = cls.__new__(cls)\n    power._base_value = kilowatts * 10**3\n    return power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_megawatts","title":"from_megawatts  <code>classmethod</code>","text":"<pre><code>from_megawatts(megawatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>megawatts</code> <p>The power in megawatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megawatts(cls, megawatts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        megawatts: The power in megawatts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    power = cls.__new__(cls)\n    power._base_value = megawatts * 10**6\n    return power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_milliwatts","title":"from_milliwatts  <code>classmethod</code>","text":"<pre><code>from_milliwatts(milliwatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>milliwatts</code> <p>The power in milliwatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_milliwatts(cls, milliwatts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        milliwatts: The power in milliwatts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    power = cls.__new__(cls)\n    power._base_value = milliwatts * 10**-3\n    return power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER  DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_watts","title":"from_watts  <code>classmethod</code>","text":"<pre><code>from_watts(watts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>watts</code> <p>The power in watts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_watts(cls, watts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        watts: The power in watts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    power = cls.__new__(cls)\n    power._base_value = watts\n    return power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.\n\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity","title":"frequenz.sdk.timeseries.Quantity","text":"<p>A quantity with a unit.</p> <p>Quantities try to behave like float and are also immutable.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Quantity:\n    \"\"\"A quantity with a unit.\n\n    Quantities try to behave like float and are also immutable.\n    \"\"\"\n\n    _base_value: float\n    \"\"\"The value of this quantity in the base unit.\"\"\"\n\n    _exponent_unit_map: dict[int, str] | None = None\n    \"\"\"A mapping from the exponent of the base unit to the unit symbol.\n\n    If None, this quantity has no unit.  None is possible only when using the base\n    class.  Sub-classes must define this.\n    \"\"\"\n\n    def __init__(self, value: float, exponent: int = 0) -&gt; None:\n        \"\"\"Initialize a new quantity.\n\n        Args:\n            value: The value of this quantity in a given exponent of the base unit.\n            exponent: The exponent of the base unit the given value is in.\n        \"\"\"\n        self._base_value = value * 10**exponent\n\n    def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n        \"\"\"Initialize a new subclass of Quantity.\n\n        Args:\n            exponent_unit_map: A mapping from the exponent of the base unit to the unit\n                symbol.\n\n        Raises:\n            TypeError: If the given exponent_unit_map is not a dict.\n            ValueError: If the given exponent_unit_map does not contain a base unit\n                (exponent 0).\n        \"\"\"\n        if 0 not in exponent_unit_map:\n            raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n        cls._exponent_unit_map = exponent_unit_map\n        super().__init_subclass__()\n\n    _zero_cache: dict[type, Quantity] = {}\n    \"\"\"Cache for zero singletons.\n\n    This is a workaround for mypy getting confused when using @functools.cache and\n    @classmethod combined with returning Self. It believes the resulting type of this\n    method is Self and complains that members of the actual class don't exist in Self,\n    so we need to implement the cache ourselves.\n    \"\"\"\n\n    @classmethod\n    def zero(cls) -&gt; Self:\n        \"\"\"Return a quantity with value 0.\n\n        Returns:\n            A quantity with value 0.\n        \"\"\"\n        _zero = cls._zero_cache.get(cls, None)\n        if _zero is None:\n            _zero = cls.__new__(cls)\n            _zero._base_value = 0\n            cls._zero_cache[cls] = _zero\n        assert isinstance(_zero, cls)\n        return _zero\n\n    @classmethod\n    def from_string(cls, string: str) -&gt; Self:\n        \"\"\"Return a quantity from a string representation.\n\n        Args:\n            string: The string representation of the quantity.\n\n        Returns:\n            A quantity object with the value given in the string.\n\n        Raises:\n            ValueError: If the string does not match the expected format.\n\n        \"\"\"\n        split_string = string.split(\" \")\n\n        if len(split_string) != 2:\n            raise ValueError(\n                f\"Expected a string of the form 'value unit', got {string}\"\n            )\n\n        assert cls._exponent_unit_map is not None\n        exp_map = cls._exponent_unit_map\n\n        for exponent, unit in exp_map.items():\n            if unit == split_string[1]:\n                instance = cls.__new__(cls)\n                try:\n                    instance._base_value = float(split_string[0]) * 10**exponent\n                except ValueError as error:\n                    raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n                return instance\n\n        raise ValueError(f\"Unknown unit {split_string[1]}\")\n\n    @property\n    def base_value(self) -&gt; float:\n        \"\"\"Return the value of this quantity in the base unit.\n\n        Returns:\n            The value of this quantity in the base unit.\n        \"\"\"\n        return self._base_value\n\n    @property\n    def base_unit(self) -&gt; str | None:\n        \"\"\"Return the base unit of this quantity.\n\n        None if this quantity has no unit.\n\n        Returns:\n            The base unit of this quantity.\n        \"\"\"\n        if not self._exponent_unit_map:\n            return None\n        return self._exponent_unit_map[0]\n\n    def isnan(self) -&gt; bool:\n        \"\"\"Return whether this quantity is NaN.\n\n        Returns:\n            Whether this quantity is NaN.\n        \"\"\"\n        return math.isnan(self._base_value)\n\n    def isinf(self) -&gt; bool:\n        \"\"\"Return whether this quantity is infinite.\n\n        Returns:\n            Whether this quantity is infinite.\n        \"\"\"\n        return math.isinf(self._base_value)\n\n    def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n        \"\"\"Return whether this quantity is close to another.\n\n        Args:\n            other: The quantity to compare to.\n            rel_tol: The relative tolerance.\n            abs_tol: The absolute tolerance.\n\n        Returns:\n            Whether this quantity is close to another.\n        \"\"\"\n        return math.isclose(\n            self._base_value,\n            other._base_value,  # pylint: disable=protected-access\n            rel_tol=rel_tol,\n            abs_tol=abs_tol,\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a representation of this quantity.\n\n        Returns:\n            A representation of this quantity.\n        \"\"\"\n        return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this quantity.\n\n        Returns:\n            A string representation of this quantity.\n        \"\"\"\n        return self.__format__(\"\")\n\n    # pylint: disable=too-many-branches\n    def __format__(self, __format_spec: str) -&gt; str:\n        \"\"\"Return a formatted string representation of this quantity.\n\n        If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n        trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n        The returned string will use the unit that will result in the maximum precision,\n        based on the magnitude of the value.\n\n        Example:\n            ```python\n            from frequenz.sdk.timeseries import Current\n            c = Current.from_amperes(0.2345)\n            assert f\"{c:.2}\" == \"234.5 mA\"\n            c = Current.from_amperes(1.2345)\n            assert f\"{c:.2}\" == \"1.23 A\"\n            c = Current.from_milliamperes(1.2345)\n            assert f\"{c:.6}\" == \"1.2345 mA\"\n            ```\n\n        Args:\n            __format_spec: The format specifier.\n\n        Returns:\n            A string representation of this quantity.\n\n        Raises:\n            ValueError: If the given format specifier is invalid.\n        \"\"\"\n        keep_trailing_zeros = False\n        if __format_spec != \"\":\n            fspec_parts = __format_spec.split(\".\")\n            if (\n                len(fspec_parts) != 2\n                or fspec_parts[0] not in (\"\", \"0\")\n                or not fspec_parts[1].isdigit()\n            ):\n                raise ValueError(\n                    \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n                )\n            if fspec_parts[0] == \"0\":\n                keep_trailing_zeros = True\n            precision = int(fspec_parts[1])\n        else:\n            precision = 3\n        if not self._exponent_unit_map:\n            return f\"{self._base_value:.{precision}f}\"\n\n        if math.isinf(self._base_value) or math.isnan(self._base_value):\n            return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n        if abs_value := abs(self._base_value):\n            precision_pow = 10 ** (precision)\n            # Prevent numbers like 999.999999 being rendered as 1000 V\n            # instead of 1 kV.\n            # This could happen because the str formatting function does\n            # rounding as well.\n            # This is an imperfect solution that works for _most_ cases.\n            # isclose parameters were chosen according to the observed cases\n            if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n                # If the value is close to the precision, round it\n                exponent = math.ceil(math.log10(precision_pow))\n            else:\n                exponent = math.floor(math.log10(abs_value))\n        else:\n            exponent = 0\n\n        unit_place = exponent - exponent % 3\n        if unit_place &lt; min(self._exponent_unit_map):\n            unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n            unit_place = min(self._exponent_unit_map)\n        elif unit_place &gt; max(self._exponent_unit_map):\n            unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n            unit_place = max(self._exponent_unit_map)\n        else:\n            unit = self._exponent_unit_map[unit_place]\n\n        value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n        if value_str in (\"-0\", \"0\"):\n            stripped = value_str\n        else:\n            stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n        if not keep_trailing_zeros:\n            value_str = stripped\n        unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n        return f\"{value_str} {unit_str}\"\n\n    def __add__(self, other: Self) -&gt; Self:\n        \"\"\"Return the sum of this quantity and another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            The sum of this quantity and another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        summe = type(self).__new__(type(self))\n        summe._base_value = self._base_value + other._base_value\n        return summe\n\n    def __sub__(self, other: Self) -&gt; Self:\n        \"\"\"Return the difference of this quantity and another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            The difference of this quantity and another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        difference = type(self).__new__(type(self))\n        difference._base_value = self._base_value - other._base_value\n        return difference\n\n    def __mul__(self, percent: Percentage) -&gt; Self:\n        \"\"\"Scale this quantity by a percentage.\n\n        Args:\n            percent: The percentage by which to scale this quantity.\n\n        Returns:\n            The scaled quantity.\n        \"\"\"\n        if not isinstance(percent, Percentage):\n            return NotImplemented\n\n        product = type(self).__new__(type(self))\n        product._base_value = self._base_value * percent.as_fraction()\n        return product\n\n    def __gt__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is greater than another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is greater than another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &gt; other._base_value\n\n    def __ge__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is greater than or equal to another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is greater than or equal to another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &gt;= other._base_value\n\n    def __lt__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is less than another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is less than another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &lt; other._base_value\n\n    def __le__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is less than or equal to another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is less than or equal to another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &lt;= other._base_value\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Return whether this quantity is equal to another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is equal to another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        # The above check ensures that both quantities are the exact same type, because\n        # `isinstance` returns true for subclasses and superclasses.  But the above check\n        # doesn't help mypy identify the type of other,  so the below line is necessary.\n        assert isinstance(other, self.__class__)\n        return self._base_value == other._base_value\n\n    def __neg__(self) -&gt; Self:\n        \"\"\"Return the negation of this quantity.\n\n        Returns:\n            The negation of this quantity.\n        \"\"\"\n        negation = type(self).__new__(type(self))\n        negation._base_value = -self._base_value\n        return negation\n\n    def __abs__(self) -&gt; Self:\n        \"\"\"Return the absolute value of this quantity.\n\n        Returns:\n            The absolute value of this quantity.\n        \"\"\"\n        absolute = type(self).__new__(type(self))\n        absolute._base_value = abs(self._base_value)\n        return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__mul__","title":"__mul__","text":"<pre><code>__mul__(percent: Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a percentage.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percentage by which to scale this quantity.</p> <p> TYPE: <code>Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, percent: Percentage) -&gt; Self:\n    \"\"\"Scale this quantity by a percentage.\n\n    Args:\n        percent: The percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    if not isinstance(percent, Percentage):\n        return NotImplemented\n\n    product = type(self).__new__(type(self))\n    product._base_value = self._base_value * percent.as_fraction()\n    return product\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER  DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.\n\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ReceiverFetcher","title":"frequenz.sdk.timeseries.ReceiverFetcher","text":"<p>             Bases: <code>Generic[T]</code>, <code>Protocol</code></p> <p>An interface that just exposes a <code>new_receiver</code> method.</p> Source code in <code>frequenz/sdk/_internal/_channels.py</code> <pre><code>class ReceiverFetcher(typing.Generic[T], typing.Protocol):\n    \"\"\"An interface that just exposes a `new_receiver` method.\"\"\"\n\n    @abc.abstractmethod\n    def new_receiver(self, *, maxsize: int = 50) -&gt; Receiver[T]:\n        \"\"\"Get a receiver from the channel.\n\n        Args:\n            maxsize: The maximum size of the receiver.\n\n        Returns:\n            A receiver instance.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ReceiverFetcher-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ReceiverFetcher.new_receiver","title":"new_receiver  <code>abstractmethod</code>","text":"<pre><code>new_receiver(*, maxsize: int = 50) -&gt; Receiver[T]\n</code></pre> <p>Get a receiver from the channel.</p> PARAMETER  DESCRIPTION <code>maxsize</code> <p>The maximum size of the receiver.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[T]</code> <p>A receiver instance.</p> Source code in <code>frequenz/sdk/_internal/_channels.py</code> <pre><code>@abc.abstractmethod\ndef new_receiver(self, *, maxsize: int = 50) -&gt; Receiver[T]:\n    \"\"\"Get a receiver from the channel.\n\n    Args:\n        maxsize: The maximum size of the receiver.\n\n    Returns:\n        A receiver instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig","title":"frequenz.sdk.timeseries.ResamplerConfig  <code>dataclass</code>","text":"<p>Resampler configuration.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>@dataclass(frozen=True)\nclass ResamplerConfig:\n    \"\"\"Resampler configuration.\"\"\"\n\n    resampling_period: timedelta\n    \"\"\"The resampling period.\n\n    This is the time it passes between resampled data should be calculated.\n\n    It must be a positive time span.\n    \"\"\"\n\n    max_data_age_in_periods: float = 3.0\n    \"\"\"The maximum age a sample can have to be considered *relevant* for resampling.\n\n    Expressed in number of periods, where period is the `resampling_period`\n    if we are downsampling (resampling period bigger than the input period) or\n    the input sampling period if we are upsampling (input period bigger than\n    the resampling period).\n\n    It must be bigger than 1.0.\n\n    Example:\n        If `resampling_period` is 3 seconds, the input sampling period is\n        1 and `max_data_age_in_periods` is 2, then data older than 3*2\n        = 6 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n\n        If `resampling_period` is 3 seconds, the input sampling period is\n        5 and `max_data_age_in_periods` is 2, then data older than 5*2\n        = 10 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n    \"\"\"\n\n    resampling_function: ResamplingFunction = average\n    \"\"\"The resampling function.\n\n    This function will be applied to the sequence of relevant samples at\n    a given time. The result of the function is what is sent as the resampled\n    value.\n    \"\"\"\n\n    initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n    \"\"\"The initial length of the resampling buffer.\n\n    The buffer could grow or shrink depending on the source properties,\n    like sampling rate, to make sure all the requested past sampling periods\n    can be stored.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n    \"\"\"The minimum length of the resampling buffer that will emit a warning.\n\n    If a buffer grows bigger than this value, it will emit a warning in the\n    logs, so buffers don't grow too big inadvertently.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n    \"\"\"The maximum length of the resampling buffer.\n\n    Buffers won't be allowed to grow beyond this point even if it would be\n    needed to keep all the requested past sampling periods. An error will be\n    emitted in the logs if the buffer length needs to be truncated to this\n    value.\n\n    It must be at bigger than `warn_buffer_len`.\n    \"\"\"\n\n    align_to: datetime | None = UNIX_EPOCH\n    \"\"\"The time to align the resampling period to.\n\n    The resampling period will be aligned to this time, so the first resampled\n    sample will be at the first multiple of `resampling_period` starting from\n    `align_to`. It must be an aware datetime and can be in the future too.\n\n    If `align_to` is `None`, the resampling period will be aligned to the\n    time the resampler is created.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Check that config values are valid.\n\n        Raises:\n            ValueError: If any value is out of range.\n        \"\"\"\n        if self.resampling_period.total_seconds() &lt; 0.0:\n            raise ValueError(\n                f\"resampling_period ({self.resampling_period}) must be positive\"\n            )\n        if self.max_data_age_in_periods &lt; 1.0:\n            raise ValueError(\n                f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n            )\n        if self.warn_buffer_len &lt; 1:\n            raise ValueError(\n                f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n            )\n        if self.max_buffer_len &lt;= self.warn_buffer_len:\n            raise ValueError(\n                f\"max_buffer_len ({self.max_buffer_len}) should \"\n                f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n            )\n\n        if self.initial_buffer_len &lt; 1:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n            )\n        if self.initial_buffer_len &gt; self.max_buffer_len:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n                f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n                \"initial_buffer_len or a bigger max_buffer_len\"\n            )\n        if self.initial_buffer_len &gt; self.warn_buffer_len:\n            _logger.warning(\n                \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n                self.initial_buffer_len,\n                self.warn_buffer_len,\n            )\n        if self.align_to is not None and self.align_to.tzinfo is None:\n            raise ValueError(\n                f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.align_to","title":"align_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>align_to: datetime | None = UNIX_EPOCH\n</code></pre> <p>The time to align the resampling period to.</p> <p>The resampling period will be aligned to this time, so the first resampled sample will be at the first multiple of <code>resampling_period</code> starting from <code>align_to</code>. It must be an aware datetime and can be in the future too.</p> <p>If <code>align_to</code> is <code>None</code>, the resampling period will be aligned to the time the resampler is created.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.initial_buffer_len","title":"initial_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n</code></pre> <p>The initial length of the resampling buffer.</p> <p>The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.max_buffer_len","title":"max_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n</code></pre> <p>The maximum length of the resampling buffer.</p> <p>Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value.</p> <p>It must be at bigger than <code>warn_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.max_data_age_in_periods","title":"max_data_age_in_periods  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_data_age_in_periods: float = 3.0\n</code></pre> <p>The maximum age a sample can have to be considered relevant for resampling.</p> <p>Expressed in number of periods, where period is the <code>resampling_period</code> if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period).</p> <p>It must be bigger than 1.0.</p> Example <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 1 and <code>max_data_age_in_periods</code> is 2, then data older than 3*2 = 6 seconds will be discarded when creating a new sample and never passed to the resampling function.</p> <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 5 and <code>max_data_age_in_periods</code> is 2, then data older than 5*2 = 10 seconds will be discarded when creating a new sample and never passed to the resampling function.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.resampling_function","title":"resampling_function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resampling_function: ResamplingFunction = average\n</code></pre> <p>The resampling function.</p> <p>This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.resampling_period","title":"resampling_period  <code>instance-attribute</code>","text":"<pre><code>resampling_period: timedelta\n</code></pre> <p>The resampling period.</p> <p>This is the time it passes between resampled data should be calculated.</p> <p>It must be a positive time span.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.warn_buffer_len","title":"warn_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n</code></pre> <p>The minimum length of the resampling buffer that will emit a warning.</p> <p>If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertently.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Check that config values are valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any value is out of range.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Check that config values are valid.\n\n    Raises:\n        ValueError: If any value is out of range.\n    \"\"\"\n    if self.resampling_period.total_seconds() &lt; 0.0:\n        raise ValueError(\n            f\"resampling_period ({self.resampling_period}) must be positive\"\n        )\n    if self.max_data_age_in_periods &lt; 1.0:\n        raise ValueError(\n            f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n        )\n    if self.warn_buffer_len &lt; 1:\n        raise ValueError(\n            f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n        )\n    if self.max_buffer_len &lt;= self.warn_buffer_len:\n        raise ValueError(\n            f\"max_buffer_len ({self.max_buffer_len}) should \"\n            f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n        )\n\n    if self.initial_buffer_len &lt; 1:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n        )\n    if self.initial_buffer_len &gt; self.max_buffer_len:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n            f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n            \"initial_buffer_len or a bigger max_buffer_len\"\n        )\n    if self.initial_buffer_len &gt; self.warn_buffer_len:\n        _logger.warning(\n            \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n            self.initial_buffer_len,\n            self.warn_buffer_len,\n        )\n    if self.align_to is not None and self.align_to.tzinfo is None:\n        raise ValueError(\n            f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample","title":"frequenz.sdk.timeseries.Sample  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[QuantityT]</code></p> <p>A measurement taken at a particular point in time.</p> <p>The <code>value</code> could be <code>None</code> if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True, order=True)\nclass Sample(Generic[QuantityT]):\n    \"\"\"A measurement taken at a particular point in time.\n\n    The `value` could be `None` if a component is malfunctioning or data is\n    lacking for another reason, but a sample still needs to be sent to have a\n    coherent view on a group of component metrics for a particular timestamp.\n    \"\"\"\n\n    timestamp: datetime\n    \"\"\"The time when this sample was generated.\"\"\"\n\n    value: QuantityT | None = None\n    \"\"\"The value of this sample.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The time when this sample was generated.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: QuantityT | None = None\n</code></pre> <p>The value of this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase","title":"frequenz.sdk.timeseries.Sample3Phase  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[QuantityT]</code></p> <p>A 3-phase measurement made at a particular point in time.</p> <p>Each of the <code>value</code> fields could be <code>None</code> if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Sample3Phase(Generic[QuantityT]):\n    \"\"\"A 3-phase measurement made at a particular point in time.\n\n    Each of the `value` fields could be `None` if a component is malfunctioning\n    or data is lacking for another reason, but a sample still needs to be sent\n    to have a coherent view on a group of component metrics for a particular\n    timestamp.\n    \"\"\"\n\n    timestamp: datetime\n    \"\"\"The time when this sample was generated.\"\"\"\n    value_p1: QuantityT | None\n    \"\"\"The value of the 1st phase in this sample.\"\"\"\n\n    value_p2: QuantityT | None\n    \"\"\"The value of the 2nd phase in this sample.\"\"\"\n\n    value_p3: QuantityT | None\n    \"\"\"The value of the 3rd phase in this sample.\"\"\"\n\n    def __iter__(self) -&gt; Iterator[QuantityT | None]:\n        \"\"\"Return an iterator that yields values from each of the phases.\n\n        Yields:\n            Per-phase measurements one-by-one.\n        \"\"\"\n        yield self.value_p1\n        yield self.value_p2\n        yield self.value_p3\n\n    @overload\n    def max(self, default: QuantityT) -&gt; QuantityT: ...\n\n    @overload\n    def max(self, default: None = None) -&gt; QuantityT | None: ...\n\n    def max(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n        \"\"\"Return the max value among all phases, or default if they are all `None`.\n\n        Args:\n            default: value to return if all phases are `None`.\n\n        Returns:\n            Max value among all phases, if available, default value otherwise.\n        \"\"\"\n        if not any(self):\n            return default\n        value: QuantityT = functools.reduce(\n            lambda x, y: x if x &gt; y else y,\n            filter(None, self),\n        )\n        return value\n\n    @overload\n    def min(self, default: QuantityT) -&gt; QuantityT: ...\n\n    @overload\n    def min(self, default: None = None) -&gt; QuantityT | None: ...\n\n    def min(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n        \"\"\"Return the min value among all phases, or default if they are all `None`.\n\n        Args:\n            default: value to return if all phases are `None`.\n\n        Returns:\n            Min value among all phases, if available, default value otherwise.\n        \"\"\"\n        if not any(self):\n            return default\n        value: QuantityT = functools.reduce(\n            lambda x, y: x if x &lt; y else y,\n            filter(None, self),\n        )\n        return value\n\n    def map(\n        self,\n        function: Callable[[QuantityT], QuantityT],\n        default: QuantityT | None = None,\n    ) -&gt; Self:\n        \"\"\"Apply the given function on each of the phase values and return the result.\n\n        If a phase value is `None`, replace it with `default` instead.\n\n        Args:\n            function: The function to apply on each of the phase values.\n            default: The value to apply if a phase value is `None`.\n\n        Returns:\n            A new instance, with the given function applied on values for each of the\n                phases.\n        \"\"\"\n        return self.__class__(\n            timestamp=self.timestamp,\n            value_p1=default if self.value_p1 is None else function(self.value_p1),\n            value_p2=default if self.value_p2 is None else function(self.value_p2),\n            value_p3=default if self.value_p3 is None else function(self.value_p3),\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The time when this sample was generated.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p1","title":"value_p1  <code>instance-attribute</code>","text":"<pre><code>value_p1: QuantityT | None\n</code></pre> <p>The value of the 1st phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p2","title":"value_p2  <code>instance-attribute</code>","text":"<pre><code>value_p2: QuantityT | None\n</code></pre> <p>The value of the 2nd phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p3","title":"value_p3  <code>instance-attribute</code>","text":"<pre><code>value_p3: QuantityT | None\n</code></pre> <p>The value of the 3rd phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[QuantityT | None]\n</code></pre> <p>Return an iterator that yields values from each of the phases.</p> YIELDS DESCRIPTION <code>QuantityT | None</code> <p>Per-phase measurements one-by-one.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def __iter__(self) -&gt; Iterator[QuantityT | None]:\n    \"\"\"Return an iterator that yields values from each of the phases.\n\n    Yields:\n        Per-phase measurements one-by-one.\n    \"\"\"\n    yield self.value_p1\n    yield self.value_p2\n    yield self.value_p3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.map","title":"map","text":"<pre><code>map(\n    function: Callable[[QuantityT], QuantityT],\n    default: QuantityT | None = None,\n) -&gt; Self\n</code></pre> <p>Apply the given function on each of the phase values and return the result.</p> <p>If a phase value is <code>None</code>, replace it with <code>default</code> instead.</p> PARAMETER  DESCRIPTION <code>function</code> <p>The function to apply on each of the phase values.</p> <p> TYPE: <code>Callable[[QuantityT], QuantityT]</code> </p> <code>default</code> <p>The value to apply if a phase value is <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new instance, with the given function applied on values for each of the phases.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def map(\n    self,\n    function: Callable[[QuantityT], QuantityT],\n    default: QuantityT | None = None,\n) -&gt; Self:\n    \"\"\"Apply the given function on each of the phase values and return the result.\n\n    If a phase value is `None`, replace it with `default` instead.\n\n    Args:\n        function: The function to apply on each of the phase values.\n        default: The value to apply if a phase value is `None`.\n\n    Returns:\n        A new instance, with the given function applied on values for each of the\n            phases.\n    \"\"\"\n    return self.__class__(\n        timestamp=self.timestamp,\n        value_p1=default if self.value_p1 is None else function(self.value_p1),\n        value_p2=default if self.value_p2 is None else function(self.value_p2),\n        value_p3=default if self.value_p3 is None else function(self.value_p3),\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.max","title":"max","text":"<pre><code>max(default: QuantityT | None = None) -&gt; QuantityT | None\n</code></pre> <p>Return the max value among all phases, or default if they are all <code>None</code>.</p> PARAMETER  DESCRIPTION <code>default</code> <p>value to return if all phases are <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>QuantityT | None</code> <p>Max value among all phases, if available, default value otherwise.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def max(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n    \"\"\"Return the max value among all phases, or default if they are all `None`.\n\n    Args:\n        default: value to return if all phases are `None`.\n\n    Returns:\n        Max value among all phases, if available, default value otherwise.\n    \"\"\"\n    if not any(self):\n        return default\n    value: QuantityT = functools.reduce(\n        lambda x, y: x if x &gt; y else y,\n        filter(None, self),\n    )\n    return value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.min","title":"min","text":"<pre><code>min(default: QuantityT | None = None) -&gt; QuantityT | None\n</code></pre> <p>Return the min value among all phases, or default if they are all <code>None</code>.</p> PARAMETER  DESCRIPTION <code>default</code> <p>value to return if all phases are <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>QuantityT | None</code> <p>Min value among all phases, if available, default value otherwise.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def min(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n    \"\"\"Return the min value among all phases, or default if they are all `None`.\n\n    Args:\n        default: value to return if all phases are `None`.\n\n    Returns:\n        Min value among all phases, if available, default value otherwise.\n    \"\"\"\n    if not any(self):\n        return default\n    value: QuantityT = functools.reduce(\n        lambda x, y: x if x &lt; y else y,\n        filter(None, self),\n    )\n    return value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature","title":"frequenz.sdk.timeseries.Temperature","text":"<p>             Bases: <code>Quantity</code></p> <p>A temperature quantity (in degrees Celsius).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Temperature(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={\n        0: \"\u00b0C\",\n    },\n):\n    \"\"\"A temperature quantity (in degrees Celsius).\"\"\"\n\n    @classmethod\n    def from_celsius(cls, value: float) -&gt; Self:\n        \"\"\"Initialize a new temperature quantity.\n\n        Args:\n            value: The temperature in degrees Celsius.\n\n        Returns:\n            A new temperature quantity.\n        \"\"\"\n        power = cls.__new__(cls)\n        power._base_value = value\n        return power\n\n    def as_celsius(self) -&gt; float:\n        \"\"\"Return the temperature in degrees Celsius.\n\n        Returns:\n            The temperature in degrees Celsius.\n        \"\"\"\n        return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__mul__","title":"__mul__","text":"<pre><code>__mul__(percent: Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a percentage.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percentage by which to scale this quantity.</p> <p> TYPE: <code>Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, percent: Percentage) -&gt; Self:\n    \"\"\"Scale this quantity by a percentage.\n\n    Args:\n        percent: The percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    if not isinstance(percent, Percentage):\n        return NotImplemented\n\n    product = type(self).__new__(type(self))\n    product._base_value = self._base_value * percent.as_fraction()\n    return product\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.as_celsius","title":"as_celsius","text":"<pre><code>as_celsius() -&gt; float\n</code></pre> <p>Return the temperature in degrees Celsius.</p> RETURNS DESCRIPTION <code>float</code> <p>The temperature in degrees Celsius.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_celsius(self) -&gt; float:\n    \"\"\"Return the temperature in degrees Celsius.\n\n    Returns:\n        The temperature in degrees Celsius.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.from_celsius","title":"from_celsius  <code>classmethod</code>","text":"<pre><code>from_celsius(value: float) -&gt; Self\n</code></pre> <p>Initialize a new temperature quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The temperature in degrees Celsius.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new temperature quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_celsius(cls, value: float) -&gt; Self:\n    \"\"\"Initialize a new temperature quantity.\n\n    Args:\n        value: The temperature in degrees Celsius.\n\n    Returns:\n        A new temperature quantity.\n    \"\"\"\n    power = cls.__new__(cls)\n    power._base_value = value\n    return power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER  DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.\n\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage","title":"frequenz.sdk.timeseries.Voltage","text":"<p>             Bases: <code>Quantity</code></p> <p>A voltage quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Voltage(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={0: \"V\", -3: \"mV\", 3: \"kV\"},\n):\n    \"\"\"A voltage quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_volts(cls, volts: float) -&gt; Self:\n        \"\"\"Initialize a new voltage quantity.\n\n        Args:\n            volts: The voltage in volts.\n\n        Returns:\n            A new voltage quantity.\n        \"\"\"\n        voltage = cls.__new__(cls)\n        voltage._base_value = volts\n        return voltage\n\n    @classmethod\n    def from_millivolts(cls, millivolts: float) -&gt; Self:\n        \"\"\"Initialize a new voltage quantity.\n\n        Args:\n            millivolts: The voltage in millivolts.\n\n        Returns:\n            A new voltage quantity.\n        \"\"\"\n        voltage = cls.__new__(cls)\n        voltage._base_value = millivolts * 10**-3\n        return voltage\n\n    @classmethod\n    def from_kilovolts(cls, kilovolts: float) -&gt; Self:\n        \"\"\"Initialize a new voltage quantity.\n\n        Args:\n            kilovolts: The voltage in kilovolts.\n\n        Returns:\n            A new voltage quantity.\n        \"\"\"\n        voltage = cls.__new__(cls)\n        voltage._base_value = kilovolts * 10**3\n        return voltage\n\n    def as_volts(self) -&gt; float:\n        \"\"\"Return the voltage in volts.\n\n        Returns:\n            The voltage in volts.\n        \"\"\"\n        return self._base_value\n\n    def as_millivolts(self) -&gt; float:\n        \"\"\"Return the voltage in millivolts.\n\n        Returns:\n            The voltage in millivolts.\n        \"\"\"\n        return self._base_value * 1e3\n\n    def as_kilovolts(self) -&gt; float:\n        \"\"\"Return the voltage in kilovolts.\n\n        Returns:\n            The voltage in kilovolts.\n        \"\"\"\n        return self._base_value / 1e3\n\n    @overload  # type: ignore\n    def __mul__(self, other: Percentage) -&gt; Self:\n        \"\"\"Scale this voltage by a percentage.\n\n        Args:\n            other: The percentage by which to scale this voltage.\n\n        Returns:\n            The scaled voltage.\n        \"\"\"\n\n    @overload\n    def __mul__(self, other: Current) -&gt; Power:\n        \"\"\"Multiply the voltage by the current to get the power.\n\n        Args:\n            other: The current to multiply the voltage with.\n\n        Returns:\n            The calculated power.\n        \"\"\"\n\n    def __mul__(self, other: Percentage | Current) -&gt; Self | Power:\n        \"\"\"Return a voltage or power from multiplying this voltage by the given value.\n\n        Args:\n            other: The percentage or current to multiply by.\n\n        Returns:\n            The calculated voltage or power.\n        \"\"\"\n        if isinstance(other, Percentage):\n            return super().__mul__(other)\n        if isinstance(other, Current):\n            return Power.from_watts(self._base_value * other._base_value)\n\n        return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Percentage | Current) -&gt; Self | Power\n</code></pre> <p>Return a voltage or power from multiplying this voltage by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The percentage or current to multiply by.</p> <p> TYPE: <code>Percentage | Current</code> </p> RETURNS DESCRIPTION <code>Self | Power</code> <p>The calculated voltage or power.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: Percentage | Current) -&gt; Self | Power:\n    \"\"\"Return a voltage or power from multiplying this voltage by the given value.\n\n    Args:\n        other: The percentage or current to multiply by.\n\n    Returns:\n        The calculated voltage or power.\n    \"\"\"\n    if isinstance(other, Percentage):\n        return super().__mul__(other)\n    if isinstance(other, Current):\n        return Power.from_watts(self._base_value * other._base_value)\n\n    return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_kilovolts","title":"as_kilovolts","text":"<pre><code>as_kilovolts() -&gt; float\n</code></pre> <p>Return the voltage in kilovolts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in kilovolts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilovolts(self) -&gt; float:\n    \"\"\"Return the voltage in kilovolts.\n\n    Returns:\n        The voltage in kilovolts.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_millivolts","title":"as_millivolts","text":"<pre><code>as_millivolts() -&gt; float\n</code></pre> <p>Return the voltage in millivolts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in millivolts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_millivolts(self) -&gt; float:\n    \"\"\"Return the voltage in millivolts.\n\n    Returns:\n        The voltage in millivolts.\n    \"\"\"\n    return self._base_value * 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_volts","title":"as_volts","text":"<pre><code>as_volts() -&gt; float\n</code></pre> <p>Return the voltage in volts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in volts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_volts(self) -&gt; float:\n    \"\"\"Return the voltage in volts.\n\n    Returns:\n        The voltage in volts.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_kilovolts","title":"from_kilovolts  <code>classmethod</code>","text":"<pre><code>from_kilovolts(kilovolts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER  DESCRIPTION <code>kilovolts</code> <p>The voltage in kilovolts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilovolts(cls, kilovolts: float) -&gt; Self:\n    \"\"\"Initialize a new voltage quantity.\n\n    Args:\n        kilovolts: The voltage in kilovolts.\n\n    Returns:\n        A new voltage quantity.\n    \"\"\"\n    voltage = cls.__new__(cls)\n    voltage._base_value = kilovolts * 10**3\n    return voltage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_millivolts","title":"from_millivolts  <code>classmethod</code>","text":"<pre><code>from_millivolts(millivolts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER  DESCRIPTION <code>millivolts</code> <p>The voltage in millivolts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_millivolts(cls, millivolts: float) -&gt; Self:\n    \"\"\"Initialize a new voltage quantity.\n\n    Args:\n        millivolts: The voltage in millivolts.\n\n    Returns:\n        A new voltage quantity.\n    \"\"\"\n    voltage = cls.__new__(cls)\n    voltage._base_value = millivolts * 10**-3\n    return voltage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER  DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_volts","title":"from_volts  <code>classmethod</code>","text":"<pre><code>from_volts(volts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER  DESCRIPTION <code>volts</code> <p>The voltage in volts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_volts(cls, volts: float) -&gt; Self:\n    \"\"\"Initialize a new voltage quantity.\n\n    Args:\n        volts: The voltage in volts.\n\n    Returns:\n        A new voltage quantity.\n    \"\"\"\n    voltage = cls.__new__(cls)\n    voltage._base_value = volts\n    return voltage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.\n\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/consumer/","title":"consumer","text":""},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer","title":"frequenz.sdk.timeseries.consumer","text":"<p>The logical component for calculating high level consumer metrics for a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer","title":"frequenz.sdk.timeseries.consumer.Consumer","text":"<p>Calculate high level consumer metrics in a microgrid.</p> <p>Under normal circumstances this is expected to correspond to the gross consumption of the site excluding active parts and battery.</p> <p>Consumer provides methods for fetching power values from different points in the microgrid. These methods return <code>FormulaReceiver</code> objects, which can be used like normal <code>Receiver</code>s, but can also be composed to form higher-order formula streams.</p> <p>Note</p> <p><code>Consumer</code> instances are not meant to be created directly by users. Use the <code>microgrid.consumer</code> method for creating <code>Consumer</code> instances.</p> Example <pre><code>from datetime import timedelta\n\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.timeseries import ResamplerConfig\n\nawait microgrid.initialize(\n    \"127.0.0.1\",\n    50051,\n    ResamplerConfig(resampling_period=timedelta(seconds=1.0))\n)\n\nconsumer = microgrid.consumer()\n\n# Get a receiver for a builtin formula\nconsumer_power_recv = consumer.power.new_receiver()\nasync for consumer_power_sample in consumer_power_recv:\n    print(consumer_power_sample)\n</code></pre> Source code in <code>frequenz/sdk/timeseries/consumer.py</code> <pre><code>class Consumer:\n    \"\"\"Calculate high level consumer metrics in a microgrid.\n\n    Under normal circumstances this is expected to correspond to the gross\n    consumption of the site excluding active parts and battery.\n\n    Consumer provides methods for fetching power values from different points\n    in the microgrid. These methods return `FormulaReceiver` objects, which can\n    be used like normal `Receiver`s, but can also be composed to form\n    higher-order formula streams.\n\n    !!! note\n        `Consumer` instances are not meant to be created directly by users.\n        Use the [`microgrid.consumer`][frequenz.sdk.microgrid.consumer] method\n        for creating `Consumer` instances.\n\n    Example:\n        ```python\n        from datetime import timedelta\n\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.timeseries import ResamplerConfig\n\n        await microgrid.initialize(\n            \"127.0.0.1\",\n            50051,\n            ResamplerConfig(resampling_period=timedelta(seconds=1.0))\n        )\n\n        consumer = microgrid.consumer()\n\n        # Get a receiver for a builtin formula\n        consumer_power_recv = consumer.power.new_receiver()\n        async for consumer_power_sample in consumer_power_recv:\n            print(consumer_power_sample)\n        ```\n    \"\"\"\n\n    _formula_pool: FormulaEnginePool\n    \"\"\"The formula engine pool to generate consumer metrics.\"\"\"\n\n    def __init__(\n        self,\n        channel_registry: ChannelRegistry,\n        resampler_subscription_sender: Sender[ComponentMetricRequest],\n    ) -&gt; None:\n        \"\"\"Initialize the consumer formula generator.\n\n        Args:\n            channel_registry: The channel registry to use for the consumer.\n            resampler_subscription_sender: The sender to use for resampler subscriptions.\n        \"\"\"\n        namespace = f\"consumer-{uuid.uuid4()}\"\n        self._formula_pool = FormulaEnginePool(\n            namespace,\n            channel_registry,\n            resampler_subscription_sender,\n        )\n\n    @property\n    def power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the consumer power for the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        It will start the formula engine to calculate consumer power if it is\n        not already running.\n\n        A receiver from the formula engine can be created using the\n        `new_receiver` method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream consumer power.\n        \"\"\"\n        engine = self._formula_pool.from_power_formula_generator(\n            \"consumer_power\",\n            ConsumerPowerFormula,\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all formula engines.\"\"\"\n        await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the consumer power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>It will start the formula engine to calculate consumer power if it is not already running.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream consumer power.</p>"},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer.__init__","title":"__init__","text":"<pre><code>__init__(\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[\n        ComponentMetricRequest\n    ],\n) -&gt; None\n</code></pre> <p>Initialize the consumer formula generator.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>The channel registry to use for the consumer.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>The sender to use for resampler subscriptions.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> Source code in <code>frequenz/sdk/timeseries/consumer.py</code> <pre><code>def __init__(\n    self,\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n    \"\"\"Initialize the consumer formula generator.\n\n    Args:\n        channel_registry: The channel registry to use for the consumer.\n        resampler_subscription_sender: The sender to use for resampler subscriptions.\n    \"\"\"\n    namespace = f\"consumer-{uuid.uuid4()}\"\n    self._formula_pool = FormulaEnginePool(\n        namespace,\n        channel_registry,\n        resampler_subscription_sender,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all formula engines.</p> Source code in <code>frequenz/sdk/timeseries/consumer.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all formula engines.\"\"\"\n    await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/grid/","title":"grid","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid","title":"frequenz.sdk.timeseries.grid","text":"<p>Grid connection point.</p> <p>This module provides the <code>Grid</code> type, which represents a grid connection point in a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid","title":"frequenz.sdk.timeseries.grid.Grid  <code>dataclass</code>","text":"<p>A grid connection point.</p> <p>Note</p> <p>The <code>Grid</code> instance is not meant to be created directly by users. Use the <code>microgrid.grid</code> method for creating or getting the <code>Grid</code> instance.</p> Example <pre><code>from datetime import timedelta\n\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.timeseries import ResamplerConfig\n\nawait microgrid.initialize(\n    \"127.0.0.1\",\n    50051,\n    ResamplerConfig(resampling_period=timedelta(seconds=1))\n)\n\ngrid = microgrid.grid()\n\n# Get a receiver for a builtin formula\ngrid_power_recv = grid.power.new_receiver()\nasync for grid_power_sample in grid_power_recv:\n    print(grid_power_sample)\n</code></pre> Source code in <code>frequenz/sdk/timeseries/grid.py</code> <pre><code>@dataclass(frozen=True)\nclass Grid:\n    \"\"\"A grid connection point.\n\n    !!! note\n        The `Grid` instance is not meant to be created directly by users.\n        Use the [`microgrid.grid`][frequenz.sdk.microgrid.grid] method for\n        creating or getting the `Grid` instance.\n\n    Example:\n        ```python\n        from datetime import timedelta\n\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.timeseries import ResamplerConfig\n\n        await microgrid.initialize(\n            \"127.0.0.1\",\n            50051,\n            ResamplerConfig(resampling_period=timedelta(seconds=1))\n        )\n\n        grid = microgrid.grid()\n\n        # Get a receiver for a builtin formula\n        grid_power_recv = grid.power.new_receiver()\n        async for grid_power_sample in grid_power_recv:\n            print(grid_power_sample)\n        ```\n    \"\"\"\n\n    fuse: Fuse | None\n    \"\"\"The fuse protecting the grid connection point.\n\n    The rated current of the fuse is set to zero in case of an islanded\n    microgrid.\n    And the fuse is set to `None` when the grid connection component metadata\n    lacks information about the fuse.\n    \"\"\"\n\n    _formula_pool: FormulaEnginePool\n    \"\"\"The formula engine pool to generate grid metrics.\"\"\"\n\n    @property\n    def power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the grid power for the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate grid power is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream grid power.\n        \"\"\"\n        engine = self._formula_pool.from_power_formula_generator(\n            \"grid_power\",\n            GridPowerFormula,\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def current(self) -&gt; FormulaEngine3Phase[Current]:\n        \"\"\"Fetch the grid current for the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate grid current is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream grid current.\n        \"\"\"\n        engine = self._formula_pool.from_3_phase_current_formula_generator(\n            \"grid_current\",\n            GridCurrentFormula,\n        )\n        assert isinstance(engine, FormulaEngine3Phase)\n        return engine\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all formula engines.\"\"\"\n        await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid.current","title":"current  <code>property</code>","text":"<pre><code>current: FormulaEngine3Phase[Current]\n</code></pre> <p>Fetch the grid current for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate grid current is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine3Phase[Current]</code> <p>A FormulaEngine that will calculate and stream grid current.</p>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid.fuse","title":"fuse  <code>instance-attribute</code>","text":"<pre><code>fuse: Fuse | None\n</code></pre> <p>The fuse protecting the grid connection point.</p> <p>The rated current of the fuse is set to zero in case of an islanded microgrid. And the fuse is set to <code>None</code> when the grid connection component metadata lacks information about the fuse.</p>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the grid power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate grid power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream grid power.</p>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all formula engines.</p> Source code in <code>frequenz/sdk/timeseries/grid.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all formula engines.\"\"\"\n    await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.get","title":"frequenz.sdk.timeseries.grid.get","text":"<pre><code>get() -&gt; Grid\n</code></pre> <p>Get the grid connection.</p> <p>Note that the rated current of the fuse is set to zero in case of an islanded microgrid. And the fuse is set to <code>None</code> when the grid connection component metadata lacks information about the fuse.</p> RETURNS DESCRIPTION <code>Grid</code> <p>The grid connection.</p> Source code in <code>frequenz/sdk/timeseries/grid.py</code> <pre><code>def get() -&gt; Grid:\n    \"\"\"Get the grid connection.\n\n    Note that the rated current of the fuse is set to zero in case of an\n    islanded microgrid.\n    And the fuse is set to `None` when the grid connection component metadata\n    lacks information about the fuse.\n\n    Returns:\n        The grid connection.\n    \"\"\"\n    assert _GRID, \"Grid is not initialized\"\n    return _GRID\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.initialize","title":"frequenz.sdk.timeseries.grid.initialize","text":"<pre><code>initialize(\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[\n        ComponentMetricRequest\n    ],\n) -&gt; None\n</code></pre> <p>Initialize the grid connection.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>The channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>The sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If there is more than 1 grid connection point in the microgrid, or if the grid connection point is not initialized.</p> Source code in <code>frequenz/sdk/timeseries/grid.py</code> <pre><code>def initialize(\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n    \"\"\"Initialize the grid connection.\n\n    Args:\n        channel_registry: The channel registry instance shared with the\n            resampling actor.\n        resampler_subscription_sender: The sender for sending metric requests\n            to the resampling actor.\n\n    Raises:\n        RuntimeError: If there is more than 1 grid connection point in the\n            microgrid, or if the grid connection point is not initialized.\n    \"\"\"\n    global _GRID  # pylint: disable=global-statement\n\n    grid_connections = list(\n        connection_manager.get().component_graph.components(\n            component_categories={ComponentCategory.GRID},\n        )\n    )\n\n    grid_connections_count = len(grid_connections)\n\n    fuse: Fuse | None = None\n\n    if grid_connections_count == 0:\n        fuse = Fuse(max_current=Current.zero())\n        _logger.info(\n            \"No grid connection found for this microgrid. This is normal for an islanded microgrid.\"\n        )\n    elif grid_connections_count &gt; 1:\n        raise RuntimeError(\n            f\"Expected at most one grid connection, got {grid_connections_count}\"\n        )\n    else:\n        if grid_connections[0].metadata is None:\n            raise RuntimeError(\"Grid metadata is None\")\n\n        # The current implementation of the Component Graph fails to\n        # effectively convert components from a dictionary representation to\n        # the expected Component object.\n        # Specifically for the component metadata, it hands back a dictionary\n        # instead of the expected ComponentMetadata type.\n        metadata = grid_connections[0].metadata\n        if isinstance(metadata, dict):\n            fuse_dict = metadata.get(\"fuse\", None)\n            fuse = Fuse(**fuse_dict) if fuse_dict else None\n\n        if fuse is None:\n            _logger.warning(\"The grid connection point does not have a fuse\")\n\n    namespace = f\"grid-{uuid.uuid4()}\"\n    formula_pool = FormulaEnginePool(\n        namespace,\n        channel_registry,\n        resampler_subscription_sender,\n    )\n\n    _GRID = Grid(fuse, formula_pool)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/producer/","title":"producer","text":""},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer","title":"frequenz.sdk.timeseries.producer","text":"<p>The logical component for calculating high level producer metrics for a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer","title":"frequenz.sdk.timeseries.producer.Producer","text":"<p>Calculate high level producer metrics in a microgrid.</p> <p>Under normal circumstances this is expected to correspond to the gross production of the sites active parts excluding EV chargers and batteries.</p> <p>Producer provides methods for fetching power values from different points in the microgrid. These methods return <code>FormulaReceiver</code> objects, which can be used like normal <code>Receiver</code>s, but can also be composed to form higher-order formula streams.</p> <p>Note</p> <p><code>Producer</code> instances are not meant to be created directly by users. Use the <code>microgrid.producer</code> method for creating <code>Producer</code> instances.</p> Example <pre><code>from datetime import timedelta\n\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.timeseries import ResamplerConfig\n\nawait microgrid.initialize(\n    \"127.0.0.1\",\n    50051,\n    ResamplerConfig(resampling_period=timedelta(seconds=1.0))\n)\n\nproducer = microgrid.producer()\n\n# Get a receiver for a builtin formula\nproducer_power_recv = producer.power.new_receiver()\nasync for producer_power_sample in producer_power_recv:\n    print(producer_power_sample)\n</code></pre> Source code in <code>frequenz/sdk/timeseries/producer.py</code> <pre><code>class Producer:\n    \"\"\"Calculate high level producer metrics in a microgrid.\n\n    Under normal circumstances this is expected to correspond to the gross\n    production of the sites active parts excluding EV chargers and batteries.\n\n    Producer provides methods for fetching power values from different points\n    in the microgrid. These methods return `FormulaReceiver` objects, which can\n    be used like normal `Receiver`s, but can also be composed to form\n    higher-order formula streams.\n\n    !!! note\n        `Producer` instances are not meant to be created directly by users.\n        Use the [`microgrid.producer`][frequenz.sdk.microgrid.producer] method\n        for creating `Producer` instances.\n\n    Example:\n        ```python\n        from datetime import timedelta\n\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.timeseries import ResamplerConfig\n\n        await microgrid.initialize(\n            \"127.0.0.1\",\n            50051,\n            ResamplerConfig(resampling_period=timedelta(seconds=1.0))\n        )\n\n        producer = microgrid.producer()\n\n        # Get a receiver for a builtin formula\n        producer_power_recv = producer.power.new_receiver()\n        async for producer_power_sample in producer_power_recv:\n            print(producer_power_sample)\n        ```\n    \"\"\"\n\n    _formula_pool: FormulaEnginePool\n    \"\"\"The formula engine pool to generate producer metrics.\"\"\"\n\n    def __init__(\n        self,\n        channel_registry: ChannelRegistry,\n        resampler_subscription_sender: Sender[ComponentMetricRequest],\n    ) -&gt; None:\n        \"\"\"Initialize the producer formula generator.\n\n        Args:\n            channel_registry: The channel registry to use for the producer.\n            resampler_subscription_sender: The sender to use for resampler subscriptions.\n        \"\"\"\n        namespace = f\"producer-{uuid.uuid4()}\"\n        self._formula_pool = FormulaEnginePool(\n            namespace,\n            channel_registry,\n            resampler_subscription_sender,\n        )\n\n    @property\n    def power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the producer power for the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        It will start the formula engine to calculate producer power if it is\n        not already running.\n\n        A receiver from the formula engine can be created using the\n        `new_receiver` method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream producer power.\n        \"\"\"\n        engine = self._formula_pool.from_power_formula_generator(\n            \"producer_power\",\n            ProducerPowerFormula,\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all formula engines.\"\"\"\n        await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the producer power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>It will start the formula engine to calculate producer power if it is not already running.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream producer power.</p>"},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer.__init__","title":"__init__","text":"<pre><code>__init__(\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[\n        ComponentMetricRequest\n    ],\n) -&gt; None\n</code></pre> <p>Initialize the producer formula generator.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>The channel registry to use for the producer.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>The sender to use for resampler subscriptions.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> Source code in <code>frequenz/sdk/timeseries/producer.py</code> <pre><code>def __init__(\n    self,\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n    \"\"\"Initialize the producer formula generator.\n\n    Args:\n        channel_registry: The channel registry to use for the producer.\n        resampler_subscription_sender: The sender to use for resampler subscriptions.\n    \"\"\"\n    namespace = f\"producer-{uuid.uuid4()}\"\n    self._formula_pool = FormulaEnginePool(\n        namespace,\n        channel_registry,\n        resampler_subscription_sender,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all formula engines.</p> Source code in <code>frequenz/sdk/timeseries/producer.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all formula engines.\"\"\"\n    await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/","title":"battery_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool","title":"frequenz.sdk.timeseries.battery_pool","text":"<p>Manage a pool of batteries.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool","title":"frequenz.sdk.timeseries.battery_pool.BatteryPool","text":"<p>An interface for interaction with pools of batteries.</p> <p>Note</p> <p><code>BatteryPool</code> instances are not meant to be created directly by users.  Use the <code>microgrid.battery_pool</code> method for creating <code>BatteryPool</code> instances.</p> Provides <ul> <li>properties for fetching reporting streams of instantaneous   power,   soc,   capacity values and   available power bounds and other status through   power_status.</li> <li>control methods for proposing power values, namely:   propose_power,   propose_charge and   propose_discharge.</li> </ul> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>class BatteryPool:\n    \"\"\"An interface for interaction with pools of batteries.\n\n    !!! note\n        `BatteryPool` instances are not meant to be created directly by users.  Use the\n        [`microgrid.battery_pool`][frequenz.sdk.microgrid.battery_pool] method for\n        creating `BatteryPool` instances.\n\n    Provides:\n      - properties for fetching reporting streams of instantaneous\n        [power][frequenz.sdk.timeseries.battery_pool.BatteryPool.power],\n        [soc][frequenz.sdk.timeseries.battery_pool.BatteryPool.soc],\n        [capacity][frequenz.sdk.timeseries.battery_pool.BatteryPool.capacity] values and\n        available power bounds and other status through\n        [power_status][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status].\n      - control methods for proposing power values, namely:\n        [propose_power][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power],\n        [propose_charge][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_charge] and\n        [propose_discharge][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_discharge].\n    \"\"\"\n\n    def __init__(\n        self,\n        battery_pool_ref: BatteryPoolReferenceStore,\n        name: str | None,\n        priority: int,\n    ):\n        \"\"\"Create a BatteryPool instance.\n\n        !!! note\n            `BatteryPool` instances are not meant to be created directly by users.  Use\n            the [`microgrid.battery_pool`][frequenz.sdk.microgrid.battery_pool] method\n            for creating `BatteryPool` instances.\n\n        Args:\n            battery_pool_ref: The battery pool reference store instance.\n            name: An optional name used to identify this instance of the pool or a\n                corresponding actor in the logs.\n            priority: The priority of the actor using this wrapper.\n        \"\"\"\n        self._battery_pool = battery_pool_ref\n        unique_id = str(uuid.uuid4())\n        self._source_id = unique_id if name is None else f\"{name}-{unique_id}\"\n        self._priority = priority\n\n    async def propose_power(\n        self,\n        power: Power | None,\n        *,\n        request_timeout: timedelta = timedelta(seconds=5.0),\n        bounds: timeseries.Bounds[Power | None] = timeseries.Bounds(None, None),\n    ) -&gt; None:\n        \"\"\"Send a proposal to the power manager for the pool's set of batteries.\n\n        Power values need to follow the Passive Sign Convention (PSC). That is, positive\n        values indicate charge power and negative values indicate discharge power.\n\n        If the same batteries are shared by multiple actors, the power manager will\n        consider the priority of the actors, the bounds they set, and their preferred\n        power, when calculating the target power for the batteries.\n\n        The preferred power of lower priority actors will take precedence as long as\n        they respect the bounds set by higher priority actors.  If lower priority actors\n        request power values outside of the bounds set by higher priority actors, the\n        target power will be the closest value to the preferred power that is within the\n        bounds.\n\n        When there are no other actors trying to use the same batteries, the actor's\n        preferred power would be set as the target power, as long as it falls within the\n        system power bounds for the batteries.\n\n        The result of the request can be accessed using the receiver returned from the\n        [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n        method, which also streams the bounds that an actor should comply with, based on\n        its priority.\n\n        Args:\n            power: The power to propose for the batteries in the pool.  If `None`, this\n                proposal will not have any effect on the target power, unless bounds are\n                specified.  If both are `None`, it is equivalent to not having a\n                proposal or withdrawing a previous one.\n            request_timeout: The timeout for the request.\n            bounds: The power bounds for the proposal.  These bounds will apply to\n                actors with a lower priority, and can be overridden by bounds from\n                actors with a higher priority.  If None, the power bounds will be set\n                to the maximum power of the batteries in the pool.  This is currently\n                and experimental feature.\n        \"\"\"\n        await self._battery_pool._power_manager_requests_sender.send(\n            _power_managing.Proposal(\n                source_id=self._source_id,\n                preferred_power=power,\n                bounds=bounds,\n                component_ids=self._battery_pool._batteries,\n                priority=self._priority,\n                creation_time=asyncio.get_running_loop().time(),\n                request_timeout=request_timeout,\n            )\n        )\n\n    async def propose_charge(\n        self,\n        power: Power | None,\n        *,\n        request_timeout: timedelta = timedelta(seconds=5.0),\n    ) -&gt; None:\n        \"\"\"Set the given charge power for the batteries in the pool.\n\n        Power values need to be positive values, indicating charge power.\n\n        When using the Passive Sign Convention, the\n        [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n        method might be more convenient.\n\n        If the same batteries are shared by multiple actors, the behaviour is the same\n        as that of the `propose_power` method.  The bounds for lower priority actors\n        can't be specified with this method.  If that's required, use the\n        `propose_power` method instead.\n\n        The result of the request can be accessed using the receiver returned from the\n        [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n        method.\n\n        Args:\n            power: The unsigned charge power to propose for the batteries in the pool.\n                If None, the proposed power of higher priority actors will take\n                precedence as the target power.\n            request_timeout: The timeout for the request.\n\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\n        if power and power &lt; Power.zero():\n            raise ValueError(\"Charge power must be positive.\")\n        await self._battery_pool._power_manager_requests_sender.send(\n            _power_managing.Proposal(\n                source_id=self._source_id,\n                preferred_power=power,\n                bounds=timeseries.Bounds(None, None),\n                component_ids=self._battery_pool._batteries,\n                priority=self._priority,\n                creation_time=asyncio.get_running_loop().time(),\n                request_timeout=request_timeout,\n            )\n        )\n\n    async def propose_discharge(\n        self,\n        power: Power | None,\n        *,\n        request_timeout: timedelta = timedelta(seconds=5.0),\n    ) -&gt; None:\n        \"\"\"Set the given discharge power for the batteries in the pool.\n\n        Power values need to be positive values, indicating discharge power.\n\n        When using the Passive Sign Convention, the\n        [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n        method might be more convenient.\n\n        If the same batteries are shared by multiple actors, the behaviour is the same\n        as that of the `propose_power` method.  The bounds for lower priority actors\n        can't be specified with this method.  If that's required, use the\n        `propose_power` method instead.\n\n        The result of the request can be accessed using the receiver returned from the\n        [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n        method.\n\n        Args:\n            power: The unsigned discharge power to propose for the batteries in the\n                pool.  If None, the proposed power of higher priority actors will take\n                precedence as the target power.\n            request_timeout: The timeout for the request.\n\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\n        if power and power &lt; Power.zero():\n            raise ValueError(\"Discharge power must be positive.\")\n        await self._battery_pool._power_manager_requests_sender.send(\n            _power_managing.Proposal(\n                source_id=self._source_id,\n                preferred_power=power,\n                bounds=timeseries.Bounds(None, None),\n                component_ids=self._battery_pool._batteries,\n                priority=self._priority,\n                creation_time=asyncio.get_running_loop().time(),\n                request_timeout=request_timeout,\n            )\n        )\n\n    @property\n    def battery_ids(self) -&gt; abc.Set[int]:\n        \"\"\"Return ids of the batteries in the pool.\n\n        Returns:\n            Ids of the batteries in the pool\n        \"\"\"\n        return self._battery_pool._batteries\n\n    @property\n    def power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the total power of the batteries in the pool.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all\n                batteries in the pool.\n        \"\"\"\n        engine = self._battery_pool._formula_pool.from_power_formula_generator(\n            \"battery_pool_power\",\n            BatteryPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._battery_pool._batteries,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def soc(self) -&gt; ReceiverFetcher[Sample[Percentage]]:\n        \"\"\"Fetch the normalized average weighted-by-capacity SoC values for the pool.\n\n        The SoC values are normalized to the 0-100% range and clamped if they are out\n        of bounds. Only values from working batteries with operational inverters are\n        considered in the calculation.\n\n        Average SoC is calculated using the formula:\n        ```\n        working_batteries: Set[BatteryData] # working batteries from the battery pool\n\n        soc_scaled = min(max(\n            0,\n            (soc - soc_lower_bound) / (soc_upper_bound - soc_lower_bound) * 100,\n        ), 100)\n        used_capacity = sum(\n            battery.usable_capacity * battery.soc_scaled\n            for battery in working_batteries\n        )\n        total_capacity = sum(battery.usable_capacity for battery in working_batteries)\n        average_soc = used_capacity/total_capacity\n        ```\n\n        `None` values will be sent if there are no working batteries with operational\n        inverters to calculate the metric with.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the aggregate SoC of all\n                batteries in the pool, considering only working batteries with\n                operational inverters.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + SoCCalculator.name()\n\n        if method_name not in self._battery_pool._active_methods:\n            calculator = SoCCalculator(self._battery_pool._batteries)\n            self._battery_pool._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._battery_pool._working_batteries,\n                min_update_interval=self._battery_pool._min_update_interval,\n            )\n\n        return self._battery_pool._active_methods[method_name]\n\n    @property\n    def temperature(self) -&gt; ReceiverFetcher[Sample[Temperature]]:\n        \"\"\"Fetch the average temperature of the batteries in the pool.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the average temperature\n                of all batteries in the pool.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + TemperatureCalculator.name()\n        if method_name not in self._battery_pool._active_methods:\n            calculator = TemperatureCalculator(self._battery_pool._batteries)\n            self._battery_pool._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._battery_pool._working_batteries,\n                min_update_interval=self._battery_pool._min_update_interval,\n            )\n        return self._battery_pool._active_methods[method_name]\n\n    @property\n    def capacity(self) -&gt; ReceiverFetcher[Sample[Energy]]:\n        \"\"\"Get a receiver to receive new capacity metrics when they change.\n\n        The reported capacity values consider only working batteries with operational\n        inverters.\n\n        Calculated with the formula:\n        ```\n        working_batteries: Set[BatteryData] # working batteries from the battery pool\n        total_capacity = sum(\n            battery.capacity * (soc_upper_bound - soc_lower_bound) / 100\n            for battery in working_batteries\n        )\n        ```\n\n        `None` will be sent if there are no working batteries with operational\n        inverters to calculate metrics.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the capacity of all\n                batteries in the pool, considering only working batteries with\n                operational inverters.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + CapacityCalculator.name()\n\n        if method_name not in self._battery_pool._active_methods:\n            calculator = CapacityCalculator(self._battery_pool._batteries)\n            self._battery_pool._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._battery_pool._working_batteries,\n                min_update_interval=self._battery_pool._min_update_interval,\n            )\n\n        return self._battery_pool._active_methods[method_name]\n\n    @property\n    def power_status(self) -&gt; ReceiverFetcher[BatteryPoolReport]:\n        \"\"\"Get a receiver to receive new power status reports when they change.\n\n        These include\n          - the current inclusion/exclusion bounds available for the pool's priority,\n          - the current target power for the pool's set of batteries,\n          - the result of the last distribution request for the pool's set of batteries.\n\n        Returns:\n            A receiver that will stream power status reports for the pool's priority.\n        \"\"\"\n        sub = _power_managing.ReportRequest(\n            source_id=self._source_id,\n            priority=self._priority,\n            component_ids=self._battery_pool._batteries,\n        )\n        self._battery_pool._power_bounds_subs[sub.get_channel_name()] = (\n            asyncio.create_task(\n                self._battery_pool._power_manager_bounds_subscription_sender.send(sub)\n            )\n        )\n        channel = self._battery_pool._channel_registry.get_or_create(\n            _power_managing._Report, sub.get_channel_name()\n        )\n        channel.resend_latest = True\n\n        # More details on why the cast is needed here:\n        # https://github.com/frequenz-floss/frequenz-sdk-python/issues/823\n        return cast(ReceiverFetcher[BatteryPoolReport], channel)\n\n    @property\n    def _system_power_bounds(self) -&gt; ReceiverFetcher[SystemBounds]:\n        \"\"\"Get receiver to receive new power bounds when they change.\n\n        Power bounds refer to the min and max power that a battery can\n        discharge or charge at and is also denoted as SoP.\n\n        Power bounds formulas are described in the receiver return type.\n        None will be send if there is no component to calculate metrics.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the power bounds\n                of all batteries in the pool.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + PowerBoundsCalculator.name()\n\n        if method_name not in self._battery_pool._active_methods:\n            calculator = PowerBoundsCalculator(self._battery_pool._batteries)\n            self._battery_pool._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._battery_pool._working_batteries,\n                min_update_interval=self._battery_pool._min_update_interval,\n            )\n\n        return self._battery_pool._active_methods[method_name]\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.battery_ids","title":"battery_ids  <code>property</code>","text":"<pre><code>battery_ids: Set[int]\n</code></pre> <p>Return ids of the batteries in the pool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Ids of the batteries in the pool</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.capacity","title":"capacity  <code>property</code>","text":"<pre><code>capacity: ReceiverFetcher[Sample[Energy]]\n</code></pre> <p>Get a receiver to receive new capacity metrics when they change.</p> <p>The reported capacity values consider only working batteries with operational inverters.</p> <p>Calculated with the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\ntotal_capacity = sum(\n    battery.capacity * (soc_upper_bound - soc_lower_bound) / 100\n    for battery in working_batteries\n)\n</code></pre></p> <p><code>None</code> will be sent if there are no working batteries with operational inverters to calculate metrics.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Sample[Energy]]</code> <p>A MetricAggregator that will calculate and stream the capacity of all batteries in the pool, considering only working batteries with operational inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the total power of the batteries in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status","title":"power_status  <code>property</code>","text":"<pre><code>power_status: ReceiverFetcher[BatteryPoolReport]\n</code></pre> <p>Get a receiver to receive new power status reports when they change.</p> <p>These include   - the current inclusion/exclusion bounds available for the pool's priority,   - the current target power for the pool's set of batteries,   - the result of the last distribution request for the pool's set of batteries.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[BatteryPoolReport]</code> <p>A receiver that will stream power status reports for the pool's priority.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.soc","title":"soc  <code>property</code>","text":"<pre><code>soc: ReceiverFetcher[Sample[Percentage]]\n</code></pre> <p>Fetch the normalized average weighted-by-capacity SoC values for the pool.</p> <p>The SoC values are normalized to the 0-100% range and clamped if they are out of bounds. Only values from working batteries with operational inverters are considered in the calculation.</p> <p>Average SoC is calculated using the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\n\nsoc_scaled = min(max(\n    0,\n    (soc - soc_lower_bound) / (soc_upper_bound - soc_lower_bound) * 100,\n), 100)\nused_capacity = sum(\n    battery.usable_capacity * battery.soc_scaled\n    for battery in working_batteries\n)\ntotal_capacity = sum(battery.usable_capacity for battery in working_batteries)\naverage_soc = used_capacity/total_capacity\n</code></pre></p> <p><code>None</code> values will be sent if there are no working batteries with operational inverters to calculate the metric with.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Sample[Percentage]]</code> <p>A MetricAggregator that will calculate and stream the aggregate SoC of all batteries in the pool, considering only working batteries with operational inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.temperature","title":"temperature  <code>property</code>","text":"<pre><code>temperature: ReceiverFetcher[Sample[Temperature]]\n</code></pre> <p>Fetch the average temperature of the batteries in the pool.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Sample[Temperature]]</code> <p>A MetricAggregator that will calculate and stream the average temperature of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.__init__","title":"__init__","text":"<pre><code>__init__(\n    battery_pool_ref: BatteryPoolReferenceStore,\n    name: str | None,\n    priority: int,\n)\n</code></pre> <p>Create a BatteryPool instance.</p> <p>Note</p> <p><code>BatteryPool</code> instances are not meant to be created directly by users.  Use the <code>microgrid.battery_pool</code> method for creating <code>BatteryPool</code> instances.</p> PARAMETER  DESCRIPTION <code>battery_pool_ref</code> <p>The battery pool reference store instance.</p> <p> TYPE: <code>BatteryPoolReferenceStore</code> </p> <code>name</code> <p>An optional name used to identify this instance of the pool or a corresponding actor in the logs.</p> <p> TYPE: <code>str | None</code> </p> <code>priority</code> <p>The priority of the actor using this wrapper.</p> <p> TYPE: <code>int</code> </p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>def __init__(\n    self,\n    battery_pool_ref: BatteryPoolReferenceStore,\n    name: str | None,\n    priority: int,\n):\n    \"\"\"Create a BatteryPool instance.\n\n    !!! note\n        `BatteryPool` instances are not meant to be created directly by users.  Use\n        the [`microgrid.battery_pool`][frequenz.sdk.microgrid.battery_pool] method\n        for creating `BatteryPool` instances.\n\n    Args:\n        battery_pool_ref: The battery pool reference store instance.\n        name: An optional name used to identify this instance of the pool or a\n            corresponding actor in the logs.\n        priority: The priority of the actor using this wrapper.\n    \"\"\"\n    self._battery_pool = battery_pool_ref\n    unique_id = str(uuid.uuid4())\n    self._source_id = unique_id if name is None else f\"{name}-{unique_id}\"\n    self._priority = priority\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_charge","title":"propose_charge  <code>async</code>","text":"<pre><code>propose_charge(\n    power: Power | None,\n    *,\n    request_timeout: timedelta = timedelta(seconds=5.0)\n) -&gt; None\n</code></pre> <p>Set the given charge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating charge power.</p> <p>When using the Passive Sign Convention, the <code>propose_power</code> method might be more convenient.</p> <p>If the same batteries are shared by multiple actors, the behaviour is the same as that of the <code>propose_power</code> method.  The bounds for lower priority actors can't be specified with this method.  If that's required, use the <code>propose_power</code> method instead.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_status</code> method.</p> PARAMETER  DESCRIPTION <code>power</code> <p>The unsigned charge power to propose for the batteries in the pool. If None, the proposed power of higher priority actors will take precedence as the target power.</p> <p> TYPE: <code>Power | None</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>async def propose_charge(\n    self,\n    power: Power | None,\n    *,\n    request_timeout: timedelta = timedelta(seconds=5.0),\n) -&gt; None:\n    \"\"\"Set the given charge power for the batteries in the pool.\n\n    Power values need to be positive values, indicating charge power.\n\n    When using the Passive Sign Convention, the\n    [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n    method might be more convenient.\n\n    If the same batteries are shared by multiple actors, the behaviour is the same\n    as that of the `propose_power` method.  The bounds for lower priority actors\n    can't be specified with this method.  If that's required, use the\n    `propose_power` method instead.\n\n    The result of the request can be accessed using the receiver returned from the\n    [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n    method.\n\n    Args:\n        power: The unsigned charge power to propose for the batteries in the pool.\n            If None, the proposed power of higher priority actors will take\n            precedence as the target power.\n        request_timeout: The timeout for the request.\n\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\n    if power and power &lt; Power.zero():\n        raise ValueError(\"Charge power must be positive.\")\n    await self._battery_pool._power_manager_requests_sender.send(\n        _power_managing.Proposal(\n            source_id=self._source_id,\n            preferred_power=power,\n            bounds=timeseries.Bounds(None, None),\n            component_ids=self._battery_pool._batteries,\n            priority=self._priority,\n            creation_time=asyncio.get_running_loop().time(),\n            request_timeout=request_timeout,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_discharge","title":"propose_discharge  <code>async</code>","text":"<pre><code>propose_discharge(\n    power: Power | None,\n    *,\n    request_timeout: timedelta = timedelta(seconds=5.0)\n) -&gt; None\n</code></pre> <p>Set the given discharge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating discharge power.</p> <p>When using the Passive Sign Convention, the <code>propose_power</code> method might be more convenient.</p> <p>If the same batteries are shared by multiple actors, the behaviour is the same as that of the <code>propose_power</code> method.  The bounds for lower priority actors can't be specified with this method.  If that's required, use the <code>propose_power</code> method instead.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_status</code> method.</p> PARAMETER  DESCRIPTION <code>power</code> <p>The unsigned discharge power to propose for the batteries in the pool.  If None, the proposed power of higher priority actors will take precedence as the target power.</p> <p> TYPE: <code>Power | None</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>async def propose_discharge(\n    self,\n    power: Power | None,\n    *,\n    request_timeout: timedelta = timedelta(seconds=5.0),\n) -&gt; None:\n    \"\"\"Set the given discharge power for the batteries in the pool.\n\n    Power values need to be positive values, indicating discharge power.\n\n    When using the Passive Sign Convention, the\n    [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n    method might be more convenient.\n\n    If the same batteries are shared by multiple actors, the behaviour is the same\n    as that of the `propose_power` method.  The bounds for lower priority actors\n    can't be specified with this method.  If that's required, use the\n    `propose_power` method instead.\n\n    The result of the request can be accessed using the receiver returned from the\n    [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n    method.\n\n    Args:\n        power: The unsigned discharge power to propose for the batteries in the\n            pool.  If None, the proposed power of higher priority actors will take\n            precedence as the target power.\n        request_timeout: The timeout for the request.\n\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\n    if power and power &lt; Power.zero():\n        raise ValueError(\"Discharge power must be positive.\")\n    await self._battery_pool._power_manager_requests_sender.send(\n        _power_managing.Proposal(\n            source_id=self._source_id,\n            preferred_power=power,\n            bounds=timeseries.Bounds(None, None),\n            component_ids=self._battery_pool._batteries,\n            priority=self._priority,\n            creation_time=asyncio.get_running_loop().time(),\n            request_timeout=request_timeout,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power","title":"propose_power  <code>async</code>","text":"<pre><code>propose_power(\n    power: Power | None,\n    *,\n    request_timeout: timedelta = timedelta(seconds=5.0),\n    bounds: Bounds[Power | None] = timeseries.Bounds(\n        None, None\n    )\n) -&gt; None\n</code></pre> <p>Send a proposal to the power manager for the pool's set of batteries.</p> <p>Power values need to follow the Passive Sign Convention (PSC). That is, positive values indicate charge power and negative values indicate discharge power.</p> <p>If the same batteries are shared by multiple actors, the power manager will consider the priority of the actors, the bounds they set, and their preferred power, when calculating the target power for the batteries.</p> <p>The preferred power of lower priority actors will take precedence as long as they respect the bounds set by higher priority actors.  If lower priority actors request power values outside of the bounds set by higher priority actors, the target power will be the closest value to the preferred power that is within the bounds.</p> <p>When there are no other actors trying to use the same batteries, the actor's preferred power would be set as the target power, as long as it falls within the system power bounds for the batteries.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_status</code> method, which also streams the bounds that an actor should comply with, based on its priority.</p> PARAMETER  DESCRIPTION <code>power</code> <p>The power to propose for the batteries in the pool.  If <code>None</code>, this proposal will not have any effect on the target power, unless bounds are specified.  If both are <code>None</code>, it is equivalent to not having a proposal or withdrawing a previous one.</p> <p> TYPE: <code>Power | None</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>bounds</code> <p>The power bounds for the proposal.  These bounds will apply to actors with a lower priority, and can be overridden by bounds from actors with a higher priority.  If None, the power bounds will be set to the maximum power of the batteries in the pool.  This is currently and experimental feature.</p> <p> TYPE: <code>Bounds[Power | None]</code> DEFAULT: <code>Bounds(None, None)</code> </p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>async def propose_power(\n    self,\n    power: Power | None,\n    *,\n    request_timeout: timedelta = timedelta(seconds=5.0),\n    bounds: timeseries.Bounds[Power | None] = timeseries.Bounds(None, None),\n) -&gt; None:\n    \"\"\"Send a proposal to the power manager for the pool's set of batteries.\n\n    Power values need to follow the Passive Sign Convention (PSC). That is, positive\n    values indicate charge power and negative values indicate discharge power.\n\n    If the same batteries are shared by multiple actors, the power manager will\n    consider the priority of the actors, the bounds they set, and their preferred\n    power, when calculating the target power for the batteries.\n\n    The preferred power of lower priority actors will take precedence as long as\n    they respect the bounds set by higher priority actors.  If lower priority actors\n    request power values outside of the bounds set by higher priority actors, the\n    target power will be the closest value to the preferred power that is within the\n    bounds.\n\n    When there are no other actors trying to use the same batteries, the actor's\n    preferred power would be set as the target power, as long as it falls within the\n    system power bounds for the batteries.\n\n    The result of the request can be accessed using the receiver returned from the\n    [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n    method, which also streams the bounds that an actor should comply with, based on\n    its priority.\n\n    Args:\n        power: The power to propose for the batteries in the pool.  If `None`, this\n            proposal will not have any effect on the target power, unless bounds are\n            specified.  If both are `None`, it is equivalent to not having a\n            proposal or withdrawing a previous one.\n        request_timeout: The timeout for the request.\n        bounds: The power bounds for the proposal.  These bounds will apply to\n            actors with a lower priority, and can be overridden by bounds from\n            actors with a higher priority.  If None, the power bounds will be set\n            to the maximum power of the batteries in the pool.  This is currently\n            and experimental feature.\n    \"\"\"\n    await self._battery_pool._power_manager_requests_sender.send(\n        _power_managing.Proposal(\n            source_id=self._source_id,\n            preferred_power=power,\n            bounds=bounds,\n            component_ids=self._battery_pool._batteries,\n            priority=self._priority,\n            creation_time=asyncio.get_running_loop().time(),\n            request_timeout=request_timeout,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport","title":"frequenz.sdk.timeseries.battery_pool.BatteryPoolReport","text":"<p>             Bases: <code>Report</code></p> <p>A status report for a battery pool.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_result_types.py</code> <pre><code>class BatteryPoolReport(Report):\n    \"\"\"A status report for a battery pool.\"\"\"\n\n    target_power: Power | None\n    \"\"\"The currently set power for the batteries.\"\"\"\n\n    distribution_result: power_distributing.Result | None\n    \"\"\"The result of the last power distribution.\n\n    This is `None` if no power distribution has been performed yet.\n    \"\"\"\n\n    @property\n    def bounds(self) -&gt; Bounds[Power] | None:\n        \"\"\"The usable bounds for the batteries.\n\n        These bounds are adjusted to any restrictions placed by actors with higher\n        priorities.\n\n        There might be exclusion zones within these bounds. If necessary, the\n        [`adjust_to_bounds`][frequenz.sdk.timeseries.battery_pool.BatteryPoolReport.adjust_to_bounds]\n        method may be used to check if a desired power value fits the bounds, or to get\n        the closest possible power values that do fit the bounds.\n        \"\"\"\n\n    @abc.abstractmethod\n    def adjust_to_bounds(self, power: Power) -&gt; tuple[Power | None, Power | None]:\n        \"\"\"Adjust a power value to the bounds.\n\n        This method can be used to adjust a desired power value to the power bounds\n        available to the actor.\n\n        If the given power value falls within the usable bounds, it will be returned\n        unchanged.\n\n        If it falls outside the usable bounds, the closest possible value on the\n        corresponding side will be returned.  For example, if the given power is lower\n        than the lowest usable power, only the lowest usable power will be returned, and\n        similarly for the highest usable power.\n\n        If the given power falls within an exclusion zone that's contained within the\n        usable bounds, the closest possible power values on both sides will be returned.\n\n        !!! note\n            It is completely optional to use this method to adjust power values before\n            proposing them, because the battery pool will do this automatically.  This\n            method is provided for convenience, and for granular control when there are\n            two possible power values, both of which fall within the available bounds.\n\n        Example:\n            ```python\n            from frequenz.sdk import microgrid\n\n            power_status_rx = microgrid.battery_pool().power_status.new_receiver()\n            power_status = await power_status_rx.receive()\n            desired_power = Power.from_watts(1000.0)\n\n            match power_status.adjust_to_bounds(desired_power):\n                case (power, _) if power == desired_power:\n                    print(\"Desired power is available.\")\n                case (None, power) | (power, None) if power:\n                    print(f\"Closest available power is {power}.\")\n                case (lower, upper) if lower and upper:\n                    print(f\"Two options {lower}, {upper} to propose to battery pool.\")\n                case (None, None):\n                    print(\"No available power\")\n            ```\n\n        Args:\n            power: The power value to adjust.\n\n        Returns:\n            A tuple of the closest power values to the desired power that fall within\n                the available bounds for the actor.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport.bounds","title":"bounds  <code>property</code>","text":"<pre><code>bounds: Bounds[Power] | None\n</code></pre> <p>The usable bounds for the batteries.</p> <p>These bounds are adjusted to any restrictions placed by actors with higher priorities.</p> <p>There might be exclusion zones within these bounds. If necessary, the <code>adjust_to_bounds</code> method may be used to check if a desired power value fits the bounds, or to get the closest possible power values that do fit the bounds.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport.distribution_result","title":"distribution_result  <code>instance-attribute</code>","text":"<pre><code>distribution_result: Result | None\n</code></pre> <p>The result of the last power distribution.</p> <p>This is <code>None</code> if no power distribution has been performed yet.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport.target_power","title":"target_power  <code>instance-attribute</code>","text":"<pre><code>target_power: Power | None\n</code></pre> <p>The currently set power for the batteries.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport.adjust_to_bounds","title":"adjust_to_bounds  <code>abstractmethod</code>","text":"<pre><code>adjust_to_bounds(\n    power: Power,\n) -&gt; tuple[Power | None, Power | None]\n</code></pre> <p>Adjust a power value to the bounds.</p> <p>This method can be used to adjust a desired power value to the power bounds available to the actor.</p> <p>If the given power value falls within the usable bounds, it will be returned unchanged.</p> <p>If it falls outside the usable bounds, the closest possible value on the corresponding side will be returned.  For example, if the given power is lower than the lowest usable power, only the lowest usable power will be returned, and similarly for the highest usable power.</p> <p>If the given power falls within an exclusion zone that's contained within the usable bounds, the closest possible power values on both sides will be returned.</p> <p>Note</p> <p>It is completely optional to use this method to adjust power values before proposing them, because the battery pool will do this automatically.  This method is provided for convenience, and for granular control when there are two possible power values, both of which fall within the available bounds.</p> Example <pre><code>from frequenz.sdk import microgrid\n\npower_status_rx = microgrid.battery_pool().power_status.new_receiver()\npower_status = await power_status_rx.receive()\ndesired_power = Power.from_watts(1000.0)\n\nmatch power_status.adjust_to_bounds(desired_power):\n    case (power, _) if power == desired_power:\n        print(\"Desired power is available.\")\n    case (None, power) | (power, None) if power:\n        print(f\"Closest available power is {power}.\")\n    case (lower, upper) if lower and upper:\n        print(f\"Two options {lower}, {upper} to propose to battery pool.\")\n    case (None, None):\n        print(\"No available power\")\n</code></pre> PARAMETER  DESCRIPTION <code>power</code> <p>The power value to adjust.</p> <p> TYPE: <code>Power</code> </p> RETURNS DESCRIPTION <code>tuple[Power | None, Power | None]</code> <p>A tuple of the closest power values to the desired power that fall within the available bounds for the actor.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_result_types.py</code> <pre><code>@abc.abstractmethod\ndef adjust_to_bounds(self, power: Power) -&gt; tuple[Power | None, Power | None]:\n    \"\"\"Adjust a power value to the bounds.\n\n    This method can be used to adjust a desired power value to the power bounds\n    available to the actor.\n\n    If the given power value falls within the usable bounds, it will be returned\n    unchanged.\n\n    If it falls outside the usable bounds, the closest possible value on the\n    corresponding side will be returned.  For example, if the given power is lower\n    than the lowest usable power, only the lowest usable power will be returned, and\n    similarly for the highest usable power.\n\n    If the given power falls within an exclusion zone that's contained within the\n    usable bounds, the closest possible power values on both sides will be returned.\n\n    !!! note\n        It is completely optional to use this method to adjust power values before\n        proposing them, because the battery pool will do this automatically.  This\n        method is provided for convenience, and for granular control when there are\n        two possible power values, both of which fall within the available bounds.\n\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n\n        power_status_rx = microgrid.battery_pool().power_status.new_receiver()\n        power_status = await power_status_rx.receive()\n        desired_power = Power.from_watts(1000.0)\n\n        match power_status.adjust_to_bounds(desired_power):\n            case (power, _) if power == desired_power:\n                print(\"Desired power is available.\")\n            case (None, power) | (power, None) if power:\n                print(f\"Closest available power is {power}.\")\n            case (lower, upper) if lower and upper:\n                print(f\"Two options {lower}, {upper} to propose to battery pool.\")\n            case (None, None):\n                print(\"No available power\")\n        ```\n\n    Args:\n        power: The power value to adjust.\n\n    Returns:\n        A tuple of the closest power values to the desired power that fall within\n            the available bounds for the actor.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/","title":"ev_charger_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool","title":"frequenz.sdk.timeseries.ev_charger_pool","text":"<p>Interactions with EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit","title":"frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit  <code>dataclass</code>","text":"<p>A current limit, to be sent to the EV Charger.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_set_current_bounds.py</code> <pre><code>@dataclass\nclass ComponentCurrentLimit:\n    \"\"\"A current limit, to be sent to the EV Charger.\"\"\"\n\n    component_id: int\n    \"\"\"The component ID of the EV Charger.\"\"\"\n\n    max_amps: float\n    \"\"\"The maximum current in amps, that an EV can draw from this EV Charger.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The component ID of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit.max_amps","title":"max_amps  <code>instance-attribute</code>","text":"<pre><code>max_amps: float\n</code></pre> <p>The maximum current in amps, that an EV can draw from this EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData","title":"frequenz.sdk.timeseries.ev_charger_pool.EVChargerData  <code>dataclass</code>","text":"<p>Data for an EV Charger, including the 3-phase current and the component state.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>@dataclass(frozen=True)\nclass EVChargerData:\n    \"\"\"Data for an EV Charger, including the 3-phase current and the component state.\"\"\"\n\n    component_id: int\n    \"\"\"The component ID of the EV Charger.\"\"\"\n\n    current: Sample3Phase[Current]\n    \"\"\"The 3-phase current of the EV Charger.\"\"\"\n\n    state: EVChargerState\n    \"\"\"The state of the EV Charger.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The component ID of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData.current","title":"current  <code>instance-attribute</code>","text":"<pre><code>current: Sample3Phase[Current]\n</code></pre> <p>The 3-phase current of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: EVChargerState\n</code></pre> <p>The state of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool","title":"frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool","text":"<p>An interface for interaction with pools of EV Chargers.</p> <p>Note</p> <p><code>EVChargerPool</code> instances are not meant to be created directly by users. Use the <code>microgrid.ev_charger_pool</code> method for creating <code>EVChargerPool</code> instances.</p> Provides <ul> <li>Aggregate <code>power</code>   and 3-phase   <code>current</code>   measurements of the EV Chargers in the pool.</li> <li>The   <code>component_data</code>   method for fetching the 3-phase current and state of individual EV Chargers in   the pool.</li> <li>The   <code>set_bounds</code>   method for limiting the max current of individual EV Chargers in the pool.</li> </ul> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>class EVChargerPool:\n    \"\"\"An interface for interaction with pools of EV Chargers.\n\n    !!! note\n        `EVChargerPool` instances are not meant to be created directly by users. Use the\n        [`microgrid.ev_charger_pool`][frequenz.sdk.microgrid.ev_charger_pool] method for\n        creating `EVChargerPool` instances.\n\n    Provides:\n      - Aggregate [`power`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.power]\n        and 3-phase\n        [`current`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.current]\n        measurements of the EV Chargers in the pool.\n      - The\n        [`component_data`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.component_data]\n        method for fetching the 3-phase current and state of individual EV Chargers in\n        the pool.\n      - The\n        [`set_bounds`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.set_bounds]\n        method for limiting the max current of individual EV Chargers in the pool.\n    \"\"\"\n\n    def __init__(\n        self,\n        channel_registry: ChannelRegistry,\n        resampler_subscription_sender: Sender[ComponentMetricRequest],\n        component_ids: set[int] | None = None,\n        repeat_interval: timedelta = timedelta(seconds=3.0),\n    ) -&gt; None:\n        \"\"\"Create an `EVChargerPool` instance.\n\n        !!! note\n            `EVChargerPool` instances are not meant to be created directly by users. Use\n            the [`microgrid.ev_charger_pool`][frequenz.sdk.microgrid.ev_charger_pool]\n            method for creating `EVChargerPool` instances.\n\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n            component_ids: An optional list of component_ids belonging to this pool.  If\n                not specified, IDs of all EV Chargers in the microgrid will be fetched\n                from the component graph.\n            repeat_interval: Interval after which to repeat the last set bounds to the\n                microgrid API, if no new calls to `set_bounds` have been made.\n        \"\"\"\n        self._channel_registry: ChannelRegistry = channel_registry\n        self._repeat_interval: timedelta = repeat_interval\n        self._resampler_subscription_sender: Sender[ComponentMetricRequest] = (\n            resampler_subscription_sender\n        )\n        self._component_ids: set[int] = set()\n        if component_ids is not None:\n            self._component_ids = component_ids\n        else:\n            graph = connection_manager.get().component_graph\n            self._component_ids = {\n                evc.component_id\n                for evc in graph.components(\n                    component_categories={ComponentCategory.EV_CHARGER}\n                )\n            }\n        self._state_tracker: StateTracker | None = None\n        self._status_streams: dict[int, tuple[Task[None], Broadcast[EVChargerData]]] = (\n            {}\n        )\n        self._namespace: str = f\"ev-charger-pool-{uuid.uuid4()}\"\n        self._formula_pool: FormulaEnginePool = FormulaEnginePool(\n            self._namespace,\n            self._channel_registry,\n            self._resampler_subscription_sender,\n        )\n        self._bounds_setter: BoundsSetter | None = None\n\n    @property\n    def component_ids(self) -&gt; abc.Set[int]:\n        \"\"\"Return component IDs of all EV Chargers managed by this EVChargerPool.\n\n        Returns:\n            Set of managed component IDs.\n        \"\"\"\n        return self._component_ids\n\n    @property\n    def current(self) -&gt; FormulaEngine3Phase[Current]:\n        \"\"\"Fetch the total current for the EV Chargers in the pool.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate EV Charger current is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total current of all EV\n                Chargers.\n        \"\"\"\n        engine = self._formula_pool.from_3_phase_current_formula_generator(\n            \"ev_charger_total_current\",\n            EVChargerCurrentFormula,\n            FormulaGeneratorConfig(component_ids=self._component_ids),\n        )\n        assert isinstance(engine, FormulaEngine3Phase)\n        return engine\n\n    @property\n    def power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the total power for the EV Chargers in the pool.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate EV Charger power is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all EV\n                Chargers.\n        \"\"\"\n        engine = self._formula_pool.from_power_formula_generator(\n            \"ev_charger_power\",\n            EVChargerPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._component_ids,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    def component_data(self, component_id: int) -&gt; Receiver[EVChargerData]:\n        \"\"\"Stream 3-phase current values and state of an EV Charger.\n\n        Args:\n            component_id: id of the EV Charger for which data is requested.\n\n        Returns:\n            A receiver that streams objects containing 3-phase current and state of\n                an EV Charger.\n        \"\"\"\n        if recv := self._status_streams.get(component_id, None):\n            task, output_chan = recv\n            if not task.done():\n                return output_chan.new_receiver()\n            _logger.warning(\"Restarting component_status for id: %s\", component_id)\n        else:\n            output_chan = Broadcast[EVChargerData](\n                f\"evpool-component_status-{component_id}\"\n            )\n\n        task = asyncio.create_task(\n            self._stream_component_data(component_id, output_chan.new_sender())\n        )\n\n        self._status_streams[component_id] = (task, output_chan)\n\n        return output_chan.new_receiver()\n\n    async def set_bounds(self, component_id: int, max_current: Current) -&gt; None:\n        \"\"\"Send given max current bound for the given EV Charger to the microgrid API.\n\n        Bounds are used to limit the max current drawn by an EV, although the exact\n        value will be determined by the EV.\n\n        Args:\n            component_id: ID of EV Charger to set the current bounds to.\n            max_current: maximum current that an EV can draw from this EV Charger.\n        \"\"\"\n        if not self._bounds_setter:\n            self._bounds_setter = BoundsSetter(self._repeat_interval)\n        await self._bounds_setter.set(component_id, max_current.as_amperes())\n\n    def new_bounds_sender(self) -&gt; Sender[ComponentCurrentLimit]:\n        \"\"\"Return a `Sender` for setting EV Charger current bounds with.\n\n        Bounds are used to limit the max current drawn by an EV, although the exact\n        value will be determined by the EV.\n\n        Returns:\n            A new `Sender`.\n        \"\"\"\n        if not self._bounds_setter:\n            self._bounds_setter = BoundsSetter(self._repeat_interval)\n        return self._bounds_setter.new_bounds_sender()\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all tasks and channels owned by the EVChargerPool.\"\"\"\n        if self._bounds_setter:\n            await self._bounds_setter.stop()\n        if self._state_tracker:\n            await self._state_tracker.stop()\n        await self._formula_pool.stop()\n        for stream in self._status_streams.values():\n            task, chan = stream\n            await chan.close()\n            await cancel_and_await(task)\n\n    async def _get_current_streams(self, component_id: int) -&gt; tuple[\n        Receiver[Sample[Quantity]],\n        Receiver[Sample[Quantity]],\n        Receiver[Sample[Quantity]],\n    ]:\n        \"\"\"Fetch current streams from the resampler for each phase.\n\n        Args:\n            component_id: id of EV Charger for which current streams are being fetched.\n\n        Returns:\n            A tuple of 3 receivers stream resampled current values for the given\n                component id, one for each phase.\n        \"\"\"\n\n        async def resampler_subscribe(\n            metric_id: ComponentMetricId,\n        ) -&gt; Receiver[Sample[Quantity]]:\n            request = ComponentMetricRequest(\n                namespace=\"ev-pool\",\n                component_id=component_id,\n                metric_id=metric_id,\n                start_time=None,\n            )\n            await self._resampler_subscription_sender.send(request)\n            return self._channel_registry.get_or_create(\n                Sample[Quantity], request.get_channel_name()\n            ).new_receiver()\n\n        return (\n            await resampler_subscribe(ComponentMetricId.CURRENT_PHASE_1),\n            await resampler_subscribe(ComponentMetricId.CURRENT_PHASE_2),\n            await resampler_subscribe(ComponentMetricId.CURRENT_PHASE_3),\n        )\n\n    async def _stream_component_data(\n        self,\n        component_id: int,\n        sender: Sender[EVChargerData],\n    ) -&gt; None:\n        \"\"\"Stream 3-phase current values and state of an EV Charger.\n\n        Args:\n            component_id: id of the EV Charger for which data is requested.\n            sender: A sender to stream EV Charger data to.\n\n        Raises:\n            ChannelClosedError: If the channels from the resampler are closed.\n        \"\"\"\n        if not self._state_tracker:\n            self._state_tracker = StateTracker(self._component_ids)\n\n        (phase_1_rx, phase_2_rx, phase_3_rx) = await self._get_current_streams(\n            component_id\n        )\n        while True:\n            try:\n                (phase_1, phase_2, phase_3) = (\n                    await phase_1_rx.receive(),\n                    await phase_2_rx.receive(),\n                    await phase_3_rx.receive(),\n                )\n            except ChannelClosedError:\n                _logger.exception(\"Streams closed for component_id=%s.\", component_id)\n                raise\n\n            sample = Sample3Phase(\n                timestamp=phase_1.timestamp,\n                value_p1=(\n                    None\n                    if phase_1.value is None\n                    else Current.from_amperes(phase_1.value.base_value)\n                ),\n                value_p2=(\n                    None\n                    if phase_2.value is None\n                    else Current.from_amperes(phase_2.value.base_value)\n                ),\n                value_p3=(\n                    None\n                    if phase_3.value is None\n                    else Current.from_amperes(phase_3.value.base_value)\n                ),\n            )\n\n            if (\n                phase_1.value is None\n                and phase_2.value is None\n                and phase_3.value is None\n            ):\n                state = EVChargerState.MISSING\n            else:\n                state = self._state_tracker.get(component_id)\n\n            await sender.send(\n                EVChargerData(\n                    component_id=component_id,\n                    current=sample,\n                    state=state,\n                )\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids: Set[int]\n</code></pre> <p>Return component IDs of all EV Chargers managed by this EVChargerPool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Set of managed component IDs.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.current","title":"current  <code>property</code>","text":"<pre><code>current: FormulaEngine3Phase[Current]\n</code></pre> <p>Fetch the total current for the EV Chargers in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate EV Charger current is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine3Phase[Current]</code> <p>A FormulaEngine that will calculate and stream the total current of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the total power for the EV Chargers in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate EV Charger power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total power of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.__init__","title":"__init__","text":"<pre><code>__init__(\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[\n        ComponentMetricRequest\n    ],\n    component_ids: set[int] | None = None,\n    repeat_interval: timedelta = timedelta(seconds=3.0),\n) -&gt; None\n</code></pre> <p>Create an <code>EVChargerPool</code> instance.</p> <p>Note</p> <p><code>EVChargerPool</code> instances are not meant to be created directly by users. Use the <code>microgrid.ev_charger_pool</code> method for creating <code>EVChargerPool</code> instances.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>component_ids</code> <p>An optional list of component_ids belonging to this pool.  If not specified, IDs of all EV Chargers in the microgrid will be fetched from the component graph.</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>repeat_interval</code> <p>Interval after which to repeat the last set bounds to the microgrid API, if no new calls to <code>set_bounds</code> have been made.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=3.0)</code> </p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def __init__(\n    self,\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n    component_ids: set[int] | None = None,\n    repeat_interval: timedelta = timedelta(seconds=3.0),\n) -&gt; None:\n    \"\"\"Create an `EVChargerPool` instance.\n\n    !!! note\n        `EVChargerPool` instances are not meant to be created directly by users. Use\n        the [`microgrid.ev_charger_pool`][frequenz.sdk.microgrid.ev_charger_pool]\n        method for creating `EVChargerPool` instances.\n\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n        component_ids: An optional list of component_ids belonging to this pool.  If\n            not specified, IDs of all EV Chargers in the microgrid will be fetched\n            from the component graph.\n        repeat_interval: Interval after which to repeat the last set bounds to the\n            microgrid API, if no new calls to `set_bounds` have been made.\n    \"\"\"\n    self._channel_registry: ChannelRegistry = channel_registry\n    self._repeat_interval: timedelta = repeat_interval\n    self._resampler_subscription_sender: Sender[ComponentMetricRequest] = (\n        resampler_subscription_sender\n    )\n    self._component_ids: set[int] = set()\n    if component_ids is not None:\n        self._component_ids = component_ids\n    else:\n        graph = connection_manager.get().component_graph\n        self._component_ids = {\n            evc.component_id\n            for evc in graph.components(\n                component_categories={ComponentCategory.EV_CHARGER}\n            )\n        }\n    self._state_tracker: StateTracker | None = None\n    self._status_streams: dict[int, tuple[Task[None], Broadcast[EVChargerData]]] = (\n        {}\n    )\n    self._namespace: str = f\"ev-charger-pool-{uuid.uuid4()}\"\n    self._formula_pool: FormulaEnginePool = FormulaEnginePool(\n        self._namespace,\n        self._channel_registry,\n        self._resampler_subscription_sender,\n    )\n    self._bounds_setter: BoundsSetter | None = None\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.component_data","title":"component_data","text":"<pre><code>component_data(\n    component_id: int,\n) -&gt; Receiver[EVChargerData]\n</code></pre> <p>Stream 3-phase current values and state of an EV Charger.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the EV Charger for which data is requested.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A receiver that streams objects containing 3-phase current and state of an EV Charger.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def component_data(self, component_id: int) -&gt; Receiver[EVChargerData]:\n    \"\"\"Stream 3-phase current values and state of an EV Charger.\n\n    Args:\n        component_id: id of the EV Charger for which data is requested.\n\n    Returns:\n        A receiver that streams objects containing 3-phase current and state of\n            an EV Charger.\n    \"\"\"\n    if recv := self._status_streams.get(component_id, None):\n        task, output_chan = recv\n        if not task.done():\n            return output_chan.new_receiver()\n        _logger.warning(\"Restarting component_status for id: %s\", component_id)\n    else:\n        output_chan = Broadcast[EVChargerData](\n            f\"evpool-component_status-{component_id}\"\n        )\n\n    task = asyncio.create_task(\n        self._stream_component_data(component_id, output_chan.new_sender())\n    )\n\n    self._status_streams[component_id] = (task, output_chan)\n\n    return output_chan.new_receiver()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.new_bounds_sender","title":"new_bounds_sender","text":"<pre><code>new_bounds_sender() -&gt; Sender[ComponentCurrentLimit]\n</code></pre> <p>Return a <code>Sender</code> for setting EV Charger current bounds with.</p> <p>Bounds are used to limit the max current drawn by an EV, although the exact value will be determined by the EV.</p> RETURNS DESCRIPTION <code>Sender[ComponentCurrentLimit]</code> <p>A new <code>Sender</code>.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def new_bounds_sender(self) -&gt; Sender[ComponentCurrentLimit]:\n    \"\"\"Return a `Sender` for setting EV Charger current bounds with.\n\n    Bounds are used to limit the max current drawn by an EV, although the exact\n    value will be determined by the EV.\n\n    Returns:\n        A new `Sender`.\n    \"\"\"\n    if not self._bounds_setter:\n        self._bounds_setter = BoundsSetter(self._repeat_interval)\n    return self._bounds_setter.new_bounds_sender()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.set_bounds","title":"set_bounds  <code>async</code>","text":"<pre><code>set_bounds(component_id: int, max_current: Current) -&gt; None\n</code></pre> <p>Send given max current bound for the given EV Charger to the microgrid API.</p> <p>Bounds are used to limit the max current drawn by an EV, although the exact value will be determined by the EV.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>ID of EV Charger to set the current bounds to.</p> <p> TYPE: <code>int</code> </p> <code>max_current</code> <p>maximum current that an EV can draw from this EV Charger.</p> <p> TYPE: <code>Current</code> </p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>async def set_bounds(self, component_id: int, max_current: Current) -&gt; None:\n    \"\"\"Send given max current bound for the given EV Charger to the microgrid API.\n\n    Bounds are used to limit the max current drawn by an EV, although the exact\n    value will be determined by the EV.\n\n    Args:\n        component_id: ID of EV Charger to set the current bounds to.\n        max_current: maximum current that an EV can draw from this EV Charger.\n    \"\"\"\n    if not self._bounds_setter:\n        self._bounds_setter = BoundsSetter(self._repeat_interval)\n    await self._bounds_setter.set(component_id, max_current.as_amperes())\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all tasks and channels owned by the EVChargerPool.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all tasks and channels owned by the EVChargerPool.\"\"\"\n    if self._bounds_setter:\n        await self._bounds_setter.stop()\n    if self._state_tracker:\n        await self._state_tracker.stop()\n    await self._formula_pool.stop()\n    for stream in self._status_streams.values():\n        task, chan = stream\n        await chan.close()\n        await cancel_and_await(task)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolError","title":"frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolError","text":"<p>             Bases: <code>Exception</code></p> <p>An error that occurred in any of the EVChargerPool methods.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>class EVChargerPoolError(Exception):\n    \"\"\"An error that occurred in any of the EVChargerPool methods.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState","title":"frequenz.sdk.timeseries.ev_charger_pool.EVChargerState","text":"<p>             Bases: <code>Enum</code></p> <p>State of individual EV charger.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>class EVChargerState(Enum):\n    \"\"\"State of individual EV charger.\"\"\"\n\n    UNSPECIFIED = \"UNSPECIFIED\"\n    \"\"\"The state is unspecified.\"\"\"\n\n    MISSING = \"MISSING\"\n    \"\"\"The EV Charger is missing.\"\"\"\n\n    IDLE = \"IDLE\"\n    \"\"\"The EV Charger is idle.\"\"\"\n\n    EV_PLUGGED = \"EV_PLUGGED\"\n    \"\"\"The EV Charger has an EV plugged in.\"\"\"\n\n    EV_LOCKED = \"EV_LOCKED\"\n    \"\"\"The EV Charger has an EV plugged in and locked.\"\"\"\n\n    ERROR = \"ERROR\"\n    \"\"\"The EV Charger is in an error state.\"\"\"\n\n    @classmethod\n    def from_ev_charger_data(cls, data: EVChargerData) -&gt; EVChargerState:\n        \"\"\"Create an `EVChargerState` instance from component data.\n\n        Args:\n            data: ev charger data coming from microgrid.\n\n        Returns:\n            An `EVChargerState` instance.\n        \"\"\"\n        if data.component_state == EVChargerComponentState.UNSPECIFIED:\n            return EVChargerState.UNSPECIFIED\n        if data.component_state in (\n            EVChargerComponentState.AUTHORIZATION_REJECTED,\n            EVChargerComponentState.ERROR,\n        ):\n            return EVChargerState.ERROR\n\n        if data.cable_state == EVChargerCableState.UNSPECIFIED:\n            return EVChargerState.UNSPECIFIED\n        if data.cable_state == EVChargerCableState.EV_LOCKED:\n            return EVChargerState.EV_LOCKED\n        if data.cable_state == EVChargerCableState.EV_PLUGGED:\n            return EVChargerState.EV_PLUGGED\n        return EVChargerState.IDLE\n\n    def is_ev_connected(self) -&gt; bool:\n        \"\"\"Check whether an EV is connected to the charger.\n\n        Returns:\n            Whether an EV is connected to the charger.\n        \"\"\"\n        return self in (EVChargerState.EV_PLUGGED, EVChargerState.EV_LOCKED)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 'ERROR'\n</code></pre> <p>The EV Charger is in an error state.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.EV_LOCKED","title":"EV_LOCKED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_LOCKED = 'EV_LOCKED'\n</code></pre> <p>The EV Charger has an EV plugged in and locked.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.EV_PLUGGED","title":"EV_PLUGGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EV_PLUGGED = 'EV_PLUGGED'\n</code></pre> <p>The EV Charger has an EV plugged in.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.IDLE","title":"IDLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IDLE = 'IDLE'\n</code></pre> <p>The EV Charger is idle.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.MISSING","title":"MISSING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MISSING = 'MISSING'\n</code></pre> <p>The EV Charger is missing.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = 'UNSPECIFIED'\n</code></pre> <p>The state is unspecified.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.from_ev_charger_data","title":"from_ev_charger_data  <code>classmethod</code>","text":"<pre><code>from_ev_charger_data(data: EVChargerData) -&gt; EVChargerState\n</code></pre> <p>Create an <code>EVChargerState</code> instance from component data.</p> PARAMETER  DESCRIPTION <code>data</code> <p>ev charger data coming from microgrid.</p> <p> TYPE: <code>EVChargerData</code> </p> RETURNS DESCRIPTION <code>EVChargerState</code> <p>An <code>EVChargerState</code> instance.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>@classmethod\ndef from_ev_charger_data(cls, data: EVChargerData) -&gt; EVChargerState:\n    \"\"\"Create an `EVChargerState` instance from component data.\n\n    Args:\n        data: ev charger data coming from microgrid.\n\n    Returns:\n        An `EVChargerState` instance.\n    \"\"\"\n    if data.component_state == EVChargerComponentState.UNSPECIFIED:\n        return EVChargerState.UNSPECIFIED\n    if data.component_state in (\n        EVChargerComponentState.AUTHORIZATION_REJECTED,\n        EVChargerComponentState.ERROR,\n    ):\n        return EVChargerState.ERROR\n\n    if data.cable_state == EVChargerCableState.UNSPECIFIED:\n        return EVChargerState.UNSPECIFIED\n    if data.cable_state == EVChargerCableState.EV_LOCKED:\n        return EVChargerState.EV_LOCKED\n    if data.cable_state == EVChargerCableState.EV_PLUGGED:\n        return EVChargerState.EV_PLUGGED\n    return EVChargerState.IDLE\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.is_ev_connected","title":"is_ev_connected","text":"<pre><code>is_ev_connected() -&gt; bool\n</code></pre> <p>Check whether an EV is connected to the charger.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether an EV is connected to the charger.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>def is_ev_connected(self) -&gt; bool:\n    \"\"\"Check whether an EV is connected to the charger.\n\n    Returns:\n        Whether an EV is connected to the charger.\n    \"\"\"\n    return self in (EVChargerState.EV_PLUGGED, EVChargerState.EV_LOCKED)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/","title":"formula_engine","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine","title":"frequenz.sdk.timeseries.formula_engine","text":"<p>The formula engine module.</p> <p>This module exposes the FormulaEngine and FormulaEngine3Phase classes.</p>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine","title":"frequenz.sdk.timeseries.formula_engine.FormulaEngine","text":"<p>             Bases: <code>Generic[QuantityT]</code>, <code>_ComposableFormulaEngine['FormulaEngine', 'HigherOrderFormulaBuilder', QuantityT]</code></p> <p><code>FormulaEngine</code>s are a part of the SDK's data pipeline, and provide a way for the SDK to apply formulas on resampled data streams.</p> <p>They are used in the SDK to calculate and stream metrics like <code>grid_power</code>, <code>consumer_power</code>, etc., which are building blocks of the Frequenz SDK Microgrid Model.</p> <p>The SDK creates the formulas by analysing the configuration of components in the Component Graph.</p>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine.new_receiver()</code> method can be used to create a Receiver that streams the Samples calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\n\nbattery_pool = microgrid.battery_pool()\n\nasync for power in battery_pool.power.new_receiver():\n    print(f\"{power=}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--composition","title":"Composition","text":"<p>Composite <code>FormulaEngine</code>s can be built using arithmetic operations on <code>FormulaEngine</code>s streaming the same type of data.</p> <p>For example, if you're interested in a particular composite metric that can be calculated by subtracting <code>battery_pool().power</code> and <code>ev_charger_pool().power</code> from the <code>grid().power</code>, we can build a <code>FormulaEngine</code> that provides a stream of this calculated metric as follows:</p> <pre><code>from frequenz.sdk import microgrid\n\nlogical_meter = microgrid.logical_meter()\nbattery_pool = microgrid.battery_pool()\nev_charger_pool = microgrid.ev_charger_pool()\ngrid = microgrid.grid()\n\n# apply operations on formula engines to create a formula engine that would\n# apply these operations on the corresponding data streams.\nnet_power = (\n    grid.power - (battery_pool.power + ev_charger_pool.power)\n).build(\"net_power\")\n\nasync for power in net_power.new_receiver():\n    print(f\"{power=}\")\n</code></pre> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>class FormulaEngine(\n    Generic[QuantityT],\n    _ComposableFormulaEngine[\n        \"FormulaEngine\",  # type: ignore[type-arg]\n        \"HigherOrderFormulaBuilder\",  # type: ignore[type-arg]\n        QuantityT,\n    ],\n):\n    \"\"\"[`FormulaEngine`][frequenz.sdk.timeseries.formula_engine.FormulaEngine]s are a\n    part of the SDK's data pipeline, and provide a way for the SDK to apply formulas on\n    resampled data streams.\n\n    They are used in the SDK to calculate and stream metrics like\n    [`grid_power`][frequenz.sdk.timeseries.grid.Grid.power],\n    [`consumer_power`][frequenz.sdk.timeseries.consumer.Consumer.power],\n    etc., which are building blocks of the\n    [Frequenz SDK Microgrid Model][frequenz.sdk.microgrid--frequenz-sdk-microgrid-model].\n\n    The SDK creates the formulas by analysing the configuration of components in the\n    {{glossary(\"Component Graph\")}}.\n\n    ### Streaming Interface\n\n    The\n    [`FormulaEngine.new_receiver()`][frequenz.sdk.timeseries.formula_engine.FormulaEngine.new_receiver]\n    method can be used to create a\n    [Receiver](https://frequenz-floss.github.io/frequenz-channels-python/latest/reference/frequenz/channels/#frequenz.channels.Receiver)\n    that streams the [Sample][frequenz.sdk.timeseries.Sample]s calculated by the formula\n    engine.\n\n    ```python\n    from frequenz.sdk import microgrid\n\n    battery_pool = microgrid.battery_pool()\n\n    async for power in battery_pool.power.new_receiver():\n        print(f\"{power=}\")\n    ```\n\n    ### Composition\n\n    Composite `FormulaEngine`s can be built using arithmetic operations on\n    `FormulaEngine`s streaming the same type of data.\n\n    For example, if you're interested in a particular composite metric that can be\n    calculated by subtracting\n    [`battery_pool().power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power] and\n    [`ev_charger_pool().power`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool]\n    from the\n    [`grid().power`][frequenz.sdk.timeseries.grid.Grid.power],\n    we can build a `FormulaEngine` that provides a stream of this calculated metric as\n    follows:\n\n    ```python\n    from frequenz.sdk import microgrid\n\n    logical_meter = microgrid.logical_meter()\n    battery_pool = microgrid.battery_pool()\n    ev_charger_pool = microgrid.ev_charger_pool()\n    grid = microgrid.grid()\n\n    # apply operations on formula engines to create a formula engine that would\n    # apply these operations on the corresponding data streams.\n    net_power = (\n        grid.power - (battery_pool.power + ev_charger_pool.power)\n    ).build(\"net_power\")\n\n    async for power in net_power.new_receiver():\n        print(f\"{power=}\")\n    ```\n    \"\"\"  # noqa: D400, D205\n\n    def __init__(\n        self,\n        builder: FormulaBuilder[QuantityT],\n        create_method: Callable[[float], QuantityT],\n    ) -&gt; None:\n        \"\"\"Create a `FormulaEngine` instance.\n\n        Args:\n            builder: A `FormulaBuilder` instance to get the formula steps and metric\n                fetchers from.\n            create_method: A method to generate the output `Sample` value with.  If the\n                formula is for generating power values, this would be\n                `Power.from_watts`, for example.\n        \"\"\"\n        self._higher_order_builder = HigherOrderFormulaBuilder\n        self._name: str = builder.name\n        self._builder: FormulaBuilder[QuantityT] = builder\n        self._create_method = create_method\n        self._channel: Broadcast[Sample[QuantityT]] = Broadcast(self._name)\n\n    @classmethod\n    def from_receiver(\n        cls,\n        name: str,\n        receiver: Receiver[Sample[QuantityT]],\n        create_method: Callable[[float], QuantityT],\n        *,\n        nones_are_zeros: bool = False,\n    ) -&gt; FormulaEngine[QuantityT]:\n        \"\"\"\n        Create a formula engine from a receiver.\n\n        Can be used to compose a formula engine with a receiver. When composing\n        the new engine with other engines, make sure that receiver gets data\n        from the same resampler and that the `create_method`s match.\n\n        Example:\n            ```python\n            from frequenz.sdk import microgrid\n            from frequenz.sdk.timeseries import Power\n\n            async def run() -&gt; None:\n                producer_power_engine = microgrid.producer().power\n                consumer_power_recv = microgrid.consumer().power.new_receiver()\n\n                excess_power_recv = (\n                    (\n                        producer_power_engine\n                        + FormulaEngine.from_receiver(\n                            \"consumer power\",\n                            consumer_power_recv,\n                            Power.from_watts,\n                        )\n                    )\n                    .build(\"excess power\")\n                    .new_receiver()\n                )\n\n            asyncio.run(run())\n            ```\n\n        Args:\n            name: A name for the formula engine.\n            receiver: A receiver that streams `Sample`s.\n            create_method: A method to generate the output `Sample` value with,\n                e.g. `Power.from_watts`.\n            nones_are_zeros: If `True`, `None` values in the receiver are treated as 0.\n\n        Returns:\n            A formula engine that streams the `Sample`s from the receiver.\n        \"\"\"\n        builder = FormulaBuilder(name, create_method)\n        builder.push_metric(name, receiver, nones_are_zeros=nones_are_zeros)\n        return cls(builder, create_method)\n\n    async def _run(self) -&gt; None:\n        await self._builder.subscribe()\n        steps, metric_fetchers = self._builder.finalize()\n        evaluator = FormulaEvaluator[QuantityT](\n            self._name, steps, metric_fetchers, self._create_method\n        )\n        sender = self._channel.new_sender()\n        while True:\n            try:\n                msg = await evaluator.apply()\n            except asyncio.CancelledError:\n                _logger.exception(\"FormulaEngine task cancelled: %s\", self._name)\n                raise\n            except Exception as err:  # pylint: disable=broad-except\n                _logger.warning(\n                    \"Formula application failed: %s. Error: %s\", self._name, err\n                )\n            else:\n                await sender.send(msg)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the formula.\n\n        Returns:\n            A string representation of the formula.\n        \"\"\"\n        steps = (\n            self._builder._build_stack\n            if len(self._builder._build_stack) &gt; 0\n            else self._builder._steps\n        )\n        return format_formula(steps)\n\n    def new_receiver(\n        self, name: str | None = None, max_size: int = 50\n    ) -&gt; Receiver[Sample[QuantityT]]:\n        \"\"\"Create a new receiver that streams the output of the formula engine.\n\n        Args:\n            name: An optional name for the receiver.\n            max_size: The size of the receiver's buffer.\n\n        Returns:\n            A receiver that streams output `Sample`s from the formula engine.\n        \"\"\"\n        if self._task is None:\n            self._task = asyncio.create_task(self._run())\n\n        recv = self._channel.new_receiver(name, max_size)\n\n        # This is a hack to ensure that the lifetime of the engine is tied to the\n        # lifetime of the receiver.  This is necessary because the engine is a task that\n        # runs forever, and in cases where higher order built for example with the below\n        # idiom, the user would hold no references to the engine and it could get\n        # garbage collected before the receiver.  This behaviour is explained in the\n        # `asyncio.create_task` docs here:\n        # https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task\n        #\n        #     formula = (grid_power_engine + bat_power_engine).build().new_receiver()\n        recv._engine_reference = self  # type: ignore # pylint: disable=protected-access\n        return recv\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__add__","title":"__add__","text":"<pre><code>__add__(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that adds (data in) <code>other</code> to <code>self</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __add__(\n    self,\n    other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT,\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that adds (data in) `other` to `self`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) + other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__init__","title":"__init__","text":"<pre><code>__init__(\n    builder: FormulaBuilder[QuantityT],\n    create_method: Callable[[float], QuantityT],\n) -&gt; None\n</code></pre> <p>Create a <code>FormulaEngine</code> instance.</p> PARAMETER  DESCRIPTION <code>builder</code> <p>A <code>FormulaBuilder</code> instance to get the formula steps and metric fetchers from.</p> <p> TYPE: <code>FormulaBuilder[QuantityT]</code> </p> <code>create_method</code> <p>A method to generate the output <code>Sample</code> value with.  If the formula is for generating power values, this would be <code>Power.from_watts</code>, for example.</p> <p> TYPE: <code>Callable[[float], QuantityT]</code> </p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __init__(\n    self,\n    builder: FormulaBuilder[QuantityT],\n    create_method: Callable[[float], QuantityT],\n) -&gt; None:\n    \"\"\"Create a `FormulaEngine` instance.\n\n    Args:\n        builder: A `FormulaBuilder` instance to get the formula steps and metric\n            fetchers from.\n        create_method: A method to generate the output `Sample` value with.  If the\n            formula is for generating power values, this would be\n            `Power.from_watts`, for example.\n    \"\"\"\n    self._higher_order_builder = HigherOrderFormulaBuilder\n    self._name: str = builder.name\n    self._builder: FormulaBuilder[QuantityT] = builder\n    self._create_method = create_method\n    self._channel: Broadcast[Sample[QuantityT]] = Broadcast(self._name)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__mul__","title":"__mul__","text":"<pre><code>__mul__(\n    other: (\n        _GenericEngine | _GenericHigherOrderBuilder | float\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that multiplies (data in) <code>self</code> with <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __mul__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that multiplies (data in) `self` with `other`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) * other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the formula.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of the formula.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the formula.\n\n    Returns:\n        A string representation of the formula.\n    \"\"\"\n    steps = (\n        self._builder._build_stack\n        if len(self._builder._build_stack) &gt; 0\n        else self._builder._steps\n    )\n    return format_formula(steps)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__sub__","title":"__sub__","text":"<pre><code>__sub__(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that subtracts (data in) <code>other</code> from <code>self</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __sub__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that subtracts (data in) `other` from `self`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) - other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(\n    other: (\n        _GenericEngine | _GenericHigherOrderBuilder | float\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that divides (data in) <code>self</code> by <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __truediv__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that divides (data in) `self` by `other`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) / other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.consumption","title":"consumption","text":"<pre><code>consumption() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the consumption operator on <code>self</code>.</p> <p>The consumption operator returns either the identity if the power value is positive or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def consumption(self) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"\n    Return a formula builder that applies the consumption operator on `self`.\n\n    The consumption operator returns either the identity if the power value is\n    positive or 0.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).consumption()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.from_receiver","title":"from_receiver  <code>classmethod</code>","text":"<pre><code>from_receiver(\n    name: str,\n    receiver: Receiver[Sample[QuantityT]],\n    create_method: Callable[[float], QuantityT],\n    *,\n    nones_are_zeros: bool = False\n) -&gt; FormulaEngine[QuantityT]\n</code></pre> <p>Create a formula engine from a receiver.</p> <p>Can be used to compose a formula engine with a receiver. When composing the new engine with other engines, make sure that receiver gets data from the same resampler and that the <code>create_method</code>s match.</p> Example <pre><code>from frequenz.sdk import microgrid\nfrom frequenz.sdk.timeseries import Power\n\nasync def run() -&gt; None:\n    producer_power_engine = microgrid.producer().power\n    consumer_power_recv = microgrid.consumer().power.new_receiver()\n\n    excess_power_recv = (\n        (\n            producer_power_engine\n            + FormulaEngine.from_receiver(\n                \"consumer power\",\n                consumer_power_recv,\n                Power.from_watts,\n            )\n        )\n        .build(\"excess power\")\n        .new_receiver()\n    )\n\nasyncio.run(run())\n</code></pre> PARAMETER  DESCRIPTION <code>name</code> <p>A name for the formula engine.</p> <p> TYPE: <code>str</code> </p> <code>receiver</code> <p>A receiver that streams <code>Sample</code>s.</p> <p> TYPE: <code>Receiver[Sample[QuantityT]]</code> </p> <code>create_method</code> <p>A method to generate the output <code>Sample</code> value with, e.g. <code>Power.from_watts</code>.</p> <p> TYPE: <code>Callable[[float], QuantityT]</code> </p> <code>nones_are_zeros</code> <p>If <code>True</code>, <code>None</code> values in the receiver are treated as 0.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>FormulaEngine[QuantityT]</code> <p>A formula engine that streams the <code>Sample</code>s from the receiver.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>@classmethod\ndef from_receiver(\n    cls,\n    name: str,\n    receiver: Receiver[Sample[QuantityT]],\n    create_method: Callable[[float], QuantityT],\n    *,\n    nones_are_zeros: bool = False,\n) -&gt; FormulaEngine[QuantityT]:\n    \"\"\"\n    Create a formula engine from a receiver.\n\n    Can be used to compose a formula engine with a receiver. When composing\n    the new engine with other engines, make sure that receiver gets data\n    from the same resampler and that the `create_method`s match.\n\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.timeseries import Power\n\n        async def run() -&gt; None:\n            producer_power_engine = microgrid.producer().power\n            consumer_power_recv = microgrid.consumer().power.new_receiver()\n\n            excess_power_recv = (\n                (\n                    producer_power_engine\n                    + FormulaEngine.from_receiver(\n                        \"consumer power\",\n                        consumer_power_recv,\n                        Power.from_watts,\n                    )\n                )\n                .build(\"excess power\")\n                .new_receiver()\n            )\n\n        asyncio.run(run())\n        ```\n\n    Args:\n        name: A name for the formula engine.\n        receiver: A receiver that streams `Sample`s.\n        create_method: A method to generate the output `Sample` value with,\n            e.g. `Power.from_watts`.\n        nones_are_zeros: If `True`, `None` values in the receiver are treated as 0.\n\n    Returns:\n        A formula engine that streams the `Sample`s from the receiver.\n    \"\"\"\n    builder = FormulaBuilder(name, create_method)\n    builder.push_metric(name, receiver, nones_are_zeros=nones_are_zeros)\n    return cls(builder, create_method)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.max","title":"max","text":"<pre><code>max(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the maximum of <code>self</code> and <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def max(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula engine that outputs the maximum of `self` and `other`.\n\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).max(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.min","title":"min","text":"<pre><code>min(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the minimum of <code>self</code> and <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def min(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula engine that outputs the minimum of `self` and `other`.\n\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).min(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver(\n    name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample[QuantityT]]\n</code></pre> <p>Create a new receiver that streams the output of the formula engine.</p> PARAMETER  DESCRIPTION <code>name</code> <p>An optional name for the receiver.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>max_size</code> <p>The size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[Sample[QuantityT]]</code> <p>A receiver that streams output <code>Sample</code>s from the formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def new_receiver(\n    self, name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample[QuantityT]]:\n    \"\"\"Create a new receiver that streams the output of the formula engine.\n\n    Args:\n        name: An optional name for the receiver.\n        max_size: The size of the receiver's buffer.\n\n    Returns:\n        A receiver that streams output `Sample`s from the formula engine.\n    \"\"\"\n    if self._task is None:\n        self._task = asyncio.create_task(self._run())\n\n    recv = self._channel.new_receiver(name, max_size)\n\n    # This is a hack to ensure that the lifetime of the engine is tied to the\n    # lifetime of the receiver.  This is necessary because the engine is a task that\n    # runs forever, and in cases where higher order built for example with the below\n    # idiom, the user would hold no references to the engine and it could get\n    # garbage collected before the receiver.  This behaviour is explained in the\n    # `asyncio.create_task` docs here:\n    # https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task\n    #\n    #     formula = (grid_power_engine + bat_power_engine).build().new_receiver()\n    recv._engine_reference = self  # type: ignore # pylint: disable=protected-access\n    return recv\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.production","title":"production","text":"<pre><code>production() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the production operator on <code>self</code>.</p> <p>The production operator returns either the absolute value if the power value is negative or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def production(self) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"\n    Return a formula builder that applies the production operator on `self`.\n\n    The production operator returns either the absolute value if the power value is\n    negative or 0.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).production()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase","title":"frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase","text":"<p>             Bases: <code>_ComposableFormulaEngine['FormulaEngine3Phase', 'HigherOrderFormulaBuilder3Phase', QuantityT]</code></p> <p>A <code>FormulaEngine3Phase</code> is similar to a <code>FormulaEngine</code>, except that they stream 3-phase samples.  All the current formulas (like <code>Grid.current</code>, <code>EVChargerPool.current</code>, etc.) are implemented as 3-phase formulas.</p>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine3Phase.new_receiver()</code> method can be used to create a Receiver that streams the Sample3Phase values calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\n\nev_charger_pool = microgrid.ev_charger_pool()\n\nasync for sample in ev_charger_pool.current.new_receiver():\n    print(f\"Current: {sample}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--composition","title":"Composition","text":"<p><code>FormulaEngine3Phase</code> instances can be composed together, just like <code>FormulaEngine</code> instances.</p> <pre><code>from frequenz.sdk import microgrid\n\nlogical_meter = microgrid.logical_meter()\nev_charger_pool = microgrid.ev_charger_pool()\ngrid = microgrid.grid()\n\n# Calculate grid consumption current that's not used by the EV chargers\nother_current = (grid.current - ev_charger_pool.current).build(\"other_current\")\n\nasync for sample in other_current.new_receiver():\n    print(f\"Other current: {sample}\")\n</code></pre> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>class FormulaEngine3Phase(\n    _ComposableFormulaEngine[\n        \"FormulaEngine3Phase\",  # type: ignore[type-arg]\n        \"HigherOrderFormulaBuilder3Phase\",  # type: ignore[type-arg]\n        QuantityT,\n    ]\n):\n    \"\"\"A\n    [`FormulaEngine3Phase`][frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase]\n    is similar to a\n    [`FormulaEngine`][frequenz.sdk.timeseries.formula_engine.FormulaEngine], except that\n    they stream [3-phase samples][frequenz.sdk.timeseries.Sample3Phase].  All the\n    current formulas (like\n    [`Grid.current`][frequenz.sdk.timeseries.grid.Grid.current],\n    [`EVChargerPool.current`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.current],\n    etc.) are implemented as 3-phase formulas.\n\n    ### Streaming Interface\n\n    The\n    [`FormulaEngine3Phase.new_receiver()`][frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.new_receiver]\n    method can be used to create a\n    [Receiver](https://frequenz-floss.github.io/frequenz-channels-python/latest/reference/frequenz/channels/#frequenz.channels.Receiver)\n    that streams the [Sample3Phase][frequenz.sdk.timeseries.Sample3Phase] values\n    calculated by the formula engine.\n\n    ```python\n    from frequenz.sdk import microgrid\n\n    ev_charger_pool = microgrid.ev_charger_pool()\n\n    async for sample in ev_charger_pool.current.new_receiver():\n        print(f\"Current: {sample}\")\n    ```\n\n    ### Composition\n\n    `FormulaEngine3Phase` instances can be composed together, just like `FormulaEngine`\n    instances.\n\n    ```python\n    from frequenz.sdk import microgrid\n\n    logical_meter = microgrid.logical_meter()\n    ev_charger_pool = microgrid.ev_charger_pool()\n    grid = microgrid.grid()\n\n    # Calculate grid consumption current that's not used by the EV chargers\n    other_current = (grid.current - ev_charger_pool.current).build(\"other_current\")\n\n    async for sample in other_current.new_receiver():\n        print(f\"Other current: {sample}\")\n    ```\n    \"\"\"  # noqa: D205, D400\n\n    def __init__(\n        self,\n        name: str,\n        create_method: Callable[[float], QuantityT],\n        phase_streams: tuple[\n            FormulaEngine[QuantityT],\n            FormulaEngine[QuantityT],\n            FormulaEngine[QuantityT],\n        ],\n    ) -&gt; None:\n        \"\"\"Create a `FormulaEngine3Phase` instance.\n\n        Args:\n            name: A name for the formula.\n            create_method: A method to generate the output `Sample` value with.  If the\n                formula is for generating power values, this would be\n                `Power.from_watts`, for example.\n            phase_streams: output streams of formula engines running per-phase formulas.\n        \"\"\"\n        self._higher_order_builder = HigherOrderFormulaBuilder3Phase\n        self._name: str = name\n        self._create_method = create_method\n        self._channel: Broadcast[Sample3Phase[QuantityT]] = Broadcast(self._name)\n        self._task: asyncio.Task[None] | None = None\n        self._streams: tuple[\n            FormulaEngine[QuantityT],\n            FormulaEngine[QuantityT],\n            FormulaEngine[QuantityT],\n        ] = phase_streams\n\n    async def _run(self) -&gt; None:\n        sender = self._channel.new_sender()\n        phase_1_rx = self._streams[0].new_receiver()\n        phase_2_rx = self._streams[1].new_receiver()\n        phase_3_rx = self._streams[2].new_receiver()\n\n        while True:\n            try:\n                phase_1 = await phase_1_rx.receive()\n                phase_2 = await phase_2_rx.receive()\n                phase_3 = await phase_3_rx.receive()\n                msg = Sample3Phase(\n                    phase_1.timestamp,\n                    phase_1.value,\n                    phase_2.value,\n                    phase_3.value,\n                )\n            except asyncio.CancelledError:\n                _logger.exception(\"FormulaEngine task cancelled: %s\", self._name)\n                break\n            else:\n                await sender.send(msg)\n\n    def new_receiver(\n        self, name: str | None = None, max_size: int = 50\n    ) -&gt; Receiver[Sample3Phase[QuantityT]]:\n        \"\"\"Create a new receiver that streams the output of the formula engine.\n\n        Args:\n            name: An optional name for the receiver.\n            max_size: The size of the receiver's buffer.\n\n        Returns:\n            A receiver that streams output `Sample`s from the formula engine.\n        \"\"\"\n        if self._task is None:\n            self._task = asyncio.create_task(self._run())\n\n        return self._channel.new_receiver(name, max_size)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__add__","title":"__add__","text":"<pre><code>__add__(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that adds (data in) <code>other</code> to <code>self</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __add__(\n    self,\n    other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT,\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that adds (data in) `other` to `self`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) + other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__init__","title":"__init__","text":"<pre><code>__init__(\n    name: str,\n    create_method: Callable[[float], QuantityT],\n    phase_streams: tuple[\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n    ],\n) -&gt; None\n</code></pre> <p>Create a <code>FormulaEngine3Phase</code> instance.</p> PARAMETER  DESCRIPTION <code>name</code> <p>A name for the formula.</p> <p> TYPE: <code>str</code> </p> <code>create_method</code> <p>A method to generate the output <code>Sample</code> value with.  If the formula is for generating power values, this would be <code>Power.from_watts</code>, for example.</p> <p> TYPE: <code>Callable[[float], QuantityT]</code> </p> <code>phase_streams</code> <p>output streams of formula engines running per-phase formulas.</p> <p> TYPE: <code>tuple[FormulaEngine[QuantityT], FormulaEngine[QuantityT], FormulaEngine[QuantityT]]</code> </p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    create_method: Callable[[float], QuantityT],\n    phase_streams: tuple[\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n    ],\n) -&gt; None:\n    \"\"\"Create a `FormulaEngine3Phase` instance.\n\n    Args:\n        name: A name for the formula.\n        create_method: A method to generate the output `Sample` value with.  If the\n            formula is for generating power values, this would be\n            `Power.from_watts`, for example.\n        phase_streams: output streams of formula engines running per-phase formulas.\n    \"\"\"\n    self._higher_order_builder = HigherOrderFormulaBuilder3Phase\n    self._name: str = name\n    self._create_method = create_method\n    self._channel: Broadcast[Sample3Phase[QuantityT]] = Broadcast(self._name)\n    self._task: asyncio.Task[None] | None = None\n    self._streams: tuple[\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n    ] = phase_streams\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__mul__","title":"__mul__","text":"<pre><code>__mul__(\n    other: (\n        _GenericEngine | _GenericHigherOrderBuilder | float\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that multiplies (data in) <code>self</code> with <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __mul__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that multiplies (data in) `self` with `other`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) * other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__sub__","title":"__sub__","text":"<pre><code>__sub__(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that subtracts (data in) <code>other</code> from <code>self</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __sub__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that subtracts (data in) `other` from `self`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) - other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(\n    other: (\n        _GenericEngine | _GenericHigherOrderBuilder | float\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that divides (data in) <code>self</code> by <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __truediv__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that divides (data in) `self` by `other`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) / other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.consumption","title":"consumption","text":"<pre><code>consumption() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the consumption operator on <code>self</code>.</p> <p>The consumption operator returns either the identity if the power value is positive or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def consumption(self) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"\n    Return a formula builder that applies the consumption operator on `self`.\n\n    The consumption operator returns either the identity if the power value is\n    positive or 0.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).consumption()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.max","title":"max","text":"<pre><code>max(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the maximum of <code>self</code> and <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def max(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula engine that outputs the maximum of `self` and `other`.\n\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).max(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.min","title":"min","text":"<pre><code>min(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the minimum of <code>self</code> and <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def min(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula engine that outputs the minimum of `self` and `other`.\n\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).min(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver(\n    name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample3Phase[QuantityT]]\n</code></pre> <p>Create a new receiver that streams the output of the formula engine.</p> PARAMETER  DESCRIPTION <code>name</code> <p>An optional name for the receiver.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>max_size</code> <p>The size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[Sample3Phase[QuantityT]]</code> <p>A receiver that streams output <code>Sample</code>s from the formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def new_receiver(\n    self, name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample3Phase[QuantityT]]:\n    \"\"\"Create a new receiver that streams the output of the formula engine.\n\n    Args:\n        name: An optional name for the receiver.\n        max_size: The size of the receiver's buffer.\n\n    Returns:\n        A receiver that streams output `Sample`s from the formula engine.\n    \"\"\"\n    if self._task is None:\n        self._task = asyncio.create_task(self._run())\n\n    return self._channel.new_receiver(name, max_size)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.production","title":"production","text":"<pre><code>production() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the production operator on <code>self</code>.</p> <p>The production operator returns either the absolute value if the power value is negative or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def production(self) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"\n    Return a formula builder that applies the production operator on `self`.\n\n    The production operator returns either the absolute value if the power value is\n    negative or 0.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).production()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/","title":"logical_meter","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter","title":"frequenz.sdk.timeseries.logical_meter","text":"<p>A logical meter for calculating high level metrics for a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter","title":"frequenz.sdk.timeseries.logical_meter.LogicalMeter","text":"<p>A logical meter for calculating high level metrics in a microgrid.</p> <p>LogicalMeter provides methods for fetching power values from different points in the microgrid.  These methods return <code>FormulaReceiver</code> objects, which can be used like normal <code>Receiver</code>s, but can also be composed to form higher-order formula streams.</p> <p>Note</p> <p><code>LogicalMeter</code> instances are not meant to be created directly by users.  Use the <code>microgrid.logical_meter</code> method for creating <code>LogicalMeter</code> instances.</p> Example <pre><code>from datetime import timedelta\n\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.timeseries import ResamplerConfig\n\nawait microgrid.initialize(\n    \"127.0.0.1\",\n    50051,\n    ResamplerConfig(resampling_period=timedelta(seconds=1))\n)\n\nlogical_meter = microgrid.logical_meter()\ngrid = microgrid.grid()\n\n# Get a receiver for a builtin formula\npv_power_recv = logical_meter.pv_power.new_receiver()\nasync for pv_power_sample in pv_power_recv:\n    print(pv_power_sample)\n\n# or compose formulas to create a new formula\nnet_power_recv = (\n    (\n        grid.power - logical_meter.pv_power\n    )\n    .build(\"net_power\")\n    .new_receiver()\n)\nasync for net_power_sample in net_power_recv:\n    print(net_power_sample)\n</code></pre> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>class LogicalMeter:\n    \"\"\"A logical meter for calculating high level metrics in a microgrid.\n\n    LogicalMeter provides methods for fetching power values from different points in the\n    microgrid.  These methods return `FormulaReceiver` objects, which can be used like\n    normal `Receiver`s, but can also be composed to form higher-order formula streams.\n\n    !!! note\n        `LogicalMeter` instances are not meant to be created directly by users.  Use the\n        [`microgrid.logical_meter`][frequenz.sdk.microgrid.logical_meter] method for\n        creating `LogicalMeter` instances.\n\n    Example:\n        ```python\n        from datetime import timedelta\n\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.timeseries import ResamplerConfig\n\n        await microgrid.initialize(\n            \"127.0.0.1\",\n            50051,\n            ResamplerConfig(resampling_period=timedelta(seconds=1))\n        )\n\n        logical_meter = microgrid.logical_meter()\n        grid = microgrid.grid()\n\n        # Get a receiver for a builtin formula\n        pv_power_recv = logical_meter.pv_power.new_receiver()\n        async for pv_power_sample in pv_power_recv:\n            print(pv_power_sample)\n\n        # or compose formulas to create a new formula\n        net_power_recv = (\n            (\n                grid.power - logical_meter.pv_power\n            )\n            .build(\"net_power\")\n            .new_receiver()\n        )\n        async for net_power_sample in net_power_recv:\n            print(net_power_sample)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        channel_registry: ChannelRegistry,\n        resampler_subscription_sender: Sender[ComponentMetricRequest],\n    ) -&gt; None:\n        \"\"\"Create a `LogicalMeter` instance.\n\n        !!! note\n            `LogicalMeter` instances are not meant to be created directly by users.  Use\n            the [`microgrid.logical_meter`][frequenz.sdk.microgrid.logical_meter] method\n            for creating `LogicalMeter` instances.\n\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n        \"\"\"\n        self._channel_registry: ChannelRegistry = channel_registry\n        self._resampler_subscription_sender: Sender[ComponentMetricRequest] = (\n            resampler_subscription_sender\n        )\n\n        # Use a randomly generated uuid to create a unique namespace name for the local\n        # meter to use when communicating with the resampling actor.\n        self._namespace = f\"logical-meter-{uuid.uuid4()}\"\n        self._formula_pool = FormulaEnginePool(\n            self._namespace,\n            self._channel_registry,\n            self._resampler_subscription_sender,\n        )\n\n    def start_formula(\n        self,\n        formula: str,\n        component_metric_id: ComponentMetricId,\n        *,\n        nones_are_zeros: bool = False,\n    ) -&gt; FormulaEngine[Quantity]:\n        \"\"\"Start execution of the given formula.\n\n        Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and\n        these operators: +, -, *, /, (, ).\n\n        For example, the input string: \"#20 + #5\" is a formula for adding metrics from\n        two components with ids 20 and 5.\n\n        Args:\n            formula: formula to execute.\n            component_metric_id: The metric ID to use when fetching receivers from the\n                resampling actor.\n            nones_are_zeros: Whether to treat None values from the stream as 0s.  If\n                False, the returned value will be a None.\n\n        Returns:\n            A FormulaEngine that applies the formula and streams values.\n        \"\"\"\n        return self._formula_pool.from_string(\n            formula, component_metric_id, nones_are_zeros=nones_are_zeros\n        )\n\n    @property\n    def pv_power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the PV power in the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate PV power is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream PV total power.\n        \"\"\"\n        engine = self._formula_pool.from_power_formula_generator(\n            \"pv_power\",\n            PVPowerFormula,\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def chp_power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the CHP power production in the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate CHP power production is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream CHP power production.\n        \"\"\"\n        engine = self._formula_pool.from_power_formula_generator(\n            \"chp_power\",\n            CHPPowerFormula,\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all formula engines.\"\"\"\n        await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.chp_power","title":"chp_power  <code>property</code>","text":"<pre><code>chp_power: FormulaEngine[Power]\n</code></pre> <p>Fetch the CHP power production in the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate CHP power production is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream CHP power production.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.pv_power","title":"pv_power  <code>property</code>","text":"<pre><code>pv_power: FormulaEngine[Power]\n</code></pre> <p>Fetch the PV power in the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate PV power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream PV total power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.__init__","title":"__init__","text":"<pre><code>__init__(\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[\n        ComponentMetricRequest\n    ],\n) -&gt; None\n</code></pre> <p>Create a <code>LogicalMeter</code> instance.</p> <p>Note</p> <p><code>LogicalMeter</code> instances are not meant to be created directly by users.  Use the <code>microgrid.logical_meter</code> method for creating <code>LogicalMeter</code> instances.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>def __init__(\n    self,\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n    \"\"\"Create a `LogicalMeter` instance.\n\n    !!! note\n        `LogicalMeter` instances are not meant to be created directly by users.  Use\n        the [`microgrid.logical_meter`][frequenz.sdk.microgrid.logical_meter] method\n        for creating `LogicalMeter` instances.\n\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n    \"\"\"\n    self._channel_registry: ChannelRegistry = channel_registry\n    self._resampler_subscription_sender: Sender[ComponentMetricRequest] = (\n        resampler_subscription_sender\n    )\n\n    # Use a randomly generated uuid to create a unique namespace name for the local\n    # meter to use when communicating with the resampling actor.\n    self._namespace = f\"logical-meter-{uuid.uuid4()}\"\n    self._formula_pool = FormulaEnginePool(\n        self._namespace,\n        self._channel_registry,\n        self._resampler_subscription_sender,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.start_formula","title":"start_formula","text":"<pre><code>start_formula(\n    formula: str,\n    component_metric_id: ComponentMetricId,\n    *,\n    nones_are_zeros: bool = False\n) -&gt; FormulaEngine[Quantity]\n</code></pre> <p>Start execution of the given formula.</p> <p>Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and these operators: +, -, *, /, (, ).</p> <p>For example, the input string: \"#20 + #5\" is a formula for adding metrics from two components with ids 20 and 5.</p> PARAMETER  DESCRIPTION <code>formula</code> <p>formula to execute.</p> <p> TYPE: <code>str</code> </p> <code>component_metric_id</code> <p>The metric ID to use when fetching receivers from the resampling actor.</p> <p> TYPE: <code>ComponentMetricId</code> </p> <code>nones_are_zeros</code> <p>Whether to treat None values from the stream as 0s.  If False, the returned value will be a None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>FormulaEngine[Quantity]</code> <p>A FormulaEngine that applies the formula and streams values.</p> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>def start_formula(\n    self,\n    formula: str,\n    component_metric_id: ComponentMetricId,\n    *,\n    nones_are_zeros: bool = False,\n) -&gt; FormulaEngine[Quantity]:\n    \"\"\"Start execution of the given formula.\n\n    Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and\n    these operators: +, -, *, /, (, ).\n\n    For example, the input string: \"#20 + #5\" is a formula for adding metrics from\n    two components with ids 20 and 5.\n\n    Args:\n        formula: formula to execute.\n        component_metric_id: The metric ID to use when fetching receivers from the\n            resampling actor.\n        nones_are_zeros: Whether to treat None values from the stream as 0s.  If\n            False, the returned value will be a None.\n\n    Returns:\n        A FormulaEngine that applies the formula and streams values.\n    \"\"\"\n    return self._formula_pool.from_string(\n        formula, component_metric_id, nones_are_zeros=nones_are_zeros\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all formula engines.</p> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all formula engines.\"\"\"\n    await self._formula_pool.stop()\n</code></pre>"},{"location":"tutorials/getting_started/","title":"Getting started","text":""},{"location":"tutorials/getting_started/#prerequisites","title":"Prerequisites","text":"<ol> <li>Python 3.11 or newer installed on your system.</li> <li>Access to a microgrid system supported by the <code>frequenz.sdk</code> or you can use    the sandbox.</li> <li>Basic knowledge of microgrid concepts.</li> <li>Familiarity with Channels.</li> <li>Install the Frequenz SDK</li> </ol>"},{"location":"tutorials/getting_started/#create-a-project","title":"Create a project","text":""},{"location":"tutorials/getting_started/#create-a-python-file","title":"Create a Python file","text":"<p>You can start by simply creating a Python script (e.g., <code>pv_optimization.py</code>) using your favorite text editor.</p>"},{"location":"tutorials/getting_started/#use-frequenz-repository-configuration","title":"Use Frequenz Repository Configuration","text":"<p>As an alternative and specially for larger projects, it's recommended to set up the project using the Frequenz Repository Configuration.</p>"},{"location":"tutorials/getting_started/#import-necessary-modules","title":"Import necessary modules","text":"<p>You can now open the app's main file and start adding content. Begin by importing the necessary libraries.</p> <pre><code>import asyncio\n\nfrom datetime import timedelta\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.actor import ResamplerConfig\n</code></pre>"},{"location":"tutorials/getting_started/#create-the-application-skeleton","title":"Create the application skeleton","text":"<p>The main logic of your application will run within an async function. Let's create a skeleton that contains all the necessary code to initialize a microgrid.</p> <pre><code>async def run() -&gt; None:\n    # This points to the default Frequenz microgrid sandbox\n    microgrid_host = \"microgrid.sandbox.api.frequenz.io\"\n    microgrid_port = 62060\n\n    # Initialize the microgrid\n    await microgrid.initialize(\n        microgrid_host,\n        microgrid_port,\n        ResamplerConfig(resampling_period=timedelta(seconds=1)),\n    )\n\n    # Define your application logic here\n    # ...\n</code></pre>"},{"location":"tutorials/getting_started/#define-the-main-function","title":"Define the <code>main()</code> function","text":"<p>Create a <code>main()</code> function that will set up and run the <code>run()</code> function using asyncio.</p> <pre><code>def main() -&gt; None:\n    asyncio.run(run())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/getting_started/#implement-the-application-logic","title":"Implement the application logic","text":"<p>Inside the <code>run()</code> function, implement the core logic of your application. This will include creating receivers for data streams, processing the data, making decisions, and eventually sending control messages to the microgrid system. We will cover more details in the following tutorials. For now, let's simply read the power measurements from the microgrid's grid meter and print them on the screen. The grid meter is a meter that is directly connected to the grid connection point.</p> <pre><code>async def run() -&gt; None:\n    # This points to the default Frequenz microgrid sandbox\n    ...\n\n    # Define your application logic here\n    grid_meter = microgrid.grid().power.new_receiver()\n\n    async for power in grid_meter:\n        print(power.value)\n</code></pre>"},{"location":"tutorials/getting_started/#putting-it-all-together","title":"Putting it all together","text":"<p>Here is the full version of your first Frequenz SDK application.</p> <pre><code>import asyncio\n\nfrom datetime import timedelta\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.actor import ResamplerConfig\n\nasync def run() -&gt; None:\n    # This points to the default Frequenz microgrid sandbox\n    microgrid_host = \"microgrid.sandbox.api.frequenz.io\"\n    microgrid_port = 62060\n\n    # Initialize the microgrid\n    await microgrid.initialize(\n        microgrid_host,\n        microgrid_port,\n        ResamplerConfig(resampling_period=timedelta(seconds=1)),\n    )\n\n    # Define your application logic here\n    grid_meter = microgrid.grid().power.new_receiver()\n\n    async for power in grid_meter:\n        print(power.value)\n\ndef main() -&gt; None:\n    asyncio.run(run())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/getting_started/#run-your-application","title":"Run your application","text":"<p>You're now ready to run your application. When working on an existing microgrid, make sure to update the <code>microgrid_host</code> and <code>microgrid_port</code> variables before running the script.</p> <pre><code># Example usage\npython pv_optimization.py\n</code></pre>"},{"location":"user-guide/","title":"Introduction","text":"<p>There are several fundamental concepts that one should comprehend before diving into the Frequenz SDK. These concepts encompass both general notions within the energy sector or microgrids and specific details regarding the SDK itself, such as asynchronous programming, use of channels for communication, the actor model, data pipelines, and the composition of a components graph.</p> <p>Given that users may possess diverse backgrounds and varying levels of familiarity with these subjects, the left menu is organized into sections, each dedicated to a particular topic.</p> <p>For individuals without prior knowledge, it is advisable to proceed through the sections sequentially to establish a solid foundation.</p>"},{"location":"user-guide/actors/","title":"Actors","text":"<p>Actors are a primitive unit of computation that runs autonomously.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--actor-programming-model","title":"Actor Programming Model","text":"<p>From Wikipedia</p> <p>The actor model in computer science is a mathematical model of concurrent computation that treats an actor as the basic building block of concurrent computation. In response to a message it receives, an actor can: make local decisions, create more actors, send more messages, and determine how to respond to the next message received. Actors may modify their own private state, but can only affect each other indirectly through messaging (removing the need for lock-based synchronization).</p> <p>We won't get into much more detail here because it is outside the scope of this documentation. However, if you are interested in learning more about the actor programming model, here are some useful resources:</p> <ul> <li>Actor Model (Wikipedia)</li> <li>How the Actor Model Meets the Needs of Modern, Distributed Systems   (Akka)</li> </ul>"},{"location":"user-guide/actors/#frequenz.sdk.actor--frequenz-sdk-actors","title":"Frequenz SDK Actors","text":"<p>The <code>Actor</code> class serves as the foundation for creating concurrent tasks and all actors in the SDK inherit from it. This class provides a straightforward way to implement actors. It shares similarities with the traditional actor programming model but also has some unique features:</p> <ul> <li> <p>Message Passing: Like traditional actors, our <code>Actor</code>   class communicates through message passing. Even when no particular message passing   mechanism is enforced, the SDK actors use <code>frequenz.channels</code> for communication.</p> </li> <li> <p>Automatic Restart: If an unhandled exception occurs in an actor's logic   (<code>_run()</code> method), the actor will be automatically restarted. This ensures   robustness in the face of errors.</p> </li> <li> <p>Simplified Task Management: Actors manage asynchronous tasks using   <code>asyncio</code>. You can create and manage tasks within the actor, and the   <code>Actor</code> class handles task cancellation and cleanup.</p> </li> <li> <p>Simplified lifecycle management: Actors are [async context managers] and also   a <code>run()</code> function is provided to easily run a group of   actors and wait for them to finish.</p> </li> </ul>"},{"location":"user-guide/actors/#frequenz.sdk.actor--lifecycle","title":"Lifecycle","text":"<p>Actors are not started when they are created. There are 3 main ways to start an actor (from most to least recommended):</p> <ol> <li>By using the <code>run()</code> function.</li> <li>By using the actor as an async context manager.</li> <li>By using the <code>start()</code> method.</li> </ol> <p>Warning</p> <ol> <li> <p>If an actor raises an unhandled exception, it will be restarted automatically.</p> </li> <li> <p>Actors manage <code>asyncio.Task</code> objects, so a reference to the actor object must    be held for as long as the actor is expected to be running, otherwise its tasks    will be cancelled and the actor will stop. For more information, please refer to    the Python <code>asyncio</code>    documentation.</p> </li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--the-run-function","title":"The <code>run()</code> Function","text":"<p>The <code>run()</code> function can start many actors at once and waits for them to finish. If any of the actors are stopped with errors, the errors will be logged.</p> Example <pre><code>from frequenz.sdk.actor import Actor, run\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nawait run(MyActor()) # (1)!\n</code></pre> <ol> <li>This line will block until the actor is stopped.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--async-context-manager","title":"Async Context Manager","text":"<p>When an actor is used as an async context manager, it is started when the <code>async with</code> block is entered and stopped automatically when the block is exited (even if an exception is raised).</p> Example <pre><code>from frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nasync with MyActor() as actor: # (1)!\n    print(\"The actor is running\")\n# (2)!\n</code></pre> <ol> <li><code>start()</code> is called automatically when entering     the <code>async with</code> block.</li> <li><code>stop()</code> is called automatically when exiting     the <code>async with</code> block.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--the-start-method","title":"The <code>start()</code> Method","text":"<p>When using the <code>start()</code> method, the actor is started in the background and the method returns immediately. The actor will continue to run until it is manually stopped.</p> Example <pre><code>from frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nactor = MyActor() # (1)!\nactor.start() # (2)!\nprint(\"The actor is running\") # (3)!\nawait actor.stop() # (4)!\n</code></pre> <ol> <li>The actor is created but not started yet.</li> <li>The actor is started manually, it keeps running in the background.</li> <li> <p>Danger</p> <p>If this function would raise an exception, the actor will never be stopped!</p> </li> <li> <p>Until the actor is stopped manually.</p> </li> </ol> <p>Warning</p> <p>This method is not recommended because it is easy to forget to stop the actor manually, especially in error conditions.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--communication","title":"Communication","text":"<p>The <code>Actor</code> class doesn't impose any specific way to communicate between actors. However, <code>frequenz.channels</code> are always used as the communication mechanism between actors in the SDK.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--implementing-an-actor","title":"Implementing an Actor","text":"<p>To implement an actor, you must inherit from the <code>Actor</code> class and implement an initializer and the abstract <code>_run()</code> method.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--initialization","title":"Initialization","text":"<p>The initializer is called when the actor is created. The <code>Actor</code> class initializer (<code>__init__</code>) should be always called first in the class we are implementing to make sure actors are properly initialized.</p> <p>The <code>Actor.__init__()</code> takes one optional argument, a <code>name</code> that will be used to identify the actor in logs. If no name is provided, a default name will be generated, but it is recommended that <code>Actor</code> subclasses can also receive a name as an argument to make it easier to identify individual instances in logs more easily.</p> <p>The actor initializer normally also accepts as arguments the input channels receivers and output channels senders that will be used for communication. These channels should be created outside the actor and passed to it as arguments to ensure actors can be composed easily.</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass EchoActor(Actor):  # (1)!\n    def __init__(\n            self,\n            input: Receiver[int],  # (2)!\n            output: Sender[int],  # (3)!\n            name: str | None = None,  # (4)!\n    ) -&gt; None:\n        super().__init__(name=name) # (5)!\n        self._input: Receiver[int] = input  # (6)!\n        self._output: Sender[int] = output  # (7)!\n</code></pre> <ol> <li> <p>We define a new actor class called <code>EchoActor</code> that inherits from     <code>Actor</code>.</p> </li> <li> <p>We accept an <code>input</code> argument that will be used to receive messages from     a channel.</p> </li> <li>We accept an <code>output</code> argument that will be used to send messages to a channel.</li> <li>We accept an optional <code>name</code> argument that will be used to identify the actor in     logs.</li> <li>We call <code>Actor.__init__()</code> to make sure the     actor is properly initialized.</li> <li>We store the <code>input</code> argument in a private instance variable to use it later.</li> <li>We store the <code>output</code> argument in a private instance variable to use it later.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--the-_run-method","title":"The <code>_run()</code> Method","text":"<p>The abstract <code>_run()</code> method is called automatically by the base class when the actor is started.</p> <p>Normally an actor should run forever (or until it is stopped), so it is very common to have an infinite loop in the <code>_run()</code> method, typically receiving messages from one or more channels (receivers), processing them and sending the results to other channels (senders).</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass EchoActor(Actor):\n    def __init__(\n            self,\n            input: Receiver[int],\n            output: Sender[int],\n            name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._input: Receiver[int] = input\n        self._output: Sender[int] = output\n\n    async def _run(self) -&gt; None:  # (1)!\n        async for msg in self._input:  # (2)!\n            await self._output.send(msg)  # (3)!\n</code></pre> <ol> <li>We implement the abstract <code>_run()</code> method.</li> <li>We receive messages from the <code>input</code> channel one by one.</li> <li>We send the received message to the <code>output</code> channel.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--stopping","title":"Stopping","text":"<p>By default, the <code>stop()</code> method will call the <code>cancel()</code> method (which will cancel all the tasks created by the actor) and will wait for them to finish.</p> <p>This means that when an actor is stopped, the <code>_run()</code> method will receive a <code>CancelledError</code> exception. You should have this in mind when implementing your actor and make sure to handle this exception properly if you need to do any cleanup.</p> <p>The actor will handle the <code>CancelledError</code> exception automatically if it is not handled in the <code>_run()</code> method, so if there is no need for extra cleanup, you don't need to worry about it.</p> <p>If an unhandled exception is raised in the <code>_run()</code> method, the actor will re-run the <code>_run()</code> method automatically. This ensures robustness in the face of errors, but you should also have this in mind if you need to do any cleanup to make sure the re-run doesn't cause any problems.</p> Tip <p>You could implement your own <code>stop()</code> method to, for example, send a message to a channel to notify that the actor should stop, or any other more graceful way to stop the actor if you need to make sure it can't be interrupted at any <code>await</code> point.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--spawning-extra-tasks","title":"Spawning Extra Tasks","text":"<p>Actors run at least one background task, created automatically by the <code>Actor</code> class. But <code>Actor</code> inherits from <code>BackgroundService</code>, which provides a few methods to create and manage extra tasks.</p> <p>If your actor needs to spawn extra tasks, you can use <code>BackgroundService</code> facilities to manage the tasks, so they are also automatically stopped when the actor is stopped.</p> <p>All you need to do is add the newly spawned tasks to the actor's <code>tasks</code> set.</p> Example <pre><code>import asyncio\nfrom frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        extra_task = asyncio.create_task(self._extra_task())  # (1)!\n        self.tasks.add(extra_task)  # (2)!\n        while True:  # (3)!\n            print(\"_run() running\")\n            await asyncio.sleep(1)\n\n    async def _extra_task(self) -&gt; None:\n        while True:  # (4)!\n            print(\"_extra_task() running\")\n            await asyncio.sleep(1.1)\n\nasync with MyActor() as actor:  # (5)!\n    await asyncio.sleep(3)  # (6)!\n# (7)!\n</code></pre> <ol> <li>We create a new task using <code>asyncio.create_task()</code>.</li> <li>We add the task to the actor's <code>tasks</code> set.     This ensures the task will be cancelled and cleaned up when the actor is stopped.</li> <li>We leave the actor running forever.</li> <li>The extra task will also run forever.</li> <li>The actor is started.</li> <li>We wait for 3 seconds, the actor should print a bunch of \"_run() running\" and     \"_extra_task() running\" messages while it's running.</li> <li>The actor is stopped and the extra task is cancelled automatically.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--examples","title":"Examples","text":"<p>Here are a few simple but complete examples to demonstrate how to create actors and connect them using channels.</p> <p>Tip</p> <p>The code examples are annotated with markers (like ), you can click on them to see the step-by-step explanation of what's going on. The annotations are numbered according to the order of execution.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--composing-actors","title":"Composing actors","text":"<p>This example shows how to create two actors and connect them using broadcast channels.</p> compose.py<pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass Actor1(Actor):  # (1)!\n    def __init__(\n        self,\n        receiver: Receiver[str],\n        output: Sender[str],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver = receiver\n        self._output = output\n\n    async def _run(self) -&gt; None:\n        async for msg in self._receiver:\n            await self._output.send(f\"Actor1 forwarding: {msg!r}\")  # (8)!\n\n\nclass Actor2(Actor):\n    def __init__(\n        self,\n        receiver: Receiver[str],\n        output: Sender[str],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver = receiver\n        self._output = output\n\n    async def _run(self) -&gt; None:\n        async for msg in self._receiver:\n            await self._output.send(f\"Actor2 forwarding: {msg!r}\")  # (9)!\n\n\nasync def main() -&gt; None:  # (2)!\n    # (4)!\n    input_channel: Broadcast[str] = Broadcast(\"Input to Actor1\")\n    middle_channel: Broadcast[str] = Broadcast(\"Actor1 -&gt; Actor2 stream\")\n    output_channel: Broadcast[str] = Broadcast(\"Actor2 output\")\n\n    input_sender = input_channel.new_sender()\n    output_receiver = output_channel.new_receiver()\n\n    async with (  # (5)!\n        Actor1(input_channel.new_receiver(), middle_channel.new_sender(), \"actor1\"),\n        Actor2(middle_channel.new_receiver(), output_channel.new_sender(), \"actor1\"),\n    ):\n        await input_sender.send(\"Hello\")  # (6)!\n        msg = await output_receiver.receive()  # (7)!\n        print(msg)  # (10)!\n    # (11)!\n\nif __name__ == \"__main__\":  # (3)!\n    asyncio.run(main())\n</code></pre> <ol> <li> <p>We define 2 actors: <code>Actor1</code> and <code>Actor2</code> that will just forward a message    from an input channel to an output channel, adding some text.</p> </li> <li> <p>We define an async <code>main()</code> function with the main logic of our asyncio program.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We create a bunch of broadcast channels to connect our actors.</p> <ul> <li><code>input_channel</code> is the input channel for <code>Actor1</code>.</li> <li><code>middle_channel</code> is the channel that connects <code>Actor1</code> and <code>Actor2</code>.</li> <li><code>output_channel</code> is the output channel for <code>Actor2</code>.</li> </ul> </li> <li> <p>We create two actors and use them as async context managers, <code>Actor1</code> and     <code>Actor2</code>, and connect them by creating new     senders and     receivers from the channels.</p> <p>Note</p> <p>We don't use the <code>run()</code> function here because we want to stop the actors when we are done with them, but the actors will run forever (as long as the channel is not closed). So the async context manager is a better fit for this example.</p> </li> <li> <p>We schedule the sending of the message    <code>Hello</code> to <code>Actor1</code> via <code>input_channel</code>.</p> </li> <li> <p>We receive (await) the response from    <code>Actor2</code> via <code>output_channel</code>. Between this and the previous steps the    <code>async</code> calls in the actors will be executed.</p> </li> <li> <p><code>Actor1</code> sends the re-formatted message (<code>Actor1 forwarding: Hello</code>) to    <code>Actor2</code> via the <code>middle_channel</code>.</p> </li> <li> <p><code>Actor2</code> sends the re-formatted message (<code>Actor2 forwarding: \"Actor1    forwarding: 'Hello'\"</code>) to the <code>output_channel</code>.</p> </li> <li> <p>Finally, we print the received message, which will still be <code>Actor2     forwarding: \"Actor1 forwarding: 'Hello'\"</code>.</p> </li> <li> <p>The actors are stopped and cleaned up automatically when the <code>async with</code>     block ends.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Actor2 forwarding: \"Actor1 forwarding: 'Hello'\"\n</code></pre>"},{"location":"user-guide/actors/#frequenz.sdk.actor--receiving-from-multiple-channels","title":"Receiving from multiple channels","text":"<p>This example shows how to create an actor that receives messages from multiple broadcast channels using <code>select()</code>.</p> select.py<pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.channels.util import select, selected_from\nfrom frequenz.sdk.actor import Actor, run\n\n\nclass EchoActor(Actor):  # (1)!\n    def __init__(\n        self,\n        receiver_1: Receiver[bool],\n        receiver_2: Receiver[bool],\n        output: Sender[bool],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver_1 = receiver_1\n        self._receiver_2 = receiver_2\n        self._output = output\n\n    async def _run(self) -&gt; None:  # (2)!\n        async for selected in select(self._receiver_1, self._receiver_2):  # (10)!\n            if selected_from(selected, self._receiver_1):  # (11)!\n                print(f\"Received from receiver_1: {selected.value}\")\n                await self._output.send(selected.value)\n                if not selected.value:  # (12)!\n                    break\n            elif selected_from(selected, self._receiver_2):  # (13)!\n                print(f\"Received from receiver_2: {selected.value}\")\n                await self._output.send(selected.value)\n                if not selected.value:  # (14)!\n                    break\n            else:\n                assert False, \"Unknown selected channel\"\n        print(\"EchoActor finished\")\n    # (15)!\n\n\n# (3)!\ninput_channel_1 = Broadcast[bool](\"input_channel_1\")\ninput_channel_2 = Broadcast[bool](\"input_channel_2\")\necho_channel = Broadcast[bool](\"echo_channel\")\n\necho_actor = EchoActor(  # (4)!\n    input_channel_1.new_receiver(),\n    input_channel_2.new_receiver(),\n    echo_channel.new_sender(),\n    \"echo-actor\",\n)\n\necho_receiver = echo_channel.new_receiver()  # (5)!\n\nasync def main() -&gt; None:  # (6)!\n    # (8)!\n    await input_channel_1.new_sender().send(True)\n    await input_channel_2.new_sender().send(False)\n\n    await run(echo_actor)  # (9)!\n\n    await echo_channel.close()  # (16)!\n\n    async for message in echo_receiver:  # (17)!\n        print(f\"Received {message=}\")\n\n\nif __name__ == \"__main__\":  # (7)!\n    asyncio.run(main())\n</code></pre> <ol> <li> <p>We define an <code>EchoActor</code> that receives messages from two channels and sends     them to another channel.</p> </li> <li> <p>We implement the <code>_run()</code> method that will receive messages from the two     channels using and send them to the output channel. The <code>run()</code> method will stop if     a <code>False</code> message is received.</p> </li> <li> <p>We create the channels that will be used with the actor.</p> </li> <li> <p>We create the actor and connect it to the channels by creating new receivers and     senders from the channels.</p> </li> <li> <p>We create a receiver for the <code>echo_channel</code> to eventually receive the messages sent     by the actor.</p> </li> <li> <p>We define the <code>main()</code> function that will run the actor.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We send a message to each of the input channels. These messages will be queued in     the channels until they are consumed by the actor.</p> </li> <li> <p>We start the actor and wait for it to finish using the     <code>run()</code> function.</p> </li> <li> <p>The <code>select()</code> function will get the first message     available from the two channels. The order in which they will be handled is     unknown, but in this example we assume that the first message will be from     <code>input_channel_1</code> (<code>True</code>) and the second from <code>input_channel_1</code> (<code>False</code>).</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>True</code> for the <code>input_channel_1</code> receiver. <code>selected.value</code> holds the received     message, so <code>\"Received from receiver_1: True\"</code> will be printed and <code>True</code> will be     sent to the <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>True</code>, the loop will continue, going back to the and the     the loop will continue, going back to the     <code>select()</code> function.</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>False</code> for the <code>input_channel_1</code> receiver and <code>True</code> for the <code>input_channel_2</code>     receiver. The message stored in <code>selected.value</code> will now be <code>False</code>, so     <code>\"Received from receiver_2: False\"</code> will be printed and <code>False</code> will be sent to the     <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>False</code>, the loop will break.</p> </li> <li> <p>The <code>_run()</code> method will finish normally and the actor will be stopped, so     the <code>run()</code> function will return.</p> </li> <li> <p>We close the <code>echo_channel</code> to make sure the <code>echo_receiver</code> will stop receiving     messages after all the queued messages are consumed (otherwise the step 17 will     never end!).</p> </li> <li> <p>We receive the messages sent by the actor to the <code>echo_channel</code> one by one and print     them, it should print first <code>Received message=True</code> and then <code>Received     message=False</code>.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Received from receiver_1: True\nReceived from receiver_2: False\nReceived message=True\nReceived message=False\n</code></pre>"},{"location":"user-guide/formula-engine/","title":"Formula Engine","text":""},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine","title":"FormulaEngine","text":"<p><code>FormulaEngine</code>s are a part of the SDK's data pipeline, and provide a way for the SDK to apply formulas on resampled data streams.</p> <p>They are used in the SDK to calculate and stream metrics like <code>grid_power</code>, <code>consumer_power</code>, etc., which are building blocks of the Frequenz SDK Microgrid Model.</p> <p>The SDK creates the formulas by analysing the configuration of components in the Component Graph.</p>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine.new_receiver()</code> method can be used to create a Receiver that streams the Samples calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\n\nbattery_pool = microgrid.battery_pool()\n\nasync for power in battery_pool.power.new_receiver():\n    print(f\"{power=}\")\n</code></pre>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--composition","title":"Composition","text":"<p>Composite <code>FormulaEngine</code>s can be built using arithmetic operations on <code>FormulaEngine</code>s streaming the same type of data.</p> <p>For example, if you're interested in a particular composite metric that can be calculated by subtracting <code>battery_pool().power</code> and <code>ev_charger_pool().power</code> from the <code>grid().power</code>, we can build a <code>FormulaEngine</code> that provides a stream of this calculated metric as follows:</p> <pre><code>from frequenz.sdk import microgrid\n\nlogical_meter = microgrid.logical_meter()\nbattery_pool = microgrid.battery_pool()\nev_charger_pool = microgrid.ev_charger_pool()\ngrid = microgrid.grid()\n\n# apply operations on formula engines to create a formula engine that would\n# apply these operations on the corresponding data streams.\nnet_power = (\n    grid.power - (battery_pool.power + ev_charger_pool.power)\n).build(\"net_power\")\n\nasync for power in net_power.new_receiver():\n    print(f\"{power=}\")\n</code></pre>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase","title":"FormulaEngine3Phase","text":"<p>A <code>FormulaEngine3Phase</code> is similar to a <code>FormulaEngine</code>, except that they stream 3-phase samples.  All the current formulas (like <code>Grid.current</code>, <code>EVChargerPool.current</code>, etc.) are implemented as 3-phase formulas.</p>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine3Phase.new_receiver()</code> method can be used to create a Receiver that streams the Sample3Phase values calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\n\nev_charger_pool = microgrid.ev_charger_pool()\n\nasync for sample in ev_charger_pool.current.new_receiver():\n    print(f\"Current: {sample}\")\n</code></pre>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--composition","title":"Composition","text":"<p><code>FormulaEngine3Phase</code> instances can be composed together, just like <code>FormulaEngine</code> instances.</p> <pre><code>from frequenz.sdk import microgrid\n\nlogical_meter = microgrid.logical_meter()\nev_charger_pool = microgrid.ev_charger_pool()\ngrid = microgrid.grid()\n\n# Calculate grid consumption current that's not used by the EV chargers\nother_current = (grid.current - ev_charger_pool.current).build(\"other_current\")\n\nasync for sample in other_current.new_receiver():\n    print(f\"Other current: {sample}\")\n</code></pre>"},{"location":"user-guide/glossary/","title":"Glossary","text":"<p>This glossary provides definitions for common terminology used in the Frequenz SDK, focusing on microgrid components, metrics, measurements, and power-related terms.</p>"},{"location":"user-guide/glossary/#common-acronyms","title":"Common Acronyms","text":""},{"location":"user-guide/glossary/#ac","title":"AC","text":"<p>Alternating current. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#bms","title":"BMS","text":"<p>Battery management system. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#chp","title":"CHP","text":"<p>Combined heat and power. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#dc","title":"DC","text":"<p>Direct current. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#ev","title":"EV","text":"<p>Electric vehicle. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#psc","title":"PSC","text":"<p>Passive sign convention. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#pv","title":"PV","text":"<p>Photovoltaic. See the Wikipedia article for more details.</p> <p>In the SDK it is normally used as a synonym for solar panel.</p>"},{"location":"user-guide/glossary/#soc","title":"SoC","text":"<p>State of charge. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#sop","title":"SoP","text":"<p>State of power.</p>"},{"location":"user-guide/glossary/#microgrid","title":"Microgrid","text":"<p>A local electrical grid that connects a set of different types of components together. It can be connected to the public grid, or be completely isolated, in which case it is known as an island.</p>"},{"location":"user-guide/glossary/#component-category","title":"Component Category","text":"<p>The category components of a microgrid belong to.</p> <p>Components of the same category have the same characteristics (for example offer the same set of metrics).</p>"},{"location":"user-guide/glossary/#battery","title":"Battery","text":"<p>A storage system for electrical energy.</p>"},{"location":"user-guide/glossary/#chp-plant","title":"CHP Plant","text":"<p>A generator that produces combined heat and power (CHP). Usually powered via combustion of some form of fuel.</p>"},{"location":"user-guide/glossary/#converter","title":"Converter","text":"<p>Generally refers to DC-to-DC converter.</p>"},{"location":"user-guide/glossary/#dc-to-dc-converter","title":"DC-to-DC Converter","text":"<p>An electronic circuit or electromechanical device that converts a source of DC from one voltage level to another.</p>"},{"location":"user-guide/glossary/#ev-charger","title":"EV Charger","text":"<p>A station for charging EVs.</p>"},{"location":"user-guide/glossary/#electrolyzer","title":"Electrolyzer","text":"<p>A device that converts water into hydrogen and oxygen.</p>"},{"location":"user-guide/glossary/#grid","title":"Grid","text":"<p>A point where the local microgrid is connected to the public electricity grid.</p>"},{"location":"user-guide/glossary/#inverter","title":"Inverter","text":"<p>A device or circuitry that converts DC electricity to AC electricity.</p>"},{"location":"user-guide/glossary/#meter","title":"Meter","text":"<p>A device for measuring electrical metrics (for example current, voltage, etc.).</p>"},{"location":"user-guide/glossary/#pv-array","title":"PV Array","text":"<p>A collection of PV panels.</p>"},{"location":"user-guide/glossary/#pre-charge-module","title":"Pre-charge module","text":"<p>A device that gradually ramp the DC voltage up to prevent any potential damage to sensitive electrical components, like capacitors.</p> <p>While many inverters and batteries come equipped with in-built pre-charging mechanisms, some may lack this feature. In such cases, external pre-charging modules can be used.</p>"},{"location":"user-guide/glossary/#relay","title":"Relay","text":"<p>A device that generally have two states: open (connected) and closed (disconnected).</p> <p>They are generally placed in front of another component, e.g., an inverter, to control whether the component is connected to the microgrid or not.</p>"},{"location":"user-guide/glossary/#sensor","title":"Sensor","text":"<p>A device for [measuring](#measurement] ambient metrics (for example temperature, humidity, etc.).</p>"},{"location":"user-guide/glossary/#solar-panel","title":"Solar Panel","text":"<p>A panel with PV cells that generates DC electricity from sunlight.</p>"},{"location":"user-guide/glossary/#wind-turbine","title":"Wind Turbine","text":"<p>A device that converts the wind's kinetic energy into electrical energy.</p>"},{"location":"user-guide/glossary/#component","title":"Component","text":"<p>A device (of a particular category) within a microgrid.</p>"},{"location":"user-guide/glossary/#component-id","title":"Component ID","text":"<p>A numeric identifier uniquely representing an instance of a component in a particular microgrid. It is always of type <code>int</code>.</p> <p>For example, a battery with a component ID of 5.</p>"},{"location":"user-guide/glossary/#component-graph","title":"Component Graph","text":"<p>A graph representation of the configuration in which the electrical components in a microgrid are connected with each other.  Some of the ways in which the SDK uses the component graph are:</p> <ul> <li>figure out how to calculate high level metrics like <code>grid_power</code>, <code>consumer_power</code>, etc. for a microgrid, using the available components.</li> <li>identify the available batteries or     EV chargers at a site that can be controlled.</li> </ul>"},{"location":"user-guide/glossary/#island","title":"Island","text":"<p>A microgrid that is not connected to the public electricity grid.</p>"},{"location":"user-guide/glossary/#passive-sign-convention","title":"Passive Sign Convention","text":"<p>A convention for the direction of power flow in a circuit. When the electricity is flowing into a component the value is positive, and when it is flowing out of a component the value is negative.</p> <p>In microgrids that have a grid connection, power flowing away from the grid is positive, and power flowing towards the grid is negative.</p>"},{"location":"user-guide/glossary/#component-data","title":"Component Data","text":""},{"location":"user-guide/glossary/#metric","title":"Metric","text":"<p>A quantifiable attribute of a component.</p> <p>For example, the metric capacity of a battery.</p>"},{"location":"user-guide/glossary/#measurement","title":"Measurement","text":"<p>An individual numeric value obtained from a metric of a component instance. It is consistently of type <code>float</code>, but it is often expressed in specific units.</p> <p>In the context of a sample, this is commonly referred to as a sample value.</p> <p>For example, a measurement of the capacity of a battery with component ID 5 can be 400, typically measured in Watt-hours (Wh).</p>"},{"location":"user-guide/glossary/#timestamp","title":"Timestamp","text":"<p>A specific point in time, always represented as a <code>datetime</code> with a <code>timezone</code> attached.</p> <p>For example, 2022-01-01 22:00:00.000 UTC.</p>"},{"location":"user-guide/glossary/#sample","title":"Sample","text":"<p>A measurement recorded at a particular timestamp, typically represented as a tuple <code>(timestamp, value)</code>.</p> <p>For example, recording a measurement of 400 from the capacity of a battery at 2022-01-01 22:00:00.000 UTC would constitute a sample <code>(2022-01-01 22:00:00.000 UTC, 400)</code>.</p>"},{"location":"user-guide/glossary/#sample-value","title":"Sample Value","text":"<p>A measurement stored in a sample.</p>"},{"location":"user-guide/glossary/#time-series","title":"Time Series","text":"<p>A sequence of samples, often organized by timestamp and typically with regular intervals. However, irregular (event-based) time series are also possible.</p> <p>For example, a time series representing measurements of a battery's capacity at 2022-01-01 22:00:00.000 UTC every second for 5 seconds would appear as follows:</p> <pre><code>(2022-01-01 22:00:00.000 UTC, 400)\n(2022-01-01 22:00:01.000 UTC, 401)\n(2022-01-01 22:00:02.000 UTC, 403)\n(2022-01-01 22:00:03.000 UTC, 402)\n(2022-01-01 22:00:04.000 UTC, 403)\n</code></pre>"},{"location":"user-guide/glossary/#timeseries","title":"Timeseries","text":"<p>Same as time series.</p>"},{"location":"user-guide/glossary/#metric-id","title":"Metric ID","text":"<p>An identifier for a component's metric, typically a string (<code>str</code>).</p> <p>Components belonging to the same category have the same set of metric IDs.</p> <p>For example, the metric ID for the capacity of a battery is simply <code>capacity</code>.</p>"},{"location":"user-guide/glossary/#time-series-id","title":"Time Series ID","text":"<p>An identifier for a time series originating from a metric of a specific component. Typically a string (<code>str</code>) derived from the tuple (component ID, metric ID) for components.</p> <p>For example, a time series for the capacity of a battery with component ID 5 has the ID (component_id, metric_id) (or <code>f\"{component_id}_{metric_id}\"</code>).</p>"},{"location":"user-guide/glossary/#timeseries-id","title":"Timeseries ID","text":"<p>Same as time series ID.</p>"},{"location":"user-guide/glossary/#metrics","title":"Metrics","text":"<p>All metrics related to power, energy, current, etc. use the PSC to determine the sign of the value.</p>"},{"location":"user-guide/glossary/#consumption","title":"Consumption","text":"<p>The amount of electricity flowing into a component. It is the clipped positive value when using the PSC, so if the electricity is flowing out of the component instead, this will be zero.</p>"},{"location":"user-guide/glossary/#gross-consumption","title":"Gross Consumption","text":"<p>Consumption before accounting for any local generation from solar, wind or CHP.</p>"},{"location":"user-guide/glossary/#instantaneous-power","title":"Instantaneous Power","text":"<p>Same as power.</p>"},{"location":"user-guide/glossary/#load","title":"Load","text":"<p>Typically refers to a device that consumes electricity, but also to the amount of electricity consumed by such a device. In a microgrid context, it is often used to refer to all the electrical devices that are doing active work, for example a light bulb, a motor, a cooler, etc.</p> <p>When using the PSC, this is the same as consumption and it is a positive value. If a load generates electricity instead, it is a negative value but it wouldn't typically be called a load.</p>"},{"location":"user-guide/glossary/#net-consumption","title":"Net Consumption","text":"<p>This term traditionally refers to the difference between the gross consumption and the local generation (like PV production). It is the electricity consumption that needs to be provided by the battery or from the public grid.</p>"},{"location":"user-guide/glossary/#net-load","title":"Net Load","text":"<p>Same as net consumption.</p>"},{"location":"user-guide/glossary/#power","title":"Power","text":"<p>The rate of energy transfer, i.e. the amount of energy transferred per unit of time. It is typically measured in Watts (W).</p> <p>For AC electricity, there are three types of power: active, reactive, and apparent (P, Q and |S| respectively in power triangle).</p> <p>See the Wikipedia article for more information.</p>"},{"location":"user-guide/glossary/#power-triangle","title":"Power Triangle","text":"<p>The visual representation of the relationship between the three types of AC power and phase of voltage relative to current.</p> <p></p> <p>(CC-BY-SA 3.0, Wikimedia Commons)</p>"},{"location":"user-guide/glossary/#active-power","title":"Active Power","text":"<p>The AC power that is actually consumed by the load. It is the real part of the apparent power, P in the power triangle.</p>"},{"location":"user-guide/glossary/#apparent-power","title":"Apparent Power","text":"<p>The AC power that is actually supplied to the load. The magnitude of the vector sum of the active and reactive power, |S| in the power-triangle.</p>"},{"location":"user-guide/glossary/#phase-of-voltage-relative-to-current","title":"Phase of Voltage Relative to Current","text":"<p>The angle of difference (in degrees) between current and voltage in an AC circuit, \u03c6 in the power triangle.</p>"},{"location":"user-guide/glossary/#power-factor","title":"Power Factor","text":"<p>The ratio of real power to apparent power in an AC circuit. Can be obtained by computing the cosine of \u03c6, in the power triangle. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#reactive-power","title":"Reactive Power","text":"<p>The AC power that is not consumed by the load, but is alternately stored and returned to the source. It is the imaginary part of the apparent power, Q in the power triangle.</p>"},{"location":"user-guide/glossary/#real-power","title":"Real Power","text":"<p>Same as active power.</p>"},{"location":"user-guide/glossary/#production","title":"Production","text":"<p>The amount of electricity flowing out of a component. It is the clipped negative value when using the PSC, so if the electricity is flowing into the component instead, this will be zero.</p>"},{"location":"user-guide/glossary/#residual-consumption","title":"Residual Consumption","text":"<p>In microgrid context sometimes used as the remaining difference between the net consumption and the battery power, i.e. what we define as grid power.</p>"},{"location":"user-guide/glossary/#residual-load","title":"Residual Load","text":"<p>Same as residual consumption.</p>"},{"location":"user-guide/glossary/#state-of-charge","title":"State of Charge","text":"<p>The level of charge of a battery relative to its capacity, expressed in percentage points. Calculated as the ratio between the remaining energy in the battery at a given time and the maximum possible energy under similar health conditions. Source</p>"},{"location":"user-guide/glossary/#state-of-power","title":"State of Power","text":"<p>The ratio of peak power to nominal power. Peak power is the maximum power that can be sustained for a specific duration without violating preset operational design limits on battery voltage, SoC, power, or current.</p> <p>This indicator is crucial to ensure that charge or discharge power remains within specific limits, optimizing the battery's lifespan. It is particularly useful in peak power applications to define battery conditions for substantial charges or discharges.</p> <p>The state of power depends on the state of charge, battery capacity, initial characteristics, chemistry, and battery voltage, as well as external factors like temperature and humidity, which can also have a significant impact on it. Source</p>"},{"location":"user-guide/microgrid-concepts/","title":"Microgrid Concepts","text":"<p>A microgrid is a local electrical grid that connects a set of electrical components together.  They are often built around a passive power consumer, to supplement the electricity consumed from the public grid with on-site power generation or storage systems.</p> <p>Microgrids can also function in island-mode, without a grid connection, or without a local power consumer, but they have to have at least one of the two, to be meaningful.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--frequenz-sdk-microgrid-model","title":"Frequenz SDK Microgrid Model","text":"<p>The SDK aims to provide an abstract model of the microgrid that enables high-level interactions with microgrid components, without having to worry about (or even be aware of) location-specific details such as:</p> <ul> <li>where the meters are placed,</li> <li>how many batteries,</li> <li>whether there's a grid connection or a passive consumer,</li> <li>what models the inverters are, etc.</li> <li>whether components are having downtimes, because metrics and   limits get adjusted automatically when components are having downtimes.</li> </ul> <p>Users of the SDK can develop applications around this interface once and deploy anywhere, and the SDK will take care of translating the requests and instructions to correspond to the specific microgrid configurations.</p> <pre><code>flowchart LR\n\nsubgraph Left[Measurements only]\ndirection LR\n  grid[\"Grid Connection\"]\n  consumer[\"Consumer\"]\n  pv[\"PV Arrays\"]\n  chp[\"CHP\"]\nend\n\njunction(( ))\n\nsubgraph Right[Measurements and control]\ndirection LR\n  bat[\"Batteries\"]\n  ev[\"EV Chargers\"]\nend\n\ngrid --- junction\nconsumer --- junction\npv --- junction\nchp --- junction\n\njunction --- bat\njunction --- ev</code></pre>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--grid","title":"Grid","text":"<p>This refers to a microgrid's connection to the external Grid.  The power flowing through this connection can be streamed through <code>grid_power</code>.</p> <p>In locations without a grid connection, this method remains accessible, and streams zero values.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--consumer","title":"Consumer","text":"<p>This is the main power consumer at the site of a microgrid, and often the load the microgrid is built to support.  The power drawn by the consumer is available through <code>consumer_power</code></p> <p>In locations without a consumer, this method streams zero values.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--producers-pv-arrays-chp","title":"Producers: PV Arrays, CHP","text":"<p>The total PV power production in a microgrid can be streamed through <code>pv_power</code> , and similarly the total CHP production in a site can be streamed through <code>chp_power</code>.  And total producer power is available through <code>producer_power</code>.</p> <p>As is the case with the other methods, if PV Arrays or CHPs are not available in a microgrid, the corresponding methods stream zero values.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--batteries","title":"Batteries","text":"<p>The total Battery power is available through <code>battery_pool</code>'s <code>power</code>.  The battery pool by default uses all batteries available at a location, but battery pool instances can be created for subsets of batteries if necessary, by specifying the battery ids.</p> <p>The <code>battery_pool</code> also provides <code>soc</code>, <code>capacity</code>, <code>temperature</code> and available power bounds through the <code>power_status</code> method.</p> <p>The <code>battery_pool</code> also provides control methods <code>propose_power</code> (which accepts values in the Passive Sign Convention and supports both charging and discharging), or through <code>propose_charge</code>, or <code>propose_discharge</code>.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--ev-chargers","title":"EV Chargers","text":"<p>The <code>ev_charger_pool</code> offers a <code>power</code> method that streams the total power measured for all the EV Chargers at a site.</p> <p>It also offers a <code>component_data</code> method for fetching the status of individual EV Chargers, including state changes like when an EV is connected or disconnected, and a <code>set_bounds</code> method to limit the charge power of individual EV Chargers.</p>"}]}