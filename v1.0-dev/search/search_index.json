{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Python SDK","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The Frequenz Python SDK is a development kit for interacting with the Frequenz development platform.</p>"},{"location":"#installation","title":"Installation","text":"<p>First, you need to make sure you have Python installed (at least version 3.11):</p> <pre><code>$ python3 --version\nPython 3.11.4\n</code></pre> <p>Note</p> <p>These instructions assume you are using a POSIX compatible <code>sh</code> shell.</p> <p>If that command doesn't print a version newer than 3.11.0, you'll need to download and install Python first.</p> <p>To install the SDK, you probably want to create a new virtual environment first:</p> <pre><code>mkdir my-sdk-project\ncd my-sdk-project\npython3 -m venv .venv\n. .venv/bin/activate\n</code></pre> <p>Tip</p> <p>Using <code>direnv</code> can greatly simplify this process as it automates the creation, activation, and deactivation of the virtual environment. The first time you enable <code>direnv</code>, the virtual environment will be created, and each time you enter or leave a subdirectory, it will be activated and deactivated, respectively.</p> <pre><code>sudo apt install direnv # if you use Debian/Ubuntu\nmkdir my-sdk-project\ncd my-sdk-project\necho \"layout python python3\" &gt; .envrc\ndirenv allow\n</code></pre> <p>This will create the virtual environment and activate it automatically for you.</p> <p>Now you can install the SDK by using <code>pip</code> (if you don't have <code>pip</code> installed you can follow the official instructions):</p> <pre><code>python3 -m pip install frequenz-sdk\n</code></pre> <p>To verify that the installation worked, you can invoke the Python interpreter and import the SDK:</p> <pre><code>$ python3\nPython 3.11.4 (main, Jun  7 2023, 10:13:09) [GCC 12.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import frequenz.sdk\n&gt;&gt;&gt;\n</code></pre>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Python SDK","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>User Guide</li> <li>Tutorials</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>sdk<ul> <li>actor<ul> <li>power_distributing<ul> <li>power_distributing</li> <li>request</li> <li>result</li> </ul> </li> </ul> </li> <li>microgrid<ul> <li>component_graph</li> <li>connection_manager</li> </ul> </li> <li>timeseries<ul> <li>battery_pool</li> <li>consumer</li> <li>ev_charger_pool</li> <li>formula_engine</li> <li>grid</li> <li>logical_meter</li> <li>producer</li> <li>pv_pool</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/sdk/","title":"Index","text":""},{"location":"reference/frequenz/sdk/#frequenz.sdk","title":"frequenz.sdk","text":"<p>Frequenz Python SDK.</p>"},{"location":"reference/frequenz/sdk/actor/","title":"Index","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor","title":"frequenz.sdk.actor","text":"<p>Actors are a primitive unit of computation that runs autonomously.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--actor-programming-model","title":"Actor Programming Model","text":"<p>From Wikipedia</p> <p>The actor model in computer science is a mathematical model of concurrent computation that treats an actor as the basic building block of concurrent computation. In response to a message it receives, an actor can: make local decisions, create more actors, send more messages, and determine how to respond to the next message received. Actors may modify their own private state, but can only affect each other indirectly through messaging (removing the need for lock-based synchronization).</p> <p>We won't get into much more detail here because it is outside the scope of this documentation. However, if you are interested in learning more about the actor programming model, here are some useful resources:</p> <ul> <li>Actor Model (Wikipedia)</li> <li>How the Actor Model Meets the Needs of Modern, Distributed Systems   (Akka)</li> </ul>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--frequenz-sdk-actors","title":"Frequenz SDK Actors","text":"<p>The <code>Actor</code> class serves as the foundation for creating concurrent tasks and all actors in the SDK inherit from it. This class provides a straightforward way to implement actors. It shares similarities with the traditional actor programming model but also has some unique features:</p> <ul> <li> <p>Message Passing: Like traditional actors, our <code>Actor</code>   class communicates through message passing. Even when no particular message passing   mechanism is enforced, the SDK actors use <code>frequenz.channels</code> for communication.</p> </li> <li> <p>Automatic Restart: If an unhandled exception occurs in an actor's logic   (<code>_run()</code> method), the actor will be automatically restarted. This ensures   robustness in the face of errors.</p> </li> <li> <p>Simplified Task Management: Actors manage asynchronous tasks using   <code>asyncio</code>. You can create and manage tasks within the actor, and the   <code>Actor</code> class handles task cancellation and cleanup.</p> </li> <li> <p>Simplified lifecycle management: Actors are [async context managers] and also   a <code>run()</code> function is provided to easily run a group of   actors and wait for them to finish.</p> </li> </ul>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--lifecycle","title":"Lifecycle","text":"<p>Actors are not started when they are created. There are 3 main ways to start an actor (from most to least recommended):</p> <ol> <li>By using the <code>run()</code> function.</li> <li>By using the actor as an async context manager.</li> <li>By using the <code>start()</code> method.</li> </ol> <p>Warning</p> <ol> <li> <p>If an actor raises an unhandled exception, it will be restarted automatically.</p> </li> <li> <p>Actors manage <code>asyncio.Task</code> objects, so a reference to the actor object must    be held for as long as the actor is expected to be running, otherwise its tasks    will be cancelled and the actor will stop. For more information, please refer to    the Python <code>asyncio</code>    documentation.</p> </li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--the-run-function","title":"The <code>run()</code> Function","text":"<p>The <code>run()</code> function can start many actors at once and waits for them to finish. If any of the actors is stopped with errors, the errors will be logged.</p> Example <pre><code>from frequenz.sdk.actor import Actor, run\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nawait run(MyActor()) # (1)!\n</code></pre> <ol> <li>This line will block until the actor completes its execution or is manually stopped.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--async-context-manager","title":"Async Context Manager","text":"<p>When an actor is used as an async context manager, it is started when the <code>async with</code> block is entered and stopped automatically when the block is exited (even if an unhandled exception is raised).</p> Example <pre><code>from frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nasync with MyActor() as actor: # (1)!\n    print(\"The actor is running\")\n# (2)!\n</code></pre> <ol> <li><code>start()</code> is called automatically when entering     the <code>async with</code> block.</li> <li><code>stop()</code> is called automatically when exiting     the <code>async with</code> block.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--the-start-method","title":"The <code>start()</code> Method","text":"<p>When using the <code>start()</code> method, the actor is started in the background and the method returns immediately. The actor will continue to run until it is manually stopped or until it completes its execution.</p> Example <pre><code>from frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nactor = MyActor() # (1)!\nactor.start() # (2)!\nprint(\"The actor is running\") # (3)!\nawait actor.stop() # (4)!\n</code></pre> <ol> <li>The actor is created but not started yet.</li> <li>The actor is started manually, it keeps running in the background.</li> <li> <p>Danger</p> <p>If this function would raise an exception, the actor will never be stopped!</p> </li> <li> <p>Until the actor is stopped manually.</p> </li> </ol> <p>Warning</p> <p>This method is not recommended because it is easy to forget to stop the actor manually, especially in error conditions.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--communication","title":"Communication","text":"<p>The <code>Actor</code> class doesn't impose any specific way to communicate between actors. However, <code>frequenz.channels</code> are always used as the communication mechanism between actors in the SDK.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--implementing-an-actor","title":"Implementing an Actor","text":"<p>To implement an actor, you must inherit from the <code>Actor</code> class and implement an initializer and the abstract <code>_run()</code> method.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--initialization","title":"Initialization","text":"<p>The initializer is called when the actor is created. The <code>Actor</code> class initializer (<code>__init__</code>) should be always called first in the class we are implementing to make sure actors are properly initialized.</p> <p>The <code>Actor.__init__()</code> takes one optional argument, a <code>name</code> that will be used to identify the actor in logs. If no name is provided, a default name will be generated, but it is recommended that <code>Actor</code> subclasses can also receive a name as an argument to make it easier to identify individual instances in logs more easily.</p> <p>The actor initializer normally also accepts as arguments the input channels receivers and output channels senders that will be used for communication. These channels should be created outside the actor and passed to it as arguments to ensure actors can be composed easily.</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass EchoActor(Actor):  # (1)!\n    def __init__(\n            self,\n            input: Receiver[int],  # (2)!\n            output: Sender[int],  # (3)!\n            name: str | None = None,  # (4)!\n    ) -&gt; None:\n        super().__init__(name=name) # (5)!\n        self._input: Receiver[int] = input  # (6)!\n        self._output: Sender[int] = output  # (7)!\n</code></pre> <ol> <li> <p>We define a new actor class called <code>EchoActor</code> that inherits from     <code>Actor</code>.</p> </li> <li> <p>We accept an <code>input</code> argument that will be used to receive messages from     a channel.</p> </li> <li>We accept an <code>output</code> argument that will be used to send messages to a channel.</li> <li>We accept an optional <code>name</code> argument that will be used to identify the actor in     logs.</li> <li>We call <code>Actor.__init__()</code> to make sure the     actor is properly initialized.</li> <li>We store the <code>input</code> argument in a private attribute to use it later.</li> <li>We store the <code>output</code> argument in a private attribute to use it later.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--the-_run-method","title":"The <code>_run()</code> Method","text":"<p>The abstract <code>_run()</code> method is called automatically by the base class when the actor is started.</p> <p>Normally an actor should run forever (or until it is stopped), so it is very common to have an infinite loop in the <code>_run()</code> method, typically receiving messages from one or more channels (receivers), processing them and sending the results to other channels (senders). However, it is worth noting that an actor can also be designed for a one-time execution or a limited number of runs, terminating upon completion.</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass EchoActor(Actor):\n    def __init__(\n            self,\n            input: Receiver[int],\n            output: Sender[int],\n            name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._input: Receiver[int] = input\n        self._output: Sender[int] = output\n\n    async def _run(self) -&gt; None:  # (1)!\n        async for msg in self._input:  # (2)!\n            await self._output.send(msg)  # (3)!\n</code></pre> <ol> <li>We implement the abstract <code>_run()</code> method.</li> <li>We receive messages from the <code>input</code> channel one by one.</li> <li>We send the received message to the <code>output</code> channel.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--stopping","title":"Stopping","text":"<p>By default, the <code>stop()</code> method will call the <code>cancel()</code> method (which will cancel all the tasks created by the actor) and will wait for them to finish.</p> <p>This means that when an actor is stopped, the <code>_run()</code> method will receive a <code>CancelledError</code> exception. You should have this in mind when implementing your actor and make sure to handle this exception properly if you need to do any cleanup.</p> <p>The actor will handle the <code>CancelledError</code> exception automatically if it is not handled in the <code>_run()</code> method, so if there is no need for extra cleanup, you don't need to worry about it.</p> <p>If an unhandled exception is raised in the <code>_run()</code> method, the actor will re-run the <code>_run()</code> method automatically. This ensures robustness in the face of errors, but you should also have this in mind if you need to do any cleanup to make sure the re-run doesn't cause any problems.</p> Tip <p>You could implement your own <code>stop()</code> method to, for example, send a message to a channel to notify that the actor should stop, or any other more graceful way to stop the actor if you need to make sure it can't be interrupted at any <code>await</code> point.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--spawning-extra-tasks","title":"Spawning Extra Tasks","text":"<p>Actors run at least one background task, created automatically by the <code>Actor</code> class. But <code>Actor</code> inherits from <code>BackgroundService</code>, which provides a few methods to create and manage extra tasks.</p> <p>If your actor needs to spawn extra tasks, you can use <code>BackgroundService</code> facilities to manage the tasks, so they are also automatically stopped when the actor is stopped.</p> <p>All you need to do is add the newly spawned tasks to the actor's <code>tasks</code> set.</p> Example <pre><code>import asyncio\nfrom frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        extra_task = asyncio.create_task(self._extra_task())  # (1)!\n        self.tasks.add(extra_task)  # (2)!\n        while True:  # (3)!\n            print(\"_run() running\")\n            await asyncio.sleep(1)\n\n    async def _extra_task(self) -&gt; None:\n        while True:  # (4)!\n            print(\"_extra_task() running\")\n            await asyncio.sleep(1.1)\n\nasync with MyActor() as actor:  # (5)!\n    await asyncio.sleep(3)  # (6)!\n# (7)!\n</code></pre> <ol> <li>We create a new task using <code>asyncio.create_task()</code>.</li> <li>We add the task to the actor's <code>tasks</code> set.     This ensures the task will be cancelled and cleaned up when the actor is stopped.</li> <li>We leave the actor running forever.</li> <li>The extra task will also run forever.</li> <li>The actor is started.</li> <li>We wait for 3 seconds, the actor should print a bunch of \"_run() running\" and     \"_extra_task() running\" messages while it's running.</li> <li>The actor is stopped and the extra task is cancelled automatically.</li> </ol>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--examples","title":"Examples","text":"<p>Here are a few simple but complete examples to demonstrate how to create actors and connect them using channels.</p> <p>Tip</p> <p>The code examples are annotated with markers (like ), you can click on them to see the step-by-step explanation of what's going on. The annotations are numbered according to the order of execution.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--composing-actors","title":"Composing actors","text":"<p>This example shows how to create two actors and connect them using broadcast channels.</p> compose.py<pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass Actor1(Actor):  # (1)!\n    def __init__(\n        self,\n        receiver: Receiver[str],\n        output: Sender[str],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver = receiver\n        self._output = output\n\n    async def _run(self) -&gt; None:\n        async for msg in self._receiver:\n            await self._output.send(f\"Actor1 forwarding: {msg!r}\")  # (8)!\n\n\nclass Actor2(Actor):\n    def __init__(\n        self,\n        receiver: Receiver[str],\n        output: Sender[str],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver = receiver\n        self._output = output\n\n    async def _run(self) -&gt; None:\n        async for msg in self._receiver:\n            await self._output.send(f\"Actor2 forwarding: {msg!r}\")  # (9)!\n\n\nasync def main() -&gt; None:  # (2)!\n    # (4)!\n    input_channel: Broadcast[str] = Broadcast(\"Input to Actor1\")\n    middle_channel: Broadcast[str] = Broadcast(\"Actor1 -&gt; Actor2 stream\")\n    output_channel: Broadcast[str] = Broadcast(\"Actor2 output\")\n\n    input_sender = input_channel.new_sender()\n    output_receiver = output_channel.new_receiver()\n\n    async with (  # (5)!\n        Actor1(input_channel.new_receiver(), middle_channel.new_sender(), \"actor1\"),\n        Actor2(middle_channel.new_receiver(), output_channel.new_sender(), \"actor2\"),\n    ):\n        await input_sender.send(\"Hello\")  # (6)!\n        msg = await output_receiver.receive()  # (7)!\n        print(msg)  # (10)!\n    # (11)!\n\nif __name__ == \"__main__\":  # (3)!\n    asyncio.run(main())\n</code></pre> <ol> <li> <p>We define 2 actors: <code>Actor1</code> and <code>Actor2</code> that will just forward a message    from an input channel to an output channel, adding some text.</p> </li> <li> <p>We define an async <code>main()</code> function within the main logic of our asyncio program.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We create a bunch of broadcast channels to connect our actors.</p> <ul> <li><code>input_channel</code> is the input channel for <code>Actor1</code>.</li> <li><code>middle_channel</code> is the channel that connects <code>Actor1</code> and <code>Actor2</code>.</li> <li><code>output_channel</code> is the output channel for <code>Actor2</code>.</li> </ul> </li> <li> <p>We create two actors and use them as async context managers, <code>Actor1</code> and     <code>Actor2</code>, and connect them by creating new     senders and     receivers from the channels.</p> <p>Note</p> <p>We don't use the <code>run()</code> function here because we want to stop the actors when we are done with them, but the actors will run forever (as long as the channel is not closed). So the async context manager is a better fit for this example.</p> </li> <li> <p>We schedule the sending of the message    <code>Hello</code> to <code>Actor1</code> via <code>input_channel</code>.</p> </li> <li> <p>We receive (await) the response from    <code>Actor2</code> via <code>output_channel</code>. Between this and the previous steps the    <code>async</code> calls in the actors will be executed.</p> </li> <li> <p><code>Actor1</code> sends the re-formatted message (<code>Actor1 forwarding: Hello</code>) to    <code>Actor2</code> via the <code>middle_channel</code>.</p> </li> <li> <p><code>Actor2</code> sends the re-formatted message (<code>Actor2 forwarding: \"Actor1    forwarding: 'Hello'\"</code>) to the <code>output_channel</code>.</p> </li> <li> <p>Finally, we print the received message, which will still be <code>Actor2     forwarding: \"Actor1 forwarding: 'Hello'\"</code>.</p> </li> <li> <p>The actors are stopped and cleaned up automatically when the <code>async with</code>     block ends.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Actor2 forwarding: \"Actor1 forwarding: 'Hello'\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor--receiving-from-multiple-channels","title":"Receiving from multiple channels","text":"<p>This example shows how to create an actor that receives messages from multiple broadcast channels using <code>select()</code>.</p> select.py<pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.channels.util import select, selected_from\nfrom frequenz.sdk.actor import Actor, run\n\n\nclass EchoActor(Actor):  # (1)!\n    def __init__(\n        self,\n        receiver_1: Receiver[bool],\n        receiver_2: Receiver[bool],\n        output: Sender[bool],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver_1 = receiver_1\n        self._receiver_2 = receiver_2\n        self._output = output\n\n    async def _run(self) -&gt; None:  # (2)!\n        async for selected in select(self._receiver_1, self._receiver_2):  # (10)!\n            if selected_from(selected, self._receiver_1):  # (11)!\n                print(f\"Received from receiver_1: {selected.value}\")\n                await self._output.send(selected.value)\n                if not selected.value:  # (12)!\n                    break\n            elif selected_from(selected, self._receiver_2):  # (13)!\n                print(f\"Received from receiver_2: {selected.value}\")\n                await self._output.send(selected.value)\n                if not selected.value:  # (14)!\n                    break\n            else:\n                assert False, \"Unknown selected channel\"\n        print(\"EchoActor finished\")\n    # (15)!\n\n\n# (3)!\ninput_channel_1 = Broadcast[bool](\"input_channel_1\")\ninput_channel_2 = Broadcast[bool](\"input_channel_2\")\necho_channel = Broadcast[bool](\"echo_channel\")\n\necho_actor = EchoActor(  # (4)!\n    input_channel_1.new_receiver(),\n    input_channel_2.new_receiver(),\n    echo_channel.new_sender(),\n    \"echo-actor\",\n)\n\necho_receiver = echo_channel.new_receiver()  # (5)!\n\nasync def main() -&gt; None:  # (6)!\n    # (8)!\n    await input_channel_1.new_sender().send(True)\n    await input_channel_2.new_sender().send(False)\n\n    await run(echo_actor)  # (9)!\n\n    await echo_channel.close()  # (16)!\n\n    async for message in echo_receiver:  # (17)!\n        print(f\"Received {message=}\")\n\n\nif __name__ == \"__main__\":  # (7)!\n    asyncio.run(main())\n</code></pre> <ol> <li> <p>We define an <code>EchoActor</code> that receives messages from two channels and sends     them to another channel.</p> </li> <li> <p>We implement the <code>_run()</code> method that will receive messages from the two     channels using <code>select()</code> and send them to the     output channel. The <code>run()</code> method will stop if a <code>False</code> message is received.</p> </li> <li> <p>We create the channels that will be used with the actor.</p> </li> <li> <p>We create the actor and connect it to the channels by creating new receivers and     senders from the channels.</p> </li> <li> <p>We create a receiver for the <code>echo_channel</code> to eventually receive the messages sent     by the actor.</p> </li> <li> <p>We define the <code>main()</code> function that will run the actor.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We send a message to each of the input channels. These messages will be queued in     the channels until they are consumed by the actor.</p> </li> <li> <p>We start the actor and wait for it to finish using the     <code>run()</code> function.</p> </li> <li> <p>The <code>select()</code> function will get the first message     available from the two channels. The order in which they will be handled is     unknown, but in this example we assume that the first message will be from     <code>input_channel_1</code> (<code>True</code>) and the second from <code>input_channel_1</code> (<code>False</code>).</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>True</code> for the <code>input_channel_1</code> receiver. <code>selected.value</code> holds the received     message, so <code>\"Received from receiver_1: True\"</code> will be printed and <code>True</code> will be     sent to the <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>True</code>, the loop will continue, going back to the     <code>select()</code> function.</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>False</code> for the <code>input_channel_1</code> receiver and <code>True</code> for the <code>input_channel_2</code>     receiver. The message stored in <code>selected.value</code> will now be <code>False</code>, so     <code>\"Received from receiver_2: False\"</code> will be printed and <code>False</code> will be sent to the     <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>False</code>, the loop will break.</p> </li> <li> <p>The <code>_run()</code> method will finish normally and the actor will be stopped, so     the <code>run()</code> function will return.</p> </li> <li> <p>We close the <code>echo_channel</code> to make sure the <code>echo_receiver</code> will stop receiving     messages after all the queued messages are consumed (otherwise the step 17 will     never end!).</p> </li> <li> <p>We receive the messages sent by the actor to the <code>echo_channel</code> one by one and print     them, it should print first <code>Received message=True</code> and then <code>Received     message=False</code>.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Received from receiver_1: True\nReceived from receiver_2: False\nReceived message=True\nReceived message=False\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor","title":"frequenz.sdk.actor.Actor","text":"<p>               Bases: <code>BackgroundService</code>, <code>ABC</code></p> <p>A primitive unit of computation that runs autonomously.</p> <p>To implement an actor, subclasses must implement the <code>_run()</code> method, which should run the actor's logic. The <code>_run()</code> method is called by the base class when the actor is started, and is expected to run until the actor is stopped.</p> <p>Info</p> <p>Please read the <code>actor</code> module documentation for more comprehensive guide on how to use and implement actors properly.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>class Actor(BackgroundService, abc.ABC):\n    \"\"\"A primitive unit of computation that runs autonomously.\n\n    To implement an actor, subclasses must implement the\n    [`_run()`][frequenz.sdk.actor--the-_run-method] method, which should run the actor's\n    logic. The [`_run()`][frequenz.sdk.actor--the-_run-method] method is called by the\n    base class when the actor is started, and is expected to run until the actor is\n    stopped.\n\n    !!! info\n\n        Please read the [`actor` module documentation][frequenz.sdk.actor] for more\n        comprehensive guide on how to use and implement actors properly.\n    \"\"\"\n\n    RESTART_DELAY: timedelta = timedelta(seconds=2)\n    \"\"\"The delay to wait between restarts of this actor.\"\"\"\n\n    _restart_limit: int | None = None\n    \"\"\"The number of times actors can be restarted when they are stopped by unhandled exceptions.\n\n    If this is bigger than 0 or `None`, the actor will be restarted when there is an\n    unhanded exception in the `_run()` method.\n\n    If `None`, the actor will be restarted an unlimited number of times.\n\n    !!! note\n\n        This is mostly used for testing purposes and shouldn't be set in production.\n    \"\"\"\n\n    def start(self) -&gt; None:\n        \"\"\"Start this actor.\n\n        If this actor is already running, this method does nothing.\n        \"\"\"\n        if self.is_running:\n            return\n        self._tasks.clear()\n        self._tasks.add(asyncio.create_task(self._run_loop()))\n\n    @abc.abstractmethod\n    async def _run(self) -&gt; None:\n        \"\"\"Run this actor's logic.\"\"\"\n\n    async def _delay_if_restart(self, iteration: int) -&gt; None:\n        \"\"\"Delay the restart of this actor's n'th iteration.\n\n        Args:\n            iteration: The current iteration of the restart.\n        \"\"\"\n        # NB: I think it makes sense (in the future) to think about deminishing returns\n        # the longer the actor has been running.\n        # Not just for the restart-delay but actually for the n_restarts counter as well.\n        if iteration &gt; 0:\n            delay = self.RESTART_DELAY.total_seconds()\n            _logger.info(\"Actor %s: Waiting %s seconds...\", self, delay)\n            await asyncio.sleep(delay)\n\n    async def _run_loop(self) -&gt; None:\n        \"\"\"Run the actor's task continuously, managing restarts, cancellation, and termination.\n\n        This method handles the execution of the actor's task, including\n        restarts for unhandled exceptions, cancellation, or normal termination.\n\n        Raises:\n            asyncio.CancelledError: If the actor's `_run()` method is cancelled.\n            Exception: If the actor's `_run()` method raises any other exception.\n            BaseException: If the actor's `_run()` method raises any base exception.\n        \"\"\"\n        _logger.info(\"Actor %s: Started.\", self)\n        n_restarts = 0\n        while True:\n            try:\n                await self._delay_if_restart(n_restarts)\n                await self._run()\n                _logger.info(\"Actor %s: _run() returned without error.\", self)\n            except asyncio.CancelledError:\n                _logger.info(\"Actor %s: Cancelled.\", self)\n                raise\n            except Exception:  # pylint: disable=broad-except\n                _logger.exception(\"Actor %s: Raised an unhandled exception.\", self)\n                limit_str = \"\u221e\" if self._restart_limit is None else self._restart_limit\n                limit_str = f\"({n_restarts}/{limit_str})\"\n                if self._restart_limit is None or n_restarts &lt; self._restart_limit:\n                    n_restarts += 1\n                    _logger.info(\"Actor %s: Restarting %s...\", self._name, limit_str)\n                    continue\n                _logger.info(\n                    \"Actor %s: Maximum restarts attempted %s, bailing out...\",\n                    self,\n                    limit_str,\n                )\n                raise\n            except BaseException:  # pylint: disable=broad-except\n                _logger.exception(\"Actor %s: Raised a BaseException.\", self)\n                raise\n            break\n\n        _logger.info(\"Actor %s: Stopped.\", self)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str | None = None) -&gt; None\n</code></pre> <p>Initialize this BackgroundService.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of this background service. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __init__(self, *, name: str | None = None) -&gt; None:\n    \"\"\"Initialize this BackgroundService.\n\n    Args:\n        name: The name of this background service. If `None`, `str(id(self))` will\n            be used. This is used mostly for debugging purposes.\n    \"\"\"\n    self._name: str = str(id(self)) if name is None else name\n    self._tasks: set[asyncio.Task[Any]] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService","title":"frequenz.sdk.actor.BackgroundService","text":"<p>               Bases: <code>ABC</code></p> <p>A background service that can be started and stopped.</p> <p>A background service is a service that runs in the background spawning one or more tasks. The service can be started and stopped and can work as an async context manager to provide deterministic cleanup.</p> <p>To implement a background service, subclasses must implement the <code>start()</code> method, which should start the background tasks needed by the service, and add them to the <code>_tasks</code> protected attribute.</p> <p>If you need to collect results or handle exceptions of the tasks when stopping the service, then you need to also override the <code>stop()</code> method, as the base implementation does not collect any results and re-raises all exceptions.</p> <p>Warning</p> <p>As background services manage <code>asyncio.Task</code> objects, a reference to them must be held for as long as the background service is expected to be running, otherwise its tasks will be cancelled and the service will stop. For more information, please refer to the Python <code>asyncio</code> documentation.</p> Example <pre><code>import datetime\nimport asyncio\n\nclass Clock(BackgroundService):\n    def __init__(self, resolution_s: float, *, name: str | None = None) -&gt; None:\n        super().__init__(name=name)\n        self._resolution_s = resolution_s\n\n    def start(self) -&gt; None:\n        self._tasks.add(asyncio.create_task(self._tick()))\n\n    async def _tick(self) -&gt; None:\n        while True:\n            await asyncio.sleep(self._resolution_s)\n            print(datetime.datetime.now())\n\nasync def main() -&gt; None:\n    # As an async context manager\n    async with Clock(resolution_s=1):\n        await asyncio.sleep(5)\n\n    # Manual start/stop (only use if necessary, as cleanup is more complicated)\n    clock = Clock(resolution_s=1)\n    clock.start()\n    await asyncio.sleep(5)\n    await clock.stop()\n\nasyncio.run(main())\n</code></pre> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>class BackgroundService(abc.ABC):\n    \"\"\"A background service that can be started and stopped.\n\n    A background service is a service that runs in the background spawning one or more\n    tasks. The service can be [started][frequenz.sdk.actor.BackgroundService.start]\n    and [stopped][frequenz.sdk.actor.BackgroundService.stop] and can work as an\n    async context manager to provide deterministic cleanup.\n\n    To implement a background service, subclasses must implement the\n    [`start()`][frequenz.sdk.actor.BackgroundService.start] method, which should\n    start the background tasks needed by the service, and add them to the `_tasks`\n    protected attribute.\n\n    If you need to collect results or handle exceptions of the tasks when stopping the\n    service, then you need to also override the\n    [`stop()`][frequenz.sdk.actor.BackgroundService.stop] method, as the base\n    implementation does not collect any results and re-raises all exceptions.\n\n    !!! warning\n\n        As background services manage [`asyncio.Task`][] objects, a reference to them\n        must be held for as long as the background service is expected to be running,\n        otherwise its tasks will be cancelled and the service will stop. For more\n        information, please refer to the [Python `asyncio`\n        documentation](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task).\n\n    Example:\n        ```python\n        import datetime\n        import asyncio\n\n        class Clock(BackgroundService):\n            def __init__(self, resolution_s: float, *, name: str | None = None) -&gt; None:\n                super().__init__(name=name)\n                self._resolution_s = resolution_s\n\n            def start(self) -&gt; None:\n                self._tasks.add(asyncio.create_task(self._tick()))\n\n            async def _tick(self) -&gt; None:\n                while True:\n                    await asyncio.sleep(self._resolution_s)\n                    print(datetime.datetime.now())\n\n        async def main() -&gt; None:\n            # As an async context manager\n            async with Clock(resolution_s=1):\n                await asyncio.sleep(5)\n\n            # Manual start/stop (only use if necessary, as cleanup is more complicated)\n            clock = Clock(resolution_s=1)\n            clock.start()\n            await asyncio.sleep(5)\n            await clock.stop()\n\n        asyncio.run(main())\n        ```\n    \"\"\"\n\n    def __init__(self, *, name: str | None = None) -&gt; None:\n        \"\"\"Initialize this BackgroundService.\n\n        Args:\n            name: The name of this background service. If `None`, `str(id(self))` will\n                be used. This is used mostly for debugging purposes.\n        \"\"\"\n        self._name: str = str(id(self)) if name is None else name\n        self._tasks: set[asyncio.Task[Any]] = set()\n\n    @abc.abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"Start this background service.\"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of this background service.\n\n        Returns:\n            The name of this background service.\n        \"\"\"\n        return self._name\n\n    @property\n    def tasks(self) -&gt; collections.abc.Set[asyncio.Task[Any]]:\n        \"\"\"Return the set of running tasks spawned by this background service.\n\n        Users typically should not modify the tasks in the returned set and only use\n        them for informational purposes.\n\n        !!! danger\n\n            Changing the returned tasks may lead to unexpected behavior, don't do it\n            unless the class explicitly documents it is safe to do so.\n\n        Returns:\n            The set of running tasks spawned by this background service.\n        \"\"\"\n        return self._tasks\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Return whether this background service is running.\n\n        A service is considered running when at least one task is running.\n\n        Returns:\n            Whether this background service is running.\n        \"\"\"\n        return any(not task.done() for task in self._tasks)\n\n    def cancel(self, msg: str | None = None) -&gt; None:\n        \"\"\"Cancel all running tasks spawned by this background service.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\n        for task in self._tasks:\n            task.cancel(msg)\n\n    async def stop(self, msg: str | None = None) -&gt; None:\n        \"\"\"Stop this background service.\n\n        This method cancels all running tasks spawned by this service and waits for them\n        to finish.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception.\n        \"\"\"\n        if not self._tasks:\n            return\n        self.cancel(msg)\n        try:\n            await self.wait()\n        except BaseExceptionGroup as exc_group:\n            # We want to ignore CancelledError here as we explicitly cancelled all the\n            # tasks.\n            _, rest = exc_group.split(asyncio.CancelledError)\n            if rest is not None:\n                # We are filtering out from an exception group, we really don't want to\n                # add the exceptions we just filtered by adding a from clause here.\n                raise rest  # pylint: disable=raise-missing-from\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"Enter an async context.\n\n        Start this background service.\n\n        Returns:\n            This background service.\n        \"\"\"\n        self.start()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit an async context.\n\n        Stop this background service.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception raised, if any.\n            exc_tb: The traceback of the exception raised, if any.\n        \"\"\"\n        await self.stop()\n\n    async def wait(self) -&gt; None:\n        \"\"\"Wait this background service to finish.\n\n        Wait until all background service tasks are finished.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception (`CancelError` is not considered an error and not returned in\n                the exception group).\n        \"\"\"\n        # We need to account for tasks that were created between when we started\n        # awaiting and we finished awaiting.\n        while self._tasks:\n            done, pending = await asyncio.wait(self._tasks)\n            assert not pending\n\n            # We remove the done tasks, but there might be new ones created after we\n            # started waiting.\n            self._tasks = self._tasks - done\n\n            exceptions: list[BaseException] = []\n            for task in done:\n                try:\n                    # This will raise a CancelledError if the task was cancelled or any\n                    # other exception if the task raised one.\n                    _ = task.result()\n                except BaseException as error:  # pylint: disable=broad-except\n                    exceptions.append(error)\n            if exceptions:\n                raise BaseExceptionGroup(\n                    f\"Error while stopping background service {self}\", exceptions\n                )\n\n    def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n        \"\"\"Await this background service.\n\n        An awaited background service will wait for all its tasks to finish.\n\n        Returns:\n            An implementation-specific generator for the awaitable.\n        \"\"\"\n        return self.wait().__await__()\n\n    def __del__(self) -&gt; None:\n        \"\"\"Destroy this instance.\n\n        Cancel all running tasks spawned by this background service.\n        \"\"\"\n        self.cancel(\"{self!r} was deleted\")\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\n\n        Returns:\n            A string representation of this instance.\n        \"\"\"\n        return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\n\n        Returns:\n            A string representation of this instance.\n        \"\"\"\n        return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str | None = None) -&gt; None\n</code></pre> <p>Initialize this BackgroundService.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of this background service. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __init__(self, *, name: str | None = None) -&gt; None:\n    \"\"\"Initialize this BackgroundService.\n\n    Args:\n        name: The name of this background service. If `None`, `str(id(self))` will\n            be used. This is used mostly for debugging purposes.\n    \"\"\"\n    self._name: str = str(id(self)) if name is None else name\n    self._tasks: set[asyncio.Task[Any]] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.start","title":"start  <code>abstractmethod</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>@abc.abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"Start this background service.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry","title":"frequenz.sdk.actor.ChannelRegistry","text":"<p>Dynamically creates, own and provide access to broadcast channels.</p> <p>It can be used by actors to dynamically establish a communication channel between each other.</p> <p>The registry is responsible for creating channels when they are first requested via the <code>get_or_create()</code> method.</p> <p>The registry also stores type information to make sure that the same channel is not used for different message types.</p> <p>Since the registry owns the channels, it is also responsible for closing them when they are no longer needed. There is no way to remove a channel without closing it.</p> Note <p>This registry stores <code>Broadcast</code> channels.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>class ChannelRegistry:\n    \"\"\"Dynamically creates, own and provide access to broadcast channels.\n\n    It can be used by actors to dynamically establish a communication channel\n    between each other.\n\n    The registry is responsible for creating channels when they are first requested via\n    the [`get_or_create()`][frequenz.sdk.actor.ChannelRegistry.get_or_create] method.\n\n    The registry also stores type information to make sure that the same channel is not\n    used for different message types.\n\n    Since the registry owns the channels, it is also responsible for closing them when\n    they are no longer needed. There is no way to remove a channel without closing it.\n\n    Note:\n        This registry stores [`Broadcast`][frequenz.channels.Broadcast] channels.\n    \"\"\"\n\n    def __init__(self, *, name: str) -&gt; None:\n        \"\"\"Initialize this registry.\n\n        Args:\n            name: A name to identify the registry in the logs. This name is also used as\n                a prefix for the channel names.\n        \"\"\"\n        self._name = name\n        self._channels: dict[str, _Entry] = {}\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of this registry.\"\"\"\n        return self._name\n\n    def message_type(self, key: str) -&gt; type:\n        \"\"\"Get the message type of the channel for the given key.\n\n        Args:\n            key: The key to identify the channel.\n\n        Returns:\n            The message type of the channel.\n\n        Raises:\n            KeyError: If the channel does not exist.\n        \"\"\"\n        entry = self._channels.get(key)\n        if entry is None:\n            raise KeyError(f\"No channel for key {key!r} exists.\")\n        return entry.message_type\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"Check whether the channel for the given `key` exists.\"\"\"\n        return key in self._channels\n\n    def get_or_create(self, message_type: type[_T], key: str) -&gt; Broadcast[_T]:\n        \"\"\"Get or create a channel for the given key.\n\n        If a channel for the given key already exists, the message type of the existing\n        channel is checked against the requested message type. If they do not match,\n        a `ValueError` is raised.\n\n        Note:\n            The types have to match exactly, it doesn't do a subtype check due to\n            technical limitations. In the future subtype checks might be supported.\n\n        Args:\n            message_type: The type of the message that is sent through the channel.\n            key: The key to identify the channel.\n\n        Returns:\n            The channel for the given key.\n\n        Raises:\n            ValueError: If the channel exists and the message type does not match.\n        \"\"\"\n        if key not in self._channels:\n            if _logger.isEnabledFor(logging.DEBUG):\n                _logger.debug(\n                    \"Creating a new channel for key %r with type %s at:\\n%s\",\n                    key,\n                    message_type,\n                    \"\".join(traceback.format_stack(limit=10)[:9]),\n                )\n            self._channels[key] = _Entry(\n                message_type, Broadcast(name=f\"{self._name}-{key}\")\n            )\n\n        entry = self._channels[key]\n        if entry.message_type is not message_type:\n            exception = ValueError(\n                f\"Type mismatch, a channel for key {key!r} exists and the requested \"\n                f\"message type {message_type} is not the same as the existing \"\n                f\"message type {entry.message_type}.\"\n            )\n            if _logger.isEnabledFor(logging.DEBUG):\n                _logger.debug(\n                    \"%s at:\\n%s\",\n                    str(exception),\n                    # We skip the last frame because it's this method, and limit the\n                    # stack to 9 frames to avoid adding too much noise.\n                    \"\".join(traceback.format_stack(limit=10)[:9]),\n                )\n            raise exception\n\n        return cast(Broadcast[_T], entry.channel)\n\n    async def close_and_remove(self, key: str) -&gt; None:\n        \"\"\"Remove the channel for the given key.\n\n        Args:\n            key: The key to identify the channel.\n\n        Raises:\n            KeyError: If the channel does not exist.\n        \"\"\"\n        entry = self._channels.pop(key, None)\n        if entry is None:\n            raise KeyError(f\"No channel for key {key!r} exists.\")\n        await entry.channel.close()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this registry.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.__contains__","title":"__contains__","text":"<pre><code>__contains__(key: str) -&gt; bool\n</code></pre> <p>Check whether the channel for the given <code>key</code> exists.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    \"\"\"Check whether the channel for the given `key` exists.\"\"\"\n    return key in self._channels\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str) -&gt; None\n</code></pre> <p>Initialize this registry.</p> PARAMETER DESCRIPTION <code>name</code> <p>A name to identify the registry in the logs. This name is also used as a prefix for the channel names.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def __init__(self, *, name: str) -&gt; None:\n    \"\"\"Initialize this registry.\n\n    Args:\n        name: A name to identify the registry in the logs. This name is also used as\n            a prefix for the channel names.\n    \"\"\"\n    self._name = name\n    self._channels: dict[str, _Entry] = {}\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.close_and_remove","title":"close_and_remove  <code>async</code>","text":"<pre><code>close_and_remove(key: str) -&gt; None\n</code></pre> <p>Remove the channel for the given key.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If the channel does not exist.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>async def close_and_remove(self, key: str) -&gt; None:\n    \"\"\"Remove the channel for the given key.\n\n    Args:\n        key: The key to identify the channel.\n\n    Raises:\n        KeyError: If the channel does not exist.\n    \"\"\"\n    entry = self._channels.pop(key, None)\n    if entry is None:\n        raise KeyError(f\"No channel for key {key!r} exists.\")\n    await entry.channel.close()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.get_or_create","title":"get_or_create","text":"<pre><code>get_or_create(\n    message_type: type[_T], key: str\n) -&gt; Broadcast[_T]\n</code></pre> <p>Get or create a channel for the given key.</p> <p>If a channel for the given key already exists, the message type of the existing channel is checked against the requested message type. If they do not match, a <code>ValueError</code> is raised.</p> Note <p>The types have to match exactly, it doesn't do a subtype check due to technical limitations. In the future subtype checks might be supported.</p> PARAMETER DESCRIPTION <code>message_type</code> <p>The type of the message that is sent through the channel.</p> <p> TYPE: <code>type[_T]</code> </p> <code>key</code> <p>The key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Broadcast[_T]</code> <p>The channel for the given key.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the channel exists and the message type does not match.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def get_or_create(self, message_type: type[_T], key: str) -&gt; Broadcast[_T]:\n    \"\"\"Get or create a channel for the given key.\n\n    If a channel for the given key already exists, the message type of the existing\n    channel is checked against the requested message type. If they do not match,\n    a `ValueError` is raised.\n\n    Note:\n        The types have to match exactly, it doesn't do a subtype check due to\n        technical limitations. In the future subtype checks might be supported.\n\n    Args:\n        message_type: The type of the message that is sent through the channel.\n        key: The key to identify the channel.\n\n    Returns:\n        The channel for the given key.\n\n    Raises:\n        ValueError: If the channel exists and the message type does not match.\n    \"\"\"\n    if key not in self._channels:\n        if _logger.isEnabledFor(logging.DEBUG):\n            _logger.debug(\n                \"Creating a new channel for key %r with type %s at:\\n%s\",\n                key,\n                message_type,\n                \"\".join(traceback.format_stack(limit=10)[:9]),\n            )\n        self._channels[key] = _Entry(\n            message_type, Broadcast(name=f\"{self._name}-{key}\")\n        )\n\n    entry = self._channels[key]\n    if entry.message_type is not message_type:\n        exception = ValueError(\n            f\"Type mismatch, a channel for key {key!r} exists and the requested \"\n            f\"message type {message_type} is not the same as the existing \"\n            f\"message type {entry.message_type}.\"\n        )\n        if _logger.isEnabledFor(logging.DEBUG):\n            _logger.debug(\n                \"%s at:\\n%s\",\n                str(exception),\n                # We skip the last frame because it's this method, and limit the\n                # stack to 9 frames to avoid adding too much noise.\n                \"\".join(traceback.format_stack(limit=10)[:9]),\n            )\n        raise exception\n\n    return cast(Broadcast[_T], entry.channel)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.message_type","title":"message_type","text":"<pre><code>message_type(key: str) -&gt; type\n</code></pre> <p>Get the message type of the channel for the given key.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>type</code> <p>The message type of the channel.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the channel does not exist.</p> Source code in <code>frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def message_type(self, key: str) -&gt; type:\n    \"\"\"Get the message type of the channel for the given key.\n\n    Args:\n        key: The key to identify the channel.\n\n    Returns:\n        The message type of the channel.\n\n    Raises:\n        KeyError: If the channel does not exist.\n    \"\"\"\n    entry = self._channels.get(key)\n    if entry is None:\n        raise KeyError(f\"No channel for key {key!r} exists.\")\n    return entry.message_type\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest","title":"frequenz.sdk.actor.ComponentMetricRequest  <code>dataclass</code>","text":"<p>A request object to start streaming a metric for a component.</p> Source code in <code>frequenz/sdk/actor/_data_sourcing/_component_metric_request.py</code> <pre><code>@dataclass\nclass ComponentMetricRequest:\n    \"\"\"A request object to start streaming a metric for a component.\"\"\"\n\n    namespace: str\n    \"\"\"The namespace that this request belongs to.\n\n    Metric requests with a shared namespace enable the reuse of channels within\n    that namespace.\n\n    If for example, an actor making a multiple requests, uses the name of the\n    actor as the namespace, then requests from the actor will get reused when\n    possible.\n    \"\"\"\n\n    component_id: int\n    \"\"\"The ID of the requested component.\"\"\"\n\n    metric_id: ComponentMetricId\n    \"\"\"The ID of the requested component's metric.\"\"\"\n\n    start_time: datetime | None\n    \"\"\"The start time from which data is required.\n\n    When None, we will stream only live data.\n    \"\"\"\n\n    def get_channel_name(self) -&gt; str:\n        \"\"\"Return a channel name constructed from Self.\n\n        This channel name can be used by the sending side and receiving sides to\n        identify the right channel from the ChannelRegistry.\n\n        Returns:\n            A string denoting a channel name.\n        \"\"\"\n        return (\n            f\"component_metric_request&lt;namespace={self.namespace},\"\n            f\"component_id={self.component_id},\"\n            f\"metric_id={self.metric_id.name},\"\n            f\"start={self.start_time}&gt;\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: int\n</code></pre> <p>The ID of the requested component.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.metric_id","title":"metric_id  <code>instance-attribute</code>","text":"<pre><code>metric_id: ComponentMetricId\n</code></pre> <p>The ID of the requested component's metric.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.namespace","title":"namespace  <code>instance-attribute</code>","text":"<pre><code>namespace: str\n</code></pre> <p>The namespace that this request belongs to.</p> <p>Metric requests with a shared namespace enable the reuse of channels within that namespace.</p> <p>If for example, an actor making a multiple requests, uses the name of the actor as the namespace, then requests from the actor will get reused when possible.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.start_time","title":"start_time  <code>instance-attribute</code>","text":"<pre><code>start_time: datetime | None\n</code></pre> <p>The start time from which data is required.</p> <p>When None, we will stream only live data.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.get_channel_name","title":"get_channel_name","text":"<pre><code>get_channel_name() -&gt; str\n</code></pre> <p>Return a channel name constructed from Self.</p> <p>This channel name can be used by the sending side and receiving sides to identify the right channel from the ChannelRegistry.</p> RETURNS DESCRIPTION <code>str</code> <p>A string denoting a channel name.</p> Source code in <code>frequenz/sdk/actor/_data_sourcing/_component_metric_request.py</code> <pre><code>def get_channel_name(self) -&gt; str:\n    \"\"\"Return a channel name constructed from Self.\n\n    This channel name can be used by the sending side and receiving sides to\n    identify the right channel from the ChannelRegistry.\n\n    Returns:\n        A string denoting a channel name.\n    \"\"\"\n    return (\n        f\"component_metric_request&lt;namespace={self.namespace},\"\n        f\"component_id={self.component_id},\"\n        f\"metric_id={self.metric_id.name},\"\n        f\"start={self.start_time}&gt;\"\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor","title":"frequenz.sdk.actor.ComponentMetricsResamplingActor","text":"<p>               Bases: <code>Actor</code></p> <p>An actor to resample microgrid component metrics.</p> Source code in <code>frequenz/sdk/actor/_resampling.py</code> <pre><code>class ComponentMetricsResamplingActor(Actor):\n    \"\"\"An actor to resample microgrid component metrics.\"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        *,\n        channel_registry: ChannelRegistry,\n        data_sourcing_request_sender: Sender[ComponentMetricRequest],\n        resampling_request_receiver: Receiver[ComponentMetricRequest],\n        config: ResamplerConfig,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize an instance.\n\n        Args:\n            channel_registry: The channel registry used to get senders and\n                receivers for data sourcing subscriptions.\n            data_sourcing_request_sender: The sender used to send requests to\n                the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor]\n                to subscribe to component metrics.\n            resampling_request_receiver: The receiver to use to receive new\n                resampling subscription requests.\n            config: The configuration for the resampler.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\n        super().__init__(name=name)\n        self._channel_registry: ChannelRegistry = channel_registry\n        self._data_sourcing_request_sender: Sender[ComponentMetricRequest] = (\n            data_sourcing_request_sender\n        )\n        self._resampling_request_receiver: Receiver[ComponentMetricRequest] = (\n            resampling_request_receiver\n        )\n        self._resampler: Resampler = Resampler(config)\n        self._active_req_channels: set[str] = set()\n\n    async def _subscribe(self, request: ComponentMetricRequest) -&gt; None:\n        \"\"\"Request data for a component metric.\n\n        Args:\n            request: The request for component metric data.\n        \"\"\"\n        request_channel_name = request.get_channel_name()\n\n        # If we are already handling this request, there is nothing to do.\n        if request_channel_name in self._active_req_channels:\n            return\n\n        self._active_req_channels.add(request_channel_name)\n\n        data_source_request = dataclasses.replace(\n            request, namespace=request.namespace + \":Source\"\n        )\n        data_source_channel_name = data_source_request.get_channel_name()\n        await self._data_sourcing_request_sender.send(data_source_request)\n        receiver = self._channel_registry.get_or_create(\n            Sample[Quantity], data_source_channel_name\n        ).new_receiver()\n\n        # This is a temporary hack until the Sender implementation uses\n        # exceptions to report errors.\n        sender = self._channel_registry.get_or_create(\n            Sample[Quantity], request_channel_name\n        ).new_sender()\n\n        self._resampler.add_timeseries(request_channel_name, receiver, sender.send)\n\n    async def _process_resampling_requests(self) -&gt; None:\n        \"\"\"Process resampling data requests.\"\"\"\n        async for request in self._resampling_request_receiver:\n            await self._subscribe(request)\n\n    async def _run(self) -&gt; None:\n        \"\"\"Resample known component metrics and process resampling requests.\n\n        If there is a resampling error while resampling some component metric,\n        then that metric will be discarded and not resampled any more. Any\n        other error will be propagated (most likely ending in the actor being\n        restarted).\n\n        This method creates 2 main tasks:\n\n        - One task to process incoming subscription requests to resample new metrics.\n        - One task to run the resampler.\n\n        Raises:\n            RuntimeError: If there is some unexpected error while resampling or\n                handling requests.\n        \"\"\"\n        tasks_to_cancel: set[asyncio.Task[None]] = set()\n        try:\n            subscriptions_task = asyncio.create_task(\n                self._process_resampling_requests()\n            )\n            tasks_to_cancel.add(subscriptions_task)\n\n            while True:\n                resampling_task = asyncio.create_task(self._resampler.resample())\n                tasks_to_cancel.add(resampling_task)\n                done, _ = await asyncio.wait(\n                    [resampling_task, subscriptions_task],\n                    return_when=asyncio.FIRST_COMPLETED,\n                )\n\n                if subscriptions_task in done:\n                    tasks_to_cancel.remove(subscriptions_task)\n                    raise RuntimeError(\n                        \"There was a problem with the subscriptions channel.\"\n                    )\n\n                if resampling_task in done:\n                    tasks_to_cancel.remove(resampling_task)\n                    # The resampler shouldn't end without an exception\n                    error = resampling_task.exception()\n                    assert (\n                        error is not None\n                    ), \"The resample() function shouldn't exit normally.\"\n\n                    # We don't know what to do with something other than\n                    # ResamplingError, so propagate the exception if that is the\n                    # case.\n                    if not isinstance(error, ResamplingError):\n                        raise error\n                    for source, source_error in error.exceptions.items():\n                        _logger.error(\n                            \"Error resampling source %s, removing source...\", source\n                        )\n                        removed = self._resampler.remove_timeseries(source)\n                        if not removed:\n                            _logger.warning(\n                                \"Got an exception from an unknown source: \"\n                                \"source=%r, exception=%r\",\n                                source,\n                                source_error,\n                            )\n                    # The resampling_task will be re-created if we reached this point\n        finally:\n            await asyncio.gather(*[cancel_and_await(t) for t in tasks_to_cancel])\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    channel_registry: ChannelRegistry,\n    data_sourcing_request_sender: Sender[\n        ComponentMetricRequest\n    ],\n    resampling_request_receiver: Receiver[\n        ComponentMetricRequest\n    ],\n    config: ResamplerConfig,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Initialize an instance.</p> PARAMETER DESCRIPTION <code>channel_registry</code> <p>The channel registry used to get senders and receivers for data sourcing subscriptions.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>data_sourcing_request_sender</code> <p>The sender used to send requests to the <code>DataSourcingActor</code> to subscribe to component metrics.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>resampling_request_receiver</code> <p>The receiver to use to receive new resampling subscription requests.</p> <p> TYPE: <code>Receiver[ComponentMetricRequest]</code> </p> <code>config</code> <p>The configuration for the resampler.</p> <p> TYPE: <code>ResamplerConfig</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_resampling.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    *,\n    channel_registry: ChannelRegistry,\n    data_sourcing_request_sender: Sender[ComponentMetricRequest],\n    resampling_request_receiver: Receiver[ComponentMetricRequest],\n    config: ResamplerConfig,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize an instance.\n\n    Args:\n        channel_registry: The channel registry used to get senders and\n            receivers for data sourcing subscriptions.\n        data_sourcing_request_sender: The sender used to send requests to\n            the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor]\n            to subscribe to component metrics.\n        resampling_request_receiver: The receiver to use to receive new\n            resampling subscription requests.\n        config: The configuration for the resampler.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\n    super().__init__(name=name)\n    self._channel_registry: ChannelRegistry = channel_registry\n    self._data_sourcing_request_sender: Sender[ComponentMetricRequest] = (\n        data_sourcing_request_sender\n    )\n    self._resampling_request_receiver: Receiver[ComponentMetricRequest] = (\n        resampling_request_receiver\n    )\n    self._resampler: Resampler = Resampler(config)\n    self._active_req_channels: set[str] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor","title":"frequenz.sdk.actor.ConfigManagingActor","text":"<p>               Bases: <code>Actor</code></p> <p>An actor that monitors a TOML configuration file for updates.</p> <p>When the file is updated, the new configuration is sent, as a <code>dict</code>, to the <code>output</code> sender.</p> <p>When the actor is started, if a configuration file already exists, then it will be read and sent to the <code>output</code> sender before the actor starts monitoring the file for updates. This way users can rely on the actor to do the initial configuration reading too.</p> Source code in <code>frequenz/sdk/actor/_config_managing.py</code> <pre><code>class ConfigManagingActor(Actor):\n    \"\"\"An actor that monitors a TOML configuration file for updates.\n\n    When the file is updated, the new configuration is sent, as a [`dict`][], to the\n    `output` sender.\n\n    When the actor is started, if a configuration file already exists, then it will be\n    read and sent to the `output` sender before the actor starts monitoring the file\n    for updates. This way users can rely on the actor to do the initial configuration\n    reading too.\n    \"\"\"\n\n    def __init__(\n        self,\n        config_path: pathlib.Path | str,\n        output: Sender[dict[str, Any]],\n        event_types: abc.Set[EventType] = frozenset(EventType),\n        *,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize this instance.\n\n        Args:\n            config_path: The path to the TOML file with the configuration.\n            output: The sender to send the configuration to.\n            event_types: The set of event types to monitor.\n            name: The name of the actor. If `None`, `str(id(self))` will\n                be used. This is used mostly for debugging purposes.\n        \"\"\"\n        super().__init__(name=name)\n        self._config_path: pathlib.Path = (\n            config_path\n            if isinstance(config_path, pathlib.Path)\n            else pathlib.Path(config_path)\n        )\n        # FileWatcher can't watch for non-existing files, so we need to watch for the\n        # parent directory instead just in case a configuration file doesn't exist yet\n        # or it is deleted and recreated again.\n        self._file_watcher: FileWatcher = FileWatcher(\n            paths=[self._config_path.parent], event_types=event_types\n        )\n        self._output: Sender[dict[str, Any]] = output\n\n    def _read_config(self) -&gt; dict[str, Any]:\n        \"\"\"Read the contents of the configuration file.\n\n        Returns:\n            A dictionary containing configuration variables.\n\n        Raises:\n            ValueError: If config file cannot be read.\n        \"\"\"\n        try:\n            with self._config_path.open(\"rb\") as toml_file:\n                return tomllib.load(toml_file)\n        except ValueError as err:\n            _logger.error(\"%s: Can't read config file, err: %s\", self, err)\n            raise\n\n    async def send_config(self) -&gt; None:\n        \"\"\"Send the configuration to the output sender.\"\"\"\n        config = self._read_config()\n        await self._output.send(config)\n\n    async def _run(self) -&gt; None:\n        \"\"\"Monitor for and send configuration file updates.\n\n        At startup, the Config Manager sends the current config so that it\n        can be cache in the Broadcast channel and served to receivers even if\n        there hasn't been any change to the config file itself.\n        \"\"\"\n        await self.send_config()\n\n        async for event in self._file_watcher:\n            # Since we are watching the whole parent directory, we need to make sure\n            # we only react to events related to the configuration file.\n            if not event.path.samefile(self._config_path):\n                continue\n\n            match event.type:\n                case EventType.CREATE:\n                    _logger.info(\n                        \"%s: The configuration file %s was created, sending new config...\",\n                        self,\n                        self._config_path,\n                    )\n                    await self.send_config()\n                case EventType.MODIFY:\n                    _logger.info(\n                        \"%s: The configuration file %s was modified, sending update...\",\n                        self,\n                        self._config_path,\n                    )\n                    await self.send_config()\n                case EventType.DELETE:\n                    _logger.info(\n                        \"%s: The configuration file %s was deleted, ignoring...\",\n                        self,\n                        self._config_path,\n                    )\n                case _:\n                    assert_never(event.type)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    config_path: Path | str,\n    output: Sender[dict[str, Any]],\n    event_types: Set[EventType] = frozenset(EventType),\n    *,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Initialize this instance.</p> PARAMETER DESCRIPTION <code>config_path</code> <p>The path to the TOML file with the configuration.</p> <p> TYPE: <code>Path | str</code> </p> <code>output</code> <p>The sender to send the configuration to.</p> <p> TYPE: <code>Sender[dict[str, Any]]</code> </p> <code>event_types</code> <p>The set of event types to monitor.</p> <p> TYPE: <code>Set[EventType]</code> DEFAULT: <code>frozenset(EventType)</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_config_managing.py</code> <pre><code>def __init__(\n    self,\n    config_path: pathlib.Path | str,\n    output: Sender[dict[str, Any]],\n    event_types: abc.Set[EventType] = frozenset(EventType),\n    *,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize this instance.\n\n    Args:\n        config_path: The path to the TOML file with the configuration.\n        output: The sender to send the configuration to.\n        event_types: The set of event types to monitor.\n        name: The name of the actor. If `None`, `str(id(self))` will\n            be used. This is used mostly for debugging purposes.\n    \"\"\"\n    super().__init__(name=name)\n    self._config_path: pathlib.Path = (\n        config_path\n        if isinstance(config_path, pathlib.Path)\n        else pathlib.Path(config_path)\n    )\n    # FileWatcher can't watch for non-existing files, so we need to watch for the\n    # parent directory instead just in case a configuration file doesn't exist yet\n    # or it is deleted and recreated again.\n    self._file_watcher: FileWatcher = FileWatcher(\n        paths=[self._config_path.parent], event_types=event_types\n    )\n    self._output: Sender[dict[str, Any]] = output\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.send_config","title":"send_config  <code>async</code>","text":"<pre><code>send_config() -&gt; None\n</code></pre> <p>Send the configuration to the output sender.</p> Source code in <code>frequenz/sdk/actor/_config_managing.py</code> <pre><code>async def send_config(self) -&gt; None:\n    \"\"\"Send the configuration to the output sender.\"\"\"\n    config = self._read_config()\n    await self._output.send(config)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor","title":"frequenz.sdk.actor.DataSourcingActor","text":"<p>               Bases: <code>Actor</code></p> <p>An actor that provides data streams of metrics as time series.</p> Source code in <code>frequenz/sdk/actor/_data_sourcing/data_sourcing.py</code> <pre><code>class DataSourcingActor(Actor):\n    \"\"\"An actor that provides data streams of metrics as time series.\"\"\"\n\n    def __init__(\n        self,\n        request_receiver: Receiver[ComponentMetricRequest],\n        registry: ChannelRegistry,\n        *,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Create a `DataSourcingActor` instance.\n\n        Args:\n            request_receiver: A channel receiver to accept metric requests from.\n            registry: A channel registry.  To be replaced by a singleton\n                instance.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\n        super().__init__(name=name)\n        self._request_receiver = request_receiver\n        self._microgrid_api_source = MicrogridApiSource(registry)\n\n    async def _run(self) -&gt; None:\n        \"\"\"Run the actor.\"\"\"\n        async for request in self._request_receiver:\n            await self._microgrid_api_source.add_metric(request)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    request_receiver: Receiver[ComponentMetricRequest],\n    registry: ChannelRegistry,\n    *,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Create a <code>DataSourcingActor</code> instance.</p> PARAMETER DESCRIPTION <code>request_receiver</code> <p>A channel receiver to accept metric requests from.</p> <p> TYPE: <code>Receiver[ComponentMetricRequest]</code> </p> <code>registry</code> <p>A channel registry.  To be replaced by a singleton instance.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_data_sourcing/data_sourcing.py</code> <pre><code>def __init__(\n    self,\n    request_receiver: Receiver[ComponentMetricRequest],\n    registry: ChannelRegistry,\n    *,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Create a `DataSourcingActor` instance.\n\n    Args:\n        request_receiver: A channel receiver to accept metric requests from.\n        registry: A channel registry.  To be replaced by a singleton\n            instance.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\n    super().__init__(name=name)\n    self._request_receiver = request_receiver\n    self._microgrid_api_source = MicrogridApiSource(registry)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig","title":"frequenz.sdk.actor.ResamplerConfig  <code>dataclass</code>","text":"<p>Resampler configuration.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>@dataclass(frozen=True)\nclass ResamplerConfig:\n    \"\"\"Resampler configuration.\"\"\"\n\n    resampling_period: timedelta\n    \"\"\"The resampling period.\n\n    This is the time it passes between resampled data should be calculated.\n\n    It must be a positive time span.\n    \"\"\"\n\n    max_data_age_in_periods: float = 3.0\n    \"\"\"The maximum age a sample can have to be considered *relevant* for resampling.\n\n    Expressed in number of periods, where period is the `resampling_period`\n    if we are downsampling (resampling period bigger than the input period) or\n    the input sampling period if we are upsampling (input period bigger than\n    the resampling period).\n\n    It must be bigger than 1.0.\n\n    Example:\n        If `resampling_period` is 3 seconds, the input sampling period is\n        1 and `max_data_age_in_periods` is 2, then data older than 3*2\n        = 6 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n\n        If `resampling_period` is 3 seconds, the input sampling period is\n        5 and `max_data_age_in_periods` is 2, then data older than 5*2\n        = 10 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n    \"\"\"\n\n    resampling_function: ResamplingFunction = average\n    \"\"\"The resampling function.\n\n    This function will be applied to the sequence of relevant samples at\n    a given time. The result of the function is what is sent as the resampled\n    value.\n    \"\"\"\n\n    initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n    \"\"\"The initial length of the resampling buffer.\n\n    The buffer could grow or shrink depending on the source properties,\n    like sampling rate, to make sure all the requested past sampling periods\n    can be stored.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n    \"\"\"The minimum length of the resampling buffer that will emit a warning.\n\n    If a buffer grows bigger than this value, it will emit a warning in the\n    logs, so buffers don't grow too big inadvertently.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n    \"\"\"The maximum length of the resampling buffer.\n\n    Buffers won't be allowed to grow beyond this point even if it would be\n    needed to keep all the requested past sampling periods. An error will be\n    emitted in the logs if the buffer length needs to be truncated to this\n    value.\n\n    It must be at bigger than `warn_buffer_len`.\n    \"\"\"\n\n    align_to: datetime | None = UNIX_EPOCH\n    \"\"\"The time to align the resampling period to.\n\n    The resampling period will be aligned to this time, so the first resampled\n    sample will be at the first multiple of `resampling_period` starting from\n    `align_to`. It must be an aware datetime and can be in the future too.\n\n    If `align_to` is `None`, the resampling period will be aligned to the\n    time the resampler is created.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Check that config values are valid.\n\n        Raises:\n            ValueError: If any value is out of range.\n        \"\"\"\n        if self.resampling_period.total_seconds() &lt; 0.0:\n            raise ValueError(\n                f\"resampling_period ({self.resampling_period}) must be positive\"\n            )\n        if self.max_data_age_in_periods &lt; 1.0:\n            raise ValueError(\n                f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n            )\n        if self.warn_buffer_len &lt; 1:\n            raise ValueError(\n                f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n            )\n        if self.max_buffer_len &lt;= self.warn_buffer_len:\n            raise ValueError(\n                f\"max_buffer_len ({self.max_buffer_len}) should \"\n                f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n            )\n\n        if self.initial_buffer_len &lt; 1:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n            )\n        if self.initial_buffer_len &gt; self.max_buffer_len:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n                f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n                \"initial_buffer_len or a bigger max_buffer_len\"\n            )\n        if self.initial_buffer_len &gt; self.warn_buffer_len:\n            _logger.warning(\n                \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n                self.initial_buffer_len,\n                self.warn_buffer_len,\n            )\n        if self.align_to is not None and self.align_to.tzinfo is None:\n            raise ValueError(\n                f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.align_to","title":"align_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>align_to: datetime | None = UNIX_EPOCH\n</code></pre> <p>The time to align the resampling period to.</p> <p>The resampling period will be aligned to this time, so the first resampled sample will be at the first multiple of <code>resampling_period</code> starting from <code>align_to</code>. It must be an aware datetime and can be in the future too.</p> <p>If <code>align_to</code> is <code>None</code>, the resampling period will be aligned to the time the resampler is created.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.initial_buffer_len","title":"initial_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n</code></pre> <p>The initial length of the resampling buffer.</p> <p>The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.max_buffer_len","title":"max_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n</code></pre> <p>The maximum length of the resampling buffer.</p> <p>Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value.</p> <p>It must be at bigger than <code>warn_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.max_data_age_in_periods","title":"max_data_age_in_periods  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_data_age_in_periods: float = 3.0\n</code></pre> <p>The maximum age a sample can have to be considered relevant for resampling.</p> <p>Expressed in number of periods, where period is the <code>resampling_period</code> if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period).</p> <p>It must be bigger than 1.0.</p> Example <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 1 and <code>max_data_age_in_periods</code> is 2, then data older than 3*2 = 6 seconds will be discarded when creating a new sample and never passed to the resampling function.</p> <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 5 and <code>max_data_age_in_periods</code> is 2, then data older than 5*2 = 10 seconds will be discarded when creating a new sample and never passed to the resampling function.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.resampling_function","title":"resampling_function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resampling_function: ResamplingFunction = average\n</code></pre> <p>The resampling function.</p> <p>This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.resampling_period","title":"resampling_period  <code>instance-attribute</code>","text":"<pre><code>resampling_period: timedelta\n</code></pre> <p>The resampling period.</p> <p>This is the time it passes between resampled data should be calculated.</p> <p>It must be a positive time span.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.warn_buffer_len","title":"warn_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n</code></pre> <p>The minimum length of the resampling buffer that will emit a warning.</p> <p>If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertently.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Check that config values are valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any value is out of range.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Check that config values are valid.\n\n    Raises:\n        ValueError: If any value is out of range.\n    \"\"\"\n    if self.resampling_period.total_seconds() &lt; 0.0:\n        raise ValueError(\n            f\"resampling_period ({self.resampling_period}) must be positive\"\n        )\n    if self.max_data_age_in_periods &lt; 1.0:\n        raise ValueError(\n            f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n        )\n    if self.warn_buffer_len &lt; 1:\n        raise ValueError(\n            f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n        )\n    if self.max_buffer_len &lt;= self.warn_buffer_len:\n        raise ValueError(\n            f\"max_buffer_len ({self.max_buffer_len}) should \"\n            f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n        )\n\n    if self.initial_buffer_len &lt; 1:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n        )\n    if self.initial_buffer_len &gt; self.max_buffer_len:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n            f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n            \"initial_buffer_len or a bigger max_buffer_len\"\n        )\n    if self.initial_buffer_len &gt; self.warn_buffer_len:\n        _logger.warning(\n            \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n            self.initial_buffer_len,\n            self.warn_buffer_len,\n        )\n    if self.align_to is not None and self.align_to.tzinfo is None:\n        raise ValueError(\n            f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.run","title":"frequenz.sdk.actor.run  <code>async</code>","text":"<pre><code>run(*actors: Actor) -&gt; None\n</code></pre> <p>Await the completion of all actors.</p> <p>Info</p> <p>Please read the <code>actor</code> module documentation for more comprehensive guide on how to use and implement actors properly.</p> PARAMETER DESCRIPTION <code>*actors</code> <p>the actors to be awaited.</p> <p> TYPE: <code>Actor</code> DEFAULT: <code>()</code> </p> Source code in <code>frequenz/sdk/actor/_run_utils.py</code> <pre><code>async def run(*actors: Actor) -&gt; None:\n    \"\"\"Await the completion of all actors.\n\n    !!! info\n\n        Please read the [`actor` module documentation][frequenz.sdk.actor] for more\n        comprehensive guide on how to use and implement actors properly.\n\n    Args:\n        *actors: the actors to be awaited.\n    \"\"\"\n    _logger.info(\"Starting %s actor(s)...\", len(actors))\n\n    for actor in actors:\n        if actor.is_running:\n            _logger.info(\"Actor %s: Already running, skipping start.\", actor)\n        else:\n            _logger.info(\"Actor %s: Starting...\", actor)\n            actor.start()\n\n    # Wait until all actors are done\n    pending_tasks = {asyncio.create_task(a.wait(), name=str(a)) for a in actors}\n    while pending_tasks:\n        done_tasks, pending_tasks = await asyncio.wait(\n            pending_tasks, return_when=asyncio.FIRST_COMPLETED\n        )\n\n        # This should always be only one task, but we handle many for extra safety\n        for task in done_tasks:\n            # Cancellation needs to be checked first, otherwise the other methods\n            # could raise a CancelledError\n            if task.cancelled():\n                _logger.info(\"Actor %s: Cancelled while running.\", task.get_name())\n            elif exception := task.exception():\n                _logger.error(\n                    \"Actor %s: Raised an exception while running.\",\n                    task.get_name(),\n                    exc_info=exception,\n                )\n            else:\n                _logger.info(\"Actor %s: Finished normally.\", task.get_name())\n\n    _logger.info(\"All %s actor(s) finished.\", len(actors))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/","title":"Index","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing","title":"frequenz.sdk.actor.power_distributing","text":"<p>This module provides feature to set power between many batteries.</p> <p>Distributing power is very important to keep the microgrid ready for the power requirements. This module provides PowerDistributingActor that knows how to distribute power. It also provides all the secondary features that should be used to communicate with PowerDistributingActor and send requests for charging or discharging power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Result","title":"frequenz.sdk.actor.power_distributing.Result  <code>module-attribute</code>","text":"<pre><code>Result = Success | PartialFailure | Error | OutOfBounds\n</code></pre> <p>Power distribution result.</p> <p>Example: Handling power distribution results</p> <pre><code>```python\nfrom typing import assert_never\n\nfrom frequenz.sdk.actor.power_distributing import (\n    Error,\n    OutOfBounds,\n    PartialFailure,\n    Result,\n    Success,\n)\nfrom frequenz.sdk.actor.power_distributing.request import Request\nfrom frequenz.sdk.actor.power_distributing.result import PowerBounds\nfrom frequenz.sdk.timeseries._quantities import Power\n\ndef handle_power_request_result(result: Result) -&gt; None:\n    match result:\n        case Success() as success:\n            print(f\"Power request was successful: {success}\")\n        case PartialFailure() as partial_failure:\n            print(f\"Power request was partially successful: {partial_failure}\")\n        case OutOfBounds() as out_of_bounds:\n            print(f\"Power request was out of bounds: {out_of_bounds}\")\n        case Error() as error:\n            print(f\"Power request failed: {error}\")\n        case _ as unreachable:\n            assert_never(unreachable)\n\nrequest = Request(\n    namespace=\"TestChannel\",\n    power=Power.from_watts(123.4),\n    component_ids={8, 18},\n)\n\nresults: list[Result] = [\n    Success(\n        request,\n        succeeded_power=Power.from_watts(123.4),\n        succeeded_components={8, 18},\n        excess_power=Power.zero(),\n    ),\n    PartialFailure(\n        request,\n        succeeded_power=Power.from_watts(103.4),\n        succeeded_components={8},\n        excess_power=Power.zero(),\n        failed_components={18},\n        failed_power=Power.from_watts(20.0),\n    ),\n    OutOfBounds(request, bounds=PowerBounds(0, 0, 0, 800)),\n    Error(request, msg=\"The components are not available\"),\n]\n\nfor r in results:\n    handle_power_request_result(r)\n```\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus","title":"frequenz.sdk.actor.power_distributing.ComponentPoolStatus  <code>dataclass</code>","text":"<p>Status of all components of a certain category in the microgrid.</p> Source code in <code>frequenz/sdk/actor/power_distributing/_component_status/_component_status.py</code> <pre><code>@dataclass\nclass ComponentPoolStatus:\n    \"\"\"Status of all components of a certain category in the microgrid.\"\"\"\n\n    working: set[int]\n    \"\"\"Set of working component ids.\"\"\"\n\n    uncertain: set[int]\n    \"\"\"Set of components to be used only when there are none known to be working.\"\"\"\n\n    def get_working_components(self, components: abc.Set[int]) -&gt; set[int]:\n        \"\"\"From the given set of components return the working ones.\n\n        Args:\n            components: Set of components.\n\n        Returns:\n            Subset with working components.\n        \"\"\"\n        working = self.working.intersection(components)\n        if len(working) &gt; 0:\n            return working\n        return self.uncertain.intersection(components)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus.uncertain","title":"uncertain  <code>instance-attribute</code>","text":"<pre><code>uncertain: set[int]\n</code></pre> <p>Set of components to be used only when there are none known to be working.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus.working","title":"working  <code>instance-attribute</code>","text":"<pre><code>working: set[int]\n</code></pre> <p>Set of working component ids.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.ComponentPoolStatus.get_working_components","title":"get_working_components","text":"<pre><code>get_working_components(components: Set[int]) -&gt; set[int]\n</code></pre> <p>From the given set of components return the working ones.</p> PARAMETER DESCRIPTION <code>components</code> <p>Set of components.</p> <p> TYPE: <code>Set[int]</code> </p> RETURNS DESCRIPTION <code>set[int]</code> <p>Subset with working components.</p> Source code in <code>frequenz/sdk/actor/power_distributing/_component_status/_component_status.py</code> <pre><code>def get_working_components(self, components: abc.Set[int]) -&gt; set[int]:\n    \"\"\"From the given set of components return the working ones.\n\n    Args:\n        components: Set of components.\n\n    Returns:\n        Subset with working components.\n    \"\"\"\n    working = self.working.intersection(components)\n    if len(working) &gt; 0:\n        return working\n    return self.uncertain.intersection(components)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error","title":"frequenz.sdk.actor.power_distributing.Error  <code>dataclass</code>","text":"<p>               Bases: <code>_BaseResultMixin</code></p> <p>Result returned when an error occurred and power was not set at all.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Error(_BaseResultMixin):\n    \"\"\"Result returned when an error occurred and power was not set at all.\"\"\"\n\n    msg: str\n    \"\"\"The error message explaining why error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg: str\n</code></pre> <p>The error message explaining why error happened.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds","title":"frequenz.sdk.actor.power_distributing.OutOfBounds  <code>dataclass</code>","text":"<p>               Bases: <code>_BaseResultMixin</code></p> <p>Result returned when the power was not set because it was out of bounds.</p> <p>This result happens when the originating request was done with <code>adjust_power = False</code> and the requested power is not within the available bounds.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass OutOfBounds(_BaseResultMixin):\n    \"\"\"Result returned when the power was not set because it was out of bounds.\n\n    This result happens when the originating request was done with\n    `adjust_power = False` and the requested power is not within the available bounds.\n    \"\"\"\n\n    bounds: PowerBounds\n    \"\"\"The power bounds for the requested components.\n\n    If the requested power negative, then this value is the lower bound.\n    Otherwise it is upper bound.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds.bounds","title":"bounds  <code>instance-attribute</code>","text":"<pre><code>bounds: PowerBounds\n</code></pre> <p>The power bounds for the requested components.</p> <p>If the requested power negative, then this value is the lower bound. Otherwise it is upper bound.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure","title":"frequenz.sdk.actor.power_distributing.PartialFailure  <code>dataclass</code>","text":"<p>               Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when some of the components had an error setting the power.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PartialFailure(_BaseSuccessMixin, _BaseResultMixin):\n    \"\"\"Result returned when some of the components had an error setting the power.\"\"\"\n\n    failed_power: Power\n    \"\"\"The part of the requested power that failed to be set.\"\"\"\n\n    failed_components: abc.Set[int]\n    \"\"\"The subset of batteries for which the request failed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.excess_power","title":"excess_power  <code>instance-attribute</code>","text":"<pre><code>excess_power: Power\n</code></pre> <p>The part of the requested power that could not be fulfilled.</p> <p>This happens when the requested power is outside the available power bounds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.failed_components","title":"failed_components  <code>instance-attribute</code>","text":"<pre><code>failed_components: Set[int]\n</code></pre> <p>The subset of batteries for which the request failed.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.failed_power","title":"failed_power  <code>instance-attribute</code>","text":"<pre><code>failed_power: Power\n</code></pre> <p>The part of the requested power that failed to be set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.succeeded_components","title":"succeeded_components  <code>instance-attribute</code>","text":"<pre><code>succeeded_components: Set[int]\n</code></pre> <p>The subset of components for which power was set successfully.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.succeeded_power","title":"succeeded_power  <code>instance-attribute</code>","text":"<pre><code>succeeded_power: Power\n</code></pre> <p>The part of the requested power that was successfully set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor","title":"frequenz.sdk.actor.power_distributing.PowerDistributingActor","text":"<p>               Bases: <code>Actor</code></p> <p>Actor to distribute the power between batteries in a microgrid.</p> <p>The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time.</p> <p>For each user a bidirectional channel needs to be created through which they can send and receive requests and responses.</p> <p>It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout + time for processing the request.</p> <p>Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED.</p> <ul> <li>If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed.</li> </ul> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>class PowerDistributingActor(Actor):\n    # pylint: disable=too-many-instance-attributes\n    \"\"\"Actor to distribute the power between batteries in a microgrid.\n\n    The purpose of this tool is to keep an equal SoC level in all batteries.\n    The PowerDistributingActor can have many concurrent users which at this time\n    need to be known at construction time.\n\n    For each user a bidirectional channel needs to be created through which\n    they can send and receive requests and responses.\n\n    It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if\n    the processing function fails then the response will never come.\n    The timeout should be Result:request_timeout + time for processing the request.\n\n    Edge cases:\n    * If there are 2 requests to be processed for the same subset of batteries, then\n    only the latest request will be processed. Older request will be ignored. User with\n    older request will get response with Result.Status.IGNORED.\n\n    * If there are 2 requests and their subset of batteries is different but they\n    overlap (they have at least one common battery), then then both batteries\n    will be processed. However it is not expected so the proper error log will be\n    printed.\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        requests_receiver: Receiver[Request],\n        results_sender: Sender[Result],\n        component_pool_status_sender: Sender[ComponentPoolStatus],\n        *,\n        api_power_request_timeout: timedelta,\n        component_category: ComponentCategory,\n        component_type: ComponentType | None = None,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Create class instance.\n\n        Args:\n            requests_receiver: Receiver for receiving power requests from the power\n                manager.\n            results_sender: Sender for sending results to the power manager.\n            component_pool_status_sender: Channel for sending information about which\n                components are expected to be working.\n            api_power_request_timeout: Timeout to use when making power requests to\n                the microgrid API.\n            component_category: The category of the components that this actor is\n                responsible for.\n            component_type: The type of the component of the given category that this\n                actor is responsible for.  This is used only when the component category\n                is not enough to uniquely identify the component.  For example, when the\n                category is `ComponentCategory.INVERTER`, the type is needed to identify\n                the inverter as a solar inverter or a battery inverter.  This can be\n                `None` when the component category is enough to uniquely identify the\n                component.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n\n        Raises:\n            ValueError: If the given component category is not supported.\n        \"\"\"\n        super().__init__(name=name)\n        self._component_category = component_category\n        self._component_type = component_type\n        self._requests_receiver = requests_receiver\n        self._result_sender = results_sender\n        self._api_power_request_timeout = api_power_request_timeout\n\n        self._component_manager: ComponentManager\n        if component_category == ComponentCategory.BATTERY:\n            self._component_manager = BatteryManager(\n                component_pool_status_sender, results_sender, api_power_request_timeout\n            )\n        elif component_category == ComponentCategory.EV_CHARGER:\n            self._component_manager = EVChargerManager(\n                component_pool_status_sender, results_sender, api_power_request_timeout\n            )\n        elif (\n            component_category == ComponentCategory.INVERTER\n            and component_type == InverterType.SOLAR\n        ):\n            self._component_manager = PVManager(\n                component_pool_status_sender, results_sender, api_power_request_timeout\n            )\n        else:\n            raise ValueError(\n                f\"PowerDistributor doesn't support controlling: {component_category}\"\n            )\n\n    @override\n    async def _run(self) -&gt; None:  # pylint: disable=too-many-locals\n        \"\"\"Run actor main function.\n\n        It waits for new requests in task_queue and process it, and send\n        `set_power` request with distributed power.\n        The output of the `set_power` method is processed.\n        Every battery and inverter that failed or didn't respond in time will be marked\n        as broken for some time.\n        \"\"\"\n        await self._component_manager.start()\n\n        async for request in self._requests_receiver:\n            await self._component_manager.distribute_power(request)\n\n    @override\n    async def stop(self, msg: str | None = None) -&gt; None:\n        \"\"\"Stop this actor.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\n        await self._component_manager.stop()\n        await super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    requests_receiver: Receiver[Request],\n    results_sender: Sender[Result],\n    component_pool_status_sender: Sender[\n        ComponentPoolStatus\n    ],\n    *,\n    api_power_request_timeout: timedelta,\n    component_category: ComponentCategory,\n    component_type: ComponentType | None = None,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Create class instance.</p> PARAMETER DESCRIPTION <code>requests_receiver</code> <p>Receiver for receiving power requests from the power manager.</p> <p> TYPE: <code>Receiver[Request]</code> </p> <code>results_sender</code> <p>Sender for sending results to the power manager.</p> <p> TYPE: <code>Sender[Result]</code> </p> <code>component_pool_status_sender</code> <p>Channel for sending information about which components are expected to be working.</p> <p> TYPE: <code>Sender[ComponentPoolStatus]</code> </p> <code>api_power_request_timeout</code> <p>Timeout to use when making power requests to the microgrid API.</p> <p> TYPE: <code>timedelta</code> </p> <code>component_category</code> <p>The category of the components that this actor is responsible for.</p> <p> TYPE: <code>ComponentCategory</code> </p> <code>component_type</code> <p>The type of the component of the given category that this actor is responsible for.  This is used only when the component category is not enough to uniquely identify the component.  For example, when the category is <code>ComponentCategory.INVERTER</code>, the type is needed to identify the inverter as a solar inverter or a battery inverter.  This can be <code>None</code> when the component category is enough to uniquely identify the component.</p> <p> TYPE: <code>ComponentType | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given component category is not supported.</p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    requests_receiver: Receiver[Request],\n    results_sender: Sender[Result],\n    component_pool_status_sender: Sender[ComponentPoolStatus],\n    *,\n    api_power_request_timeout: timedelta,\n    component_category: ComponentCategory,\n    component_type: ComponentType | None = None,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Create class instance.\n\n    Args:\n        requests_receiver: Receiver for receiving power requests from the power\n            manager.\n        results_sender: Sender for sending results to the power manager.\n        component_pool_status_sender: Channel for sending information about which\n            components are expected to be working.\n        api_power_request_timeout: Timeout to use when making power requests to\n            the microgrid API.\n        component_category: The category of the components that this actor is\n            responsible for.\n        component_type: The type of the component of the given category that this\n            actor is responsible for.  This is used only when the component category\n            is not enough to uniquely identify the component.  For example, when the\n            category is `ComponentCategory.INVERTER`, the type is needed to identify\n            the inverter as a solar inverter or a battery inverter.  This can be\n            `None` when the component category is enough to uniquely identify the\n            component.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n\n    Raises:\n        ValueError: If the given component category is not supported.\n    \"\"\"\n    super().__init__(name=name)\n    self._component_category = component_category\n    self._component_type = component_type\n    self._requests_receiver = requests_receiver\n    self._result_sender = results_sender\n    self._api_power_request_timeout = api_power_request_timeout\n\n    self._component_manager: ComponentManager\n    if component_category == ComponentCategory.BATTERY:\n        self._component_manager = BatteryManager(\n            component_pool_status_sender, results_sender, api_power_request_timeout\n        )\n    elif component_category == ComponentCategory.EV_CHARGER:\n        self._component_manager = EVChargerManager(\n            component_pool_status_sender, results_sender, api_power_request_timeout\n        )\n    elif (\n        component_category == ComponentCategory.INVERTER\n        and component_type == InverterType.SOLAR\n    ):\n        self._component_manager = PVManager(\n            component_pool_status_sender, results_sender, api_power_request_timeout\n        )\n    else:\n        raise ValueError(\n            f\"PowerDistributor doesn't support controlling: {component_category}\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this actor.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>@override\nasync def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this actor.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    await self._component_manager.stop()\n    await super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request","title":"frequenz.sdk.actor.power_distributing.Request  <code>dataclass</code>","text":"<p>Request to set power to the <code>PowerDistributingActor</code>.</p> Source code in <code>frequenz/sdk/actor/power_distributing/request.py</code> <pre><code>@dataclasses.dataclass\nclass Request:\n    \"\"\"Request to set power to the `PowerDistributingActor`.\"\"\"\n\n    power: Power\n    \"\"\"The requested power.\"\"\"\n\n    component_ids: abc.Set[int]\n    \"\"\"The component ids of the components to be used for this request.\"\"\"\n\n    adjust_power: bool = True\n    \"\"\"Whether to adjust the power to match the bounds.\n\n    If `True`, the power will be adjusted (lowered) to match the bounds, so\n    only the reduced power will be set.\n\n    If `False` and the power is outside the available bounds, the request will\n    fail and be replied to with an `OutOfBound` result.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.adjust_power","title":"adjust_power  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>adjust_power: bool = True\n</code></pre> <p>Whether to adjust the power to match the bounds.</p> <p>If <code>True</code>, the power will be adjusted (lowered) to match the bounds, so only the reduced power will be set.</p> <p>If <code>False</code> and the power is outside the available bounds, the request will fail and be replied to with an <code>OutOfBound</code> result.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.component_ids","title":"component_ids  <code>instance-attribute</code>","text":"<pre><code>component_ids: Set[int]\n</code></pre> <p>The component ids of the components to be used for this request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.power","title":"power  <code>instance-attribute</code>","text":"<pre><code>power: Power\n</code></pre> <p>The requested power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success","title":"frequenz.sdk.actor.power_distributing.Success  <code>dataclass</code>","text":"<p>               Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when setting the power was successful for all components.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Success(_BaseSuccessMixin, _BaseResultMixin):  # Order matters here. See above.\n    \"\"\"Result returned when setting the power was successful for all components.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success.excess_power","title":"excess_power  <code>instance-attribute</code>","text":"<pre><code>excess_power: Power\n</code></pre> <p>The part of the requested power that could not be fulfilled.</p> <p>This happens when the requested power is outside the available power bounds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success.succeeded_components","title":"succeeded_components  <code>instance-attribute</code>","text":"<pre><code>succeeded_components: Set[int]\n</code></pre> <p>The subset of components for which power was set successfully.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success.succeeded_power","title":"succeeded_power  <code>instance-attribute</code>","text":"<pre><code>succeeded_power: Power\n</code></pre> <p>The part of the requested power that was successfully set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/","title":"power_distributing","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing","title":"frequenz.sdk.actor.power_distributing.power_distributing","text":"<p>Actor to distribute power between batteries.</p> <p>When charge/discharge method is called the power should be distributed so that the SoC in batteries stays at the same level. That way of distribution prevents using only one battery, increasing temperature, and maximize the total amount power to charge/discharge.</p> <p>Purpose of this actor is to keep SoC level of each component at the equal level.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor","title":"frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor","text":"<p>               Bases: <code>Actor</code></p> <p>Actor to distribute the power between batteries in a microgrid.</p> <p>The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time.</p> <p>For each user a bidirectional channel needs to be created through which they can send and receive requests and responses.</p> <p>It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout + time for processing the request.</p> <p>Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED.</p> <ul> <li>If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed.</li> </ul> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>class PowerDistributingActor(Actor):\n    # pylint: disable=too-many-instance-attributes\n    \"\"\"Actor to distribute the power between batteries in a microgrid.\n\n    The purpose of this tool is to keep an equal SoC level in all batteries.\n    The PowerDistributingActor can have many concurrent users which at this time\n    need to be known at construction time.\n\n    For each user a bidirectional channel needs to be created through which\n    they can send and receive requests and responses.\n\n    It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if\n    the processing function fails then the response will never come.\n    The timeout should be Result:request_timeout + time for processing the request.\n\n    Edge cases:\n    * If there are 2 requests to be processed for the same subset of batteries, then\n    only the latest request will be processed. Older request will be ignored. User with\n    older request will get response with Result.Status.IGNORED.\n\n    * If there are 2 requests and their subset of batteries is different but they\n    overlap (they have at least one common battery), then then both batteries\n    will be processed. However it is not expected so the proper error log will be\n    printed.\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        requests_receiver: Receiver[Request],\n        results_sender: Sender[Result],\n        component_pool_status_sender: Sender[ComponentPoolStatus],\n        *,\n        api_power_request_timeout: timedelta,\n        component_category: ComponentCategory,\n        component_type: ComponentType | None = None,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Create class instance.\n\n        Args:\n            requests_receiver: Receiver for receiving power requests from the power\n                manager.\n            results_sender: Sender for sending results to the power manager.\n            component_pool_status_sender: Channel for sending information about which\n                components are expected to be working.\n            api_power_request_timeout: Timeout to use when making power requests to\n                the microgrid API.\n            component_category: The category of the components that this actor is\n                responsible for.\n            component_type: The type of the component of the given category that this\n                actor is responsible for.  This is used only when the component category\n                is not enough to uniquely identify the component.  For example, when the\n                category is `ComponentCategory.INVERTER`, the type is needed to identify\n                the inverter as a solar inverter or a battery inverter.  This can be\n                `None` when the component category is enough to uniquely identify the\n                component.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n\n        Raises:\n            ValueError: If the given component category is not supported.\n        \"\"\"\n        super().__init__(name=name)\n        self._component_category = component_category\n        self._component_type = component_type\n        self._requests_receiver = requests_receiver\n        self._result_sender = results_sender\n        self._api_power_request_timeout = api_power_request_timeout\n\n        self._component_manager: ComponentManager\n        if component_category == ComponentCategory.BATTERY:\n            self._component_manager = BatteryManager(\n                component_pool_status_sender, results_sender, api_power_request_timeout\n            )\n        elif component_category == ComponentCategory.EV_CHARGER:\n            self._component_manager = EVChargerManager(\n                component_pool_status_sender, results_sender, api_power_request_timeout\n            )\n        elif (\n            component_category == ComponentCategory.INVERTER\n            and component_type == InverterType.SOLAR\n        ):\n            self._component_manager = PVManager(\n                component_pool_status_sender, results_sender, api_power_request_timeout\n            )\n        else:\n            raise ValueError(\n                f\"PowerDistributor doesn't support controlling: {component_category}\"\n            )\n\n    @override\n    async def _run(self) -&gt; None:  # pylint: disable=too-many-locals\n        \"\"\"Run actor main function.\n\n        It waits for new requests in task_queue and process it, and send\n        `set_power` request with distributed power.\n        The output of the `set_power` method is processed.\n        Every battery and inverter that failed or didn't respond in time will be marked\n        as broken for some time.\n        \"\"\"\n        await self._component_manager.start()\n\n        async for request in self._requests_receiver:\n            await self._component_manager.distribute_power(request)\n\n    @override\n    async def stop(self, msg: str | None = None) -&gt; None:\n        \"\"\"Stop this actor.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\n        await self._component_manager.stop()\n        await super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.RESTART_DELAY","title":"RESTART_DELAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTART_DELAY: timedelta = timedelta(seconds=2)\n</code></pre> <p>The delay to wait between restarts of this actor.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__init__","title":"__init__","text":"<pre><code>__init__(\n    requests_receiver: Receiver[Request],\n    results_sender: Sender[Result],\n    component_pool_status_sender: Sender[\n        ComponentPoolStatus\n    ],\n    *,\n    api_power_request_timeout: timedelta,\n    component_category: ComponentCategory,\n    component_type: ComponentType | None = None,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Create class instance.</p> PARAMETER DESCRIPTION <code>requests_receiver</code> <p>Receiver for receiving power requests from the power manager.</p> <p> TYPE: <code>Receiver[Request]</code> </p> <code>results_sender</code> <p>Sender for sending results to the power manager.</p> <p> TYPE: <code>Sender[Result]</code> </p> <code>component_pool_status_sender</code> <p>Channel for sending information about which components are expected to be working.</p> <p> TYPE: <code>Sender[ComponentPoolStatus]</code> </p> <code>api_power_request_timeout</code> <p>Timeout to use when making power requests to the microgrid API.</p> <p> TYPE: <code>timedelta</code> </p> <code>component_category</code> <p>The category of the components that this actor is responsible for.</p> <p> TYPE: <code>ComponentCategory</code> </p> <code>component_type</code> <p>The type of the component of the given category that this actor is responsible for.  This is used only when the component category is not enough to uniquely identify the component.  For example, when the category is <code>ComponentCategory.INVERTER</code>, the type is needed to identify the inverter as a solar inverter or a battery inverter.  This can be <code>None</code> when the component category is enough to uniquely identify the component.</p> <p> TYPE: <code>ComponentType | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given component category is not supported.</p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    requests_receiver: Receiver[Request],\n    results_sender: Sender[Result],\n    component_pool_status_sender: Sender[ComponentPoolStatus],\n    *,\n    api_power_request_timeout: timedelta,\n    component_category: ComponentCategory,\n    component_type: ComponentType | None = None,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Create class instance.\n\n    Args:\n        requests_receiver: Receiver for receiving power requests from the power\n            manager.\n        results_sender: Sender for sending results to the power manager.\n        component_pool_status_sender: Channel for sending information about which\n            components are expected to be working.\n        api_power_request_timeout: Timeout to use when making power requests to\n            the microgrid API.\n        component_category: The category of the components that this actor is\n            responsible for.\n        component_type: The type of the component of the given category that this\n            actor is responsible for.  This is used only when the component category\n            is not enough to uniquely identify the component.  For example, when the\n            category is `ComponentCategory.INVERTER`, the type is needed to identify\n            the inverter as a solar inverter or a battery inverter.  This can be\n            `None` when the component category is enough to uniquely identify the\n            component.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n\n    Raises:\n        ValueError: If the given component category is not supported.\n    \"\"\"\n    super().__init__(name=name)\n    self._component_category = component_category\n    self._component_type = component_type\n    self._requests_receiver = requests_receiver\n    self._result_sender = results_sender\n    self._api_power_request_timeout = api_power_request_timeout\n\n    self._component_manager: ComponentManager\n    if component_category == ComponentCategory.BATTERY:\n        self._component_manager = BatteryManager(\n            component_pool_status_sender, results_sender, api_power_request_timeout\n        )\n    elif component_category == ComponentCategory.EV_CHARGER:\n        self._component_manager = EVChargerManager(\n            component_pool_status_sender, results_sender, api_power_request_timeout\n        )\n    elif (\n        component_category == ComponentCategory.INVERTER\n        and component_type == InverterType.SOLAR\n    ):\n        self._component_manager = PVManager(\n            component_pool_status_sender, results_sender, api_power_request_timeout\n        )\n    else:\n        raise ValueError(\n            f\"PowerDistributor doesn't support controlling: {component_category}\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start this actor.\n\n    If this actor is already running, this method does nothing.\n    \"\"\"\n    if self.is_running:\n        return\n    self._tasks.clear()\n    self._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this actor.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>@override\nasync def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this actor.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    await self._component_manager.stop()\n    await super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/","title":"request","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request","title":"frequenz.sdk.actor.power_distributing.request","text":"<p>Definition of the user request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request","title":"frequenz.sdk.actor.power_distributing.request.Request  <code>dataclass</code>","text":"<p>Request to set power to the <code>PowerDistributingActor</code>.</p> Source code in <code>frequenz/sdk/actor/power_distributing/request.py</code> <pre><code>@dataclasses.dataclass\nclass Request:\n    \"\"\"Request to set power to the `PowerDistributingActor`.\"\"\"\n\n    power: Power\n    \"\"\"The requested power.\"\"\"\n\n    component_ids: abc.Set[int]\n    \"\"\"The component ids of the components to be used for this request.\"\"\"\n\n    adjust_power: bool = True\n    \"\"\"Whether to adjust the power to match the bounds.\n\n    If `True`, the power will be adjusted (lowered) to match the bounds, so\n    only the reduced power will be set.\n\n    If `False` and the power is outside the available bounds, the request will\n    fail and be replied to with an `OutOfBound` result.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.adjust_power","title":"adjust_power  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>adjust_power: bool = True\n</code></pre> <p>Whether to adjust the power to match the bounds.</p> <p>If <code>True</code>, the power will be adjusted (lowered) to match the bounds, so only the reduced power will be set.</p> <p>If <code>False</code> and the power is outside the available bounds, the request will fail and be replied to with an <code>OutOfBound</code> result.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.component_ids","title":"component_ids  <code>instance-attribute</code>","text":"<pre><code>component_ids: Set[int]\n</code></pre> <p>The component ids of the components to be used for this request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.power","title":"power  <code>instance-attribute</code>","text":"<pre><code>power: Power\n</code></pre> <p>The requested power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/","title":"result","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result","title":"frequenz.sdk.actor.power_distributing.result","text":"<p>Results from PowerDistributingActor.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Result","title":"frequenz.sdk.actor.power_distributing.result.Result  <code>module-attribute</code>","text":"<pre><code>Result = Success | PartialFailure | Error | OutOfBounds\n</code></pre> <p>Power distribution result.</p> <p>Example: Handling power distribution results</p> <pre><code>```python\nfrom typing import assert_never\n\nfrom frequenz.sdk.actor.power_distributing import (\n    Error,\n    OutOfBounds,\n    PartialFailure,\n    Result,\n    Success,\n)\nfrom frequenz.sdk.actor.power_distributing.request import Request\nfrom frequenz.sdk.actor.power_distributing.result import PowerBounds\nfrom frequenz.sdk.timeseries._quantities import Power\n\ndef handle_power_request_result(result: Result) -&gt; None:\n    match result:\n        case Success() as success:\n            print(f\"Power request was successful: {success}\")\n        case PartialFailure() as partial_failure:\n            print(f\"Power request was partially successful: {partial_failure}\")\n        case OutOfBounds() as out_of_bounds:\n            print(f\"Power request was out of bounds: {out_of_bounds}\")\n        case Error() as error:\n            print(f\"Power request failed: {error}\")\n        case _ as unreachable:\n            assert_never(unreachable)\n\nrequest = Request(\n    namespace=\"TestChannel\",\n    power=Power.from_watts(123.4),\n    component_ids={8, 18},\n)\n\nresults: list[Result] = [\n    Success(\n        request,\n        succeeded_power=Power.from_watts(123.4),\n        succeeded_components={8, 18},\n        excess_power=Power.zero(),\n    ),\n    PartialFailure(\n        request,\n        succeeded_power=Power.from_watts(103.4),\n        succeeded_components={8},\n        excess_power=Power.zero(),\n        failed_components={18},\n        failed_power=Power.from_watts(20.0),\n    ),\n    OutOfBounds(request, bounds=PowerBounds(0, 0, 0, 800)),\n    Error(request, msg=\"The components are not available\"),\n]\n\nfor r in results:\n    handle_power_request_result(r)\n```\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error","title":"frequenz.sdk.actor.power_distributing.result.Error  <code>dataclass</code>","text":"<p>               Bases: <code>_BaseResultMixin</code></p> <p>Result returned when an error occurred and power was not set at all.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Error(_BaseResultMixin):\n    \"\"\"Result returned when an error occurred and power was not set at all.\"\"\"\n\n    msg: str\n    \"\"\"The error message explaining why error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg: str\n</code></pre> <p>The error message explaining why error happened.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds","title":"frequenz.sdk.actor.power_distributing.result.OutOfBounds  <code>dataclass</code>","text":"<p>               Bases: <code>_BaseResultMixin</code></p> <p>Result returned when the power was not set because it was out of bounds.</p> <p>This result happens when the originating request was done with <code>adjust_power = False</code> and the requested power is not within the available bounds.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass OutOfBounds(_BaseResultMixin):\n    \"\"\"Result returned when the power was not set because it was out of bounds.\n\n    This result happens when the originating request was done with\n    `adjust_power = False` and the requested power is not within the available bounds.\n    \"\"\"\n\n    bounds: PowerBounds\n    \"\"\"The power bounds for the requested components.\n\n    If the requested power negative, then this value is the lower bound.\n    Otherwise it is upper bound.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds.bounds","title":"bounds  <code>instance-attribute</code>","text":"<pre><code>bounds: PowerBounds\n</code></pre> <p>The power bounds for the requested components.</p> <p>If the requested power negative, then this value is the lower bound. Otherwise it is upper bound.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure","title":"frequenz.sdk.actor.power_distributing.result.PartialFailure  <code>dataclass</code>","text":"<p>               Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when some of the components had an error setting the power.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PartialFailure(_BaseSuccessMixin, _BaseResultMixin):\n    \"\"\"Result returned when some of the components had an error setting the power.\"\"\"\n\n    failed_power: Power\n    \"\"\"The part of the requested power that failed to be set.\"\"\"\n\n    failed_components: abc.Set[int]\n    \"\"\"The subset of batteries for which the request failed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.excess_power","title":"excess_power  <code>instance-attribute</code>","text":"<pre><code>excess_power: Power\n</code></pre> <p>The part of the requested power that could not be fulfilled.</p> <p>This happens when the requested power is outside the available power bounds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_components","title":"failed_components  <code>instance-attribute</code>","text":"<pre><code>failed_components: Set[int]\n</code></pre> <p>The subset of batteries for which the request failed.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_power","title":"failed_power  <code>instance-attribute</code>","text":"<pre><code>failed_power: Power\n</code></pre> <p>The part of the requested power that failed to be set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.succeeded_components","title":"succeeded_components  <code>instance-attribute</code>","text":"<pre><code>succeeded_components: Set[int]\n</code></pre> <p>The subset of components for which power was set successfully.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.succeeded_power","title":"succeeded_power  <code>instance-attribute</code>","text":"<pre><code>succeeded_power: Power\n</code></pre> <p>The part of the requested power that was successfully set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds","title":"frequenz.sdk.actor.power_distributing.result.PowerBounds  <code>dataclass</code>","text":"<p>Inclusion and exclusion power bounds for the requested components.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PowerBounds:\n    \"\"\"Inclusion and exclusion power bounds for the requested components.\"\"\"\n\n    inclusion_lower: float\n    \"\"\"The lower value of the inclusion power bounds for the requested components.\"\"\"\n\n    exclusion_lower: float\n    \"\"\"The lower value of the exclusion power bounds for the requested components.\"\"\"\n\n    exclusion_upper: float\n    \"\"\"The upper value of the exclusion power bounds for the requested components.\"\"\"\n\n    inclusion_upper: float\n    \"\"\"The upper value of the inclusion power bounds for the requested components.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.exclusion_lower","title":"exclusion_lower  <code>instance-attribute</code>","text":"<pre><code>exclusion_lower: float\n</code></pre> <p>The lower value of the exclusion power bounds for the requested components.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.exclusion_upper","title":"exclusion_upper  <code>instance-attribute</code>","text":"<pre><code>exclusion_upper: float\n</code></pre> <p>The upper value of the exclusion power bounds for the requested components.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.inclusion_lower","title":"inclusion_lower  <code>instance-attribute</code>","text":"<pre><code>inclusion_lower: float\n</code></pre> <p>The lower value of the inclusion power bounds for the requested components.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.inclusion_upper","title":"inclusion_upper  <code>instance-attribute</code>","text":"<pre><code>inclusion_upper: float\n</code></pre> <p>The upper value of the inclusion power bounds for the requested components.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success","title":"frequenz.sdk.actor.power_distributing.result.Success  <code>dataclass</code>","text":"<p>               Bases: <code>_BaseSuccessMixin</code>, <code>_BaseResultMixin</code></p> <p>Result returned when setting the power was successful for all components.</p> Source code in <code>frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Success(_BaseSuccessMixin, _BaseResultMixin):  # Order matters here. See above.\n    \"\"\"Result returned when setting the power was successful for all components.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success.excess_power","title":"excess_power  <code>instance-attribute</code>","text":"<pre><code>excess_power: Power\n</code></pre> <p>The part of the requested power that could not be fulfilled.</p> <p>This happens when the requested power is outside the available power bounds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Request\n</code></pre> <p>The user's request to which this message responds.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success.succeeded_components","title":"succeeded_components  <code>instance-attribute</code>","text":"<pre><code>succeeded_components: Set[int]\n</code></pre> <p>The subset of components for which power was set successfully.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success.succeeded_power","title":"succeeded_power  <code>instance-attribute</code>","text":"<pre><code>succeeded_power: Power\n</code></pre> <p>The part of the requested power that was successfully set.</p>"},{"location":"reference/frequenz/sdk/microgrid/","title":"Index","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid","title":"frequenz.sdk.microgrid","text":"<p>A microgrid is a local electrical grid that connects a set of electrical components together.  They are often built around a passive power consumer, to supplement the electricity consumed from the public grid with on-site power generation or storage systems.</p> <p>Microgrids can also function in island-mode, without a grid connection, or without a local power consumer, but they have to have at least one of the two, to be meaningful.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--frequenz-sdk-microgrid-model","title":"Frequenz SDK Microgrid Model","text":"<p>The SDK aims to provide an abstract model of the microgrid that enables high-level interactions with microgrid components, without having to worry about (or even be aware of) location-specific details such as:</p> <ul> <li>where the meters are placed,</li> <li>how many batteries,</li> <li>whether there's a grid connection or a passive consumer,</li> <li>what models the inverters are, etc.</li> <li>whether components are having downtimes, because metrics and   limits get adjusted automatically when components are having downtimes.</li> </ul> <p>Users of the SDK can develop applications around this interface once and deploy anywhere, and the SDK will take care of translating the requests and instructions to correspond to the specific microgrid configurations.</p> <pre><code>flowchart LR\n\nsubgraph Left[Measurements only]\ndirection LR\n  grid[\"Grid Connection\"]\n  consumer[\"Consumer\"]\n  pv[\"PV Arrays\"]\n  chp[\"CHP\"]\nend\n\njunction(( ))\n\nsubgraph Right[Measurements and control]\ndirection LR\n  bat[\"Batteries\"]\n  ev[\"EV Chargers\"]\nend\n\ngrid --- junction\nconsumer --- junction\npv --- junction\nchp --- junction\n\njunction --- bat\njunction --- ev</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--grid","title":"Grid","text":"<p>This refers to a microgrid's connection to the external Grid.  The power flowing through this connection can be streamed through <code>grid_power</code>.</p> <p>In locations without a grid connection, this method remains accessible, and streams zero values.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--consumer","title":"Consumer","text":"<p>This is the main power consumer at the site of a microgrid, and often the load the microgrid is built to support.  The power drawn by the consumer is available through <code>consumer_power</code></p> <p>In locations without a consumer, this method streams zero values.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--producers-pv-arrays-chp","title":"Producers: PV Arrays, CHP","text":"<p>The total CHP production in a site can be streamed through <code>chp_power</code>.  PV Power is available through the PV pool described below.  And total producer power is available through <code>microgrid.producer().power</code>.</p> <p>As is the case with the other methods, if PV Arrays or CHPs are not available in a microgrid, the corresponding methods stream zero values.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--pv-arrays","title":"PV Arrays","text":"<p>The total PV power production is available through <code>pv_pool</code>'s <code>power</code>.  The PV pool by default uses all PV inverters available at a location, but PV pool instances can be created for subsets of PV inverters if necessary, by specifying the inverter ids.</p> <p>The <code>pv_pool</code> also provides available power bounds through the <code>power_status</code> method.</p> <p>The <code>pv_pool</code> also provides a control method <code>propose_power</code>, which accepts values in the Passive Sign Convention and supports only production.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--batteries","title":"Batteries","text":"<p>The total Battery power is available through the <code>battery_pool</code>'s <code>power</code>.  The battery pool by default uses all batteries available at a location, but battery pool instances can be created for subsets of batteries if necessary, by specifying the battery ids.</p> <p>The <code>battery_pool</code> also provides <code>soc</code>, <code>capacity</code>, <code>temperature</code> and available power bounds through the <code>power_status</code> method.</p> <p>The <code>battery_pool</code> also provides control methods <code>propose_power</code> (which accepts values in the Passive Sign Convention and supports both charging and discharging), or through <code>propose_charge</code>, or <code>propose_discharge</code>.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--ev-chargers","title":"EV Chargers","text":"<p>The <code>ev_charger_pool</code> offers a <code>power</code> method that streams the total power measured for all the EV Chargers at a site.</p> <p>The <code>ev_charger_pool</code> also provides available power bounds through the <code>power_status</code> method.</p> <p>The <code>ev_charger_pool</code> also provides a control method <code>propose_power</code>, which accepts values in the Passive Sign Convention and supports only charging.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--component-pools","title":"Component pools","text":"<p>The SDK provides a unified interface for interacting with sets of Batteries, EV chargers and PV arrays, through their corresponding <code>Pool</code>s.</p> <ul> <li>Battery pool</li> <li>EV charger pool</li> <li>PV pool</li> </ul> <p>All of them provide support for streaming aggregated data and for setting the power values of the components.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--streaming-component-data","title":"Streaming component data","text":"<p>All pools have a <code>power</code> property, which is a <code>FormulaEngine</code> that can</p> <ul> <li> <p>provide a stream of resampled power values, which correspond to the sum of the power measured from all the components in the pool together.</p> </li> <li> <p>be composed with other power streams to for composite formulas.</p> </li> </ul> <p>In addition, the battery pool has some additional properties that can be used as streams for metrics specific to batteries: <code>soc</code>, <code>capacity</code> and <code>temperature</code>.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--setting-power","title":"Setting power","text":"<p>All pools provide a <code>propose_power</code> method for setting power for the pool.  This would then be distributed to the individual components in the pool, using an algorithm that's suitable for the category of the components.  For example, when controlling batteries, power could be distributed based on the <code>SoC</code> of the individual batteries, to keep the batteries in balance.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--resolving-conflicting-power-proposals","title":"Resolving conflicting power proposals","text":"<p>When there are multiple actors trying to control the same set of batteries, a target power is calculated based on the priorities of the actors making the requests.  Actors need to specify their priorities as parameters when creating the <code>*Pool</code> instances using the constructors mentioned above.</p> <p>The algorithm used for resolving power conflicts based on actor priority can be found in the documentation for any of the <code>propose_power</code> methods.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid--shifting-the-target-power-by-an-operating-point-power","title":"Shifting the target power by an Operating Point power","text":"<p>There are cases where the target power needs to be shifted by an operating point.  This can be done by designating some actors to be able to set only the operating point power.</p> <p>When creating a <code>*Pool</code> instance using the above-mentioned constructors, an optional <code>set_operating_point</code> parameter can be passed to specify that this actor is special, and the target power of the regular actors will be shifted by the target power of all actors with <code>set_operating_point</code> together.</p> <p>In a location with 2 regular actors and 1 <code>set_operating_point</code> actor, here's how things would play out:</p> <ol> <li>When only regular actors have made proposals, the power bounds available from the    batteries are available to them exactly.</li> </ol> actor priority in op group? proposed power/bounds available bounds 3 No 1000, -4000..2500 -3000..3000 2 No 2500 -3000..2500 1 Yes None -3000..3000 <p>Power actually distributed to the batteries: 2500W</p> <ol> <li>When the <code>set_operating_point</code> actor has made proposals, the bounds available to the    regular actors gets shifted, and the final power that actually gets distributed to    the batteries is also shifted.</li> </ol> actor priority in op group? proposed power/bounds available bounds 3 No 1000, -4000..2500 -2000..4000 2 No 2500 -2000..2500 1 Yes -1000 -3000..3000 <p>Power actually distributed to the batteries: 1500W</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.consumer","title":"frequenz.sdk.microgrid.consumer","text":"<pre><code>consumer() -&gt; Consumer\n</code></pre> <p>Return the <code>Consumption</code> measuring point.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def consumer() -&gt; Consumer:\n    \"\"\"Return the [`Consumption`][frequenz.sdk.timeseries.consumer.Consumer] measuring point.\"\"\"\n    return _get().consumer()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.frequency","title":"frequenz.sdk.microgrid.frequency","text":"<pre><code>frequency() -&gt; GridFrequency\n</code></pre> <p>Return the grid frequency measuring point.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def frequency() -&gt; GridFrequency:\n    \"\"\"Return the grid frequency measuring point.\"\"\"\n    return _get().frequency()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.grid","title":"frequenz.sdk.microgrid.grid","text":"<pre><code>grid() -&gt; Grid\n</code></pre> <p>Return the grid measuring point.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def grid() -&gt; Grid:\n    \"\"\"Return the grid measuring point.\"\"\"\n    return _get().grid()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.initialize","title":"frequenz.sdk.microgrid.initialize  <code>async</code>","text":"<pre><code>initialize(\n    server_url: str, resampler_config: ResamplerConfig\n) -&gt; None\n</code></pre> <p>Initialize the microgrid connection manager and the data pipeline.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The location of the microgrid API server in the form of a URL. The following format is expected: <code>grpc://hostname{:port}{?ssl=ssl}</code>, where the port should be an int between <code>0</code> and <code>65535</code> (defaulting to <code>9090</code>) and ssl should be a boolean (defaulting to false). For example: <code>grpc://localhost:1090?ssl=true</code>.</p> <p> TYPE: <code>str</code> </p> <code>resampler_config</code> <p>Configuration for the resampling actor.</p> <p> TYPE: <code>ResamplerConfig</code> </p> Source code in <code>frequenz/sdk/microgrid/__init__.py</code> <pre><code>async def initialize(server_url: str, resampler_config: ResamplerConfig) -&gt; None:\n    \"\"\"Initialize the microgrid connection manager and the data pipeline.\n\n    Args:\n        server_url: The location of the microgrid API server in the form of a URL.\n            The following format is expected: `grpc://hostname{:port}{?ssl=ssl}`,\n            where the port should be an int between `0` and `65535` (defaulting to\n            `9090`) and ssl should be a boolean (defaulting to false). For example:\n            `grpc://localhost:1090?ssl=true`.\n        resampler_config: Configuration for the resampling actor.\n    \"\"\"\n    await connection_manager.initialize(server_url)\n    await _data_pipeline.initialize(resampler_config)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.logical_meter","title":"frequenz.sdk.microgrid.logical_meter","text":"<pre><code>logical_meter() -&gt; LogicalMeter\n</code></pre> <p>Return the logical meter of the microgrid.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def logical_meter() -&gt; LogicalMeter:\n    \"\"\"Return the logical meter of the microgrid.\"\"\"\n    return _get().logical_meter()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.new_battery_pool","title":"frequenz.sdk.microgrid.new_battery_pool","text":"<pre><code>new_battery_pool(\n    *,\n    priority: int,\n    component_ids: Set[int] | None = None,\n    name: str | None = None,\n    set_operating_point: bool = False\n) -&gt; BatteryPool\n</code></pre> <p>Return a new <code>BatteryPool</code> instance for the given parameters.</p> <p>The priority value is used to resolve conflicts when multiple actors are trying to propose different power values for the same set of batteries.</p> <p>Note</p> <p>When specifying priority, bigger values indicate higher priority.</p> <p>It is recommended to reuse the same instance of the <code>BatteryPool</code> within the same actor, unless they are managing different sets of batteries.</p> <p>In deployments with multiple actors managing the same set of batteries, it is recommended to use different priorities to distinguish between them.  If not, a random prioritization will be imposed on them to resolve conflicts, which may lead to unexpected behavior like longer duration to converge on the desired power.</p> PARAMETER DESCRIPTION <code>priority</code> <p>The priority of the actor making the call.</p> <p> TYPE: <code>int</code> </p> <code>component_ids</code> <p>Optional set of IDs of batteries to be managed by the <code>BatteryPool</code>.  If not specified, all batteries available in the component graph are used.</p> <p> TYPE: <code>Set[int] | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>An optional name used to identify this instance of the pool or a corresponding actor in the logs.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>set_operating_point</code> <p>Whether this instance sets the operating point power or the normal power for the components.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>BatteryPool</code> <p>A <code>BatteryPool</code> instance.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def new_battery_pool(\n    *,\n    priority: int,\n    component_ids: abc.Set[int] | None = None,\n    name: str | None = None,\n    set_operating_point: bool = False,\n) -&gt; BatteryPool:\n    \"\"\"Return a new `BatteryPool` instance for the given parameters.\n\n    The priority value is used to resolve conflicts when multiple actors are trying to\n    propose different power values for the same set of batteries.\n\n    !!! note\n        When specifying priority, bigger values indicate higher priority.\n\n        It is recommended to reuse the same instance of the `BatteryPool` within the\n        same actor, unless they are managing different sets of batteries.\n\n        In deployments with multiple actors managing the same set of batteries, it is\n        recommended to use different priorities to distinguish between them.  If not,\n        a random prioritization will be imposed on them to resolve conflicts, which may\n        lead to unexpected behavior like longer duration to converge on the desired\n        power.\n\n    Args:\n        priority: The priority of the actor making the call.\n        component_ids: Optional set of IDs of batteries to be managed by the\n            `BatteryPool`.  If not specified, all batteries available in the component\n            graph are used.\n        name: An optional name used to identify this instance of the pool or a\n            corresponding actor in the logs.\n        set_operating_point: Whether this instance sets the operating point power or the\n            normal power for the components.\n\n    Returns:\n        A `BatteryPool` instance.\n    \"\"\"\n    return _get().new_battery_pool(\n        priority=priority,\n        component_ids=component_ids,\n        name=name,\n        set_operating_point=set_operating_point,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.new_ev_charger_pool","title":"frequenz.sdk.microgrid.new_ev_charger_pool","text":"<pre><code>new_ev_charger_pool(\n    *,\n    priority: int,\n    component_ids: Set[int] | None = None,\n    name: str | None = None,\n    set_operating_point: bool = False\n) -&gt; EVChargerPool\n</code></pre> <p>Return a new <code>EVChargerPool</code> instance for the given parameters.</p> <p>The priority value is used to resolve conflicts when multiple actors are trying to propose different power values for the same set of EV chargers.</p> <p>Note</p> <p>When specifying priority, bigger values indicate higher priority.</p> <p>It is recommended to reuse the same instance of the <code>EVChargerPool</code> within the same actor, unless they are managing different sets of EV chargers.</p> <p>In deployments with multiple actors managing the same set of EV chargers, it is recommended to use different priorities to distinguish between them.  If not, a random prioritization will be imposed on them to resolve conflicts, which may lead to unexpected behavior like longer duration to converge on the desired power.</p> PARAMETER DESCRIPTION <code>priority</code> <p>The priority of the actor making the call.</p> <p> TYPE: <code>int</code> </p> <code>component_ids</code> <p>Optional set of IDs of EV Chargers to be managed by the EVChargerPool.  If not specified, all EV Chargers available in the component graph are used.</p> <p> TYPE: <code>Set[int] | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>An optional name used to identify this instance of the pool or a corresponding actor in the logs.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>set_operating_point</code> <p>Whether this instance sets the operating point power or the normal power for the components.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>EVChargerPool</code> <p>An <code>EVChargerPool</code> instance.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def new_ev_charger_pool(\n    *,\n    priority: int,\n    component_ids: abc.Set[int] | None = None,\n    name: str | None = None,\n    set_operating_point: bool = False,\n) -&gt; EVChargerPool:\n    \"\"\"Return a new `EVChargerPool` instance for the given parameters.\n\n    The priority value is used to resolve conflicts when multiple actors are trying to\n    propose different power values for the same set of EV chargers.\n\n    !!! note\n        When specifying priority, bigger values indicate higher priority.\n\n        It is recommended to reuse the same instance of the `EVChargerPool` within the\n        same actor, unless they are managing different sets of EV chargers.\n\n        In deployments with multiple actors managing the same set of EV chargers, it is\n        recommended to use different priorities to distinguish between them.  If not,\n        a random prioritization will be imposed on them to resolve conflicts, which may\n        lead to unexpected behavior like longer duration to converge on the desired\n        power.\n\n    Args:\n        priority: The priority of the actor making the call.\n        component_ids: Optional set of IDs of EV Chargers to be managed by the\n            EVChargerPool.  If not specified, all EV Chargers available in the\n            component graph are used.\n        name: An optional name used to identify this instance of the pool or a\n            corresponding actor in the logs.\n        set_operating_point: Whether this instance sets the operating point power or the\n            normal power for the components.\n\n    Returns:\n        An `EVChargerPool` instance.\n    \"\"\"\n    return _get().new_ev_charger_pool(\n        priority=priority,\n        component_ids=component_ids,\n        name=name,\n        set_operating_point=set_operating_point,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.new_pv_pool","title":"frequenz.sdk.microgrid.new_pv_pool","text":"<pre><code>new_pv_pool(\n    *,\n    priority: int,\n    component_ids: Set[int] | None = None,\n    name: str | None = None,\n    set_operating_point: bool = False\n) -&gt; PVPool\n</code></pre> <p>Return a new <code>PVPool</code> instance for the given parameters.</p> <p>The priority value is used to resolve conflicts when multiple actors are trying to propose different power values for the same set of PV inverters.</p> <p>Note</p> <p>When specifying priority, bigger values indicate higher priority.</p> <p>It is recommended to reuse the same instance of the <code>PVPool</code> within the same actor, unless they are managing different sets of PV inverters.</p> <p>In deployments with multiple actors managing the same set of PV inverters, it is recommended to use different priorities to distinguish between them.  If not, a random prioritization will be imposed on them to resolve conflicts, which may lead to unexpected behavior like longer duration to converge on the desired power.</p> PARAMETER DESCRIPTION <code>priority</code> <p>The priority of the actor making the call.</p> <p> TYPE: <code>int</code> </p> <code>component_ids</code> <p>Optional set of IDs of PV inverters to be managed by the <code>PVPool</code>. If not specified, all PV inverters available in the component graph are used.</p> <p> TYPE: <code>Set[int] | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>An optional name used to identify this instance of the pool or a corresponding actor in the logs.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>set_operating_point</code> <p>Whether this instance sets the operating point power or the normal power for the components.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>PVPool</code> <p>A <code>PVPool</code> instance.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def new_pv_pool(\n    *,\n    priority: int,\n    component_ids: abc.Set[int] | None = None,\n    name: str | None = None,\n    set_operating_point: bool = False,\n) -&gt; PVPool:\n    \"\"\"Return a new `PVPool` instance for the given parameters.\n\n    The priority value is used to resolve conflicts when multiple actors are trying to\n    propose different power values for the same set of PV inverters.\n\n    !!! note\n        When specifying priority, bigger values indicate higher priority.\n\n        It is recommended to reuse the same instance of the `PVPool` within the same\n        actor, unless they are managing different sets of PV inverters.\n\n        In deployments with multiple actors managing the same set of PV inverters, it is\n        recommended to use different priorities to distinguish between them.  If not,\n        a random prioritization will be imposed on them to resolve conflicts, which may\n        lead to unexpected behavior like longer duration to converge on the desired\n        power.\n\n    Args:\n        priority: The priority of the actor making the call.\n        component_ids: Optional set of IDs of PV inverters to be managed by the\n            `PVPool`. If not specified, all PV inverters available in the component\n            graph are used.\n        name: An optional name used to identify this instance of the pool or a\n            corresponding actor in the logs.\n        set_operating_point: Whether this instance sets the operating point power or the\n            normal power for the components.\n\n    Returns:\n        A `PVPool` instance.\n    \"\"\"\n    return _get().new_pv_pool(\n        priority=priority,\n        component_ids=component_ids,\n        name=name,\n        set_operating_point=set_operating_point,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.producer","title":"frequenz.sdk.microgrid.producer","text":"<pre><code>producer() -&gt; Producer\n</code></pre> <p>Return the <code>Production</code> measuring point.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def producer() -&gt; Producer:\n    \"\"\"Return the [`Production`][frequenz.sdk.timeseries.producer.Producer] measuring point.\"\"\"\n    return _get().producer()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.voltage_per_phase","title":"frequenz.sdk.microgrid.voltage_per_phase","text":"<pre><code>voltage_per_phase() -&gt; VoltageStreamer\n</code></pre> <p>Return the per-phase voltage measuring point.</p> Source code in <code>frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def voltage_per_phase() -&gt; VoltageStreamer:\n    \"\"\"Return the per-phase voltage measuring point.\"\"\"\n    return _get().voltage_per_phase()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/","title":"component_graph","text":""},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph","title":"frequenz.sdk.microgrid.component_graph","text":"<p>Defines a graph representation of how microgrid components are connected.</p> <p>The component graph is an approximate representation of the microgrid circuit, abstracted to a level appropriate for higher-level monitoring and control. Examples of use-cases would be:</p> <ul> <li> <p>using the graph structure to infer which component measurements     need to be combined to obtain grid power or onsite load</p> </li> <li> <p>identifying which inverter(s) need to be engaged to (dis)charge     a particular battery</p> </li> <li> <p>understanding which power flows in the microgrid are derived from     green and grey sources</p> </li> </ul> <p>It deliberately does not include all pieces of hardware placed in the microgrid, instead limiting itself to just those that are needed to monitor and control the flow of power.</p>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph","title":"frequenz.sdk.microgrid.component_graph.ComponentGraph","text":"<p>               Bases: <code>ABC</code></p> <p>Interface for component graph implementations.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>class ComponentGraph(ABC):\n    \"\"\"Interface for component graph implementations.\"\"\"\n\n    @abstractmethod\n    def components(\n        self,\n        component_ids: set[int] | None = None,\n        component_categories: set[ComponentCategory] | None = None,\n    ) -&gt; set[Component]:\n        \"\"\"Fetch the components of the microgrid.\n\n        Args:\n            component_ids: filter out any components not matching one of the provided IDs\n            component_categories: filter out any components not matching one of the\n                provided types\n\n        Returns:\n            Set of the components currently connected to the microgrid, filtered by\n                the provided `component_ids` and `component_categories` values.\n        \"\"\"\n\n    @abstractmethod\n    def connections(\n        self,\n        start: set[int] | None = None,\n        end: set[int] | None = None,\n    ) -&gt; set[Connection]:\n        \"\"\"Fetch the connections between microgrid components.\n\n        Args:\n            start: filter out any connections whose `start` does not match one of these\n                component IDs\n            end: filter out any connections whose `end` does not match one of these\n                component IDs\n\n        Returns:\n            Set of the connections between components in the microgrid, filtered by\n                the provided `start`/`end` choices.\n        \"\"\"\n\n    @abstractmethod\n    def predecessors(self, component_id: int) -&gt; set[Component]:\n        \"\"\"Fetch the graph predecessors of the specified component.\n\n        Args:\n            component_id: numerical ID of the component whose predecessors should be\n                fetched\n\n        Returns:\n            Set of IDs of the components that are predecessors of `component_id`,\n                i.e. for which there is a connection from each of these components to\n                `component_id`.\n\n        Raises:\n            KeyError: if the specified `component_id` is not in the graph\n        \"\"\"\n\n    @abstractmethod\n    def successors(self, component_id: int) -&gt; set[Component]:\n        \"\"\"Fetch the graph successors of the specified component.\n\n        Args:\n            component_id: numerical ID of the component whose successors should be\n                fetched\n\n        Returns:\n            Set of IDs of the components that are successors of `component_id`,\n                i.e. for which there is a connection from `component_id` to each of\n                these components.\n\n        Raises:\n            KeyError: if the specified `component_id` is not in the graph\n        \"\"\"\n\n    @abstractmethod\n    def is_pv_inverter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a PV inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a PV inverter.\n        \"\"\"\n\n    @abstractmethod\n    def is_pv_meter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a PV meter.\n\n        This is done by checking if the component has only PV inverters as its\n        successors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a PV meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_pv_chain(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is part of a PV chain.\n\n        A component is part of a PV chain if it is a PV meter or a PV inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of a PV chain.\n        \"\"\"\n\n    @abstractmethod\n    def is_battery_inverter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a battery inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a battery inverter.\n        \"\"\"\n\n    @abstractmethod\n    def is_battery_meter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a battery meter.\n\n        This is done by checking if the component has only battery inverters as its\n        predecessors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a battery meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_battery_chain(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is part of a battery chain.\n\n        A component is part of a battery chain if it is a battery meter or a battery\n        inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of a battery chain.\n        \"\"\"\n\n    @abstractmethod\n    def is_ev_charger(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is an EV charger.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is an EV charger.\n        \"\"\"\n\n    @abstractmethod\n    def is_ev_charger_meter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is an EV charger meter.\n\n        This is done by checking if the component has only EV chargers as its\n        successors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is an EV charger meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_ev_charger_chain(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is part of an EV charger chain.\n\n        A component is part of an EV charger chain if it is an EV charger meter or an\n        EV charger.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of an EV charger chain.\n        \"\"\"\n\n    @abstractmethod\n    def is_chp(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a CHP.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a CHP.\n        \"\"\"\n\n    @abstractmethod\n    def is_chp_meter(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is a CHP meter.\n\n        This is done by checking if the component has only CHPs as its successors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a CHP meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_chp_chain(self, component: Component) -&gt; bool:\n        \"\"\"Check if the specified component is part of a CHP chain.\n\n        A component is part of a CHP chain if it is a CHP meter or a CHP.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of a CHP chain.\n        \"\"\"\n\n    @abstractmethod\n    def dfs(\n        self,\n        current_node: Component,\n        visited: set[Component],\n        condition: Callable[[Component], bool],\n    ) -&gt; set[Component]:\n        \"\"\"\n        Search for components that fulfill the condition in the Graph.\n\n        DFS is used for searching the graph. The graph traversal is stopped\n        once a component fulfills the condition.\n\n        Args:\n            current_node: The current node to search from.\n            visited: The set of visited nodes.\n            condition: The condition function to check for.\n\n        Returns:\n            A set of component ids where the corresponding components fulfill\n            the condition function.\n        \"\"\"\n\n    @abstractmethod\n    def find_first_descendant_component(\n        self,\n        *,\n        root_category: ComponentCategory,\n        descendant_categories: Iterable[ComponentCategory],\n    ) -&gt; Component:\n        \"\"\"Find the first descendant component given root and descendant categories.\n\n        This method searches for the root component within the provided root\n        category. If multiple components share the same root category, the\n        first found one is considered as the root component.\n\n        Subsequently, it looks for the first descendant component from the root\n        component, considering only the immediate descendants.\n\n        The priority of the component to search for is determined by the order\n        of the descendant categories, with the first category having the\n        highest priority.\n\n        Args:\n            root_category: The category of the root component to search for.\n            descendant_categories: The descendant categories to search for the\n                first descendant component in.\n\n        Returns:\n            The first descendant component found in the component graph,\n            considering the specified root and descendant categories.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.components","title":"components  <code>abstractmethod</code>","text":"<pre><code>components(\n    component_ids: set[int] | None = None,\n    component_categories: (\n        set[ComponentCategory] | None\n    ) = None,\n) -&gt; set[Component]\n</code></pre> <p>Fetch the components of the microgrid.</p> PARAMETER DESCRIPTION <code>component_ids</code> <p>filter out any components not matching one of the provided IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>component_categories</code> <p>filter out any components not matching one of the provided types</p> <p> TYPE: <code>set[ComponentCategory] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>Set of the components currently connected to the microgrid, filtered by the provided <code>component_ids</code> and <code>component_categories</code> values.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef components(\n    self,\n    component_ids: set[int] | None = None,\n    component_categories: set[ComponentCategory] | None = None,\n) -&gt; set[Component]:\n    \"\"\"Fetch the components of the microgrid.\n\n    Args:\n        component_ids: filter out any components not matching one of the provided IDs\n        component_categories: filter out any components not matching one of the\n            provided types\n\n    Returns:\n        Set of the components currently connected to the microgrid, filtered by\n            the provided `component_ids` and `component_categories` values.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.connections","title":"connections  <code>abstractmethod</code>","text":"<pre><code>connections(\n    start: set[int] | None = None,\n    end: set[int] | None = None,\n) -&gt; set[Connection]\n</code></pre> <p>Fetch the connections between microgrid components.</p> PARAMETER DESCRIPTION <code>start</code> <p>filter out any connections whose <code>start</code> does not match one of these component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>end</code> <p>filter out any connections whose <code>end</code> does not match one of these component IDs</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>set[Connection]</code> <p>Set of the connections between components in the microgrid, filtered by the provided <code>start</code>/<code>end</code> choices.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef connections(\n    self,\n    start: set[int] | None = None,\n    end: set[int] | None = None,\n) -&gt; set[Connection]:\n    \"\"\"Fetch the connections between microgrid components.\n\n    Args:\n        start: filter out any connections whose `start` does not match one of these\n            component IDs\n        end: filter out any connections whose `end` does not match one of these\n            component IDs\n\n    Returns:\n        Set of the connections between components in the microgrid, filtered by\n            the provided `start`/`end` choices.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.dfs","title":"dfs  <code>abstractmethod</code>","text":"<pre><code>dfs(\n    current_node: Component,\n    visited: set[Component],\n    condition: Callable[[Component], bool],\n) -&gt; set[Component]\n</code></pre> <p>Search for components that fulfill the condition in the Graph.</p> <p>DFS is used for searching the graph. The graph traversal is stopped once a component fulfills the condition.</p> PARAMETER DESCRIPTION <code>current_node</code> <p>The current node to search from.</p> <p> TYPE: <code>Component</code> </p> <code>visited</code> <p>The set of visited nodes.</p> <p> TYPE: <code>set[Component]</code> </p> <code>condition</code> <p>The condition function to check for.</p> <p> TYPE: <code>Callable[[Component], bool]</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>A set of component ids where the corresponding components fulfill</p> <code>set[Component]</code> <p>the condition function.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef dfs(\n    self,\n    current_node: Component,\n    visited: set[Component],\n    condition: Callable[[Component], bool],\n) -&gt; set[Component]:\n    \"\"\"\n    Search for components that fulfill the condition in the Graph.\n\n    DFS is used for searching the graph. The graph traversal is stopped\n    once a component fulfills the condition.\n\n    Args:\n        current_node: The current node to search from.\n        visited: The set of visited nodes.\n        condition: The condition function to check for.\n\n    Returns:\n        A set of component ids where the corresponding components fulfill\n        the condition function.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.find_first_descendant_component","title":"find_first_descendant_component  <code>abstractmethod</code>","text":"<pre><code>find_first_descendant_component(\n    *,\n    root_category: ComponentCategory,\n    descendant_categories: Iterable[ComponentCategory]\n) -&gt; Component\n</code></pre> <p>Find the first descendant component given root and descendant categories.</p> <p>This method searches for the root component within the provided root category. If multiple components share the same root category, the first found one is considered as the root component.</p> <p>Subsequently, it looks for the first descendant component from the root component, considering only the immediate descendants.</p> <p>The priority of the component to search for is determined by the order of the descendant categories, with the first category having the highest priority.</p> PARAMETER DESCRIPTION <code>root_category</code> <p>The category of the root component to search for.</p> <p> TYPE: <code>ComponentCategory</code> </p> <code>descendant_categories</code> <p>The descendant categories to search for the first descendant component in.</p> <p> TYPE: <code>Iterable[ComponentCategory]</code> </p> RETURNS DESCRIPTION <code>Component</code> <p>The first descendant component found in the component graph,</p> <code>Component</code> <p>considering the specified root and descendant categories.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef find_first_descendant_component(\n    self,\n    *,\n    root_category: ComponentCategory,\n    descendant_categories: Iterable[ComponentCategory],\n) -&gt; Component:\n    \"\"\"Find the first descendant component given root and descendant categories.\n\n    This method searches for the root component within the provided root\n    category. If multiple components share the same root category, the\n    first found one is considered as the root component.\n\n    Subsequently, it looks for the first descendant component from the root\n    component, considering only the immediate descendants.\n\n    The priority of the component to search for is determined by the order\n    of the descendant categories, with the first category having the\n    highest priority.\n\n    Args:\n        root_category: The category of the root component to search for.\n        descendant_categories: The descendant categories to search for the\n            first descendant component in.\n\n    Returns:\n        The first descendant component found in the component graph,\n        considering the specified root and descendant categories.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_battery_chain","title":"is_battery_chain  <code>abstractmethod</code>","text":"<pre><code>is_battery_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of a battery chain.</p> <p>A component is part of a battery chain if it is a battery meter or a battery inverter.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a battery chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_chain(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is part of a battery chain.\n\n    A component is part of a battery chain if it is a battery meter or a battery\n    inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of a battery chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_battery_inverter","title":"is_battery_inverter  <code>abstractmethod</code>","text":"<pre><code>is_battery_inverter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a battery inverter.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a battery inverter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_inverter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a battery inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a battery inverter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_battery_meter","title":"is_battery_meter  <code>abstractmethod</code>","text":"<pre><code>is_battery_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a battery meter.</p> <p>This is done by checking if the component has only battery inverters as its predecessors.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a battery meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_meter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a battery meter.\n\n    This is done by checking if the component has only battery inverters as its\n    predecessors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a battery meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_chp","title":"is_chp  <code>abstractmethod</code>","text":"<pre><code>is_chp(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a CHP.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a CHP.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_chp(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a CHP.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a CHP.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_chp_chain","title":"is_chp_chain  <code>abstractmethod</code>","text":"<pre><code>is_chp_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of a CHP chain.</p> <p>A component is part of a CHP chain if it is a CHP meter or a CHP.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a CHP chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_chp_chain(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is part of a CHP chain.\n\n    A component is part of a CHP chain if it is a CHP meter or a CHP.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of a CHP chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_chp_meter","title":"is_chp_meter  <code>abstractmethod</code>","text":"<pre><code>is_chp_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a CHP meter.</p> <p>This is done by checking if the component has only CHPs as its successors.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a CHP meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_chp_meter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a CHP meter.\n\n    This is done by checking if the component has only CHPs as its successors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a CHP meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_ev_charger","title":"is_ev_charger  <code>abstractmethod</code>","text":"<pre><code>is_ev_charger(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is an EV charger.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is an EV charger.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is an EV charger.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is an EV charger.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_ev_charger_chain","title":"is_ev_charger_chain  <code>abstractmethod</code>","text":"<pre><code>is_ev_charger_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of an EV charger chain.</p> <p>A component is part of an EV charger chain if it is an EV charger meter or an EV charger.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of an EV charger chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger_chain(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is part of an EV charger chain.\n\n    A component is part of an EV charger chain if it is an EV charger meter or an\n    EV charger.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of an EV charger chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_ev_charger_meter","title":"is_ev_charger_meter  <code>abstractmethod</code>","text":"<pre><code>is_ev_charger_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is an EV charger meter.</p> <p>This is done by checking if the component has only EV chargers as its successors.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is an EV charger meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger_meter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is an EV charger meter.\n\n    This is done by checking if the component has only EV chargers as its\n    successors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is an EV charger meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_pv_chain","title":"is_pv_chain  <code>abstractmethod</code>","text":"<pre><code>is_pv_chain(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is part of a PV chain.</p> <p>A component is part of a PV chain if it is a PV meter or a PV inverter.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a PV chain.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_chain(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is part of a PV chain.\n\n    A component is part of a PV chain if it is a PV meter or a PV inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of a PV chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_pv_inverter","title":"is_pv_inverter  <code>abstractmethod</code>","text":"<pre><code>is_pv_inverter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a PV inverter.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a PV inverter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_inverter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a PV inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a PV inverter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.is_pv_meter","title":"is_pv_meter  <code>abstractmethod</code>","text":"<pre><code>is_pv_meter(component: Component) -&gt; bool\n</code></pre> <p>Check if the specified component is a PV meter.</p> <p>This is done by checking if the component has only PV inverters as its successors.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a PV meter.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_meter(self, component: Component) -&gt; bool:\n    \"\"\"Check if the specified component is a PV meter.\n\n    This is done by checking if the component has only PV inverters as its\n    successors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a PV meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.predecessors","title":"predecessors  <code>abstractmethod</code>","text":"<pre><code>predecessors(component_id: int) -&gt; set[Component]\n</code></pre> <p>Fetch the graph predecessors of the specified component.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>numerical ID of the component whose predecessors should be fetched</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>Set of IDs of the components that are predecessors of <code>component_id</code>, i.e. for which there is a connection from each of these components to <code>component_id</code>.</p> RAISES DESCRIPTION <code>KeyError</code> <p>if the specified <code>component_id</code> is not in the graph</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef predecessors(self, component_id: int) -&gt; set[Component]:\n    \"\"\"Fetch the graph predecessors of the specified component.\n\n    Args:\n        component_id: numerical ID of the component whose predecessors should be\n            fetched\n\n    Returns:\n        Set of IDs of the components that are predecessors of `component_id`,\n            i.e. for which there is a connection from each of these components to\n            `component_id`.\n\n    Raises:\n        KeyError: if the specified `component_id` is not in the graph\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.ComponentGraph.successors","title":"successors  <code>abstractmethod</code>","text":"<pre><code>successors(component_id: int) -&gt; set[Component]\n</code></pre> <p>Fetch the graph successors of the specified component.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>numerical ID of the component whose successors should be fetched</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>set[Component]</code> <p>Set of IDs of the components that are successors of <code>component_id</code>, i.e. for which there is a connection from <code>component_id</code> to each of these components.</p> RAISES DESCRIPTION <code>KeyError</code> <p>if the specified <code>component_id</code> is not in the graph</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>@abstractmethod\ndef successors(self, component_id: int) -&gt; set[Component]:\n    \"\"\"Fetch the graph successors of the specified component.\n\n    Args:\n        component_id: numerical ID of the component whose successors should be\n            fetched\n\n    Returns:\n        Set of IDs of the components that are successors of `component_id`,\n            i.e. for which there is a connection from `component_id` to each of\n            these components.\n\n    Raises:\n        KeyError: if the specified `component_id` is not in the graph\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component_graph/#frequenz.sdk.microgrid.component_graph.InvalidGraphError","title":"frequenz.sdk.microgrid.component_graph.InvalidGraphError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception type that will be thrown if graph data is not valid.</p> Source code in <code>frequenz/sdk/microgrid/component_graph.py</code> <pre><code>class InvalidGraphError(Exception):\n    \"\"\"Exception type that will be thrown if graph data is not valid.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/","title":"connection_manager","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager","title":"frequenz.sdk.microgrid.connection_manager","text":"<p>Microgrid Connection Manager singleton abstraction.</p> <p>This module provides a singleton abstraction over the microgrid. The main purpose is to provide the connection the microgrid API client and the microgrid component graph.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager","title":"frequenz.sdk.microgrid.connection_manager.ConnectionManager","text":"<p>               Bases: <code>ABC</code></p> <p>Creates and stores core features.</p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>class ConnectionManager(ABC):\n    \"\"\"Creates and stores core features.\"\"\"\n\n    def __init__(self, server_url: str) -&gt; None:\n        \"\"\"Create object instance.\n\n        Args:\n            server_url: The location of the microgrid API server in the form of a URL.\n                The following format is expected: `grpc://hostname{:port}{?ssl=ssl}`,\n                where the port should be an int between `0` and `65535` (defaulting to\n                `9090`) and ssl should be a boolean (defaulting to false). For example:\n                `grpc://localhost:1090?ssl=true`.\n        \"\"\"\n        super().__init__()\n        self._server_url = server_url\n\n    @property\n    def server_url(self) -&gt; str:\n        \"\"\"The location of the microgrid API server in the form of a URL.\"\"\"\n        return self._server_url\n\n    @property\n    @abstractmethod\n    def api_client(self) -&gt; ApiClient:\n        \"\"\"Get ApiClient.\n\n        Returns:\n            api client\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def component_graph(self) -&gt; ComponentGraph:\n        \"\"\"Get component graph.\n\n        Returns:\n            component graph\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def microgrid_id(self) -&gt; int | None:\n        \"\"\"Get the ID of the microgrid if available.\n\n        Returns:\n            the ID of the microgrid if available, None otherwise.\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def location(self) -&gt; Location | None:\n        \"\"\"Get the location of the microgrid if available.\n\n        Returns:\n            the location of the microgrid if available, None otherwise.\n        \"\"\"\n\n    async def _update_api(self, server_url: str) -&gt; None:\n        self._server_url = server_url\n\n    @abstractmethod\n    async def _initialize(self) -&gt; None:\n        \"\"\"Initialize the object. This function should be called only once.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.api_client","title":"api_client  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>api_client: ApiClient\n</code></pre> <p>Get ApiClient.</p> RETURNS DESCRIPTION <code>ApiClient</code> <p>api client</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.component_graph","title":"component_graph  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>component_graph: ComponentGraph\n</code></pre> <p>Get component graph.</p> RETURNS DESCRIPTION <code>ComponentGraph</code> <p>component graph</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.location","title":"location  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>location: Location | None\n</code></pre> <p>Get the location of the microgrid if available.</p> RETURNS DESCRIPTION <code>Location | None</code> <p>the location of the microgrid if available, None otherwise.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.microgrid_id","title":"microgrid_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>microgrid_id: int | None\n</code></pre> <p>Get the ID of the microgrid if available.</p> RETURNS DESCRIPTION <code>int | None</code> <p>the ID of the microgrid if available, None otherwise.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.server_url","title":"server_url  <code>property</code>","text":"<pre><code>server_url: str\n</code></pre> <p>The location of the microgrid API server in the form of a URL.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.__init__","title":"__init__","text":"<pre><code>__init__(server_url: str) -&gt; None\n</code></pre> <p>Create object instance.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The location of the microgrid API server in the form of a URL. The following format is expected: <code>grpc://hostname{:port}{?ssl=ssl}</code>, where the port should be an int between <code>0</code> and <code>65535</code> (defaulting to <code>9090</code>) and ssl should be a boolean (defaulting to false). For example: <code>grpc://localhost:1090?ssl=true</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>def __init__(self, server_url: str) -&gt; None:\n    \"\"\"Create object instance.\n\n    Args:\n        server_url: The location of the microgrid API server in the form of a URL.\n            The following format is expected: `grpc://hostname{:port}{?ssl=ssl}`,\n            where the port should be an int between `0` and `65535` (defaulting to\n            `9090`) and ssl should be a boolean (defaulting to false). For example:\n            `grpc://localhost:1090?ssl=true`.\n    \"\"\"\n    super().__init__()\n    self._server_url = server_url\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.get","title":"frequenz.sdk.microgrid.connection_manager.get","text":"<pre><code>get() -&gt; ConnectionManager\n</code></pre> <p>Get the MicrogridApi instance created by initialize().</p> <p>This function should be only called after initialize().</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Raised when: * If <code>initialize()</code> method was not called before this call. * If <code>initialize()</code> methods was called but was not awaited and instance was     not created yet.</p> RETURNS DESCRIPTION <code>ConnectionManager</code> <p>MicrogridApi instance.</p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>def get() -&gt; ConnectionManager:\n    \"\"\"Get the MicrogridApi instance created by initialize().\n\n    This function should be only called after initialize().\n\n    Raises:\n        RuntimeError: Raised when:\n            * If `initialize()` method was not called before this call.\n            * If `initialize()` methods was called but was not awaited and instance was\n                not created yet.\n\n    Returns:\n        MicrogridApi instance.\n    \"\"\"\n    if _CONNECTION_MANAGER is None:\n        raise RuntimeError(\n            \"ConnectionManager is not initialized. \"\n            \"Call `await microgrid.initialize()` first.\"\n        )\n\n    return _CONNECTION_MANAGER\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.initialize","title":"frequenz.sdk.microgrid.connection_manager.initialize  <code>async</code>","text":"<pre><code>initialize(server_url: str) -&gt; None\n</code></pre> <p>Initialize the MicrogridApi. This function should be called only once.</p> PARAMETER DESCRIPTION <code>server_url</code> <p>The location of the microgrid API server in the form of a URL. The following format is expected: <code>grpc://hostname{:port}{?ssl=ssl}</code>, where the port should be an int between <code>0</code> and <code>65535</code> (defaulting to <code>9090</code>) and ssl should be a boolean (defaulting to false). For example: <code>grpc://localhost:1090?ssl=true</code>.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If method was called more then once.</p> Source code in <code>frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>async def initialize(server_url: str) -&gt; None:\n    \"\"\"Initialize the MicrogridApi. This function should be called only once.\n\n    Args:\n        server_url: The location of the microgrid API server in the form of a URL.\n            The following format is expected: `grpc://hostname{:port}{?ssl=ssl}`,\n            where the port should be an int between `0` and `65535` (defaulting to\n            `9090`) and ssl should be a boolean (defaulting to false). For example:\n            `grpc://localhost:1090?ssl=true`.\n\n    Raises:\n        AssertionError: If method was called more then once.\n    \"\"\"\n    # From Doc: pylint just try to discourage this usage.\n    # That doesn't mean you cannot use it.\n    global _CONNECTION_MANAGER  # pylint: disable=global-statement\n\n    if _CONNECTION_MANAGER is not None:\n        raise AssertionError(\"MicrogridApi was already initialized.\")\n\n    _logger.info(\"Connecting to microgrid at %s\", server_url)\n\n    microgrid_api = _InsecureConnectionManager(server_url)\n    await microgrid_api._initialize()  # pylint: disable=protected-access\n\n    # Check again that _MICROGRID_API is None in case somebody had the great idea of\n    # calling initialize() twice and in parallel.\n    if _CONNECTION_MANAGER is not None:\n        raise AssertionError(\"MicrogridApi was already initialized.\")\n\n    _CONNECTION_MANAGER = microgrid_api\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/","title":"Index","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries","title":"frequenz.sdk.timeseries","text":"<p>Handling of timeseries streams.</p> <p>A timeseries is a stream (normally an async iterator) of <code>Sample</code>s.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries--periodicity-and-alignment","title":"Periodicity and alignment","text":"<p>All the data produced by this package is always periodic and aligned to the <code>UNIX_EPOCH</code> (by default).</p> <p>Classes normally take a (re)sampling period as and argument and, optionally, an <code>align_to</code> argument.</p> <p>This means timestamps are always separated exactly by a period, and that this timestamp falls always at multiples of the period, starting at the <code>align_to</code>.</p> <p>This ensures that the data is predictable and consistent among restarts.</p> Example <p>If we have a period of 10 seconds, and are aligning to the UNIX epoch. Assuming the following timeline starts in 1970-01-01 00:00:00 UTC and our current <code>now</code> is 1970-01-01 00:00:32 UTC, then the next timestamp will be at 1970-01-01 00:00:40 UTC:</p> <pre><code>align_to = 1970-01-01 00:00:00         next event = 1970-01-01 00:00:40\n|                                       |\n|---------|---------|---------|-|-------|---------|---------|---------|\n0        10        20        30 |      40        50        60        70\n                               now = 1970-01-01 00:00:32\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.UNIX_EPOCH","title":"frequenz.sdk.timeseries.UNIX_EPOCH  <code>module-attribute</code>","text":"<pre><code>UNIX_EPOCH = fromtimestamp(0.0, tz=utc)\n</code></pre> <p>The UNIX epoch (in UTC).</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds","title":"frequenz.sdk.timeseries.Bounds  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Lower and upper bound values.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Bounds(Generic[_T]):\n    \"\"\"Lower and upper bound values.\"\"\"\n\n    lower: _T\n    \"\"\"Lower bound.\"\"\"\n\n    upper: _T\n    \"\"\"Upper bound.\"\"\"\n\n    def __contains__(self, item: _T) -&gt; bool:\n        \"\"\"\n        Check if the value is within the range of the container.\n\n        Args:\n            item: The value to check.\n\n        Returns:\n            bool: True if value is within the range, otherwise False.\n        \"\"\"\n        if self.lower is None and self.upper is None:\n            return True\n        if self.lower is None:\n            return item &lt;= self.upper\n        if self.upper is None:\n            return self.lower &lt;= item\n\n        return cast(Comparable, self.lower) &lt;= item &lt;= cast(Comparable, self.upper)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: _T\n</code></pre> <p>Lower bound.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: _T\n</code></pre> <p>Upper bound.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Bounds.__contains__","title":"__contains__","text":"<pre><code>__contains__(item: _T) -&gt; bool\n</code></pre> <p>Check if the value is within the range of the container.</p> PARAMETER DESCRIPTION <code>item</code> <p>The value to check.</p> <p> TYPE: <code>_T</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if value is within the range, otherwise False.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def __contains__(self, item: _T) -&gt; bool:\n    \"\"\"\n    Check if the value is within the range of the container.\n\n    Args:\n        item: The value to check.\n\n    Returns:\n        bool: True if value is within the range, otherwise False.\n    \"\"\"\n    if self.lower is None and self.upper is None:\n        return True\n    if self.lower is None:\n        return item &lt;= self.upper\n    if self.upper is None:\n        return self.lower &lt;= item\n\n    return cast(Comparable, self.lower) &lt;= item &lt;= cast(Comparable, self.upper)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current","title":"frequenz.sdk.timeseries.Current","text":"<p>               Bases: <code>Quantity</code></p> <p>A current quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Current(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={\n        -3: \"mA\",\n        0: \"A\",\n    },\n):\n    \"\"\"A current quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_amperes(cls, amperes: float) -&gt; Self:\n        \"\"\"Initialize a new current quantity.\n\n        Args:\n            amperes: The current in amperes.\n\n        Returns:\n            A new current quantity.\n        \"\"\"\n        return cls._new(amperes)\n\n    @classmethod\n    def from_milliamperes(cls, milliamperes: float) -&gt; Self:\n        \"\"\"Initialize a new current quantity.\n\n        Args:\n            milliamperes: The current in milliamperes.\n\n        Returns:\n            A new current quantity.\n        \"\"\"\n        return cls._new(milliamperes, exponent=-3)\n\n    def as_amperes(self) -&gt; float:\n        \"\"\"Return the current in amperes.\n\n        Returns:\n            The current in amperes.\n        \"\"\"\n        return self._base_value\n\n    def as_milliamperes(self) -&gt; float:\n        \"\"\"Return the current in milliamperes.\n\n        Returns:\n            The current in milliamperes.\n        \"\"\"\n        return self._base_value * 1e3\n\n    # See comment for Power.__mul__ for why we need the ignore here.\n    @overload  # type: ignore[override]\n    def __mul__(self, scalar: float, /) -&gt; Self:\n        \"\"\"Scale this current by a scalar.\n\n        Args:\n            scalar: The scalar by which to scale this current.\n\n        Returns:\n            The scaled current.\n        \"\"\"\n\n    @overload\n    def __mul__(self, percent: Percentage, /) -&gt; Self:\n        \"\"\"Scale this current by a percentage.\n\n        Args:\n            percent: The percentage by which to scale this current.\n\n        Returns:\n            The scaled current.\n        \"\"\"\n\n    @overload\n    def __mul__(self, other: Voltage, /) -&gt; Power:\n        \"\"\"Multiply the current by a voltage to get a power.\n\n        Args:\n            other: The voltage.\n\n        Returns:\n            The calculated power.\n        \"\"\"\n\n    def __mul__(self, other: float | Percentage | Voltage, /) -&gt; Self | Power:\n        \"\"\"Return a current or power from multiplying this current by the given value.\n\n        Args:\n            other: The scalar, percentage or voltage to multiply by.\n\n        Returns:\n            A current or power.\n        \"\"\"\n        match other:\n            case float() | Percentage():\n                return super().__mul__(other)\n            case Voltage():\n                return Power._new(self._base_value * other._base_value)\n            case _:\n                return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__mul__","title":"__mul__","text":"<pre><code>__mul__(\n    other: float | Percentage | Voltage,\n) -&gt; Self | Power\n</code></pre> <p>Return a current or power from multiplying this current by the given value.</p> PARAMETER DESCRIPTION <code>other</code> <p>The scalar, percentage or voltage to multiply by.</p> <p> TYPE: <code>float | Percentage | Voltage</code> </p> RETURNS DESCRIPTION <code>Self | Power</code> <p>A current or power.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: float | Percentage | Voltage, /) -&gt; Self | Power:\n    \"\"\"Return a current or power from multiplying this current by the given value.\n\n    Args:\n        other: The scalar, percentage or voltage to multiply by.\n\n    Returns:\n        A current or power.\n    \"\"\"\n    match other:\n        case float() | Percentage():\n            return super().__mul__(other)\n        case Voltage():\n            return Power._new(self._base_value * other._base_value)\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.as_amperes","title":"as_amperes","text":"<pre><code>as_amperes() -&gt; float\n</code></pre> <p>Return the current in amperes.</p> RETURNS DESCRIPTION <code>float</code> <p>The current in amperes.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_amperes(self) -&gt; float:\n    \"\"\"Return the current in amperes.\n\n    Returns:\n        The current in amperes.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.as_milliamperes","title":"as_milliamperes","text":"<pre><code>as_milliamperes() -&gt; float\n</code></pre> <p>Return the current in milliamperes.</p> RETURNS DESCRIPTION <code>float</code> <p>The current in milliamperes.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_milliamperes(self) -&gt; float:\n    \"\"\"Return the current in milliamperes.\n\n    Returns:\n        The current in milliamperes.\n    \"\"\"\n    return self._base_value * 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.from_amperes","title":"from_amperes  <code>classmethod</code>","text":"<pre><code>from_amperes(amperes: float) -&gt; Self\n</code></pre> <p>Initialize a new current quantity.</p> PARAMETER DESCRIPTION <code>amperes</code> <p>The current in amperes.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new current quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_amperes(cls, amperes: float) -&gt; Self:\n    \"\"\"Initialize a new current quantity.\n\n    Args:\n        amperes: The current in amperes.\n\n    Returns:\n        A new current quantity.\n    \"\"\"\n    return cls._new(amperes)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.from_milliamperes","title":"from_milliamperes  <code>classmethod</code>","text":"<pre><code>from_milliamperes(milliamperes: float) -&gt; Self\n</code></pre> <p>Initialize a new current quantity.</p> PARAMETER DESCRIPTION <code>milliamperes</code> <p>The current in milliamperes.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new current quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_milliamperes(cls, milliamperes: float) -&gt; Self:\n    \"\"\"Initialize a new current quantity.\n\n    Args:\n        milliamperes: The current in milliamperes.\n\n    Returns:\n        A new current quantity.\n    \"\"\"\n    return cls._new(milliamperes, exponent=-3)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy","title":"frequenz.sdk.timeseries.Energy","text":"<p>               Bases: <code>Quantity</code></p> <p>An energy quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Energy(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={\n        0: \"Wh\",\n        3: \"kWh\",\n        6: \"MWh\",\n    },\n):\n    \"\"\"An energy quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_watt_hours(cls, watt_hours: float) -&gt; Self:\n        \"\"\"Initialize a new energy quantity.\n\n        Args:\n            watt_hours: The energy in watt hours.\n\n        Returns:\n            A new energy quantity.\n        \"\"\"\n        return cls._new(watt_hours)\n\n    @classmethod\n    def from_kilowatt_hours(cls, kilowatt_hours: float) -&gt; Self:\n        \"\"\"Initialize a new energy quantity.\n\n        Args:\n            kilowatt_hours: The energy in kilowatt hours.\n\n        Returns:\n            A new energy quantity.\n        \"\"\"\n        return cls._new(kilowatt_hours, exponent=3)\n\n    @classmethod\n    def from_megawatt_hours(cls, megawatt_hours: float) -&gt; Self:\n        \"\"\"Initialize a new energy quantity.\n\n        Args:\n            megawatt_hours: The energy in megawatt hours.\n\n        Returns:\n            A new energy quantity.\n        \"\"\"\n        return cls._new(megawatt_hours, exponent=6)\n\n    def as_watt_hours(self) -&gt; float:\n        \"\"\"Return the energy in watt hours.\n\n        Returns:\n            The energy in watt hours.\n        \"\"\"\n        return self._base_value\n\n    def as_kilowatt_hours(self) -&gt; float:\n        \"\"\"Return the energy in kilowatt hours.\n\n        Returns:\n            The energy in kilowatt hours.\n        \"\"\"\n        return self._base_value / 1e3\n\n    def as_megawatt_hours(self) -&gt; float:\n        \"\"\"Return the energy in megawatt hours.\n\n        Returns:\n            The energy in megawatt hours.\n        \"\"\"\n        return self._base_value / 1e6\n\n    def __mul__(self, other: float | Percentage) -&gt; Self:\n        \"\"\"Scale this energy by a percentage.\n\n        Args:\n            other: The percentage by which to scale this energy.\n\n        Returns:\n            The scaled energy.\n        \"\"\"\n        match other:\n            case float():\n                return self._new(self._base_value * other)\n            case Percentage():\n                return self._new(self._base_value * other.as_fraction())\n            case _:\n                return NotImplemented\n\n    # See the comment for Power.__mul__ for why we need the ignore here.\n    @overload  # type: ignore[override]\n    def __truediv__(self, other: float, /) -&gt; Self:\n        \"\"\"Divide this energy by a scalar.\n\n        Args:\n            other: The scalar to divide this energy by.\n\n        Returns:\n            The divided energy.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, other: Self, /) -&gt; float:\n        \"\"\"Return the ratio of this energy to another.\n\n        Args:\n            other: The other energy.\n\n        Returns:\n            The ratio of this energy to another.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, duration: timedelta, /) -&gt; Power:\n        \"\"\"Return a power from dividing this energy by the given duration.\n\n        Args:\n            duration: The duration to divide by.\n\n        Returns:\n            A power from dividing this energy by the given duration.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, power: Power, /) -&gt; timedelta:\n        \"\"\"Return a duration from dividing this energy by the given power.\n\n        Args:\n            power: The power to divide by.\n\n        Returns:\n            A duration from dividing this energy by the given power.\n        \"\"\"\n\n    def __truediv__(\n        self, other: float | Self | timedelta | Power, /\n    ) -&gt; Self | float | Power | timedelta:\n        \"\"\"Return a power or duration from dividing this energy by the given value.\n\n        Args:\n            other: The scalar, energy, power or duration to divide by.\n\n        Returns:\n            A power or duration from dividing this energy by the given value.\n        \"\"\"\n        match other:\n            case float():\n                return super().__truediv__(other)\n            case Energy():\n                return self._base_value / other._base_value\n            case timedelta():\n                return Power._new(self._base_value / (other.total_seconds() / 3600.0))\n            case Power():\n                return timedelta(\n                    seconds=(self._base_value / other._base_value) * 3600.0\n                )\n            case _:\n                return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: float | Percentage) -&gt; Self\n</code></pre> <p>Scale this energy by a percentage.</p> PARAMETER DESCRIPTION <code>other</code> <p>The percentage by which to scale this energy.</p> <p> TYPE: <code>float | Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled energy.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: float | Percentage) -&gt; Self:\n    \"\"\"Scale this energy by a percentage.\n\n    Args:\n        other: The percentage by which to scale this energy.\n\n    Returns:\n        The scaled energy.\n    \"\"\"\n    match other:\n        case float():\n            return self._new(self._base_value * other)\n        case Percentage():\n            return self._new(self._base_value * other.as_fraction())\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(\n    other: float | Self | timedelta | Power,\n) -&gt; Self | float | Power | timedelta\n</code></pre> <p>Return a power or duration from dividing this energy by the given value.</p> PARAMETER DESCRIPTION <code>other</code> <p>The scalar, energy, power or duration to divide by.</p> <p> TYPE: <code>float | Self | timedelta | Power</code> </p> RETURNS DESCRIPTION <code>Self | float | Power | timedelta</code> <p>A power or duration from dividing this energy by the given value.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(\n    self, other: float | Self | timedelta | Power, /\n) -&gt; Self | float | Power | timedelta:\n    \"\"\"Return a power or duration from dividing this energy by the given value.\n\n    Args:\n        other: The scalar, energy, power or duration to divide by.\n\n    Returns:\n        A power or duration from dividing this energy by the given value.\n    \"\"\"\n    match other:\n        case float():\n            return super().__truediv__(other)\n        case Energy():\n            return self._base_value / other._base_value\n        case timedelta():\n            return Power._new(self._base_value / (other.total_seconds() / 3600.0))\n        case Power():\n            return timedelta(\n                seconds=(self._base_value / other._base_value) * 3600.0\n            )\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_kilowatt_hours","title":"as_kilowatt_hours","text":"<pre><code>as_kilowatt_hours() -&gt; float\n</code></pre> <p>Return the energy in kilowatt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in kilowatt hours.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilowatt_hours(self) -&gt; float:\n    \"\"\"Return the energy in kilowatt hours.\n\n    Returns:\n        The energy in kilowatt hours.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_megawatt_hours","title":"as_megawatt_hours","text":"<pre><code>as_megawatt_hours() -&gt; float\n</code></pre> <p>Return the energy in megawatt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in megawatt hours.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megawatt_hours(self) -&gt; float:\n    \"\"\"Return the energy in megawatt hours.\n\n    Returns:\n        The energy in megawatt hours.\n    \"\"\"\n    return self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_watt_hours","title":"as_watt_hours","text":"<pre><code>as_watt_hours() -&gt; float\n</code></pre> <p>Return the energy in watt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in watt hours.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_watt_hours(self) -&gt; float:\n    \"\"\"Return the energy in watt hours.\n\n    Returns:\n        The energy in watt hours.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_kilowatt_hours","title":"from_kilowatt_hours  <code>classmethod</code>","text":"<pre><code>from_kilowatt_hours(kilowatt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER DESCRIPTION <code>kilowatt_hours</code> <p>The energy in kilowatt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilowatt_hours(cls, kilowatt_hours: float) -&gt; Self:\n    \"\"\"Initialize a new energy quantity.\n\n    Args:\n        kilowatt_hours: The energy in kilowatt hours.\n\n    Returns:\n        A new energy quantity.\n    \"\"\"\n    return cls._new(kilowatt_hours, exponent=3)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_megawatt_hours","title":"from_megawatt_hours  <code>classmethod</code>","text":"<pre><code>from_megawatt_hours(megawatt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER DESCRIPTION <code>megawatt_hours</code> <p>The energy in megawatt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megawatt_hours(cls, megawatt_hours: float) -&gt; Self:\n    \"\"\"Initialize a new energy quantity.\n\n    Args:\n        megawatt_hours: The energy in megawatt hours.\n\n    Returns:\n        A new energy quantity.\n    \"\"\"\n    return cls._new(megawatt_hours, exponent=6)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_watt_hours","title":"from_watt_hours  <code>classmethod</code>","text":"<pre><code>from_watt_hours(watt_hours: float) -&gt; Self\n</code></pre> <p>Initialize a new energy quantity.</p> PARAMETER DESCRIPTION <code>watt_hours</code> <p>The energy in watt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_watt_hours(cls, watt_hours: float) -&gt; Self:\n    \"\"\"Initialize a new energy quantity.\n\n    Args:\n        watt_hours: The energy in watt hours.\n\n    Returns:\n        A new energy quantity.\n    \"\"\"\n    return cls._new(watt_hours)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency","title":"frequenz.sdk.timeseries.Frequency","text":"<p>               Bases: <code>Quantity</code></p> <p>A frequency quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Frequency(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={0: \"Hz\", 3: \"kHz\", 6: \"MHz\", 9: \"GHz\"},\n):\n    \"\"\"A frequency quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_hertz(cls, hertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            hertz: The frequency in hertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        return cls._new(hertz)\n\n    @classmethod\n    def from_kilohertz(cls, kilohertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            kilohertz: The frequency in kilohertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        return cls._new(kilohertz, exponent=3)\n\n    @classmethod\n    def from_megahertz(cls, megahertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            megahertz: The frequency in megahertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        return cls._new(megahertz, exponent=6)\n\n    @classmethod\n    def from_gigahertz(cls, gigahertz: float) -&gt; Self:\n        \"\"\"Initialize a new frequency quantity.\n\n        Args:\n            gigahertz: The frequency in gigahertz.\n\n        Returns:\n            A new frequency quantity.\n        \"\"\"\n        return cls._new(gigahertz, exponent=9)\n\n    def as_hertz(self) -&gt; float:\n        \"\"\"Return the frequency in hertz.\n\n        Returns:\n            The frequency in hertz.\n        \"\"\"\n        return self._base_value\n\n    def as_kilohertz(self) -&gt; float:\n        \"\"\"Return the frequency in kilohertz.\n\n        Returns:\n            The frequency in kilohertz.\n        \"\"\"\n        return self._base_value / 1e3\n\n    def as_megahertz(self) -&gt; float:\n        \"\"\"Return the frequency in megahertz.\n\n        Returns:\n            The frequency in megahertz.\n        \"\"\"\n        return self._base_value / 1e6\n\n    def as_gigahertz(self) -&gt; float:\n        \"\"\"Return the frequency in gigahertz.\n\n        Returns:\n            The frequency in gigahertz.\n        \"\"\"\n        return self._base_value / 1e9\n\n    def period(self) -&gt; timedelta:\n        \"\"\"Return the period of the frequency.\n\n        Returns:\n            The period of the frequency.\n        \"\"\"\n        return timedelta(seconds=1.0 / self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__mul__","title":"__mul__","text":"<pre><code>__mul__(value: float | Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a scalar or percentage.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or percentage by which to scale this quantity.</p> <p> TYPE: <code>float | Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, value: float | Percentage, /) -&gt; Self:\n    \"\"\"Scale this quantity by a scalar or percentage.\n\n    Args:\n        value: The scalar or percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value * value)\n        case Percentage():\n            return type(self)._new(self._base_value * value.as_fraction())\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_gigahertz","title":"as_gigahertz","text":"<pre><code>as_gigahertz() -&gt; float\n</code></pre> <p>Return the frequency in gigahertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in gigahertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_gigahertz(self) -&gt; float:\n    \"\"\"Return the frequency in gigahertz.\n\n    Returns:\n        The frequency in gigahertz.\n    \"\"\"\n    return self._base_value / 1e9\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_hertz","title":"as_hertz","text":"<pre><code>as_hertz() -&gt; float\n</code></pre> <p>Return the frequency in hertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in hertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_hertz(self) -&gt; float:\n    \"\"\"Return the frequency in hertz.\n\n    Returns:\n        The frequency in hertz.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_kilohertz","title":"as_kilohertz","text":"<pre><code>as_kilohertz() -&gt; float\n</code></pre> <p>Return the frequency in kilohertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in kilohertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilohertz(self) -&gt; float:\n    \"\"\"Return the frequency in kilohertz.\n\n    Returns:\n        The frequency in kilohertz.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_megahertz","title":"as_megahertz","text":"<pre><code>as_megahertz() -&gt; float\n</code></pre> <p>Return the frequency in megahertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in megahertz.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megahertz(self) -&gt; float:\n    \"\"\"Return the frequency in megahertz.\n\n    Returns:\n        The frequency in megahertz.\n    \"\"\"\n    return self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_gigahertz","title":"from_gigahertz  <code>classmethod</code>","text":"<pre><code>from_gigahertz(gigahertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER DESCRIPTION <code>gigahertz</code> <p>The frequency in gigahertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_gigahertz(cls, gigahertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        gigahertz: The frequency in gigahertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    return cls._new(gigahertz, exponent=9)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_hertz","title":"from_hertz  <code>classmethod</code>","text":"<pre><code>from_hertz(hertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER DESCRIPTION <code>hertz</code> <p>The frequency in hertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_hertz(cls, hertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        hertz: The frequency in hertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    return cls._new(hertz)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_kilohertz","title":"from_kilohertz  <code>classmethod</code>","text":"<pre><code>from_kilohertz(kilohertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER DESCRIPTION <code>kilohertz</code> <p>The frequency in kilohertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilohertz(cls, kilohertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        kilohertz: The frequency in kilohertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    return cls._new(kilohertz, exponent=3)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_megahertz","title":"from_megahertz  <code>classmethod</code>","text":"<pre><code>from_megahertz(megahertz: float) -&gt; Self\n</code></pre> <p>Initialize a new frequency quantity.</p> PARAMETER DESCRIPTION <code>megahertz</code> <p>The frequency in megahertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megahertz(cls, megahertz: float) -&gt; Self:\n    \"\"\"Initialize a new frequency quantity.\n\n    Args:\n        megahertz: The frequency in megahertz.\n\n    Returns:\n        A new frequency quantity.\n    \"\"\"\n    return cls._new(megahertz, exponent=6)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.period","title":"period","text":"<pre><code>period() -&gt; timedelta\n</code></pre> <p>Return the period of the frequency.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The period of the frequency.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def period(self) -&gt; timedelta:\n    \"\"\"Return the period of the frequency.\n\n    Returns:\n        The period of the frequency.\n    \"\"\"\n    return timedelta(seconds=1.0 / self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Fuse","title":"frequenz.sdk.timeseries.Fuse  <code>dataclass</code>","text":"<p>Fuse data class.</p> Source code in <code>frequenz/sdk/timeseries/_fuse.py</code> <pre><code>@dataclass(frozen=True)\nclass Fuse:\n    \"\"\"Fuse data class.\"\"\"\n\n    max_current: Current\n    \"\"\"Rated current of the fuse.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Fuse-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Fuse.max_current","title":"max_current  <code>instance-attribute</code>","text":"<pre><code>max_current: Current\n</code></pre> <p>Rated current of the fuse.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow","title":"frequenz.sdk.timeseries.MovingWindow","text":"<p>               Bases: <code>BackgroundService</code></p> <p>A data window that moves with the latest datapoints of a data stream.</p> <p>After initialization the <code>MovingWindow</code> can be accessed by an integer index or a timestamp. A sub window can be accessed by using a slice of integers or timestamps.</p> <p>Note that a numpy ndarray is returned and thus users can use numpys operations directly on a window.</p> <p>The window uses a ring buffer for storage and the first element is aligned to a fixed defined point in time. Since the moving nature of the window, the date of the first and the last element are constantly changing and therefore the point in time that defines the alignment can be outside of the time window. Modulo arithmetic is used to move the <code>align_to</code> timestamp into the latest window.</p> <p>If for example the <code>align_to</code> parameter is set to <code>datetime(1, 1, 1, tzinfo=timezone.utc)</code> and the window size is bigger than one day then the first element will always be aligned to midnight.</p> <p>Resampling might be required to reduce the number of samples to store, and it can be set by specifying the resampler config parameter so that the user can control the granularity of the samples to be stored in the underlying buffer.</p> <p>If resampling is not required, the resampler config parameter can be set to None in which case the MovingWindow will not perform any resampling.</p> <p>Example: Calculate the mean of a time interval</p> <pre><code>```python\nfrom datetime import datetime, timedelta, timezone\n\nasync def send_mock_data(sender: Sender[Sample]) -&gt; None:\n    while True:\n        await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n        await asyncio.sleep(1.0)\n\nasync def run() -&gt; None:\n    resampled_data_channel = Broadcast[Sample](name=\"sample-data\")\n    resampled_data_receiver = resampled_data_channel.new_receiver()\n    resampled_data_sender = resampled_data_channel.new_sender()\n\n    send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n    async with MovingWindow(\n        size=timedelta(seconds=5),\n        resampled_data_recv=resampled_data_receiver,\n        input_sampling_period=timedelta(seconds=1),\n    ) as window:\n        time_start = datetime.now(tz=timezone.utc)\n        time_end = time_start + timedelta(seconds=5)\n\n        # ... wait for 5 seconds until the buffer is filled\n        await asyncio.sleep(5)\n\n        # return an numpy array from the window\n        array = window[time_start:time_end]\n        # and use it to for example calculate the mean\n        mean = array.mean()\n\nasyncio.run(run())\n```\n</code></pre> <p>Example: Create a polars data frame from a <code>MovingWindow</code></p> <pre><code>```python\nfrom datetime import datetime, timedelta, timezone\n\nasync def send_mock_data(sender: Sender[Sample]) -&gt; None:\n    while True:\n        await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n        await asyncio.sleep(1.0)\n\nasync def run() -&gt; None:\n    resampled_data_channel = Broadcast[Sample](name=\"sample-data\")\n    resampled_data_receiver = resampled_data_channel.new_receiver()\n    resampled_data_sender = resampled_data_channel.new_sender()\n\n    send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n    # create a window that stores two days of data\n    # starting at 1.1.23 with samplerate=1\n    async with MovingWindow(\n        size=timedelta(days=2),\n        resampled_data_recv=resampled_data_receiver,\n        input_sampling_period=timedelta(seconds=1),\n    ) as window:\n        # wait for one full day until the buffer is filled\n        await asyncio.sleep(60*60*24)\n\n        time_start = datetime(2023, 1, 1, tzinfo=timezone.utc)\n        time_end = datetime(2023, 1, 2, tzinfo=timezone.utc)\n\n        # You can now create a polars series with one full day of data by\n        # passing the window slice, like:\n        # series = pl.Series(\"Jan_1\", window[time_start:time_end])\n\nasyncio.run(run())\n```\n</code></pre> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>class MovingWindow(BackgroundService):\n    \"\"\"\n    A data window that moves with the latest datapoints of a data stream.\n\n    After initialization the `MovingWindow` can be accessed by an integer\n    index or a timestamp. A sub window can be accessed by using a slice of\n    integers or timestamps.\n\n    Note that a numpy ndarray is returned and thus users can use\n    numpys operations directly on a window.\n\n    The window uses a ring buffer for storage and the first element is aligned to\n    a fixed defined point in time. Since the moving nature of the window, the\n    date of the first and the last element are constantly changing and therefore\n    the point in time that defines the alignment can be outside of the time window.\n    Modulo arithmetic is used to move the `align_to` timestamp into the latest\n    window.\n\n    If for example the `align_to` parameter is set to\n    `datetime(1, 1, 1, tzinfo=timezone.utc)` and the window size is bigger than\n    one day then the first element will always be aligned to midnight.\n\n    Resampling might be required to reduce the number of samples to store, and\n    it can be set by specifying the resampler config parameter so that the user\n    can control the granularity of the samples to be stored in the underlying\n    buffer.\n\n    If resampling is not required, the resampler config parameter can be\n    set to None in which case the MovingWindow will not perform any resampling.\n\n    Example: Calculate the mean of a time interval\n\n        ```python\n        from datetime import datetime, timedelta, timezone\n\n        async def send_mock_data(sender: Sender[Sample]) -&gt; None:\n            while True:\n                await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n                await asyncio.sleep(1.0)\n\n        async def run() -&gt; None:\n            resampled_data_channel = Broadcast[Sample](name=\"sample-data\")\n            resampled_data_receiver = resampled_data_channel.new_receiver()\n            resampled_data_sender = resampled_data_channel.new_sender()\n\n            send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n            async with MovingWindow(\n                size=timedelta(seconds=5),\n                resampled_data_recv=resampled_data_receiver,\n                input_sampling_period=timedelta(seconds=1),\n            ) as window:\n                time_start = datetime.now(tz=timezone.utc)\n                time_end = time_start + timedelta(seconds=5)\n\n                # ... wait for 5 seconds until the buffer is filled\n                await asyncio.sleep(5)\n\n                # return an numpy array from the window\n                array = window[time_start:time_end]\n                # and use it to for example calculate the mean\n                mean = array.mean()\n\n        asyncio.run(run())\n        ```\n\n    Example: Create a polars data frame from a `MovingWindow`\n\n        ```python\n        from datetime import datetime, timedelta, timezone\n\n        async def send_mock_data(sender: Sender[Sample]) -&gt; None:\n            while True:\n                await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n                await asyncio.sleep(1.0)\n\n        async def run() -&gt; None:\n            resampled_data_channel = Broadcast[Sample](name=\"sample-data\")\n            resampled_data_receiver = resampled_data_channel.new_receiver()\n            resampled_data_sender = resampled_data_channel.new_sender()\n\n            send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n            # create a window that stores two days of data\n            # starting at 1.1.23 with samplerate=1\n            async with MovingWindow(\n                size=timedelta(days=2),\n                resampled_data_recv=resampled_data_receiver,\n                input_sampling_period=timedelta(seconds=1),\n            ) as window:\n                # wait for one full day until the buffer is filled\n                await asyncio.sleep(60*60*24)\n\n                time_start = datetime(2023, 1, 1, tzinfo=timezone.utc)\n                time_end = datetime(2023, 1, 2, tzinfo=timezone.utc)\n\n                # You can now create a polars series with one full day of data by\n                # passing the window slice, like:\n                # series = pl.Series(\"Jan_1\", window[time_start:time_end])\n\n        asyncio.run(run())\n        ```\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        size: timedelta,\n        resampled_data_recv: Receiver[Sample[Quantity]],\n        input_sampling_period: timedelta,\n        resampler_config: ResamplerConfig | None = None,\n        align_to: datetime = UNIX_EPOCH,\n        *,\n        name: str | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the MovingWindow.\n\n        This method creates the underlying ring buffer and starts a\n        new task that updates the ring buffer with new incoming samples.\n        The task stops running only if the channel receiver is closed.\n\n        Args:\n            size: The time span of the moving window over which samples will be stored.\n            resampled_data_recv: A receiver that delivers samples with a\n                given sampling period.\n            input_sampling_period: The time interval between consecutive input samples.\n            resampler_config: The resampler configuration in case resampling is required.\n            align_to: A timestamp that defines a point in time to which\n                the window is aligned to modulo window size. For further\n                information, consult the class level documentation.\n            name: The name of this moving window. If `None`, `str(id(self))` will be\n                used. This is used mostly for debugging purposes.\n        \"\"\"\n        assert (\n            input_sampling_period.total_seconds() &gt; 0\n        ), \"The input sampling period should be greater than zero.\"\n        assert (\n            input_sampling_period &lt;= size\n        ), \"The input sampling period should be equal to or lower than the window size.\"\n        super().__init__(name=name)\n\n        self._sampling_period = input_sampling_period\n\n        self._resampler: Resampler | None = None\n        self._resampler_sender: Sender[Sample[Quantity]] | None = None\n\n        if resampler_config:\n            assert (\n                resampler_config.resampling_period &lt;= size\n            ), \"The resampling period should be equal to or lower than the window size.\"\n\n            self._resampler = Resampler(resampler_config)\n            self._sampling_period = resampler_config.resampling_period\n\n        # Sampling period might not fit perfectly into the window size.\n        num_samples = math.ceil(\n            size.total_seconds() / self._sampling_period.total_seconds()\n        )\n\n        self._resampled_data_recv = resampled_data_recv\n        self._buffer = OrderedRingBuffer(\n            np.empty(shape=num_samples, dtype=float),\n            sampling_period=self._sampling_period,\n            align_to=align_to,\n        )\n\n    def start(self) -&gt; None:\n        \"\"\"Start the MovingWindow.\n\n        This method starts the MovingWindow tasks.\n        \"\"\"\n        if self._resampler:\n            self._configure_resampler()\n        self._tasks.add(asyncio.create_task(self._run_impl(), name=\"update-window\"))\n\n    @property\n    def sampling_period(self) -&gt; timedelta:\n        \"\"\"\n        Return the sampling period of the MovingWindow.\n\n        Returns:\n            The sampling period of the MovingWindow.\n        \"\"\"\n        return self._sampling_period\n\n    @property\n    def oldest_timestamp(self) -&gt; datetime | None:\n        \"\"\"\n        Return the oldest timestamp of the MovingWindow.\n\n        Returns:\n            The oldest timestamp of the MovingWindow or None if the buffer is empty.\n        \"\"\"\n        return self._buffer.oldest_timestamp\n\n    @property\n    def newest_timestamp(self) -&gt; datetime | None:\n        \"\"\"\n        Return the newest timestamp of the MovingWindow.\n\n        Returns:\n            The newest timestamp of the MovingWindow or None if the buffer is empty.\n        \"\"\"\n        return self._buffer.newest_timestamp\n\n    @property\n    def capacity(self) -&gt; int:\n        \"\"\"\n        Return the capacity of the MovingWindow.\n\n        Capacity is the maximum number of samples that can be stored in the\n        MovingWindow.\n\n        Returns:\n            The capacity of the MovingWindow.\n        \"\"\"\n        return self._buffer.maxlen\n\n    # pylint before 3.0 only accepts names with 3 or more chars\n    def at(self, key: int | datetime) -&gt; float:  # pylint: disable=invalid-name\n        \"\"\"\n        Return the sample at the given index or timestamp.\n\n        In contrast to the [`window`][frequenz.sdk.timeseries.MovingWindow.window] method,\n        which expects a slice as argument, this method expects a single index as argument\n        and returns a single value.\n\n        Args:\n            key: The index or timestamp of the sample to return.\n\n        Returns:\n            The sample at the given index or timestamp.\n\n        Raises:\n            IndexError: If the buffer is empty or the index is out of bounds.\n        \"\"\"\n        if self._buffer.count_valid() == 0:\n            raise IndexError(\"The buffer is empty.\")\n\n        if isinstance(key, datetime):\n            assert self._buffer.oldest_timestamp is not None\n            assert self._buffer.newest_timestamp is not None\n            if (\n                key &lt; self._buffer.oldest_timestamp\n                or key &gt; self._buffer.newest_timestamp\n            ):\n                raise IndexError(\n                    f\"Timestamp {key} is out of range [{self._buffer.oldest_timestamp}, \"\n                    f\"{self._buffer.newest_timestamp}]\"\n                )\n            return self._buffer[self._buffer.to_internal_index(key)]\n\n        if isinstance(key, int):\n            _logger.debug(\"Returning value at index %s \", key)\n            timestamp = self._buffer.get_timestamp(key)\n            assert timestamp is not None\n            return self._buffer[self._buffer.to_internal_index(timestamp)]\n\n        raise TypeError(\"Key has to be either a timestamp or an integer.\")\n\n    def window(\n        self,\n        start: datetime | int | None,\n        end: datetime | int | None,\n        *,\n        force_copy: bool = True,\n        fill_value: float | None = np.nan,\n    ) -&gt; ArrayLike:\n        \"\"\"\n        Return an array containing the samples in the given time interval.\n\n        In contrast to the [`at`][frequenz.sdk.timeseries.MovingWindow.at] method,\n        which expects a single index as argument, this method expects a slice as argument\n        and returns an array.\n\n        Args:\n            start: The start timestamp of the time interval. If `None`, the\n                start of the window is used.\n            end: The end timestamp of the time interval. If `None`, the end of\n                the window is used.\n            force_copy: If `True`, the returned array is a copy of the underlying\n                data. Otherwise, if possible, a view of the underlying data is\n                returned.\n            fill_value: If not None, will use this value to fill missing values.\n                If missing values should be set, force_copy must be True.\n                Defaults to NaN to avoid returning outdated data unexpectedly.\n\n        Returns:\n            An array containing the samples in the given time interval.\n        \"\"\"\n        return self._buffer.window(\n            start, end, force_copy=force_copy, fill_value=fill_value\n        )\n\n    async def _run_impl(self) -&gt; None:\n        \"\"\"Awaits samples from the receiver and updates the underlying ring buffer.\n\n        Raises:\n            asyncio.CancelledError: if the MovingWindow task is cancelled.\n        \"\"\"\n        try:\n            async for sample in self._resampled_data_recv:\n                _logger.debug(\"Received new sample: %s\", sample)\n                if self._resampler and self._resampler_sender:\n                    await self._resampler_sender.send(sample)\n                else:\n                    self._buffer.update(sample)\n\n        except asyncio.CancelledError:\n            _logger.info(\"MovingWindow task has been cancelled.\")\n            raise\n\n        _logger.error(\"Channel has been closed\")\n\n    def _configure_resampler(self) -&gt; None:\n        \"\"\"Configure the components needed to run the resampler.\"\"\"\n        assert self._resampler is not None\n\n        async def sink_buffer(sample: Sample[Quantity]) -&gt; None:\n            if sample.value is not None:\n                self._buffer.update(sample)\n\n        resampler_channel = Broadcast[Sample[Quantity]](name=\"average\")\n        self._resampler_sender = resampler_channel.new_sender()\n        self._resampler.add_timeseries(\n            \"avg\", resampler_channel.new_receiver(), sink_buffer\n        )\n        self._tasks.add(\n            asyncio.create_task(self._resampler.resample(), name=\"resample\")\n        )\n\n    def count_valid(self) -&gt; int:\n        \"\"\"\n        Count the number of valid samples in this `MovingWindow`.\n\n        Returns:\n            The number of valid samples in this `MovingWindow`.\n        \"\"\"\n        return self._buffer.count_valid()\n\n    def count_covered(self) -&gt; int:\n        \"\"\"Count the number of samples that are covered by the oldest and newest valid samples.\n\n        Returns:\n            The count of samples between the oldest and newest (inclusive) valid samples\n                or 0 if there are is no time range covered.\n        \"\"\"\n        return self._buffer.count_covered()\n\n    @overload\n    def __getitem__(self, key: SupportsIndex) -&gt; float:\n        \"\"\"See the main __getitem__ method.\"\"\"\n\n    @overload\n    def __getitem__(self, key: datetime) -&gt; float:\n        \"\"\"See the main __getitem__ method.\"\"\"\n\n    @overload\n    def __getitem__(self, key: slice) -&gt; ArrayLike:\n        \"\"\"See the main __getitem__ method.\"\"\"\n\n    def __getitem__(self, key: SupportsIndex | datetime | slice) -&gt; float | ArrayLike:\n        \"\"\"\n        Return a sub window of the `MovingWindow`.\n\n        The `MovingWindow` is accessed either by timestamp or by index\n        or by a slice of timestamps or integers.\n\n        * If the key is an integer, the float value of that key\n          at the given position is returned.\n        * If the key is a timestamp, the float value of that key\n          that corresponds to the timestamp is returned.\n        * If the key is a slice of timestamps or integers, an ndarray is returned,\n          where the bounds correspond to the slice bounds.\n          Note that a half open interval, which is open at the end, is returned.\n\n        Args:\n            key: Either an integer or a timestamp or a slice of timestamps or integers.\n\n        Raises:\n            IndexError: when requesting an out of range timestamp or index\n            TypeError: when the key is not a datetime or slice object.\n\n        Returns:\n            A float if the key is a number or a timestamp.\n            an numpy array if the key is a slice.\n        \"\"\"\n        if isinstance(key, slice):\n            if not (key.step is None or key.step == 1):\n                raise ValueError(\"Slicing with a step other than 1 is not supported.\")\n            return self.window(key.start, key.stop)\n\n        if isinstance(key, datetime):\n            return self.at(key)\n\n        if isinstance(key, SupportsIndex):\n            return self.at(key.__index__())\n\n        raise TypeError(\n            \"Key has to be either a timestamp or an integer \"\n            \"or a slice of timestamps or integers\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.capacity","title":"capacity  <code>property</code>","text":"<pre><code>capacity: int\n</code></pre> <p>Return the capacity of the MovingWindow.</p> <p>Capacity is the maximum number of samples that can be stored in the MovingWindow.</p> RETURNS DESCRIPTION <code>int</code> <p>The capacity of the MovingWindow.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.newest_timestamp","title":"newest_timestamp  <code>property</code>","text":"<pre><code>newest_timestamp: datetime | None\n</code></pre> <p>Return the newest timestamp of the MovingWindow.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The newest timestamp of the MovingWindow or None if the buffer is empty.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.oldest_timestamp","title":"oldest_timestamp  <code>property</code>","text":"<pre><code>oldest_timestamp: datetime | None\n</code></pre> <p>Return the oldest timestamp of the MovingWindow.</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>The oldest timestamp of the MovingWindow or None if the buffer is empty.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.sampling_period","title":"sampling_period  <code>property</code>","text":"<pre><code>sampling_period: timedelta\n</code></pre> <p>Return the sampling period of the MovingWindow.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The sampling period of the MovingWindow.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    key: SupportsIndex | datetime | slice,\n) -&gt; float | ArrayLike\n</code></pre> <p>Return a sub window of the <code>MovingWindow</code>.</p> <p>The <code>MovingWindow</code> is accessed either by timestamp or by index or by a slice of timestamps or integers.</p> <ul> <li>If the key is an integer, the float value of that key   at the given position is returned.</li> <li>If the key is a timestamp, the float value of that key   that corresponds to the timestamp is returned.</li> <li>If the key is a slice of timestamps or integers, an ndarray is returned,   where the bounds correspond to the slice bounds.   Note that a half open interval, which is open at the end, is returned.</li> </ul> PARAMETER DESCRIPTION <code>key</code> <p>Either an integer or a timestamp or a slice of timestamps or integers.</p> <p> TYPE: <code>SupportsIndex | datetime | slice</code> </p> RAISES DESCRIPTION <code>IndexError</code> <p>when requesting an out of range timestamp or index</p> <code>TypeError</code> <p>when the key is not a datetime or slice object.</p> RETURNS DESCRIPTION <code>float | ArrayLike</code> <p>A float if the key is a number or a timestamp.</p> <code>float | ArrayLike</code> <p>an numpy array if the key is a slice.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __getitem__(self, key: SupportsIndex | datetime | slice) -&gt; float | ArrayLike:\n    \"\"\"\n    Return a sub window of the `MovingWindow`.\n\n    The `MovingWindow` is accessed either by timestamp or by index\n    or by a slice of timestamps or integers.\n\n    * If the key is an integer, the float value of that key\n      at the given position is returned.\n    * If the key is a timestamp, the float value of that key\n      that corresponds to the timestamp is returned.\n    * If the key is a slice of timestamps or integers, an ndarray is returned,\n      where the bounds correspond to the slice bounds.\n      Note that a half open interval, which is open at the end, is returned.\n\n    Args:\n        key: Either an integer or a timestamp or a slice of timestamps or integers.\n\n    Raises:\n        IndexError: when requesting an out of range timestamp or index\n        TypeError: when the key is not a datetime or slice object.\n\n    Returns:\n        A float if the key is a number or a timestamp.\n        an numpy array if the key is a slice.\n    \"\"\"\n    if isinstance(key, slice):\n        if not (key.step is None or key.step == 1):\n            raise ValueError(\"Slicing with a step other than 1 is not supported.\")\n        return self.window(key.start, key.stop)\n\n    if isinstance(key, datetime):\n        return self.at(key)\n\n    if isinstance(key, SupportsIndex):\n        return self.at(key.__index__())\n\n    raise TypeError(\n        \"Key has to be either a timestamp or an integer \"\n        \"or a slice of timestamps or integers\"\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__init__","title":"__init__","text":"<pre><code>__init__(\n    size: timedelta,\n    resampled_data_recv: Receiver[Sample[Quantity]],\n    input_sampling_period: timedelta,\n    resampler_config: ResamplerConfig | None = None,\n    align_to: datetime = UNIX_EPOCH,\n    *,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Initialize the MovingWindow.</p> <p>This method creates the underlying ring buffer and starts a new task that updates the ring buffer with new incoming samples. The task stops running only if the channel receiver is closed.</p> PARAMETER DESCRIPTION <code>size</code> <p>The time span of the moving window over which samples will be stored.</p> <p> TYPE: <code>timedelta</code> </p> <code>resampled_data_recv</code> <p>A receiver that delivers samples with a given sampling period.</p> <p> TYPE: <code>Receiver[Sample[Quantity]]</code> </p> <code>input_sampling_period</code> <p>The time interval between consecutive input samples.</p> <p> TYPE: <code>timedelta</code> </p> <code>resampler_config</code> <p>The resampler configuration in case resampling is required.</p> <p> TYPE: <code>ResamplerConfig | None</code> DEFAULT: <code>None</code> </p> <code>align_to</code> <p>A timestamp that defines a point in time to which the window is aligned to modulo window size. For further information, consult the class level documentation.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>UNIX_EPOCH</code> </p> <code>name</code> <p>The name of this moving window. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    size: timedelta,\n    resampled_data_recv: Receiver[Sample[Quantity]],\n    input_sampling_period: timedelta,\n    resampler_config: ResamplerConfig | None = None,\n    align_to: datetime = UNIX_EPOCH,\n    *,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the MovingWindow.\n\n    This method creates the underlying ring buffer and starts a\n    new task that updates the ring buffer with new incoming samples.\n    The task stops running only if the channel receiver is closed.\n\n    Args:\n        size: The time span of the moving window over which samples will be stored.\n        resampled_data_recv: A receiver that delivers samples with a\n            given sampling period.\n        input_sampling_period: The time interval between consecutive input samples.\n        resampler_config: The resampler configuration in case resampling is required.\n        align_to: A timestamp that defines a point in time to which\n            the window is aligned to modulo window size. For further\n            information, consult the class level documentation.\n        name: The name of this moving window. If `None`, `str(id(self))` will be\n            used. This is used mostly for debugging purposes.\n    \"\"\"\n    assert (\n        input_sampling_period.total_seconds() &gt; 0\n    ), \"The input sampling period should be greater than zero.\"\n    assert (\n        input_sampling_period &lt;= size\n    ), \"The input sampling period should be equal to or lower than the window size.\"\n    super().__init__(name=name)\n\n    self._sampling_period = input_sampling_period\n\n    self._resampler: Resampler | None = None\n    self._resampler_sender: Sender[Sample[Quantity]] | None = None\n\n    if resampler_config:\n        assert (\n            resampler_config.resampling_period &lt;= size\n        ), \"The resampling period should be equal to or lower than the window size.\"\n\n        self._resampler = Resampler(resampler_config)\n        self._sampling_period = resampler_config.resampling_period\n\n    # Sampling period might not fit perfectly into the window size.\n    num_samples = math.ceil(\n        size.total_seconds() / self._sampling_period.total_seconds()\n    )\n\n    self._resampled_data_recv = resampled_data_recv\n    self._buffer = OrderedRingBuffer(\n        np.empty(shape=num_samples, dtype=float),\n        sampling_period=self._sampling_period,\n        align_to=align_to,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.at","title":"at","text":"<pre><code>at(key: int | datetime) -&gt; float\n</code></pre> <p>Return the sample at the given index or timestamp.</p> <p>In contrast to the <code>window</code> method, which expects a slice as argument, this method expects a single index as argument and returns a single value.</p> PARAMETER DESCRIPTION <code>key</code> <p>The index or timestamp of the sample to return.</p> <p> TYPE: <code>int | datetime</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The sample at the given index or timestamp.</p> RAISES DESCRIPTION <code>IndexError</code> <p>If the buffer is empty or the index is out of bounds.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def at(self, key: int | datetime) -&gt; float:  # pylint: disable=invalid-name\n    \"\"\"\n    Return the sample at the given index or timestamp.\n\n    In contrast to the [`window`][frequenz.sdk.timeseries.MovingWindow.window] method,\n    which expects a slice as argument, this method expects a single index as argument\n    and returns a single value.\n\n    Args:\n        key: The index or timestamp of the sample to return.\n\n    Returns:\n        The sample at the given index or timestamp.\n\n    Raises:\n        IndexError: If the buffer is empty or the index is out of bounds.\n    \"\"\"\n    if self._buffer.count_valid() == 0:\n        raise IndexError(\"The buffer is empty.\")\n\n    if isinstance(key, datetime):\n        assert self._buffer.oldest_timestamp is not None\n        assert self._buffer.newest_timestamp is not None\n        if (\n            key &lt; self._buffer.oldest_timestamp\n            or key &gt; self._buffer.newest_timestamp\n        ):\n            raise IndexError(\n                f\"Timestamp {key} is out of range [{self._buffer.oldest_timestamp}, \"\n                f\"{self._buffer.newest_timestamp}]\"\n            )\n        return self._buffer[self._buffer.to_internal_index(key)]\n\n    if isinstance(key, int):\n        _logger.debug(\"Returning value at index %s \", key)\n        timestamp = self._buffer.get_timestamp(key)\n        assert timestamp is not None\n        return self._buffer[self._buffer.to_internal_index(timestamp)]\n\n    raise TypeError(\"Key has to be either a timestamp or an integer.\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.count_covered","title":"count_covered","text":"<pre><code>count_covered() -&gt; int\n</code></pre> <p>Count the number of samples that are covered by the oldest and newest valid samples.</p> RETURNS DESCRIPTION <code>int</code> <p>The count of samples between the oldest and newest (inclusive) valid samples or 0 if there are is no time range covered.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def count_covered(self) -&gt; int:\n    \"\"\"Count the number of samples that are covered by the oldest and newest valid samples.\n\n    Returns:\n        The count of samples between the oldest and newest (inclusive) valid samples\n            or 0 if there are is no time range covered.\n    \"\"\"\n    return self._buffer.count_covered()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.count_valid","title":"count_valid","text":"<pre><code>count_valid() -&gt; int\n</code></pre> <p>Count the number of valid samples in this <code>MovingWindow</code>.</p> RETURNS DESCRIPTION <code>int</code> <p>The number of valid samples in this <code>MovingWindow</code>.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def count_valid(self) -&gt; int:\n    \"\"\"\n    Count the number of valid samples in this `MovingWindow`.\n\n    Returns:\n        The number of valid samples in this `MovingWindow`.\n    \"\"\"\n    return self._buffer.count_valid()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the MovingWindow.</p> <p>This method starts the MovingWindow tasks.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the MovingWindow.\n\n    This method starts the MovingWindow tasks.\n    \"\"\"\n    if self._resampler:\n        self._configure_resampler()\n    self._tasks.add(asyncio.create_task(self._run_impl(), name=\"update-window\"))\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.window","title":"window","text":"<pre><code>window(\n    start: datetime | int | None,\n    end: datetime | int | None,\n    *,\n    force_copy: bool = True,\n    fill_value: float | None = np.nan\n) -&gt; ArrayLike\n</code></pre> <p>Return an array containing the samples in the given time interval.</p> <p>In contrast to the <code>at</code> method, which expects a single index as argument, this method expects a slice as argument and returns an array.</p> PARAMETER DESCRIPTION <code>start</code> <p>The start timestamp of the time interval. If <code>None</code>, the start of the window is used.</p> <p> TYPE: <code>datetime | int | None</code> </p> <code>end</code> <p>The end timestamp of the time interval. If <code>None</code>, the end of the window is used.</p> <p> TYPE: <code>datetime | int | None</code> </p> <code>force_copy</code> <p>If <code>True</code>, the returned array is a copy of the underlying data. Otherwise, if possible, a view of the underlying data is returned.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>fill_value</code> <p>If not None, will use this value to fill missing values. If missing values should be set, force_copy must be True. Defaults to NaN to avoid returning outdated data unexpectedly.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>nan</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>An array containing the samples in the given time interval.</p> Source code in <code>frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def window(\n    self,\n    start: datetime | int | None,\n    end: datetime | int | None,\n    *,\n    force_copy: bool = True,\n    fill_value: float | None = np.nan,\n) -&gt; ArrayLike:\n    \"\"\"\n    Return an array containing the samples in the given time interval.\n\n    In contrast to the [`at`][frequenz.sdk.timeseries.MovingWindow.at] method,\n    which expects a single index as argument, this method expects a slice as argument\n    and returns an array.\n\n    Args:\n        start: The start timestamp of the time interval. If `None`, the\n            start of the window is used.\n        end: The end timestamp of the time interval. If `None`, the end of\n            the window is used.\n        force_copy: If `True`, the returned array is a copy of the underlying\n            data. Otherwise, if possible, a view of the underlying data is\n            returned.\n        fill_value: If not None, will use this value to fill missing values.\n            If missing values should be set, force_copy must be True.\n            Defaults to NaN to avoid returning outdated data unexpectedly.\n\n    Returns:\n        An array containing the samples in the given time interval.\n    \"\"\"\n    return self._buffer.window(\n        start, end, force_copy=force_copy, fill_value=fill_value\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage","title":"frequenz.sdk.timeseries.Percentage","text":"<p>               Bases: <code>Quantity</code></p> <p>A percentage quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Percentage(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={0: \"%\"},\n):\n    \"\"\"A percentage quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_percent(cls, percent: float) -&gt; Self:\n        \"\"\"Initialize a new percentage quantity from a percent value.\n\n        Args:\n            percent: The percent value, normally in the 0.0-100.0 range.\n\n        Returns:\n            A new percentage quantity.\n        \"\"\"\n        return cls._new(percent)\n\n    @classmethod\n    def from_fraction(cls, fraction: float) -&gt; Self:\n        \"\"\"Initialize a new percentage quantity from a fraction.\n\n        Args:\n            fraction: The fraction, normally in the 0.0-1.0 range.\n\n        Returns:\n            A new percentage quantity.\n        \"\"\"\n        return cls._new(fraction * 100)\n\n    def as_percent(self) -&gt; float:\n        \"\"\"Return this quantity as a percentage.\n\n        Returns:\n            This quantity as a percentage.\n        \"\"\"\n        return self._base_value\n\n    def as_fraction(self) -&gt; float:\n        \"\"\"Return this quantity as a fraction.\n\n        Returns:\n            This quantity as a fraction.\n        \"\"\"\n        return self._base_value / 100\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__mul__","title":"__mul__","text":"<pre><code>__mul__(value: float | Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a scalar or percentage.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or percentage by which to scale this quantity.</p> <p> TYPE: <code>float | Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, value: float | Percentage, /) -&gt; Self:\n    \"\"\"Scale this quantity by a scalar or percentage.\n\n    Args:\n        value: The scalar or percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value * value)\n        case Percentage():\n            return type(self)._new(self._base_value * value.as_fraction())\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.as_fraction","title":"as_fraction","text":"<pre><code>as_fraction() -&gt; float\n</code></pre> <p>Return this quantity as a fraction.</p> RETURNS DESCRIPTION <code>float</code> <p>This quantity as a fraction.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_fraction(self) -&gt; float:\n    \"\"\"Return this quantity as a fraction.\n\n    Returns:\n        This quantity as a fraction.\n    \"\"\"\n    return self._base_value / 100\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.as_percent","title":"as_percent","text":"<pre><code>as_percent() -&gt; float\n</code></pre> <p>Return this quantity as a percentage.</p> RETURNS DESCRIPTION <code>float</code> <p>This quantity as a percentage.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_percent(self) -&gt; float:\n    \"\"\"Return this quantity as a percentage.\n\n    Returns:\n        This quantity as a percentage.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.from_fraction","title":"from_fraction  <code>classmethod</code>","text":"<pre><code>from_fraction(fraction: float) -&gt; Self\n</code></pre> <p>Initialize a new percentage quantity from a fraction.</p> PARAMETER DESCRIPTION <code>fraction</code> <p>The fraction, normally in the 0.0-1.0 range.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new percentage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_fraction(cls, fraction: float) -&gt; Self:\n    \"\"\"Initialize a new percentage quantity from a fraction.\n\n    Args:\n        fraction: The fraction, normally in the 0.0-1.0 range.\n\n    Returns:\n        A new percentage quantity.\n    \"\"\"\n    return cls._new(fraction * 100)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.from_percent","title":"from_percent  <code>classmethod</code>","text":"<pre><code>from_percent(percent: float) -&gt; Self\n</code></pre> <p>Initialize a new percentage quantity from a percent value.</p> PARAMETER DESCRIPTION <code>percent</code> <p>The percent value, normally in the 0.0-100.0 range.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new percentage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_percent(cls, percent: float) -&gt; Self:\n    \"\"\"Initialize a new percentage quantity from a percent value.\n\n    Args:\n        percent: The percent value, normally in the 0.0-100.0 range.\n\n    Returns:\n        A new percentage quantity.\n    \"\"\"\n    return cls._new(percent)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor","title":"frequenz.sdk.timeseries.PeriodicFeatureExtractor","text":"<p>A feature extractor for historical timeseries data.</p> <p>This class is creating a profile from periodically occurring windows in a buffer of historical data.</p> <p>The profile is created out of all windows that are fully contained in the underlying buffer with the same start and end time modulo a fixed period.</p> <p>Consider for example a timeseries $T$ of historical data and sub-series $S_i$ of $T$ all having the same size $l$ and the same fixed distance $p$ called period, where period of two sub-windows is defined as the distance of two points at the same position within the sub-windows.</p> <p>This class calculates a statistical profile $S$ over all $S_i$, i.e. the value of $S$ at position $i$ is calculated by performing a certain calculation, e.g. an average, over all values of $S_i$ at position $i$.</p> Note <p>The oldest window or the window that is currently overwritten in the <code>MovingWindow</code> is not considered in the profile.</p> Note <p>When constructing a <code>PeriodicFeatureExtractor</code> object the <code>MovingWindow</code> size has to be a integer multiple of the period.</p> Example <pre><code>from frequenz.sdk import microgrid\nfrom datetime import datetime, timedelta, timezone\n\nasync with MovingWindow(\n    size=timedelta(days=35),\n    resampled_data_recv=microgrid.grid().power.new_receiver(),\n    input_sampling_period=timedelta(seconds=1),\n) as moving_window:\n    feature_extractor = PeriodicFeatureExtractor(\n        moving_window=moving_window,\n        period=timedelta(days=7),\n    )\n\n    now = datetime.now(timezone.utc)\n\n    # create a daily weighted average for the next 24h\n    avg_24h = feature_extractor.avg(\n        now,\n        now + timedelta(hours=24),\n        weights=[0.1, 0.2, 0.3, 0.4]\n    )\n\n    # create a daily average for Thursday March 23 2023\n    th_avg_24h = feature_extractor.avg(datetime(2023, 3, 23), datetime(2023, 3, 24))\n</code></pre> Source code in <code>frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>class PeriodicFeatureExtractor:\n    \"\"\"\n    A feature extractor for historical timeseries data.\n\n    This class is creating a profile from periodically occurring windows in a\n    buffer of historical data.\n\n    The profile is created out of all windows that are fully contained in the\n    underlying buffer with the same start and end time modulo a fixed period.\n\n    Consider for example a timeseries $T$ of historical data and sub-series\n    $S_i$ of $T$ all having the same size $l$ and the same fixed distance $p$\n    called period, where period of two sub-windows is defined as the distance\n    of two points at the same position within the sub-windows.\n\n    This class calculates a statistical profile $S$ over all $S_i$, i.e. the\n    value of $S$ at position $i$ is calculated by performing a certain\n    calculation, e.g. an average, over all values of $S_i$ at position $i$.\n\n    Note:\n        The oldest window or the window that is currently overwritten in the\n        `MovingWindow` is not considered in the profile.\n\n    Note:\n        When constructing a `PeriodicFeatureExtractor` object the\n        `MovingWindow` size has to be a integer multiple of the period.\n\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n        from datetime import datetime, timedelta, timezone\n\n        async with MovingWindow(\n            size=timedelta(days=35),\n            resampled_data_recv=microgrid.grid().power.new_receiver(),\n            input_sampling_period=timedelta(seconds=1),\n        ) as moving_window:\n            feature_extractor = PeriodicFeatureExtractor(\n                moving_window=moving_window,\n                period=timedelta(days=7),\n            )\n\n            now = datetime.now(timezone.utc)\n\n            # create a daily weighted average for the next 24h\n            avg_24h = feature_extractor.avg(\n                now,\n                now + timedelta(hours=24),\n                weights=[0.1, 0.2, 0.3, 0.4]\n            )\n\n            # create a daily average for Thursday March 23 2023\n            th_avg_24h = feature_extractor.avg(datetime(2023, 3, 23), datetime(2023, 3, 24))\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        moving_window: MovingWindow,\n        period: timedelta,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a PeriodicFeatureExtractor object.\n\n        Args:\n            moving_window: The MovingWindow that is used for the average calculation.\n            period: The distance between two succeeding intervals.\n\n        Raises:\n            ValueError: If the MovingWindow size is not a integer multiple of the period.\n        \"\"\"\n        self._moving_window = moving_window\n\n        self._sampling_period = self._moving_window.sampling_period\n        \"\"\"The sampling_period as float to use it for indexing of samples.\"\"\"\n\n        self._period = int(period / self._sampling_period)\n        \"\"\"Distance between two succeeding intervals in samples.\"\"\"\n\n        _logger.debug(\"Initializing PeriodicFeatureExtractor!\")\n        _logger.debug(\"MovingWindow size: %i\", self._moving_window.count_valid())\n        _logger.debug(\n            \"Period between two succeeding intervals (in samples): %i\",\n            self._period,\n        )\n\n        if not self._moving_window.count_valid() % self._period == 0:\n            raise ValueError(\n                \"The MovingWindow size is not a integer multiple of the period.\"\n            )\n\n        if not is_close_to_zero(self._period - period / self._sampling_period):\n            raise ValueError(\n                \"The period is not a multiple of the sampling period. \"\n                \"This might result in unexpected behaviour.\"\n            )\n\n    @property\n    def _buffer(self) -&gt; OrderedRingBuffer[NDArray[np.float64]]:\n        return self._moving_window._buffer  # pylint: disable=protected-access\n\n    def _timestamp_to_rel_index(self, timestamp: datetime) -&gt; int:\n        \"\"\"\n        Get the index of a timestamp relative to the oldest sample in the MovingWindow.\n\n        In other word consider an integer axis where the zero is defined as the\n        oldest element in the MovingWindow. This function returns the index of\n        the given timestamp an this axis.\n\n        This method can return negative values.\n\n        Args:\n            timestamp: A timestamp that we want to shift into the window.\n\n        Returns:\n            The index of the timestamp shifted into the MovingWindow.\n        \"\"\"\n        # align timestamp to the sampling period\n        timestamp = self._buffer.normalize_timestamp(timestamp)\n\n        # distance between the input ts and the ts of oldest known samples (in samples)\n        dist_to_oldest = int(\n            (timestamp - self._buffer.time_bound_oldest) / self._sampling_period\n        )\n\n        _logger.debug(\"Shifting ts: %s\", timestamp)\n        _logger.debug(\"Oldest timestamp in buffer: %s\", self._buffer.time_bound_oldest)\n        _logger.debug(\"Distance to the oldest sample: %i\", dist_to_oldest)\n\n        return dist_to_oldest\n\n    def _reshape_np_array(\n        self, array: NDArray[np.float_], window_size: int\n    ) -&gt; NDArray[np.float_]:\n        \"\"\"\n        Reshape a numpy array to a 2D array where each row represents a window.\n\n        There are three cases to consider\n\n        1. The array size is a multiple of window_size + period,\n           i.e. num_windows is integer and we can simply reshape.\n        2. The array size is NOT a multiple of window_size + period and\n           it has length n * period + m, where m &lt; window_size.\n        3. The array size is NOT a multiple of window_size + period and\n           it has length n * period + m, where m &gt;= window_size.\n\n        Note that in the current implementation of this class we have the restriction\n        that period is a multiple integer of the size of the MovingWindow and hence\n        only case 1 can occur.\n\n        Args:\n            array: The numpy array to reshape.\n            window_size: The size of the window in samples.\n\n        Returns:\n            The reshaped 2D array.\n\n        Raises:\n            ValueError: If the array is smaller or equal to the given period.\n        \"\"\"\n        # Not using the num_windows function here because we want to\n        # differentiate between the three cases.\n        if len(array) &lt; self._period:\n            raise ValueError(\n                f\"The array (length:{len(array)}) is too small to be reshaped.\"\n            )\n\n        num_windows = len(array) // self._period\n\n        # Case 1:\n        if len(array) - num_windows * self._period == 0:\n            resized_array = array\n        # Case 2\n        elif len(array) - num_windows * self._period &lt; window_size:\n            resized_array = array[: num_windows * self._period]\n        # Case 3\n        else:\n            num_windows += 1\n            resized_array = np.resize(array, num_windows * self._period)\n\n        return resized_array.reshape(num_windows, self._period)\n\n    def _get_relative_positions(\n        self, start: datetime, window_size: int\n    ) -&gt; RelativePositions:\n        \"\"\"\n        Return relative positions of the MovingWindow.\n\n        This method calculates the shifted relative positions of the start\n        timestamp, the end timestamps as well as the next position that is\n        overwritten in the ringbuffer.\n        Shifted in that context means that the positions are moved as close\n        assume possible to the oldest sample in the MovingWindow.\n\n        Args:\n            start: The start timestamp of the window.\n            window_size: The size of the window in samples.\n\n        Returns:\n            The relative positions of the start, end and next samples.\n        \"\"\"\n        # The number of usable windows can change, when the current position of\n        # the ringbuffer is inside one of the windows inside the MovingWindow.\n        # Since this is possible, we assume that one window is always not used\n        # for the average calculation.\n        #\n        # We are ignoring either the window that is currently overwritten if\n        # the current position is inside that window or the window that would\n        # be overwritten next.\n        #\n        # Move the window to its first appearance in the MovingWindow relative\n        # to the oldest sample stored in the MovingWindow.\n        #\n        # In other words the oldest stored sample is considered to have index 0.\n        #\n        # Note that the returned value is a index not a timestamp\n        rel_start_sample = self._timestamp_to_rel_index(start) % self._period\n        rel_end_sample = rel_start_sample + window_size\n\n        # check if the newest time bound, i.e. the sample that is currently written,\n        # is inside the interval\n        rb_current_position = self._buffer.time_bound_newest\n        rel_next_position = (\n            self._timestamp_to_rel_index(rb_current_position) + 1\n        ) % self._period\n        # fix the rel_next_position if modulo period the next position\n        # is smaller then the start sample position\n        if rel_next_position &lt; rel_start_sample:\n            rel_next_position += self._period\n\n        rel_next_position += self._period * (window_size // self._period)\n\n        _logger.debug(\"current position of the ringbuffer: %s\", rb_current_position)\n        _logger.debug(\"relative start_sample: %s\", rel_start_sample)\n        _logger.debug(\"relative end_sample: %s\", rel_end_sample)\n        _logger.debug(\"relative next_position: %s\", rel_next_position)\n\n        return RelativePositions(rel_start_sample, rel_end_sample, rel_next_position)\n\n    def _get_buffer_bounds(\n        self, start: datetime, end: datetime\n    ) -&gt; tuple[int, int, int]:\n        \"\"\"\n        Get the bounds of the ringbuffer used for further operations.\n\n        This method uses the given start and end timestamps to calculate the\n        part of the ringbuffer that can be used for further operations, like\n        average or min/max.\n\n        Here we cut out the oldest window or the window that is currently\n        overwritten in the MovingWindow such that it is not considered in any\n        further operation.\n\n        Args:\n            start: The start timestamp of the window.\n            end: The end timestamp of the window.\n\n        Returns:\n            The bounds of the to be used buffer and the window size.\n\n        Raises:\n            ValueError: If the start timestamp is after the end timestamp.\n        \"\"\"\n        window_size = self._timestamp_to_rel_index(end) - self._timestamp_to_rel_index(\n            start\n        )\n        if window_size &lt;= 0:\n            raise ValueError(\"Start timestamp must be before end timestamp\")\n        if window_size &gt; self._period:\n            raise ValueError(\n                \"The window size must be smaller or equal than the period.\"\n            )\n\n        rel_pos = self._get_relative_positions(start, window_size)\n\n        if window_size &gt; self._moving_window.count_valid():\n            raise ValueError(\n                \"The window size must be smaller than the size of the `MovingWindow`\"\n            )\n\n        # shifted distance between the next incoming sample and the start of the window\n        dist_to_start = rel_pos.next - rel_pos.start\n\n        # get the start and end position inside the ringbuffer\n        end_pos = (\n            self._timestamp_to_rel_index(self._buffer.time_bound_newest) + 1\n        ) - dist_to_start\n\n        # Note that these check is working since we are using the positions\n        # relative to the oldest sample stored in the MovingWindow.\n        if rel_pos.start &lt;= rel_pos.next &lt; rel_pos.end:\n            # end position is start_position of the window that is currently written\n            # that's how end_pos is currently set\n            _logger.debug(\"Next sample will be inside the window time interval!\")\n        else:\n            _logger.debug(\"Next sample will be outside the window time interval!\")\n            # end position is start_position of the window that\n            # is overwritten next, hence we adding period.\n            end_pos += self._period\n\n        # add the offset to the oldest sample in the ringbuffer and wrap around\n        # to get the start and end positions in the ringbuffer\n        rb_offset = self._buffer.to_internal_index(self._buffer.time_bound_oldest)\n        start_pos = self._buffer.wrap(end_pos + self._period + rb_offset)\n        end_pos = self._buffer.wrap(end_pos + rb_offset)\n\n        _logger.debug(\"start_pos in ringbuffer: %s\", start_pos)\n        _logger.debug(\"end_pos in ringbuffer: %s\", end_pos)\n\n        return (start_pos, end_pos, window_size)\n\n    def _get_reshaped_np_array(\n        self, start: datetime, end: datetime\n    ) -&gt; tuple[NDArray[np.float_], int]:\n        \"\"\"\n        Create a reshaped numpy array from the MovingWindow.\n\n        The reshaped array is a two dimensional array, where one dimension is\n        the window_size and the other the number of windows returned by the\n        `_get_buffer_bounds` method.\n\n        Args:\n            start: The start timestamp of the window.\n            end: The end timestamp of the window.\n\n        Returns:\n            A tuple containing the reshaped numpy array and the window size.\n        \"\"\"\n        (start_pos, end_pos, window_size) = self._get_buffer_bounds(start, end)\n\n        if start_pos &gt;= end_pos:\n            window_start = self._buffer[start_pos : self._moving_window.count_valid()]\n            window_end = self._buffer[0:end_pos]\n            # make the linter happy\n            assert isinstance(window_start, np.ndarray)\n            assert isinstance(window_end, np.ndarray)\n            window_array = np.concatenate((window_start, window_end))\n        else:\n            window_array = self._buffer[start_pos:end_pos]\n\n        return (self._reshape_np_array(window_array, window_size), window_size)\n\n    def avg(\n        self, start: datetime, end: datetime, weights: list[float] | None = None\n    ) -&gt; NDArray[np.float_]:\n        \"\"\"\n        Create the average window out of the window defined by `start` and `end`.\n\n        This method calculates the average of a window by averaging over all\n        windows fully inside the MovingWindow having the period\n        `self.period`.\n\n        Args:\n            start: The start of the window to average over.\n            end: The end of the window to average over.\n            weights: The weights to use for the average calculation (oldest first).\n\n        Returns:\n            The averaged timeseries window.\n        \"\"\"\n        (reshaped, window_size) = self._get_reshaped_np_array(start, end)\n        return np.average(  # type: ignore[no-any-return]\n            reshaped[:, :window_size], axis=0, weights=weights\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor.__init__","title":"__init__","text":"<pre><code>__init__(\n    moving_window: MovingWindow, period: timedelta\n) -&gt; None\n</code></pre> <p>Initialize a PeriodicFeatureExtractor object.</p> PARAMETER DESCRIPTION <code>moving_window</code> <p>The MovingWindow that is used for the average calculation.</p> <p> TYPE: <code>MovingWindow</code> </p> <code>period</code> <p>The distance between two succeeding intervals.</p> <p> TYPE: <code>timedelta</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the MovingWindow size is not a integer multiple of the period.</p> Source code in <code>frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>def __init__(\n    self,\n    moving_window: MovingWindow,\n    period: timedelta,\n) -&gt; None:\n    \"\"\"\n    Initialize a PeriodicFeatureExtractor object.\n\n    Args:\n        moving_window: The MovingWindow that is used for the average calculation.\n        period: The distance between two succeeding intervals.\n\n    Raises:\n        ValueError: If the MovingWindow size is not a integer multiple of the period.\n    \"\"\"\n    self._moving_window = moving_window\n\n    self._sampling_period = self._moving_window.sampling_period\n    \"\"\"The sampling_period as float to use it for indexing of samples.\"\"\"\n\n    self._period = int(period / self._sampling_period)\n    \"\"\"Distance between two succeeding intervals in samples.\"\"\"\n\n    _logger.debug(\"Initializing PeriodicFeatureExtractor!\")\n    _logger.debug(\"MovingWindow size: %i\", self._moving_window.count_valid())\n    _logger.debug(\n        \"Period between two succeeding intervals (in samples): %i\",\n        self._period,\n    )\n\n    if not self._moving_window.count_valid() % self._period == 0:\n        raise ValueError(\n            \"The MovingWindow size is not a integer multiple of the period.\"\n        )\n\n    if not is_close_to_zero(self._period - period / self._sampling_period):\n        raise ValueError(\n            \"The period is not a multiple of the sampling period. \"\n            \"This might result in unexpected behaviour.\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor.avg","title":"avg","text":"<pre><code>avg(\n    start: datetime,\n    end: datetime,\n    weights: list[float] | None = None,\n) -&gt; NDArray[float_]\n</code></pre> <p>Create the average window out of the window defined by <code>start</code> and <code>end</code>.</p> <p>This method calculates the average of a window by averaging over all windows fully inside the MovingWindow having the period <code>self.period</code>.</p> PARAMETER DESCRIPTION <code>start</code> <p>The start of the window to average over.</p> <p> TYPE: <code>datetime</code> </p> <code>end</code> <p>The end of the window to average over.</p> <p> TYPE: <code>datetime</code> </p> <code>weights</code> <p>The weights to use for the average calculation (oldest first).</p> <p> TYPE: <code>list[float] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>NDArray[float_]</code> <p>The averaged timeseries window.</p> Source code in <code>frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>def avg(\n    self, start: datetime, end: datetime, weights: list[float] | None = None\n) -&gt; NDArray[np.float_]:\n    \"\"\"\n    Create the average window out of the window defined by `start` and `end`.\n\n    This method calculates the average of a window by averaging over all\n    windows fully inside the MovingWindow having the period\n    `self.period`.\n\n    Args:\n        start: The start of the window to average over.\n        end: The end of the window to average over.\n        weights: The weights to use for the average calculation (oldest first).\n\n    Returns:\n        The averaged timeseries window.\n    \"\"\"\n    (reshaped, window_size) = self._get_reshaped_np_array(start, end)\n    return np.average(  # type: ignore[no-any-return]\n        reshaped[:, :window_size], axis=0, weights=weights\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power","title":"frequenz.sdk.timeseries.Power","text":"<p>               Bases: <code>Quantity</code></p> <p>A power quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Power(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={\n        -3: \"mW\",\n        0: \"W\",\n        3: \"kW\",\n        6: \"MW\",\n    },\n):\n    \"\"\"A power quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_watts(cls, watts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            watts: The power in watts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        return cls._new(watts)\n\n    @classmethod\n    def from_milliwatts(cls, milliwatts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            milliwatts: The power in milliwatts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        return cls._new(milliwatts, exponent=-3)\n\n    @classmethod\n    def from_kilowatts(cls, kilowatts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            kilowatts: The power in kilowatts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        return cls._new(kilowatts, exponent=3)\n\n    @classmethod\n    def from_megawatts(cls, megawatts: float) -&gt; Self:\n        \"\"\"Initialize a new power quantity.\n\n        Args:\n            megawatts: The power in megawatts.\n\n        Returns:\n            A new power quantity.\n        \"\"\"\n        return cls._new(megawatts, exponent=6)\n\n    def as_watts(self) -&gt; float:\n        \"\"\"Return the power in watts.\n\n        Returns:\n            The power in watts.\n        \"\"\"\n        return self._base_value\n\n    def as_kilowatts(self) -&gt; float:\n        \"\"\"Return the power in kilowatts.\n\n        Returns:\n            The power in kilowatts.\n        \"\"\"\n        return self._base_value / 1e3\n\n    def as_megawatts(self) -&gt; float:\n        \"\"\"Return the power in megawatts.\n\n        Returns:\n            The power in megawatts.\n        \"\"\"\n        return self._base_value / 1e6\n\n    # We need the ignore here because otherwise mypy will give this error:\n    # &gt; Overloaded operator methods can't have wider argument types in overrides\n    # The problem seems to be when the other type implements an **incompatible**\n    # __rmul__ method, which is not the case here, so we should be safe.\n    # Please see this example:\n    # https://github.com/python/mypy/blob/c26f1297d4f19d2d1124a30efc97caebb8c28616/test-data/unit/check-overloading.test#L4738C1-L4769C55\n    # And a discussion in a mypy issue here:\n    # https://github.com/python/mypy/issues/4985#issuecomment-389692396\n    @overload  # type: ignore[override]\n    def __mul__(self, scalar: float, /) -&gt; Self:\n        \"\"\"Scale this power by a scalar.\n\n        Args:\n            scalar: The scalar by which to scale this power.\n\n        Returns:\n            The scaled power.\n        \"\"\"\n\n    @overload\n    def __mul__(self, percent: Percentage, /) -&gt; Self:\n        \"\"\"Scale this power by a percentage.\n\n        Args:\n            percent: The percentage by which to scale this power.\n\n        Returns:\n            The scaled power.\n        \"\"\"\n\n    @overload\n    def __mul__(self, other: timedelta, /) -&gt; Energy:\n        \"\"\"Return an energy from multiplying this power by the given duration.\n\n        Args:\n            other: The duration to multiply by.\n\n        Returns:\n            The calculated energy.\n        \"\"\"\n\n    def __mul__(self, other: float | Percentage | timedelta, /) -&gt; Self | Energy:\n        \"\"\"Return a power or energy from multiplying this power by the given value.\n\n        Args:\n            other: The scalar, percentage or duration to multiply by.\n\n        Returns:\n            A power or energy.\n        \"\"\"\n        match other:\n            case float() | Percentage():\n                return super().__mul__(other)\n            case timedelta():\n                return Energy._new(self._base_value * other.total_seconds() / 3600.0)\n            case _:\n                return NotImplemented\n\n    # See the comment for Power.__mul__ for why we need the ignore here.\n    @overload  # type: ignore[override]\n    def __truediv__(self, other: float, /) -&gt; Self:\n        \"\"\"Divide this power by a scalar.\n\n        Args:\n            other: The scalar to divide this power by.\n\n        Returns:\n            The divided power.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, other: Self, /) -&gt; float:\n        \"\"\"Return the ratio of this power to another.\n\n        Args:\n            other: The other power.\n\n        Returns:\n            The ratio of this power to another.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, current: Current, /) -&gt; Voltage:\n        \"\"\"Return a voltage from dividing this power by the given current.\n\n        Args:\n            current: The current to divide by.\n\n        Returns:\n            A voltage from dividing this power by the a current.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, voltage: Voltage, /) -&gt; Current:\n        \"\"\"Return a current from dividing this power by the given voltage.\n\n        Args:\n            voltage: The voltage to divide by.\n\n        Returns:\n            A current from dividing this power by a voltage.\n        \"\"\"\n\n    def __truediv__(\n        self, other: float | Self | Current | Voltage, /\n    ) -&gt; Self | float | Voltage | Current:\n        \"\"\"Return a current or voltage from dividing this power by the given value.\n\n        Args:\n            other: The scalar, power, current or voltage to divide by.\n\n        Returns:\n            A current or voltage from dividing this power by the given value.\n        \"\"\"\n        match other:\n            case float():\n                return super().__truediv__(other)\n            case Power():\n                return self._base_value / other._base_value\n            case Current():\n                return Voltage._new(self._base_value / other._base_value)\n            case Voltage():\n                return Current._new(self._base_value / other._base_value)\n            case _:\n                return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__mul__","title":"__mul__","text":"<pre><code>__mul__(\n    other: float | Percentage | timedelta,\n) -&gt; Self | Energy\n</code></pre> <p>Return a power or energy from multiplying this power by the given value.</p> PARAMETER DESCRIPTION <code>other</code> <p>The scalar, percentage or duration to multiply by.</p> <p> TYPE: <code>float | Percentage | timedelta</code> </p> RETURNS DESCRIPTION <code>Self | Energy</code> <p>A power or energy.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: float | Percentage | timedelta, /) -&gt; Self | Energy:\n    \"\"\"Return a power or energy from multiplying this power by the given value.\n\n    Args:\n        other: The scalar, percentage or duration to multiply by.\n\n    Returns:\n        A power or energy.\n    \"\"\"\n    match other:\n        case float() | Percentage():\n            return super().__mul__(other)\n        case timedelta():\n            return Energy._new(self._base_value * other.total_seconds() / 3600.0)\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(\n    other: float | Self | Current | Voltage,\n) -&gt; Self | float | Voltage | Current\n</code></pre> <p>Return a current or voltage from dividing this power by the given value.</p> PARAMETER DESCRIPTION <code>other</code> <p>The scalar, power, current or voltage to divide by.</p> <p> TYPE: <code>float | Self | Current | Voltage</code> </p> RETURNS DESCRIPTION <code>Self | float | Voltage | Current</code> <p>A current or voltage from dividing this power by the given value.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(\n    self, other: float | Self | Current | Voltage, /\n) -&gt; Self | float | Voltage | Current:\n    \"\"\"Return a current or voltage from dividing this power by the given value.\n\n    Args:\n        other: The scalar, power, current or voltage to divide by.\n\n    Returns:\n        A current or voltage from dividing this power by the given value.\n    \"\"\"\n    match other:\n        case float():\n            return super().__truediv__(other)\n        case Power():\n            return self._base_value / other._base_value\n        case Current():\n            return Voltage._new(self._base_value / other._base_value)\n        case Voltage():\n            return Current._new(self._base_value / other._base_value)\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_kilowatts","title":"as_kilowatts","text":"<pre><code>as_kilowatts() -&gt; float\n</code></pre> <p>Return the power in kilowatts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in kilowatts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilowatts(self) -&gt; float:\n    \"\"\"Return the power in kilowatts.\n\n    Returns:\n        The power in kilowatts.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_megawatts","title":"as_megawatts","text":"<pre><code>as_megawatts() -&gt; float\n</code></pre> <p>Return the power in megawatts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in megawatts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megawatts(self) -&gt; float:\n    \"\"\"Return the power in megawatts.\n\n    Returns:\n        The power in megawatts.\n    \"\"\"\n    return self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_watts","title":"as_watts","text":"<pre><code>as_watts() -&gt; float\n</code></pre> <p>Return the power in watts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in watts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_watts(self) -&gt; float:\n    \"\"\"Return the power in watts.\n\n    Returns:\n        The power in watts.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_kilowatts","title":"from_kilowatts  <code>classmethod</code>","text":"<pre><code>from_kilowatts(kilowatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER DESCRIPTION <code>kilowatts</code> <p>The power in kilowatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilowatts(cls, kilowatts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        kilowatts: The power in kilowatts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    return cls._new(kilowatts, exponent=3)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_megawatts","title":"from_megawatts  <code>classmethod</code>","text":"<pre><code>from_megawatts(megawatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER DESCRIPTION <code>megawatts</code> <p>The power in megawatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megawatts(cls, megawatts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        megawatts: The power in megawatts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    return cls._new(megawatts, exponent=6)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_milliwatts","title":"from_milliwatts  <code>classmethod</code>","text":"<pre><code>from_milliwatts(milliwatts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER DESCRIPTION <code>milliwatts</code> <p>The power in milliwatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_milliwatts(cls, milliwatts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        milliwatts: The power in milliwatts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    return cls._new(milliwatts, exponent=-3)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_watts","title":"from_watts  <code>classmethod</code>","text":"<pre><code>from_watts(watts: float) -&gt; Self\n</code></pre> <p>Initialize a new power quantity.</p> PARAMETER DESCRIPTION <code>watts</code> <p>The power in watts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_watts(cls, watts: float) -&gt; Self:\n    \"\"\"Initialize a new power quantity.\n\n    Args:\n        watts: The power in watts.\n\n    Returns:\n        A new power quantity.\n    \"\"\"\n    return cls._new(watts)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity","title":"frequenz.sdk.timeseries.Quantity","text":"<p>A quantity with a unit.</p> <p>Quantities try to behave like float and are also immutable.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Quantity:\n    \"\"\"A quantity with a unit.\n\n    Quantities try to behave like float and are also immutable.\n    \"\"\"\n\n    _base_value: float\n    \"\"\"The value of this quantity in the base unit.\"\"\"\n\n    _exponent_unit_map: dict[int, str] | None = None\n    \"\"\"A mapping from the exponent of the base unit to the unit symbol.\n\n    If None, this quantity has no unit.  None is possible only when using the base\n    class.  Sub-classes must define this.\n    \"\"\"\n\n    def __init__(self, value: float, exponent: int = 0) -&gt; None:\n        \"\"\"Initialize a new quantity.\n\n        Args:\n            value: The value of this quantity in a given exponent of the base unit.\n            exponent: The exponent of the base unit the given value is in.\n        \"\"\"\n        self._base_value = value * 10.0**exponent\n\n    @classmethod\n    def _new(cls, value: float, *, exponent: int = 0) -&gt; Self:\n        \"\"\"Instantiate a new quantity subclass instance.\n\n        Args:\n            value: The value of this quantity in a given exponent of the base unit.\n            exponent: The exponent of the base unit the given value is in.\n\n        Returns:\n            A new quantity subclass instance.\n        \"\"\"\n        self = cls.__new__(cls)\n        self._base_value = value * 10.0**exponent\n        return self\n\n    def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n        \"\"\"Initialize a new subclass of Quantity.\n\n        Args:\n            exponent_unit_map: A mapping from the exponent of the base unit to the unit\n                symbol.\n\n        Raises:\n            TypeError: If the given exponent_unit_map is not a dict.\n            ValueError: If the given exponent_unit_map does not contain a base unit\n                (exponent 0).\n        \"\"\"\n        if 0 not in exponent_unit_map:\n            raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n        cls._exponent_unit_map = exponent_unit_map\n        super().__init_subclass__()\n\n    _zero_cache: dict[type, Quantity] = {}\n    \"\"\"Cache for zero singletons.\n\n    This is a workaround for mypy getting confused when using @functools.cache and\n    @classmethod combined with returning Self. It believes the resulting type of this\n    method is Self and complains that members of the actual class don't exist in Self,\n    so we need to implement the cache ourselves.\n    \"\"\"\n\n    @classmethod\n    def zero(cls) -&gt; Self:\n        \"\"\"Return a quantity with value 0.0.\n\n        Returns:\n            A quantity with value 0.0.\n        \"\"\"\n        _zero = cls._zero_cache.get(cls, None)\n        if _zero is None:\n            _zero = cls.__new__(cls)\n            _zero._base_value = 0.0\n            cls._zero_cache[cls] = _zero\n        assert isinstance(_zero, cls)\n        return _zero\n\n    @classmethod\n    def from_string(cls, string: str) -&gt; Self:\n        \"\"\"Return a quantity from a string representation.\n\n        Args:\n            string: The string representation of the quantity.\n\n        Returns:\n            A quantity object with the value given in the string.\n\n        Raises:\n            ValueError: If the string does not match the expected format.\n\n        \"\"\"\n        split_string = string.split(\" \")\n\n        if len(split_string) != 2:\n            raise ValueError(\n                f\"Expected a string of the form 'value unit', got {string}\"\n            )\n\n        assert cls._exponent_unit_map is not None\n        exp_map = cls._exponent_unit_map\n\n        for exponent, unit in exp_map.items():\n            if unit == split_string[1]:\n                instance = cls.__new__(cls)\n                try:\n                    instance._base_value = float(split_string[0]) * 10**exponent\n                except ValueError as error:\n                    raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n                return instance\n\n        raise ValueError(f\"Unknown unit {split_string[1]}\")\n\n    @property\n    def base_value(self) -&gt; float:\n        \"\"\"Return the value of this quantity in the base unit.\n\n        Returns:\n            The value of this quantity in the base unit.\n        \"\"\"\n        return self._base_value\n\n    @property\n    def base_unit(self) -&gt; str | None:\n        \"\"\"Return the base unit of this quantity.\n\n        None if this quantity has no unit.\n\n        Returns:\n            The base unit of this quantity.\n        \"\"\"\n        if not self._exponent_unit_map:\n            return None\n        return self._exponent_unit_map[0]\n\n    def isnan(self) -&gt; bool:\n        \"\"\"Return whether this quantity is NaN.\n\n        Returns:\n            Whether this quantity is NaN.\n        \"\"\"\n        return math.isnan(self._base_value)\n\n    def isinf(self) -&gt; bool:\n        \"\"\"Return whether this quantity is infinite.\n\n        Returns:\n            Whether this quantity is infinite.\n        \"\"\"\n        return math.isinf(self._base_value)\n\n    def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n        \"\"\"Return whether this quantity is close to another.\n\n        Args:\n            other: The quantity to compare to.\n            rel_tol: The relative tolerance.\n            abs_tol: The absolute tolerance.\n\n        Returns:\n            Whether this quantity is close to another.\n        \"\"\"\n        return math.isclose(\n            self._base_value,\n            other._base_value,  # pylint: disable=protected-access\n            rel_tol=rel_tol,\n            abs_tol=abs_tol,\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a representation of this quantity.\n\n        Returns:\n            A representation of this quantity.\n        \"\"\"\n        return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this quantity.\n\n        Returns:\n            A string representation of this quantity.\n        \"\"\"\n        return self.__format__(\"\")\n\n    # pylint: disable=too-many-branches\n    def __format__(self, __format_spec: str) -&gt; str:\n        \"\"\"Return a formatted string representation of this quantity.\n\n        If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n        trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n        The returned string will use the unit that will result in the maximum precision,\n        based on the magnitude of the value.\n\n        Example:\n            ```python\n            from frequenz.sdk.timeseries import Current\n            c = Current.from_amperes(0.2345)\n            assert f\"{c:.2}\" == \"234.5 mA\"\n            c = Current.from_amperes(1.2345)\n            assert f\"{c:.2}\" == \"1.23 A\"\n            c = Current.from_milliamperes(1.2345)\n            assert f\"{c:.6}\" == \"1.2345 mA\"\n            ```\n\n        Args:\n            __format_spec: The format specifier.\n\n        Returns:\n            A string representation of this quantity.\n\n        Raises:\n            ValueError: If the given format specifier is invalid.\n        \"\"\"\n        keep_trailing_zeros = False\n        if __format_spec != \"\":\n            fspec_parts = __format_spec.split(\".\")\n            if (\n                len(fspec_parts) != 2\n                or fspec_parts[0] not in (\"\", \"0\")\n                or not fspec_parts[1].isdigit()\n            ):\n                raise ValueError(\n                    \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n                )\n            if fspec_parts[0] == \"0\":\n                keep_trailing_zeros = True\n            precision = int(fspec_parts[1])\n        else:\n            precision = 3\n        if not self._exponent_unit_map:\n            return f\"{self._base_value:.{precision}f}\"\n\n        if math.isinf(self._base_value) or math.isnan(self._base_value):\n            return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n        if abs_value := abs(self._base_value):\n            precision_pow = 10 ** (precision)\n            # Prevent numbers like 999.999999 being rendered as 1000 V\n            # instead of 1 kV.\n            # This could happen because the str formatting function does\n            # rounding as well.\n            # This is an imperfect solution that works for _most_ cases.\n            # isclose parameters were chosen according to the observed cases\n            if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n                # If the value is close to the precision, round it\n                exponent = math.ceil(math.log10(precision_pow))\n            else:\n                exponent = math.floor(math.log10(abs_value))\n        else:\n            exponent = 0\n\n        unit_place = exponent - exponent % 3\n        if unit_place &lt; min(self._exponent_unit_map):\n            unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n            unit_place = min(self._exponent_unit_map)\n        elif unit_place &gt; max(self._exponent_unit_map):\n            unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n            unit_place = max(self._exponent_unit_map)\n        else:\n            unit = self._exponent_unit_map[unit_place]\n\n        value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n        if value_str in (\"-0\", \"0\"):\n            stripped = value_str\n        else:\n            stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n        if not keep_trailing_zeros:\n            value_str = stripped\n        unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n        return f\"{value_str} {unit_str}\"\n\n    def __add__(self, other: Self) -&gt; Self:\n        \"\"\"Return the sum of this quantity and another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            The sum of this quantity and another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        summe = type(self).__new__(type(self))\n        summe._base_value = self._base_value + other._base_value\n        return summe\n\n    def __sub__(self, other: Self) -&gt; Self:\n        \"\"\"Return the difference of this quantity and another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            The difference of this quantity and another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        difference = type(self).__new__(type(self))\n        difference._base_value = self._base_value - other._base_value\n        return difference\n\n    @overload\n    def __mul__(self, scalar: float, /) -&gt; Self:\n        \"\"\"Scale this quantity by a scalar.\n\n        Args:\n            scalar: The scalar by which to scale this quantity.\n\n        Returns:\n            The scaled quantity.\n        \"\"\"\n\n    @overload\n    def __mul__(self, percent: Percentage, /) -&gt; Self:\n        \"\"\"Scale this quantity by a percentage.\n\n        Args:\n            percent: The percentage by which to scale this quantity.\n\n        Returns:\n            The scaled quantity.\n        \"\"\"\n\n    def __mul__(self, value: float | Percentage, /) -&gt; Self:\n        \"\"\"Scale this quantity by a scalar or percentage.\n\n        Args:\n            value: The scalar or percentage by which to scale this quantity.\n\n        Returns:\n            The scaled quantity.\n        \"\"\"\n        match value:\n            case float():\n                return type(self)._new(self._base_value * value)\n            case Percentage():\n                return type(self)._new(self._base_value * value.as_fraction())\n            case _:\n                return NotImplemented\n\n    @overload\n    def __truediv__(self, other: float, /) -&gt; Self:\n        \"\"\"Divide this quantity by a scalar.\n\n        Args:\n            other: The scalar or percentage to divide this quantity by.\n\n        Returns:\n            The divided quantity.\n        \"\"\"\n\n    @overload\n    def __truediv__(self, other: Self, /) -&gt; float:\n        \"\"\"Return the ratio of this quantity to another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            The ratio of this quantity to another.\n        \"\"\"\n\n    def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n        \"\"\"Divide this quantity by a scalar or another quantity.\n\n        Args:\n            value: The scalar or quantity to divide this quantity by.\n\n        Returns:\n            The divided quantity or the ratio of this quantity to another.\n        \"\"\"\n        match value:\n            case float():\n                return type(self)._new(self._base_value / value)\n            case Quantity() if type(value) is type(self):\n                return self._base_value / value._base_value\n            case _:\n                return NotImplemented\n\n    def __gt__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is greater than another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is greater than another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &gt; other._base_value\n\n    def __ge__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is greater than or equal to another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is greater than or equal to another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &gt;= other._base_value\n\n    def __lt__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is less than another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is less than another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &lt; other._base_value\n\n    def __le__(self, other: Self) -&gt; bool:\n        \"\"\"Return whether this quantity is less than or equal to another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is less than or equal to another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        return self._base_value &lt;= other._base_value\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Return whether this quantity is equal to another.\n\n        Args:\n            other: The other quantity.\n\n        Returns:\n            Whether this quantity is equal to another.\n        \"\"\"\n        if not type(other) is type(self):\n            return NotImplemented\n        # The above check ensures that both quantities are the exact same type, because\n        # `isinstance` returns true for subclasses and superclasses.  But the above check\n        # doesn't help mypy identify the type of other,  so the below line is necessary.\n        assert isinstance(other, self.__class__)\n        return self._base_value == other._base_value\n\n    def __neg__(self) -&gt; Self:\n        \"\"\"Return the negation of this quantity.\n\n        Returns:\n            The negation of this quantity.\n        \"\"\"\n        negation = type(self).__new__(type(self))\n        negation._base_value = -self._base_value\n        return negation\n\n    def __abs__(self) -&gt; Self:\n        \"\"\"Return the absolute value of this quantity.\n\n        Returns:\n            The absolute value of this quantity.\n        \"\"\"\n        absolute = type(self).__new__(type(self))\n        absolute._base_value = abs(self._base_value)\n        return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__mul__","title":"__mul__","text":"<pre><code>__mul__(value: float | Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a scalar or percentage.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or percentage by which to scale this quantity.</p> <p> TYPE: <code>float | Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, value: float | Percentage, /) -&gt; Self:\n    \"\"\"Scale this quantity by a scalar or percentage.\n\n    Args:\n        value: The scalar or percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value * value)\n        case Percentage():\n            return type(self)._new(self._base_value * value.as_fraction())\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ReceiverFetcher","title":"frequenz.sdk.timeseries.ReceiverFetcher","text":"<p>               Bases: <code>Generic[T_co]</code>, <code>Protocol</code></p> <p>An interface that just exposes a <code>new_receiver</code> method.</p> Source code in <code>frequenz/sdk/_internal/_channels.py</code> <pre><code>class ReceiverFetcher(typing.Generic[T_co], typing.Protocol):\n    \"\"\"An interface that just exposes a `new_receiver` method.\"\"\"\n\n    @abc.abstractmethod\n    def new_receiver(self, *, limit: int = 50) -&gt; Receiver[T_co]:\n        \"\"\"Get a receiver from the channel.\n\n        Args:\n            limit: The maximum size of the receiver.\n\n        Returns:\n            A receiver instance.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ReceiverFetcher-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ReceiverFetcher.new_receiver","title":"new_receiver  <code>abstractmethod</code>","text":"<pre><code>new_receiver(*, limit: int = 50) -&gt; Receiver[T_co]\n</code></pre> <p>Get a receiver from the channel.</p> PARAMETER DESCRIPTION <code>limit</code> <p>The maximum size of the receiver.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[T_co]</code> <p>A receiver instance.</p> Source code in <code>frequenz/sdk/_internal/_channels.py</code> <pre><code>@abc.abstractmethod\ndef new_receiver(self, *, limit: int = 50) -&gt; Receiver[T_co]:\n    \"\"\"Get a receiver from the channel.\n\n    Args:\n        limit: The maximum size of the receiver.\n\n    Returns:\n        A receiver instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig","title":"frequenz.sdk.timeseries.ResamplerConfig  <code>dataclass</code>","text":"<p>Resampler configuration.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>@dataclass(frozen=True)\nclass ResamplerConfig:\n    \"\"\"Resampler configuration.\"\"\"\n\n    resampling_period: timedelta\n    \"\"\"The resampling period.\n\n    This is the time it passes between resampled data should be calculated.\n\n    It must be a positive time span.\n    \"\"\"\n\n    max_data_age_in_periods: float = 3.0\n    \"\"\"The maximum age a sample can have to be considered *relevant* for resampling.\n\n    Expressed in number of periods, where period is the `resampling_period`\n    if we are downsampling (resampling period bigger than the input period) or\n    the input sampling period if we are upsampling (input period bigger than\n    the resampling period).\n\n    It must be bigger than 1.0.\n\n    Example:\n        If `resampling_period` is 3 seconds, the input sampling period is\n        1 and `max_data_age_in_periods` is 2, then data older than 3*2\n        = 6 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n\n        If `resampling_period` is 3 seconds, the input sampling period is\n        5 and `max_data_age_in_periods` is 2, then data older than 5*2\n        = 10 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n    \"\"\"\n\n    resampling_function: ResamplingFunction = average\n    \"\"\"The resampling function.\n\n    This function will be applied to the sequence of relevant samples at\n    a given time. The result of the function is what is sent as the resampled\n    value.\n    \"\"\"\n\n    initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n    \"\"\"The initial length of the resampling buffer.\n\n    The buffer could grow or shrink depending on the source properties,\n    like sampling rate, to make sure all the requested past sampling periods\n    can be stored.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n    \"\"\"The minimum length of the resampling buffer that will emit a warning.\n\n    If a buffer grows bigger than this value, it will emit a warning in the\n    logs, so buffers don't grow too big inadvertently.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n    \"\"\"The maximum length of the resampling buffer.\n\n    Buffers won't be allowed to grow beyond this point even if it would be\n    needed to keep all the requested past sampling periods. An error will be\n    emitted in the logs if the buffer length needs to be truncated to this\n    value.\n\n    It must be at bigger than `warn_buffer_len`.\n    \"\"\"\n\n    align_to: datetime | None = UNIX_EPOCH\n    \"\"\"The time to align the resampling period to.\n\n    The resampling period will be aligned to this time, so the first resampled\n    sample will be at the first multiple of `resampling_period` starting from\n    `align_to`. It must be an aware datetime and can be in the future too.\n\n    If `align_to` is `None`, the resampling period will be aligned to the\n    time the resampler is created.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Check that config values are valid.\n\n        Raises:\n            ValueError: If any value is out of range.\n        \"\"\"\n        if self.resampling_period.total_seconds() &lt; 0.0:\n            raise ValueError(\n                f\"resampling_period ({self.resampling_period}) must be positive\"\n            )\n        if self.max_data_age_in_periods &lt; 1.0:\n            raise ValueError(\n                f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n            )\n        if self.warn_buffer_len &lt; 1:\n            raise ValueError(\n                f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n            )\n        if self.max_buffer_len &lt;= self.warn_buffer_len:\n            raise ValueError(\n                f\"max_buffer_len ({self.max_buffer_len}) should \"\n                f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n            )\n\n        if self.initial_buffer_len &lt; 1:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n            )\n        if self.initial_buffer_len &gt; self.max_buffer_len:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n                f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n                \"initial_buffer_len or a bigger max_buffer_len\"\n            )\n        if self.initial_buffer_len &gt; self.warn_buffer_len:\n            _logger.warning(\n                \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n                self.initial_buffer_len,\n                self.warn_buffer_len,\n            )\n        if self.align_to is not None and self.align_to.tzinfo is None:\n            raise ValueError(\n                f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.align_to","title":"align_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>align_to: datetime | None = UNIX_EPOCH\n</code></pre> <p>The time to align the resampling period to.</p> <p>The resampling period will be aligned to this time, so the first resampled sample will be at the first multiple of <code>resampling_period</code> starting from <code>align_to</code>. It must be an aware datetime and can be in the future too.</p> <p>If <code>align_to</code> is <code>None</code>, the resampling period will be aligned to the time the resampler is created.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.initial_buffer_len","title":"initial_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n</code></pre> <p>The initial length of the resampling buffer.</p> <p>The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.max_buffer_len","title":"max_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n</code></pre> <p>The maximum length of the resampling buffer.</p> <p>Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value.</p> <p>It must be at bigger than <code>warn_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.max_data_age_in_periods","title":"max_data_age_in_periods  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_data_age_in_periods: float = 3.0\n</code></pre> <p>The maximum age a sample can have to be considered relevant for resampling.</p> <p>Expressed in number of periods, where period is the <code>resampling_period</code> if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period).</p> <p>It must be bigger than 1.0.</p> Example <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 1 and <code>max_data_age_in_periods</code> is 2, then data older than 3*2 = 6 seconds will be discarded when creating a new sample and never passed to the resampling function.</p> <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 5 and <code>max_data_age_in_periods</code> is 2, then data older than 5*2 = 10 seconds will be discarded when creating a new sample and never passed to the resampling function.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.resampling_function","title":"resampling_function  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resampling_function: ResamplingFunction = average\n</code></pre> <p>The resampling function.</p> <p>This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.resampling_period","title":"resampling_period  <code>instance-attribute</code>","text":"<pre><code>resampling_period: timedelta\n</code></pre> <p>The resampling period.</p> <p>This is the time it passes between resampled data should be calculated.</p> <p>It must be a positive time span.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.warn_buffer_len","title":"warn_buffer_len  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n</code></pre> <p>The minimum length of the resampling buffer that will emit a warning.</p> <p>If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertently.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Check that config values are valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any value is out of range.</p> Source code in <code>frequenz/sdk/timeseries/_resampling.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Check that config values are valid.\n\n    Raises:\n        ValueError: If any value is out of range.\n    \"\"\"\n    if self.resampling_period.total_seconds() &lt; 0.0:\n        raise ValueError(\n            f\"resampling_period ({self.resampling_period}) must be positive\"\n        )\n    if self.max_data_age_in_periods &lt; 1.0:\n        raise ValueError(\n            f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n        )\n    if self.warn_buffer_len &lt; 1:\n        raise ValueError(\n            f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n        )\n    if self.max_buffer_len &lt;= self.warn_buffer_len:\n        raise ValueError(\n            f\"max_buffer_len ({self.max_buffer_len}) should \"\n            f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n        )\n\n    if self.initial_buffer_len &lt; 1:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n        )\n    if self.initial_buffer_len &gt; self.max_buffer_len:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n            f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n            \"initial_buffer_len or a bigger max_buffer_len\"\n        )\n    if self.initial_buffer_len &gt; self.warn_buffer_len:\n        _logger.warning(\n            \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n            self.initial_buffer_len,\n            self.warn_buffer_len,\n        )\n    if self.align_to is not None and self.align_to.tzinfo is None:\n        raise ValueError(\n            f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample","title":"frequenz.sdk.timeseries.Sample  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[QuantityT]</code></p> <p>A measurement taken at a particular point in time.</p> <p>The <code>value</code> could be <code>None</code> if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True, order=True)\nclass Sample(Generic[QuantityT]):\n    \"\"\"A measurement taken at a particular point in time.\n\n    The `value` could be `None` if a component is malfunctioning or data is\n    lacking for another reason, but a sample still needs to be sent to have a\n    coherent view on a group of component metrics for a particular timestamp.\n    \"\"\"\n\n    timestamp: datetime\n    \"\"\"The time when this sample was generated.\"\"\"\n\n    value: QuantityT | None = None\n    \"\"\"The value of this sample.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The time when this sample was generated.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: QuantityT | None = None\n</code></pre> <p>The value of this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase","title":"frequenz.sdk.timeseries.Sample3Phase  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[QuantityT]</code></p> <p>A 3-phase measurement made at a particular point in time.</p> <p>Each of the <code>value</code> fields could be <code>None</code> if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Sample3Phase(Generic[QuantityT]):\n    \"\"\"A 3-phase measurement made at a particular point in time.\n\n    Each of the `value` fields could be `None` if a component is malfunctioning\n    or data is lacking for another reason, but a sample still needs to be sent\n    to have a coherent view on a group of component metrics for a particular\n    timestamp.\n    \"\"\"\n\n    timestamp: datetime\n    \"\"\"The time when this sample was generated.\"\"\"\n    value_p1: QuantityT | None\n    \"\"\"The value of the 1st phase in this sample.\"\"\"\n\n    value_p2: QuantityT | None\n    \"\"\"The value of the 2nd phase in this sample.\"\"\"\n\n    value_p3: QuantityT | None\n    \"\"\"The value of the 3rd phase in this sample.\"\"\"\n\n    def __iter__(self) -&gt; Iterator[QuantityT | None]:\n        \"\"\"Return an iterator that yields values from each of the phases.\n\n        Yields:\n            Per-phase measurements one-by-one.\n        \"\"\"\n        yield self.value_p1\n        yield self.value_p2\n        yield self.value_p3\n\n    @overload\n    def max(self, default: QuantityT) -&gt; QuantityT: ...\n\n    @overload\n    def max(self, default: None = None) -&gt; QuantityT | None: ...\n\n    def max(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n        \"\"\"Return the max value among all phases, or default if they are all `None`.\n\n        Args:\n            default: value to return if all phases are `None`.\n\n        Returns:\n            Max value among all phases, if available, default value otherwise.\n        \"\"\"\n        if not any(self):\n            return default\n        value: QuantityT = functools.reduce(\n            lambda x, y: x if x &gt; y else y,\n            filter(None, self),\n        )\n        return value\n\n    @overload\n    def min(self, default: QuantityT) -&gt; QuantityT: ...\n\n    @overload\n    def min(self, default: None = None) -&gt; QuantityT | None: ...\n\n    def min(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n        \"\"\"Return the min value among all phases, or default if they are all `None`.\n\n        Args:\n            default: value to return if all phases are `None`.\n\n        Returns:\n            Min value among all phases, if available, default value otherwise.\n        \"\"\"\n        if not any(self):\n            return default\n        value: QuantityT = functools.reduce(\n            lambda x, y: x if x &lt; y else y,\n            filter(None, self),\n        )\n        return value\n\n    def map(\n        self,\n        function: Callable[[QuantityT], QuantityT],\n        default: QuantityT | None = None,\n    ) -&gt; Self:\n        \"\"\"Apply the given function on each of the phase values and return the result.\n\n        If a phase value is `None`, replace it with `default` instead.\n\n        Args:\n            function: The function to apply on each of the phase values.\n            default: The value to apply if a phase value is `None`.\n\n        Returns:\n            A new instance, with the given function applied on values for each of the\n                phases.\n        \"\"\"\n        return self.__class__(\n            timestamp=self.timestamp,\n            value_p1=default if self.value_p1 is None else function(self.value_p1),\n            value_p2=default if self.value_p2 is None else function(self.value_p2),\n            value_p3=default if self.value_p3 is None else function(self.value_p3),\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>The time when this sample was generated.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p1","title":"value_p1  <code>instance-attribute</code>","text":"<pre><code>value_p1: QuantityT | None\n</code></pre> <p>The value of the 1st phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p2","title":"value_p2  <code>instance-attribute</code>","text":"<pre><code>value_p2: QuantityT | None\n</code></pre> <p>The value of the 2nd phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p3","title":"value_p3  <code>instance-attribute</code>","text":"<pre><code>value_p3: QuantityT | None\n</code></pre> <p>The value of the 3rd phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[QuantityT | None]\n</code></pre> <p>Return an iterator that yields values from each of the phases.</p> YIELDS DESCRIPTION <code>QuantityT | None</code> <p>Per-phase measurements one-by-one.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def __iter__(self) -&gt; Iterator[QuantityT | None]:\n    \"\"\"Return an iterator that yields values from each of the phases.\n\n    Yields:\n        Per-phase measurements one-by-one.\n    \"\"\"\n    yield self.value_p1\n    yield self.value_p2\n    yield self.value_p3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.map","title":"map","text":"<pre><code>map(\n    function: Callable[[QuantityT], QuantityT],\n    default: QuantityT | None = None,\n) -&gt; Self\n</code></pre> <p>Apply the given function on each of the phase values and return the result.</p> <p>If a phase value is <code>None</code>, replace it with <code>default</code> instead.</p> PARAMETER DESCRIPTION <code>function</code> <p>The function to apply on each of the phase values.</p> <p> TYPE: <code>Callable[[QuantityT], QuantityT]</code> </p> <code>default</code> <p>The value to apply if a phase value is <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new instance, with the given function applied on values for each of the phases.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def map(\n    self,\n    function: Callable[[QuantityT], QuantityT],\n    default: QuantityT | None = None,\n) -&gt; Self:\n    \"\"\"Apply the given function on each of the phase values and return the result.\n\n    If a phase value is `None`, replace it with `default` instead.\n\n    Args:\n        function: The function to apply on each of the phase values.\n        default: The value to apply if a phase value is `None`.\n\n    Returns:\n        A new instance, with the given function applied on values for each of the\n            phases.\n    \"\"\"\n    return self.__class__(\n        timestamp=self.timestamp,\n        value_p1=default if self.value_p1 is None else function(self.value_p1),\n        value_p2=default if self.value_p2 is None else function(self.value_p2),\n        value_p3=default if self.value_p3 is None else function(self.value_p3),\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.max","title":"max","text":"<pre><code>max(default: QuantityT | None = None) -&gt; QuantityT | None\n</code></pre> <p>Return the max value among all phases, or default if they are all <code>None</code>.</p> PARAMETER DESCRIPTION <code>default</code> <p>value to return if all phases are <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>QuantityT | None</code> <p>Max value among all phases, if available, default value otherwise.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def max(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n    \"\"\"Return the max value among all phases, or default if they are all `None`.\n\n    Args:\n        default: value to return if all phases are `None`.\n\n    Returns:\n        Max value among all phases, if available, default value otherwise.\n    \"\"\"\n    if not any(self):\n        return default\n    value: QuantityT = functools.reduce(\n        lambda x, y: x if x &gt; y else y,\n        filter(None, self),\n    )\n    return value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.min","title":"min","text":"<pre><code>min(default: QuantityT | None = None) -&gt; QuantityT | None\n</code></pre> <p>Return the min value among all phases, or default if they are all <code>None</code>.</p> PARAMETER DESCRIPTION <code>default</code> <p>value to return if all phases are <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>QuantityT | None</code> <p>Min value among all phases, if available, default value otherwise.</p> Source code in <code>frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def min(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n    \"\"\"Return the min value among all phases, or default if they are all `None`.\n\n    Args:\n        default: value to return if all phases are `None`.\n\n    Returns:\n        Min value among all phases, if available, default value otherwise.\n    \"\"\"\n    if not any(self):\n        return default\n    value: QuantityT = functools.reduce(\n        lambda x, y: x if x &lt; y else y,\n        filter(None, self),\n    )\n    return value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature","title":"frequenz.sdk.timeseries.Temperature","text":"<p>               Bases: <code>Quantity</code></p> <p>A temperature quantity (in degrees Celsius).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Temperature(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={\n        0: \"\u00b0C\",\n    },\n):\n    \"\"\"A temperature quantity (in degrees Celsius).\"\"\"\n\n    @classmethod\n    def from_celsius(cls, value: float) -&gt; Self:\n        \"\"\"Initialize a new temperature quantity.\n\n        Args:\n            value: The temperature in degrees Celsius.\n\n        Returns:\n            A new temperature quantity.\n        \"\"\"\n        return cls._new(value)\n\n    def as_celsius(self) -&gt; float:\n        \"\"\"Return the temperature in degrees Celsius.\n\n        Returns:\n            The temperature in degrees Celsius.\n        \"\"\"\n        return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__mul__","title":"__mul__","text":"<pre><code>__mul__(value: float | Percentage) -&gt; Self\n</code></pre> <p>Scale this quantity by a scalar or percentage.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or percentage by which to scale this quantity.</p> <p> TYPE: <code>float | Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, value: float | Percentage, /) -&gt; Self:\n    \"\"\"Scale this quantity by a scalar or percentage.\n\n    Args:\n        value: The scalar or percentage by which to scale this quantity.\n\n    Returns:\n        The scaled quantity.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value * value)\n        case Percentage():\n            return type(self)._new(self._base_value * value.as_fraction())\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.as_celsius","title":"as_celsius","text":"<pre><code>as_celsius() -&gt; float\n</code></pre> <p>Return the temperature in degrees Celsius.</p> RETURNS DESCRIPTION <code>float</code> <p>The temperature in degrees Celsius.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_celsius(self) -&gt; float:\n    \"\"\"Return the temperature in degrees Celsius.\n\n    Returns:\n        The temperature in degrees Celsius.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.from_celsius","title":"from_celsius  <code>classmethod</code>","text":"<pre><code>from_celsius(value: float) -&gt; Self\n</code></pre> <p>Initialize a new temperature quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The temperature in degrees Celsius.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new temperature quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_celsius(cls, value: float) -&gt; Self:\n    \"\"\"Initialize a new temperature quantity.\n\n    Args:\n        value: The temperature in degrees Celsius.\n\n    Returns:\n        A new temperature quantity.\n    \"\"\"\n    return cls._new(value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage","title":"frequenz.sdk.timeseries.Voltage","text":"<p>               Bases: <code>Quantity</code></p> <p>A voltage quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Voltage(\n    Quantity,\n    metaclass=_NoDefaultConstructible,\n    exponent_unit_map={0: \"V\", -3: \"mV\", 3: \"kV\"},\n):\n    \"\"\"A voltage quantity.\n\n    Objects of this type are wrappers around `float` values and are immutable.\n\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n\n    @classmethod\n    def from_volts(cls, volts: float) -&gt; Self:\n        \"\"\"Initialize a new voltage quantity.\n\n        Args:\n            volts: The voltage in volts.\n\n        Returns:\n            A new voltage quantity.\n        \"\"\"\n        return cls._new(volts)\n\n    @classmethod\n    def from_millivolts(cls, millivolts: float) -&gt; Self:\n        \"\"\"Initialize a new voltage quantity.\n\n        Args:\n            millivolts: The voltage in millivolts.\n\n        Returns:\n            A new voltage quantity.\n        \"\"\"\n        return cls._new(millivolts, exponent=-3)\n\n    @classmethod\n    def from_kilovolts(cls, kilovolts: float) -&gt; Self:\n        \"\"\"Initialize a new voltage quantity.\n\n        Args:\n            kilovolts: The voltage in kilovolts.\n\n        Returns:\n            A new voltage quantity.\n        \"\"\"\n        return cls._new(kilovolts, exponent=3)\n\n    def as_volts(self) -&gt; float:\n        \"\"\"Return the voltage in volts.\n\n        Returns:\n            The voltage in volts.\n        \"\"\"\n        return self._base_value\n\n    def as_millivolts(self) -&gt; float:\n        \"\"\"Return the voltage in millivolts.\n\n        Returns:\n            The voltage in millivolts.\n        \"\"\"\n        return self._base_value * 1e3\n\n    def as_kilovolts(self) -&gt; float:\n        \"\"\"Return the voltage in kilovolts.\n\n        Returns:\n            The voltage in kilovolts.\n        \"\"\"\n        return self._base_value / 1e3\n\n    # See comment for Power.__mul__ for why we need the ignore here.\n    @overload  # type: ignore[override]\n    def __mul__(self, scalar: float, /) -&gt; Self:\n        \"\"\"Scale this voltage by a scalar.\n\n        Args:\n            scalar: The scalar by which to scale this voltage.\n\n        Returns:\n            The scaled voltage.\n        \"\"\"\n\n    @overload\n    def __mul__(self, percent: Percentage, /) -&gt; Self:\n        \"\"\"Scale this voltage by a percentage.\n\n        Args:\n            percent: The percentage by which to scale this voltage.\n\n        Returns:\n            The scaled voltage.\n        \"\"\"\n\n    @overload\n    def __mul__(self, other: Current, /) -&gt; Power:\n        \"\"\"Multiply the voltage by the current to get the power.\n\n        Args:\n            other: The current to multiply the voltage with.\n\n        Returns:\n            The calculated power.\n        \"\"\"\n\n    def __mul__(self, other: float | Percentage | Current, /) -&gt; Self | Power:\n        \"\"\"Return a voltage or power from multiplying this voltage by the given value.\n\n        Args:\n            other: The scalar, percentage or current to multiply by.\n\n        Returns:\n            The calculated voltage or power.\n        \"\"\"\n        match other:\n            case float() | Percentage():\n                return super().__mul__(other)\n            case Current():\n                return Power._new(self._base_value * other._base_value)\n            case _:\n                return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.base_unit","title":"base_unit  <code>property</code>","text":"<pre><code>base_unit: str | None\n</code></pre> <p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.base_value","title":"base_value  <code>property</code>","text":"<pre><code>base_value: float\n</code></pre> <p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Self\n</code></pre> <p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n    \"\"\"Return the absolute value of this quantity.\n\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\n    absolute = type(self).__new__(type(self))\n    absolute._base_value = abs(self._base_value)\n    return absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__add__","title":"__add__","text":"<pre><code>__add__(other: Self) -&gt; Self\n</code></pre> <p>Return the sum of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n    \"\"\"Return the sum of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    summe = type(self).__new__(type(self))\n    summe._base_value = self._base_value + other._base_value\n    return summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Return whether this quantity is equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return whether this quantity is equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    # The above check ensures that both quantities are the exact same type, because\n    # `isinstance` returns true for subclasses and superclasses.  But the above check\n    # doesn't help mypy identify the type of other,  so the below line is necessary.\n    assert isinstance(other, self.__class__)\n    return self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__format__","title":"__format__","text":"<pre><code>__format__(__format_spec: str) -&gt; str\n</code></pre> <p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n    \"\"\"Return a formatted string representation of this quantity.\n\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n\n    Args:\n        __format_spec: The format specifier.\n\n    Returns:\n        A string representation of this quantity.\n\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\n    keep_trailing_zeros = False\n    if __format_spec != \"\":\n        fspec_parts = __format_spec.split(\".\")\n        if (\n            len(fspec_parts) != 2\n            or fspec_parts[0] not in (\"\", \"0\")\n            or not fspec_parts[1].isdigit()\n        ):\n            raise ValueError(\n                \"Invalid format specifier. Must be empty or `[0].{precision}`\"\n            )\n        if fspec_parts[0] == \"0\":\n            keep_trailing_zeros = True\n        precision = int(fspec_parts[1])\n    else:\n        precision = 3\n    if not self._exponent_unit_map:\n        return f\"{self._base_value:.{precision}f}\"\n\n    if math.isinf(self._base_value) or math.isnan(self._base_value):\n        return f\"{self._base_value} {self._exponent_unit_map[0]}\"\n\n    if abs_value := abs(self._base_value):\n        precision_pow = 10 ** (precision)\n        # Prevent numbers like 999.999999 being rendered as 1000 V\n        # instead of 1 kV.\n        # This could happen because the str formatting function does\n        # rounding as well.\n        # This is an imperfect solution that works for _most_ cases.\n        # isclose parameters were chosen according to the observed cases\n        if math.isclose(abs_value, precision_pow, abs_tol=1e-4, rel_tol=0.01):\n            # If the value is close to the precision, round it\n            exponent = math.ceil(math.log10(precision_pow))\n        else:\n            exponent = math.floor(math.log10(abs_value))\n    else:\n        exponent = 0\n\n    unit_place = exponent - exponent % 3\n    if unit_place &lt; min(self._exponent_unit_map):\n        unit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\n        unit_place = min(self._exponent_unit_map)\n    elif unit_place &gt; max(self._exponent_unit_map):\n        unit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\n        unit_place = max(self._exponent_unit_map)\n    else:\n        unit = self._exponent_unit_map[unit_place]\n\n    value_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\n\n    if value_str in (\"-0\", \"0\"):\n        stripped = value_str\n    else:\n        stripped = value_str.rstrip(\"0\").rstrip(\".\")\n\n    if not keep_trailing_zeros:\n        value_str = stripped\n    unit_str = unit if stripped not in (\"-0\", \"0\") else self._exponent_unit_map[0]\n    return f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is greater than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is greater than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__init__","title":"__init__","text":"<pre><code>__init__(value: float, exponent: int = 0) -&gt; None\n</code></pre> <p>Initialize a new quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n    \"\"\"Initialize a new quantity.\n\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\n    self._base_value = value * 10.0**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(\n    exponent_unit_map: dict[int, str]\n) -&gt; None\n</code></pre> <p>Initialize a new subclass of Quantity.</p> PARAMETER DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n    \"\"\"Initialize a new subclass of Quantity.\n\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\n    if 0 not in exponent_unit_map:\n        raise ValueError(\"Expected a base unit for the type (for exponent 0)\")\n    cls._exponent_unit_map = exponent_unit_map\n    super().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__le__","title":"__le__","text":"<pre><code>__le__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than or equal to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than or equal to another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether this quantity is less than another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n    \"\"\"Return whether this quantity is less than another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    return self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__mul__","title":"__mul__","text":"<pre><code>__mul__(\n    other: float | Percentage | Current,\n) -&gt; Self | Power\n</code></pre> <p>Return a voltage or power from multiplying this voltage by the given value.</p> PARAMETER DESCRIPTION <code>other</code> <p>The scalar, percentage or current to multiply by.</p> <p> TYPE: <code>float | Percentage | Current</code> </p> RETURNS DESCRIPTION <code>Self | Power</code> <p>The calculated voltage or power.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: float | Percentage | Current, /) -&gt; Self | Power:\n    \"\"\"Return a voltage or power from multiplying this voltage by the given value.\n\n    Args:\n        other: The scalar, percentage or current to multiply by.\n\n    Returns:\n        The calculated voltage or power.\n    \"\"\"\n    match other:\n        case float() | Percentage():\n            return super().__mul__(other)\n        case Current():\n            return Power._new(self._base_value * other._base_value)\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Self\n</code></pre> <p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n    \"\"\"Return the negation of this quantity.\n\n    Returns:\n        The negation of this quantity.\n    \"\"\"\n    negation = type(self).__new__(type(self))\n    negation._base_value = -self._base_value\n    return negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a representation of this quantity.\n\n    Returns:\n        A representation of this quantity.\n    \"\"\"\n    return f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this quantity.\n\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\n    return self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Self) -&gt; Self\n</code></pre> <p>Return the difference of this quantity and another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n    \"\"\"Return the difference of this quantity and another.\n\n    Args:\n        other: The other quantity.\n\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\n    if not type(other) is type(self):\n        return NotImplemented\n    difference = type(self).__new__(type(self))\n    difference._base_value = self._base_value - other._base_value\n    return difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(value: float | Self) -&gt; Self | float\n</code></pre> <p>Divide this quantity by a scalar or another quantity.</p> PARAMETER DESCRIPTION <code>value</code> <p>The scalar or quantity to divide this quantity by.</p> <p> TYPE: <code>float | Self</code> </p> RETURNS DESCRIPTION <code>Self | float</code> <p>The divided quantity or the ratio of this quantity to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, value: float | Self, /) -&gt; Self | float:\n    \"\"\"Divide this quantity by a scalar or another quantity.\n\n    Args:\n        value: The scalar or quantity to divide this quantity by.\n\n    Returns:\n        The divided quantity or the ratio of this quantity to another.\n    \"\"\"\n    match value:\n        case float():\n            return type(self)._new(self._base_value / value)\n        case Quantity() if type(value) is type(self):\n            return self._base_value / value._base_value\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_kilovolts","title":"as_kilovolts","text":"<pre><code>as_kilovolts() -&gt; float\n</code></pre> <p>Return the voltage in kilovolts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in kilovolts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilovolts(self) -&gt; float:\n    \"\"\"Return the voltage in kilovolts.\n\n    Returns:\n        The voltage in kilovolts.\n    \"\"\"\n    return self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_millivolts","title":"as_millivolts","text":"<pre><code>as_millivolts() -&gt; float\n</code></pre> <p>Return the voltage in millivolts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in millivolts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_millivolts(self) -&gt; float:\n    \"\"\"Return the voltage in millivolts.\n\n    Returns:\n        The voltage in millivolts.\n    \"\"\"\n    return self._base_value * 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_volts","title":"as_volts","text":"<pre><code>as_volts() -&gt; float\n</code></pre> <p>Return the voltage in volts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in volts.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_volts(self) -&gt; float:\n    \"\"\"Return the voltage in volts.\n\n    Returns:\n        The voltage in volts.\n    \"\"\"\n    return self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_kilovolts","title":"from_kilovolts  <code>classmethod</code>","text":"<pre><code>from_kilovolts(kilovolts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER DESCRIPTION <code>kilovolts</code> <p>The voltage in kilovolts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilovolts(cls, kilovolts: float) -&gt; Self:\n    \"\"\"Initialize a new voltage quantity.\n\n    Args:\n        kilovolts: The voltage in kilovolts.\n\n    Returns:\n        A new voltage quantity.\n    \"\"\"\n    return cls._new(kilovolts, exponent=3)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_millivolts","title":"from_millivolts  <code>classmethod</code>","text":"<pre><code>from_millivolts(millivolts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER DESCRIPTION <code>millivolts</code> <p>The voltage in millivolts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_millivolts(cls, millivolts: float) -&gt; Self:\n    \"\"\"Initialize a new voltage quantity.\n\n    Args:\n        millivolts: The voltage in millivolts.\n\n    Returns:\n        A new voltage quantity.\n    \"\"\"\n    return cls._new(millivolts, exponent=-3)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; Self\n</code></pre> <p>Return a quantity from a string representation.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string representation of the quantity.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity object with the value given in the string.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the string does not match the expected format.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; Self:\n    \"\"\"Return a quantity from a string representation.\n\n    Args:\n        string: The string representation of the quantity.\n\n    Returns:\n        A quantity object with the value given in the string.\n\n    Raises:\n        ValueError: If the string does not match the expected format.\n\n    \"\"\"\n    split_string = string.split(\" \")\n\n    if len(split_string) != 2:\n        raise ValueError(\n            f\"Expected a string of the form 'value unit', got {string}\"\n        )\n\n    assert cls._exponent_unit_map is not None\n    exp_map = cls._exponent_unit_map\n\n    for exponent, unit in exp_map.items():\n        if unit == split_string[1]:\n            instance = cls.__new__(cls)\n            try:\n                instance._base_value = float(split_string[0]) * 10**exponent\n            except ValueError as error:\n                raise ValueError(f\"Failed to parse string '{string}'.\") from error\n\n            return instance\n\n    raise ValueError(f\"Unknown unit {split_string[1]}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_volts","title":"from_volts  <code>classmethod</code>","text":"<pre><code>from_volts(volts: float) -&gt; Self\n</code></pre> <p>Initialize a new voltage quantity.</p> PARAMETER DESCRIPTION <code>volts</code> <p>The voltage in volts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_volts(cls, volts: float) -&gt; Self:\n    \"\"\"Initialize a new voltage quantity.\n\n    Args:\n        volts: The voltage in volts.\n\n    Returns:\n        A new voltage quantity.\n    \"\"\"\n    return cls._new(volts)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.isclose","title":"isclose","text":"<pre><code>isclose(\n    other: Self,\n    rel_tol: float = 1e-09,\n    abs_tol: float = 0.0,\n) -&gt; bool\n</code></pre> <p>Return whether this quantity is close to another.</p> PARAMETER DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n    \"\"\"Return whether this quantity is close to another.\n\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\n    return math.isclose(\n        self._base_value,\n        other._base_value,  # pylint: disable=protected-access\n        rel_tol=rel_tol,\n        abs_tol=abs_tol,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.isinf","title":"isinf","text":"<pre><code>isinf() -&gt; bool\n</code></pre> <p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n    \"\"\"Return whether this quantity is infinite.\n\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\n    return math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.isnan","title":"isnan","text":"<pre><code>isnan() -&gt; bool\n</code></pre> <p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n    \"\"\"Return whether this quantity is NaN.\n\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\n    return math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.zero","title":"zero  <code>classmethod</code>","text":"<pre><code>zero() -&gt; Self\n</code></pre> <p>Return a quantity with value 0.0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.0.</p> Source code in <code>frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n    \"\"\"Return a quantity with value 0.0.\n\n    Returns:\n        A quantity with value 0.0.\n    \"\"\"\n    _zero = cls._zero_cache.get(cls, None)\n    if _zero is None:\n        _zero = cls.__new__(cls)\n        _zero._base_value = 0.0\n        cls._zero_cache[cls] = _zero\n    assert isinstance(_zero, cls)\n    return _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/consumer/","title":"consumer","text":""},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer","title":"frequenz.sdk.timeseries.consumer","text":"<p>The logical component for calculating high level consumer metrics for a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer","title":"frequenz.sdk.timeseries.consumer.Consumer","text":"<p>Calculate high level consumer metrics in a microgrid.</p> <p>Under normal circumstances this is expected to correspond to the gross consumption of the site excluding active parts and battery.</p> <p>Consumer provides methods for fetching power values from different points in the microgrid. These methods return <code>FormulaReceiver</code> objects, which can be used like normal <code>Receiver</code>s, but can also be composed to form higher-order formula streams.</p> <p>Note</p> <p><code>Consumer</code> instances are not meant to be created directly by users. Use the <code>microgrid.consumer</code> method for creating <code>Consumer</code> instances.</p> Example <pre><code>from datetime import timedelta\n\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.timeseries import ResamplerConfig\n\nawait microgrid.initialize(\n    \"grpc://127.0.0.1:50051\",\n    ResamplerConfig(resampling_period=timedelta(seconds=1.0))\n)\n\nconsumer = microgrid.consumer()\n\n# Get a receiver for a builtin formula\nconsumer_power_recv = consumer.power.new_receiver()\nasync for consumer_power_sample in consumer_power_recv:\n    print(consumer_power_sample)\n</code></pre> Source code in <code>frequenz/sdk/timeseries/consumer.py</code> <pre><code>class Consumer:\n    \"\"\"Calculate high level consumer metrics in a microgrid.\n\n    Under normal circumstances this is expected to correspond to the gross\n    consumption of the site excluding active parts and battery.\n\n    Consumer provides methods for fetching power values from different points\n    in the microgrid. These methods return `FormulaReceiver` objects, which can\n    be used like normal `Receiver`s, but can also be composed to form\n    higher-order formula streams.\n\n    !!! note\n        `Consumer` instances are not meant to be created directly by users.\n        Use the [`microgrid.consumer`][frequenz.sdk.microgrid.consumer] method\n        for creating `Consumer` instances.\n\n    Example:\n        ```python\n        from datetime import timedelta\n\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.timeseries import ResamplerConfig\n\n        await microgrid.initialize(\n            \"grpc://127.0.0.1:50051\",\n            ResamplerConfig(resampling_period=timedelta(seconds=1.0))\n        )\n\n        consumer = microgrid.consumer()\n\n        # Get a receiver for a builtin formula\n        consumer_power_recv = consumer.power.new_receiver()\n        async for consumer_power_sample in consumer_power_recv:\n            print(consumer_power_sample)\n        ```\n    \"\"\"\n\n    _formula_pool: FormulaEnginePool\n    \"\"\"The formula engine pool to generate consumer metrics.\"\"\"\n\n    def __init__(\n        self,\n        channel_registry: ChannelRegistry,\n        resampler_subscription_sender: Sender[ComponentMetricRequest],\n    ) -&gt; None:\n        \"\"\"Initialize the consumer formula generator.\n\n        Args:\n            channel_registry: The channel registry to use for the consumer.\n            resampler_subscription_sender: The sender to use for resampler subscriptions.\n        \"\"\"\n        namespace = f\"consumer-{uuid.uuid4()}\"\n        self._formula_pool = FormulaEnginePool(\n            namespace,\n            channel_registry,\n            resampler_subscription_sender,\n        )\n\n    @property\n    def power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the consumer power for the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        It will start the formula engine to calculate consumer power if it is\n        not already running.\n\n        A receiver from the formula engine can be created using the\n        `new_receiver` method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream consumer power.\n        \"\"\"\n        engine = self._formula_pool.from_power_formula_generator(\n            \"consumer_power\",\n            ConsumerPowerFormula,\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all formula engines.\"\"\"\n        await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the consumer power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>It will start the formula engine to calculate consumer power if it is not already running.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream consumer power.</p>"},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer.__init__","title":"__init__","text":"<pre><code>__init__(\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[\n        ComponentMetricRequest\n    ],\n) -&gt; None\n</code></pre> <p>Initialize the consumer formula generator.</p> PARAMETER DESCRIPTION <code>channel_registry</code> <p>The channel registry to use for the consumer.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>The sender to use for resampler subscriptions.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> Source code in <code>frequenz/sdk/timeseries/consumer.py</code> <pre><code>def __init__(\n    self,\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n    \"\"\"Initialize the consumer formula generator.\n\n    Args:\n        channel_registry: The channel registry to use for the consumer.\n        resampler_subscription_sender: The sender to use for resampler subscriptions.\n    \"\"\"\n    namespace = f\"consumer-{uuid.uuid4()}\"\n    self._formula_pool = FormulaEnginePool(\n        namespace,\n        channel_registry,\n        resampler_subscription_sender,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/consumer/#frequenz.sdk.timeseries.consumer.Consumer.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all formula engines.</p> Source code in <code>frequenz/sdk/timeseries/consumer.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all formula engines.\"\"\"\n    await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/grid/","title":"grid","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid","title":"frequenz.sdk.timeseries.grid","text":"<p>Grid connection point.</p> <p>This module provides the <code>Grid</code> type, which represents a grid connection point in a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid","title":"frequenz.sdk.timeseries.grid.Grid  <code>dataclass</code>","text":"<p>A grid connection point.</p> <p>Note</p> <p>The <code>Grid</code> instance is not meant to be created directly by users. Use the <code>microgrid.grid</code> method for creating or getting the <code>Grid</code> instance.</p> Example <pre><code>from datetime import timedelta\n\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.timeseries import ResamplerConfig\n\nawait microgrid.initialize(\n    \"grpc://127.0.0.1:50051\",\n    ResamplerConfig(resampling_period=timedelta(seconds=1))\n)\n\ngrid = microgrid.grid()\n\n# Get a receiver for a builtin formula\ngrid_power_recv = grid.power.new_receiver()\nasync for grid_power_sample in grid_power_recv:\n    print(grid_power_sample)\n</code></pre> Source code in <code>frequenz/sdk/timeseries/grid.py</code> <pre><code>@dataclass(frozen=True)\nclass Grid:\n    \"\"\"A grid connection point.\n\n    !!! note\n        The `Grid` instance is not meant to be created directly by users.\n        Use the [`microgrid.grid`][frequenz.sdk.microgrid.grid] method for\n        creating or getting the `Grid` instance.\n\n    Example:\n        ```python\n        from datetime import timedelta\n\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.timeseries import ResamplerConfig\n\n        await microgrid.initialize(\n            \"grpc://127.0.0.1:50051\",\n            ResamplerConfig(resampling_period=timedelta(seconds=1))\n        )\n\n        grid = microgrid.grid()\n\n        # Get a receiver for a builtin formula\n        grid_power_recv = grid.power.new_receiver()\n        async for grid_power_sample in grid_power_recv:\n            print(grid_power_sample)\n        ```\n    \"\"\"\n\n    fuse: Fuse | None\n    \"\"\"The fuse protecting the grid connection point.\n\n    The rated current of the fuse is set to zero in case of an islanded\n    microgrid.\n    And the fuse is set to `None` when the grid connection component metadata\n    lacks information about the fuse.\n    \"\"\"\n\n    _formula_pool: FormulaEnginePool\n    \"\"\"The formula engine pool to generate grid metrics.\"\"\"\n\n    @property\n    def power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the grid power for the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate grid power is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream grid power.\n        \"\"\"\n        engine = self._formula_pool.from_power_formula_generator(\n            \"grid_power\",\n            GridPowerFormula,\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def _power_per_phase(self) -&gt; FormulaEngine3Phase[Power]:\n        \"\"\"Fetch the per-phase grid power for the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        A receiver from the formula engine can be created using the\n        `new_receiver`method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream grid 3-phase power.\n        \"\"\"\n        engine = self._formula_pool.from_power_3_phase_formula_generator(\n            \"grid_power_3_phase\", GridPower3PhaseFormula\n        )\n        assert isinstance(engine, FormulaEngine3Phase)\n        return engine\n\n    @property\n    def current_per_phase(self) -&gt; FormulaEngine3Phase[Current]:\n        \"\"\"Fetch the per-phase grid current for the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate grid current is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream grid current.\n        \"\"\"\n        engine = self._formula_pool.from_3_phase_current_formula_generator(\n            \"grid_current\",\n            GridCurrentFormula,\n        )\n        assert isinstance(engine, FormulaEngine3Phase)\n        return engine\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all formula engines.\"\"\"\n        await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid.current_per_phase","title":"current_per_phase  <code>property</code>","text":"<pre><code>current_per_phase: FormulaEngine3Phase[Current]\n</code></pre> <p>Fetch the per-phase grid current for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate grid current is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine3Phase[Current]</code> <p>A FormulaEngine that will calculate and stream grid current.</p>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid.fuse","title":"fuse  <code>instance-attribute</code>","text":"<pre><code>fuse: Fuse | None\n</code></pre> <p>The fuse protecting the grid connection point.</p> <p>The rated current of the fuse is set to zero in case of an islanded microgrid. And the fuse is set to <code>None</code> when the grid connection component metadata lacks information about the fuse.</p>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the grid power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate grid power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream grid power.</p>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.Grid.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all formula engines.</p> Source code in <code>frequenz/sdk/timeseries/grid.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all formula engines.\"\"\"\n    await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.get","title":"frequenz.sdk.timeseries.grid.get","text":"<pre><code>get() -&gt; Grid\n</code></pre> <p>Get the grid connection.</p> <p>Note that the rated current of the fuse is set to zero in case of an islanded microgrid. And the fuse is set to <code>None</code> when the grid connection component metadata lacks information about the fuse.</p> RETURNS DESCRIPTION <code>Grid</code> <p>The grid connection.</p> Source code in <code>frequenz/sdk/timeseries/grid.py</code> <pre><code>def get() -&gt; Grid:\n    \"\"\"Get the grid connection.\n\n    Note that the rated current of the fuse is set to zero in case of an\n    islanded microgrid.\n    And the fuse is set to `None` when the grid connection component metadata\n    lacks information about the fuse.\n\n    Returns:\n        The grid connection.\n    \"\"\"\n    assert _GRID, \"Grid is not initialized\"\n    return _GRID\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/grid/#frequenz.sdk.timeseries.grid.initialize","title":"frequenz.sdk.timeseries.grid.initialize","text":"<pre><code>initialize(\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[\n        ComponentMetricRequest\n    ],\n) -&gt; None\n</code></pre> <p>Initialize the grid connection.</p> PARAMETER DESCRIPTION <code>channel_registry</code> <p>The channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>The sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If there is more than 1 grid connection point in the microgrid, or if the grid connection point is not initialized.</p> Source code in <code>frequenz/sdk/timeseries/grid.py</code> <pre><code>def initialize(\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n    \"\"\"Initialize the grid connection.\n\n    Args:\n        channel_registry: The channel registry instance shared with the\n            resampling actor.\n        resampler_subscription_sender: The sender for sending metric requests\n            to the resampling actor.\n\n    Raises:\n        RuntimeError: If there is more than 1 grid connection point in the\n            microgrid, or if the grid connection point is not initialized.\n    \"\"\"\n    global _GRID  # pylint: disable=global-statement\n\n    grid_connections = list(\n        connection_manager.get().component_graph.components(\n            component_categories={ComponentCategory.GRID},\n        )\n    )\n\n    grid_connections_count = len(grid_connections)\n\n    fuse: Fuse | None = None\n\n    if grid_connections_count == 0:\n        fuse = Fuse(max_current=Current.zero())\n        _logger.info(\n            \"No grid connection found for this microgrid. This is normal for an islanded microgrid.\"\n        )\n    elif grid_connections_count &gt; 1:\n        raise RuntimeError(\n            f\"Expected at most one grid connection, got {grid_connections_count}\"\n        )\n    else:\n        if grid_connections[0].metadata is None:\n            raise RuntimeError(\"Grid metadata is None\")\n\n        # The current implementation of the Component Graph fails to\n        # effectively convert components from a dictionary representation to\n        # the expected Component object.\n        # Specifically for the component metadata, it hands back a dictionary\n        # instead of the expected ComponentMetadata type.\n        metadata = grid_connections[0].metadata\n        if isinstance(metadata, dict):\n            if fuse_dict := metadata.get(\"fuse\", None):\n                fuse = Fuse(\n                    max_current=Current.from_amperes(fuse_dict.get(\"max_current\", 0.0))\n                )\n\n        if fuse is None:\n            _logger.warning(\"The grid connection point does not have a fuse\")\n\n    namespace = f\"grid-{uuid.uuid4()}\"\n    formula_pool = FormulaEnginePool(\n        namespace,\n        channel_registry,\n        resampler_subscription_sender,\n    )\n\n    _GRID = Grid(fuse, formula_pool)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/producer/","title":"producer","text":""},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer","title":"frequenz.sdk.timeseries.producer","text":"<p>The logical component for calculating high level producer metrics for a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer","title":"frequenz.sdk.timeseries.producer.Producer","text":"<p>Calculate high level producer metrics in a microgrid.</p> <p>Under normal circumstances this is expected to correspond to the gross production of the sites active parts excluding EV chargers and batteries.</p> <p>Producer provides methods for fetching power values from different points in the microgrid. These methods return <code>FormulaReceiver</code> objects, which can be used like normal <code>Receiver</code>s, but can also be composed to form higher-order formula streams.</p> <p>Note</p> <p><code>Producer</code> instances are not meant to be created directly by users. Use the <code>microgrid.producer</code> method for creating <code>Producer</code> instances.</p> Example <pre><code>from datetime import timedelta\n\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.timeseries import ResamplerConfig\n\nawait microgrid.initialize(\n    \"grpc://127.0.0.1:50051\",\n    ResamplerConfig(resampling_period=timedelta(seconds=1.0))\n)\n\nproducer = microgrid.producer()\n\n# Get a receiver for a builtin formula\nproducer_power_recv = producer.power.new_receiver()\nasync for producer_power_sample in producer_power_recv:\n    print(producer_power_sample)\n</code></pre> Source code in <code>frequenz/sdk/timeseries/producer.py</code> <pre><code>class Producer:\n    \"\"\"Calculate high level producer metrics in a microgrid.\n\n    Under normal circumstances this is expected to correspond to the gross\n    production of the sites active parts excluding EV chargers and batteries.\n\n    Producer provides methods for fetching power values from different points\n    in the microgrid. These methods return `FormulaReceiver` objects, which can\n    be used like normal `Receiver`s, but can also be composed to form\n    higher-order formula streams.\n\n    !!! note\n        `Producer` instances are not meant to be created directly by users.\n        Use the [`microgrid.producer`][frequenz.sdk.microgrid.producer] method\n        for creating `Producer` instances.\n\n    Example:\n        ```python\n        from datetime import timedelta\n\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.timeseries import ResamplerConfig\n\n        await microgrid.initialize(\n            \"grpc://127.0.0.1:50051\",\n            ResamplerConfig(resampling_period=timedelta(seconds=1.0))\n        )\n\n        producer = microgrid.producer()\n\n        # Get a receiver for a builtin formula\n        producer_power_recv = producer.power.new_receiver()\n        async for producer_power_sample in producer_power_recv:\n            print(producer_power_sample)\n        ```\n    \"\"\"\n\n    _formula_pool: FormulaEnginePool\n    \"\"\"The formula engine pool to generate producer metrics.\"\"\"\n\n    def __init__(\n        self,\n        channel_registry: ChannelRegistry,\n        resampler_subscription_sender: Sender[ComponentMetricRequest],\n    ) -&gt; None:\n        \"\"\"Initialize the producer formula generator.\n\n        Args:\n            channel_registry: The channel registry to use for the producer.\n            resampler_subscription_sender: The sender to use for resampler subscriptions.\n        \"\"\"\n        namespace = f\"producer-{uuid.uuid4()}\"\n        self._formula_pool = FormulaEnginePool(\n            namespace,\n            channel_registry,\n            resampler_subscription_sender,\n        )\n\n    @property\n    def power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the producer power for the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        It will start the formula engine to calculate producer power if it is\n        not already running.\n\n        A receiver from the formula engine can be created using the\n        `new_receiver` method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream producer power.\n        \"\"\"\n        engine = self._formula_pool.from_power_formula_generator(\n            \"producer_power\",\n            ProducerPowerFormula,\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all formula engines.\"\"\"\n        await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the producer power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>It will start the formula engine to calculate producer power if it is not already running.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream producer power.</p>"},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer.__init__","title":"__init__","text":"<pre><code>__init__(\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[\n        ComponentMetricRequest\n    ],\n) -&gt; None\n</code></pre> <p>Initialize the producer formula generator.</p> PARAMETER DESCRIPTION <code>channel_registry</code> <p>The channel registry to use for the producer.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>The sender to use for resampler subscriptions.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> Source code in <code>frequenz/sdk/timeseries/producer.py</code> <pre><code>def __init__(\n    self,\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n    \"\"\"Initialize the producer formula generator.\n\n    Args:\n        channel_registry: The channel registry to use for the producer.\n        resampler_subscription_sender: The sender to use for resampler subscriptions.\n    \"\"\"\n    namespace = f\"producer-{uuid.uuid4()}\"\n    self._formula_pool = FormulaEnginePool(\n        namespace,\n        channel_registry,\n        resampler_subscription_sender,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/producer/#frequenz.sdk.timeseries.producer.Producer.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all formula engines.</p> Source code in <code>frequenz/sdk/timeseries/producer.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all formula engines.\"\"\"\n    await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/","title":"battery_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool","title":"frequenz.sdk.timeseries.battery_pool","text":"<p>Manage a pool of batteries.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool","title":"frequenz.sdk.timeseries.battery_pool.BatteryPool","text":"<p>An interface for interaction with pools of batteries.</p> Provides <ul> <li>properties for fetching reporting streams of instantaneous   power,   soc,   capacity values and   available power bounds and other status through   power_status.</li> <li>control methods for proposing power values, namely:   propose_power,   propose_charge and   propose_discharge.</li> </ul> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>class BatteryPool:\n    \"\"\"An interface for interaction with pools of batteries.\n\n    Provides:\n      - properties for fetching reporting streams of instantaneous\n        [power][frequenz.sdk.timeseries.battery_pool.BatteryPool.power],\n        [soc][frequenz.sdk.timeseries.battery_pool.BatteryPool.soc],\n        [capacity][frequenz.sdk.timeseries.battery_pool.BatteryPool.capacity] values and\n        available power bounds and other status through\n        [power_status][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status].\n      - control methods for proposing power values, namely:\n        [propose_power][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power],\n        [propose_charge][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_charge] and\n        [propose_discharge][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_discharge].\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        pool_ref_store: BatteryPoolReferenceStore,\n        name: str | None,\n        priority: int,\n        set_operating_point: bool,\n    ):\n        \"\"\"Create a BatteryPool instance.\n\n        !!! note\n            `BatteryPool` instances are not meant to be created directly by users.  Use\n            the [`microgrid.new_battery_pool`][frequenz.sdk.microgrid.new_battery_pool]\n            method for creating `BatteryPool` instances.\n\n        Args:\n            pool_ref_store: The battery pool reference store instance.\n            name: An optional name used to identify this instance of the pool or a\n                corresponding actor in the logs.\n            priority: The priority of the actor using this wrapper.\n            set_operating_point: Whether this instance sets the operating point power or\n                the normal power for the components.\n        \"\"\"\n        self._pool_ref_store = pool_ref_store\n        unique_id = str(uuid.uuid4())\n        self._source_id = unique_id if name is None else f\"{name}-{unique_id}\"\n        self._priority = priority\n        self._set_operating_point = set_operating_point\n\n    async def propose_power(\n        self,\n        power: Power | None,\n        *,\n        bounds: timeseries.Bounds[Power | None] = timeseries.Bounds(None, None),\n    ) -&gt; None:\n        \"\"\"Send a proposal to the power manager for the pool's set of batteries.\n\n        Power values need to follow the Passive Sign Convention (PSC). That is, positive\n        values indicate charge power and negative values indicate discharge power.\n\n        If the same batteries are shared by multiple actors, the power manager will\n        consider the priority of the actors, the bounds they set, and their preferred\n        power, when calculating the target power for the batteries.\n\n        The preferred power of lower priority actors will take precedence as long as\n        they respect the bounds set by higher priority actors.  If lower priority actors\n        request power values outside of the bounds set by higher priority actors, the\n        target power will be the closest value to the preferred power that is within the\n        bounds.\n\n        When there are no other actors trying to use the same batteries, the actor's\n        preferred power would be set as the target power, as long as it falls within the\n        system power bounds for the batteries.\n\n        The result of the request can be accessed using the receiver returned from the\n        [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n        method, which also streams the bounds that an actor should comply with, based on\n        its priority.\n\n        Args:\n            power: The power to propose for the batteries in the pool.  If `None`, this\n                proposal will not have any effect on the target power, unless bounds are\n                specified.  If both are `None`, it is equivalent to not having a\n                proposal or withdrawing a previous one.\n            bounds: The power bounds for the proposal.  These bounds will apply to\n                actors with a lower priority, and can be overridden by bounds from\n                actors with a higher priority.  If None, the power bounds will be set\n                to the maximum power of the batteries in the pool.  This is currently\n                and experimental feature.\n        \"\"\"\n        await self._pool_ref_store._power_manager_requests_sender.send(\n            _power_managing.Proposal(\n                source_id=self._source_id,\n                preferred_power=power,\n                bounds=bounds,\n                component_ids=self._pool_ref_store._batteries,\n                priority=self._priority,\n                creation_time=asyncio.get_running_loop().time(),\n                set_operating_point=self._set_operating_point,\n            )\n        )\n\n    async def propose_charge(self, power: Power | None) -&gt; None:\n        \"\"\"Set the given charge power for the batteries in the pool.\n\n        Power values need to be positive values, indicating charge power.\n\n        When using the Passive Sign Convention, the\n        [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n        method might be more convenient.\n\n        If the same batteries are shared by multiple actors, the behaviour is the same\n        as that of the `propose_power` method.  The bounds for lower priority actors\n        can't be specified with this method.  If that's required, use the\n        `propose_power` method instead.\n\n        The result of the request can be accessed using the receiver returned from the\n        [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n        method.\n\n        Args:\n            power: The unsigned charge power to propose for the batteries in the pool.\n                If None, the proposed power of higher priority actors will take\n                precedence as the target power.\n\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\n        if power and power &lt; Power.zero():\n            raise ValueError(\"Charge power must be positive.\")\n        await self._pool_ref_store._power_manager_requests_sender.send(\n            _power_managing.Proposal(\n                source_id=self._source_id,\n                preferred_power=power,\n                bounds=timeseries.Bounds(None, None),\n                component_ids=self._pool_ref_store._batteries,\n                priority=self._priority,\n                creation_time=asyncio.get_running_loop().time(),\n                set_operating_point=self._set_operating_point,\n            )\n        )\n\n    async def propose_discharge(self, power: Power | None) -&gt; None:\n        \"\"\"Set the given discharge power for the batteries in the pool.\n\n        Power values need to be positive values, indicating discharge power.\n\n        When using the Passive Sign Convention, the\n        [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n        method might be more convenient.\n\n        If the same batteries are shared by multiple actors, the behaviour is the same\n        as that of the `propose_power` method.  The bounds for lower priority actors\n        can't be specified with this method.  If that's required, use the\n        `propose_power` method instead.\n\n        The result of the request can be accessed using the receiver returned from the\n        [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n        method.\n\n        Args:\n            power: The unsigned discharge power to propose for the batteries in the\n                pool.  If None, the proposed power of higher priority actors will take\n                precedence as the target power.\n\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\n        if power:\n            if power &lt; Power.zero():\n                raise ValueError(\"Discharge power must be positive.\")\n            power = -power\n        await self._pool_ref_store._power_manager_requests_sender.send(\n            _power_managing.Proposal(\n                source_id=self._source_id,\n                preferred_power=power,\n                bounds=timeseries.Bounds(None, None),\n                component_ids=self._pool_ref_store._batteries,\n                priority=self._priority,\n                creation_time=asyncio.get_running_loop().time(),\n                set_operating_point=self._set_operating_point,\n            )\n        )\n\n    @property\n    def component_ids(self) -&gt; abc.Set[int]:\n        \"\"\"Return ids of the batteries in the pool.\n\n        Returns:\n            Ids of the batteries in the pool\n        \"\"\"\n        return self._pool_ref_store._batteries\n\n    @property\n    def power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the total power of the batteries in the pool.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all\n                batteries in the pool.\n        \"\"\"\n        engine = self._pool_ref_store._formula_pool.from_power_formula_generator(\n            \"battery_pool_power\",\n            BatteryPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._pool_ref_store._batteries,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def soc(self) -&gt; ReceiverFetcher[Sample[Percentage]]:\n        \"\"\"Fetch the normalized average weighted-by-capacity SoC values for the pool.\n\n        The SoC values are normalized to the 0-100% range and clamped if they are out\n        of bounds. Only values from working batteries with operational inverters are\n        considered in the calculation.\n\n        Average SoC is calculated using the formula:\n        ```\n        working_batteries: Set[BatteryData] # working batteries from the battery pool\n\n        soc_scaled = min(max(\n            0,\n            (soc - soc_lower_bound) / (soc_upper_bound - soc_lower_bound) * 100,\n        ), 100)\n        used_capacity = sum(\n            battery.usable_capacity * battery.soc_scaled\n            for battery in working_batteries\n        )\n        total_capacity = sum(battery.usable_capacity for battery in working_batteries)\n        average_soc = used_capacity/total_capacity\n        ```\n\n        `None` values will be sent if there are no working batteries with operational\n        inverters to calculate the metric with.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the aggregate SoC of all\n                batteries in the pool, considering only working batteries with\n                operational inverters.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + SoCCalculator.name()\n\n        if method_name not in self._pool_ref_store._active_methods:\n            calculator = SoCCalculator(self._pool_ref_store._batteries)\n            self._pool_ref_store._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._pool_ref_store._working_batteries,\n                min_update_interval=self._pool_ref_store._min_update_interval,\n            )\n\n        return self._pool_ref_store._active_methods[method_name]\n\n    @property\n    def temperature(self) -&gt; ReceiverFetcher[Sample[Temperature]]:\n        \"\"\"Fetch the average temperature of the batteries in the pool.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the average temperature\n                of all batteries in the pool.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + TemperatureCalculator.name()\n        if method_name not in self._pool_ref_store._active_methods:\n            calculator = TemperatureCalculator(self._pool_ref_store._batteries)\n            self._pool_ref_store._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._pool_ref_store._working_batteries,\n                min_update_interval=self._pool_ref_store._min_update_interval,\n            )\n        return self._pool_ref_store._active_methods[method_name]\n\n    @property\n    def capacity(self) -&gt; ReceiverFetcher[Sample[Energy]]:\n        \"\"\"Get a receiver to receive new capacity metrics when they change.\n\n        The reported capacity values consider only working batteries with operational\n        inverters.\n\n        Calculated with the formula:\n        ```\n        working_batteries: Set[BatteryData] # working batteries from the battery pool\n        total_capacity = sum(\n            battery.capacity * (soc_upper_bound - soc_lower_bound) / 100\n            for battery in working_batteries\n        )\n        ```\n\n        `None` will be sent if there are no working batteries with operational\n        inverters to calculate metrics.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the capacity of all\n                batteries in the pool, considering only working batteries with\n                operational inverters.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + CapacityCalculator.name()\n\n        if method_name not in self._pool_ref_store._active_methods:\n            calculator = CapacityCalculator(self._pool_ref_store._batteries)\n            self._pool_ref_store._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._pool_ref_store._working_batteries,\n                min_update_interval=self._pool_ref_store._min_update_interval,\n            )\n\n        return self._pool_ref_store._active_methods[method_name]\n\n    @property\n    def power_status(self) -&gt; ReceiverFetcher[BatteryPoolReport]:\n        \"\"\"Get a receiver to receive new power status reports when they change.\n\n        These include\n          - the current inclusion/exclusion bounds available for the pool's priority,\n          - the current target power for the pool's set of batteries,\n          - the result of the last distribution request for the pool's set of batteries.\n\n        Returns:\n            A receiver that will stream power status reports for the pool's priority.\n        \"\"\"\n        sub = _power_managing.ReportRequest(\n            source_id=self._source_id,\n            priority=self._priority,\n            component_ids=self._pool_ref_store._batteries,\n            set_operating_point=self._set_operating_point,\n        )\n        self._pool_ref_store._power_bounds_subs[sub.get_channel_name()] = (\n            asyncio.create_task(\n                self._pool_ref_store._power_manager_bounds_subscription_sender.send(sub)\n            )\n        )\n        channel = self._pool_ref_store._channel_registry.get_or_create(\n            _power_managing._Report, sub.get_channel_name()\n        )\n        channel.resend_latest = True\n\n        return channel\n\n    @property\n    def power_distribution_results(self) -&gt; ReceiverFetcher[power_distributing.Result]:\n        \"\"\"Get a receiver to receive power distribution results.\n\n        Returns:\n            A receiver that will stream power distribution results for the pool's set of\n            batteries.\n        \"\"\"\n        return MappingReceiverFetcher(\n            self._pool_ref_store._power_dist_results_fetcher,\n            lambda recv: recv.filter(\n                lambda x: x.request.component_ids == self._pool_ref_store._batteries\n            ),\n        )\n\n    @property\n    def _system_power_bounds(self) -&gt; ReceiverFetcher[SystemBounds]:\n        \"\"\"Get receiver to receive new power bounds when they change.\n\n        Power bounds refer to the min and max power that a battery can\n        discharge or charge at and is also denoted as SoP.\n\n        Power bounds formulas are described in the receiver return type.\n        None will be send if there is no component to calculate metrics.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the power bounds\n                of all batteries in the pool.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + PowerBoundsCalculator.name()\n\n        if method_name not in self._pool_ref_store._active_methods:\n            calculator = PowerBoundsCalculator(self._pool_ref_store._batteries)\n            self._pool_ref_store._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._pool_ref_store._working_batteries,\n                min_update_interval=self._pool_ref_store._min_update_interval,\n            )\n\n        return self._pool_ref_store._active_methods[method_name]\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all tasks and channels owned by the BatteryPool.\"\"\"\n        await self._pool_ref_store.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.capacity","title":"capacity  <code>property</code>","text":"<pre><code>capacity: ReceiverFetcher[Sample[Energy]]\n</code></pre> <p>Get a receiver to receive new capacity metrics when they change.</p> <p>The reported capacity values consider only working batteries with operational inverters.</p> <p>Calculated with the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\ntotal_capacity = sum(\n    battery.capacity * (soc_upper_bound - soc_lower_bound) / 100\n    for battery in working_batteries\n)\n</code></pre></p> <p><code>None</code> will be sent if there are no working batteries with operational inverters to calculate metrics.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Sample[Energy]]</code> <p>A MetricAggregator that will calculate and stream the capacity of all batteries in the pool, considering only working batteries with operational inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids: Set[int]\n</code></pre> <p>Return ids of the batteries in the pool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Ids of the batteries in the pool</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the total power of the batteries in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.power_distribution_results","title":"power_distribution_results  <code>property</code>","text":"<pre><code>power_distribution_results: ReceiverFetcher[Result]\n</code></pre> <p>Get a receiver to receive power distribution results.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Result]</code> <p>A receiver that will stream power distribution results for the pool's set of</p> <code>ReceiverFetcher[Result]</code> <p>batteries.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status","title":"power_status  <code>property</code>","text":"<pre><code>power_status: ReceiverFetcher[BatteryPoolReport]\n</code></pre> <p>Get a receiver to receive new power status reports when they change.</p> <p>These include   - the current inclusion/exclusion bounds available for the pool's priority,   - the current target power for the pool's set of batteries,   - the result of the last distribution request for the pool's set of batteries.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[BatteryPoolReport]</code> <p>A receiver that will stream power status reports for the pool's priority.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.soc","title":"soc  <code>property</code>","text":"<pre><code>soc: ReceiverFetcher[Sample[Percentage]]\n</code></pre> <p>Fetch the normalized average weighted-by-capacity SoC values for the pool.</p> <p>The SoC values are normalized to the 0-100% range and clamped if they are out of bounds. Only values from working batteries with operational inverters are considered in the calculation.</p> <p>Average SoC is calculated using the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\n\nsoc_scaled = min(max(\n    0,\n    (soc - soc_lower_bound) / (soc_upper_bound - soc_lower_bound) * 100,\n), 100)\nused_capacity = sum(\n    battery.usable_capacity * battery.soc_scaled\n    for battery in working_batteries\n)\ntotal_capacity = sum(battery.usable_capacity for battery in working_batteries)\naverage_soc = used_capacity/total_capacity\n</code></pre></p> <p><code>None</code> values will be sent if there are no working batteries with operational inverters to calculate the metric with.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Sample[Percentage]]</code> <p>A MetricAggregator that will calculate and stream the aggregate SoC of all batteries in the pool, considering only working batteries with operational inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.temperature","title":"temperature  <code>property</code>","text":"<pre><code>temperature: ReceiverFetcher[Sample[Temperature]]\n</code></pre> <p>Fetch the average temperature of the batteries in the pool.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Sample[Temperature]]</code> <p>A MetricAggregator that will calculate and stream the average temperature of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    pool_ref_store: BatteryPoolReferenceStore,\n    name: str | None,\n    priority: int,\n    set_operating_point: bool\n)\n</code></pre> <p>Create a BatteryPool instance.</p> <p>Note</p> <p><code>BatteryPool</code> instances are not meant to be created directly by users.  Use the <code>microgrid.new_battery_pool</code> method for creating <code>BatteryPool</code> instances.</p> PARAMETER DESCRIPTION <code>pool_ref_store</code> <p>The battery pool reference store instance.</p> <p> TYPE: <code>BatteryPoolReferenceStore</code> </p> <code>name</code> <p>An optional name used to identify this instance of the pool or a corresponding actor in the logs.</p> <p> TYPE: <code>str | None</code> </p> <code>priority</code> <p>The priority of the actor using this wrapper.</p> <p> TYPE: <code>int</code> </p> <code>set_operating_point</code> <p>Whether this instance sets the operating point power or the normal power for the components.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>def __init__(\n    self,\n    *,\n    pool_ref_store: BatteryPoolReferenceStore,\n    name: str | None,\n    priority: int,\n    set_operating_point: bool,\n):\n    \"\"\"Create a BatteryPool instance.\n\n    !!! note\n        `BatteryPool` instances are not meant to be created directly by users.  Use\n        the [`microgrid.new_battery_pool`][frequenz.sdk.microgrid.new_battery_pool]\n        method for creating `BatteryPool` instances.\n\n    Args:\n        pool_ref_store: The battery pool reference store instance.\n        name: An optional name used to identify this instance of the pool or a\n            corresponding actor in the logs.\n        priority: The priority of the actor using this wrapper.\n        set_operating_point: Whether this instance sets the operating point power or\n            the normal power for the components.\n    \"\"\"\n    self._pool_ref_store = pool_ref_store\n    unique_id = str(uuid.uuid4())\n    self._source_id = unique_id if name is None else f\"{name}-{unique_id}\"\n    self._priority = priority\n    self._set_operating_point = set_operating_point\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_charge","title":"propose_charge  <code>async</code>","text":"<pre><code>propose_charge(power: Power | None) -&gt; None\n</code></pre> <p>Set the given charge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating charge power.</p> <p>When using the Passive Sign Convention, the <code>propose_power</code> method might be more convenient.</p> <p>If the same batteries are shared by multiple actors, the behaviour is the same as that of the <code>propose_power</code> method.  The bounds for lower priority actors can't be specified with this method.  If that's required, use the <code>propose_power</code> method instead.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_status</code> method.</p> PARAMETER DESCRIPTION <code>power</code> <p>The unsigned charge power to propose for the batteries in the pool. If None, the proposed power of higher priority actors will take precedence as the target power.</p> <p> TYPE: <code>Power | None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>async def propose_charge(self, power: Power | None) -&gt; None:\n    \"\"\"Set the given charge power for the batteries in the pool.\n\n    Power values need to be positive values, indicating charge power.\n\n    When using the Passive Sign Convention, the\n    [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n    method might be more convenient.\n\n    If the same batteries are shared by multiple actors, the behaviour is the same\n    as that of the `propose_power` method.  The bounds for lower priority actors\n    can't be specified with this method.  If that's required, use the\n    `propose_power` method instead.\n\n    The result of the request can be accessed using the receiver returned from the\n    [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n    method.\n\n    Args:\n        power: The unsigned charge power to propose for the batteries in the pool.\n            If None, the proposed power of higher priority actors will take\n            precedence as the target power.\n\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\n    if power and power &lt; Power.zero():\n        raise ValueError(\"Charge power must be positive.\")\n    await self._pool_ref_store._power_manager_requests_sender.send(\n        _power_managing.Proposal(\n            source_id=self._source_id,\n            preferred_power=power,\n            bounds=timeseries.Bounds(None, None),\n            component_ids=self._pool_ref_store._batteries,\n            priority=self._priority,\n            creation_time=asyncio.get_running_loop().time(),\n            set_operating_point=self._set_operating_point,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_discharge","title":"propose_discharge  <code>async</code>","text":"<pre><code>propose_discharge(power: Power | None) -&gt; None\n</code></pre> <p>Set the given discharge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating discharge power.</p> <p>When using the Passive Sign Convention, the <code>propose_power</code> method might be more convenient.</p> <p>If the same batteries are shared by multiple actors, the behaviour is the same as that of the <code>propose_power</code> method.  The bounds for lower priority actors can't be specified with this method.  If that's required, use the <code>propose_power</code> method instead.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_status</code> method.</p> PARAMETER DESCRIPTION <code>power</code> <p>The unsigned discharge power to propose for the batteries in the pool.  If None, the proposed power of higher priority actors will take precedence as the target power.</p> <p> TYPE: <code>Power | None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>async def propose_discharge(self, power: Power | None) -&gt; None:\n    \"\"\"Set the given discharge power for the batteries in the pool.\n\n    Power values need to be positive values, indicating discharge power.\n\n    When using the Passive Sign Convention, the\n    [`propose_power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power]\n    method might be more convenient.\n\n    If the same batteries are shared by multiple actors, the behaviour is the same\n    as that of the `propose_power` method.  The bounds for lower priority actors\n    can't be specified with this method.  If that's required, use the\n    `propose_power` method instead.\n\n    The result of the request can be accessed using the receiver returned from the\n    [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n    method.\n\n    Args:\n        power: The unsigned discharge power to propose for the batteries in the\n            pool.  If None, the proposed power of higher priority actors will take\n            precedence as the target power.\n\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\n    if power:\n        if power &lt; Power.zero():\n            raise ValueError(\"Discharge power must be positive.\")\n        power = -power\n    await self._pool_ref_store._power_manager_requests_sender.send(\n        _power_managing.Proposal(\n            source_id=self._source_id,\n            preferred_power=power,\n            bounds=timeseries.Bounds(None, None),\n            component_ids=self._pool_ref_store._batteries,\n            priority=self._priority,\n            creation_time=asyncio.get_running_loop().time(),\n            set_operating_point=self._set_operating_point,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.propose_power","title":"propose_power  <code>async</code>","text":"<pre><code>propose_power(\n    power: Power | None,\n    *,\n    bounds: Bounds[Power | None] = timeseries.Bounds(\n        None, None\n    )\n) -&gt; None\n</code></pre> <p>Send a proposal to the power manager for the pool's set of batteries.</p> <p>Power values need to follow the Passive Sign Convention (PSC). That is, positive values indicate charge power and negative values indicate discharge power.</p> <p>If the same batteries are shared by multiple actors, the power manager will consider the priority of the actors, the bounds they set, and their preferred power, when calculating the target power for the batteries.</p> <p>The preferred power of lower priority actors will take precedence as long as they respect the bounds set by higher priority actors.  If lower priority actors request power values outside of the bounds set by higher priority actors, the target power will be the closest value to the preferred power that is within the bounds.</p> <p>When there are no other actors trying to use the same batteries, the actor's preferred power would be set as the target power, as long as it falls within the system power bounds for the batteries.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_status</code> method, which also streams the bounds that an actor should comply with, based on its priority.</p> PARAMETER DESCRIPTION <code>power</code> <p>The power to propose for the batteries in the pool.  If <code>None</code>, this proposal will not have any effect on the target power, unless bounds are specified.  If both are <code>None</code>, it is equivalent to not having a proposal or withdrawing a previous one.</p> <p> TYPE: <code>Power | None</code> </p> <code>bounds</code> <p>The power bounds for the proposal.  These bounds will apply to actors with a lower priority, and can be overridden by bounds from actors with a higher priority.  If None, the power bounds will be set to the maximum power of the batteries in the pool.  This is currently and experimental feature.</p> <p> TYPE: <code>Bounds[Power | None]</code> DEFAULT: <code>Bounds(None, None)</code> </p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>async def propose_power(\n    self,\n    power: Power | None,\n    *,\n    bounds: timeseries.Bounds[Power | None] = timeseries.Bounds(None, None),\n) -&gt; None:\n    \"\"\"Send a proposal to the power manager for the pool's set of batteries.\n\n    Power values need to follow the Passive Sign Convention (PSC). That is, positive\n    values indicate charge power and negative values indicate discharge power.\n\n    If the same batteries are shared by multiple actors, the power manager will\n    consider the priority of the actors, the bounds they set, and their preferred\n    power, when calculating the target power for the batteries.\n\n    The preferred power of lower priority actors will take precedence as long as\n    they respect the bounds set by higher priority actors.  If lower priority actors\n    request power values outside of the bounds set by higher priority actors, the\n    target power will be the closest value to the preferred power that is within the\n    bounds.\n\n    When there are no other actors trying to use the same batteries, the actor's\n    preferred power would be set as the target power, as long as it falls within the\n    system power bounds for the batteries.\n\n    The result of the request can be accessed using the receiver returned from the\n    [`power_status`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power_status]\n    method, which also streams the bounds that an actor should comply with, based on\n    its priority.\n\n    Args:\n        power: The power to propose for the batteries in the pool.  If `None`, this\n            proposal will not have any effect on the target power, unless bounds are\n            specified.  If both are `None`, it is equivalent to not having a\n            proposal or withdrawing a previous one.\n        bounds: The power bounds for the proposal.  These bounds will apply to\n            actors with a lower priority, and can be overridden by bounds from\n            actors with a higher priority.  If None, the power bounds will be set\n            to the maximum power of the batteries in the pool.  This is currently\n            and experimental feature.\n    \"\"\"\n    await self._pool_ref_store._power_manager_requests_sender.send(\n        _power_managing.Proposal(\n            source_id=self._source_id,\n            preferred_power=power,\n            bounds=bounds,\n            component_ids=self._pool_ref_store._batteries,\n            priority=self._priority,\n            creation_time=asyncio.get_running_loop().time(),\n            set_operating_point=self._set_operating_point,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all tasks and channels owned by the BatteryPool.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_battery_pool.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all tasks and channels owned by the BatteryPool.\"\"\"\n    await self._pool_ref_store.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport","title":"frequenz.sdk.timeseries.battery_pool.BatteryPoolReport","text":"<p>               Bases: <code>Protocol</code></p> <p>A status report for a battery pool.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_result_types.py</code> <pre><code>class BatteryPoolReport(typing.Protocol):\n    \"\"\"A status report for a battery pool.\"\"\"\n\n    @property\n    def target_power(self) -&gt; Power | None:\n        \"\"\"The currently set power for the batteries.\"\"\"\n\n    @property\n    def bounds(self) -&gt; Bounds[Power] | None:\n        \"\"\"The usable bounds for the batteries.\n\n        These bounds are adjusted to any restrictions placed by actors with higher\n        priorities.\n\n        There might be exclusion zones within these bounds. If necessary, the\n        [`adjust_to_bounds`][frequenz.sdk.timeseries.battery_pool.BatteryPoolReport.adjust_to_bounds]\n        method may be used to check if a desired power value fits the bounds, or to get\n        the closest possible power values that do fit the bounds.\n        \"\"\"\n\n    @abc.abstractmethod\n    def adjust_to_bounds(self, power: Power) -&gt; tuple[Power | None, Power | None]:\n        \"\"\"Adjust a power value to the bounds.\n\n        This method can be used to adjust a desired power value to the power bounds\n        available to the actor.\n\n        If the given power value falls within the usable bounds, it will be returned\n        unchanged.\n\n        If it falls outside the usable bounds, the closest possible value on the\n        corresponding side will be returned.  For example, if the given power is lower\n        than the lowest usable power, only the lowest usable power will be returned, and\n        similarly for the highest usable power.\n\n        If the given power falls within an exclusion zone that's contained within the\n        usable bounds, the closest possible power values on both sides will be returned.\n\n        !!! note\n            It is completely optional to use this method to adjust power values before\n            proposing them, because the battery pool will do this automatically.  This\n            method is provided for convenience, and for granular control when there are\n            two possible power values, both of which fall within the available bounds.\n\n        Example:\n            ```python\n            from frequenz.sdk import microgrid\n\n            power_status_rx = microgrid.new_battery_pool(\n                priority=5,\n            ).power_status.new_receiver()\n            power_status = await power_status_rx.receive()\n            desired_power = Power.from_watts(1000.0)\n\n            match power_status.adjust_to_bounds(desired_power):\n                case (power, _) if power == desired_power:\n                    print(\"Desired power is available.\")\n                case (None, power) | (power, None) if power:\n                    print(f\"Closest available power is {power}.\")\n                case (lower, upper) if lower and upper:\n                    print(f\"Two options {lower}, {upper} to propose to battery pool.\")\n                case (None, None):\n                    print(\"No available power\")\n            ```\n\n        Args:\n            power: The power value to adjust.\n\n        Returns:\n            A tuple of the closest power values to the desired power that fall within\n                the available bounds for the actor.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport.bounds","title":"bounds  <code>property</code>","text":"<pre><code>bounds: Bounds[Power] | None\n</code></pre> <p>The usable bounds for the batteries.</p> <p>These bounds are adjusted to any restrictions placed by actors with higher priorities.</p> <p>There might be exclusion zones within these bounds. If necessary, the <code>adjust_to_bounds</code> method may be used to check if a desired power value fits the bounds, or to get the closest possible power values that do fit the bounds.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport.target_power","title":"target_power  <code>property</code>","text":"<pre><code>target_power: Power | None\n</code></pre> <p>The currently set power for the batteries.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPoolReport.adjust_to_bounds","title":"adjust_to_bounds  <code>abstractmethod</code>","text":"<pre><code>adjust_to_bounds(\n    power: Power,\n) -&gt; tuple[Power | None, Power | None]\n</code></pre> <p>Adjust a power value to the bounds.</p> <p>This method can be used to adjust a desired power value to the power bounds available to the actor.</p> <p>If the given power value falls within the usable bounds, it will be returned unchanged.</p> <p>If it falls outside the usable bounds, the closest possible value on the corresponding side will be returned.  For example, if the given power is lower than the lowest usable power, only the lowest usable power will be returned, and similarly for the highest usable power.</p> <p>If the given power falls within an exclusion zone that's contained within the usable bounds, the closest possible power values on both sides will be returned.</p> <p>Note</p> <p>It is completely optional to use this method to adjust power values before proposing them, because the battery pool will do this automatically.  This method is provided for convenience, and for granular control when there are two possible power values, both of which fall within the available bounds.</p> Example <pre><code>from frequenz.sdk import microgrid\n\npower_status_rx = microgrid.new_battery_pool(\n    priority=5,\n).power_status.new_receiver()\npower_status = await power_status_rx.receive()\ndesired_power = Power.from_watts(1000.0)\n\nmatch power_status.adjust_to_bounds(desired_power):\n    case (power, _) if power == desired_power:\n        print(\"Desired power is available.\")\n    case (None, power) | (power, None) if power:\n        print(f\"Closest available power is {power}.\")\n    case (lower, upper) if lower and upper:\n        print(f\"Two options {lower}, {upper} to propose to battery pool.\")\n    case (None, None):\n        print(\"No available power\")\n</code></pre> PARAMETER DESCRIPTION <code>power</code> <p>The power value to adjust.</p> <p> TYPE: <code>Power</code> </p> RETURNS DESCRIPTION <code>tuple[Power | None, Power | None]</code> <p>A tuple of the closest power values to the desired power that fall within the available bounds for the actor.</p> Source code in <code>frequenz/sdk/timeseries/battery_pool/_result_types.py</code> <pre><code>@abc.abstractmethod\ndef adjust_to_bounds(self, power: Power) -&gt; tuple[Power | None, Power | None]:\n    \"\"\"Adjust a power value to the bounds.\n\n    This method can be used to adjust a desired power value to the power bounds\n    available to the actor.\n\n    If the given power value falls within the usable bounds, it will be returned\n    unchanged.\n\n    If it falls outside the usable bounds, the closest possible value on the\n    corresponding side will be returned.  For example, if the given power is lower\n    than the lowest usable power, only the lowest usable power will be returned, and\n    similarly for the highest usable power.\n\n    If the given power falls within an exclusion zone that's contained within the\n    usable bounds, the closest possible power values on both sides will be returned.\n\n    !!! note\n        It is completely optional to use this method to adjust power values before\n        proposing them, because the battery pool will do this automatically.  This\n        method is provided for convenience, and for granular control when there are\n        two possible power values, both of which fall within the available bounds.\n\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n\n        power_status_rx = microgrid.new_battery_pool(\n            priority=5,\n        ).power_status.new_receiver()\n        power_status = await power_status_rx.receive()\n        desired_power = Power.from_watts(1000.0)\n\n        match power_status.adjust_to_bounds(desired_power):\n            case (power, _) if power == desired_power:\n                print(\"Desired power is available.\")\n            case (None, power) | (power, None) if power:\n                print(f\"Closest available power is {power}.\")\n            case (lower, upper) if lower and upper:\n                print(f\"Two options {lower}, {upper} to propose to battery pool.\")\n            case (None, None):\n                print(\"No available power\")\n        ```\n\n    Args:\n        power: The power value to adjust.\n\n    Returns:\n        A tuple of the closest power values to the desired power that fall within\n            the available bounds for the actor.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/","title":"ev_charger_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool","title":"frequenz.sdk.timeseries.ev_charger_pool","text":"<p>Interactions with EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool","title":"frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool","text":"<p>An interface for interaction with pools of EV Chargers.</p> Provides <ul> <li>Aggregate <code>power</code>   and   <code>current_per_phase</code>   measurements of the EV Chargers in the pool.</li> </ul> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>class EVChargerPool:\n    \"\"\"An interface for interaction with pools of EV Chargers.\n\n    Provides:\n      - Aggregate [`power`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.power]\n        and\n        [`current_per_phase`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.current_per_phase]\n        measurements of the EV Chargers in the pool.\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        *,\n        pool_ref_store: EVChargerPoolReferenceStore,\n        name: str | None,\n        priority: int,\n        set_operating_point: bool,\n    ) -&gt; None:\n        \"\"\"Create an `EVChargerPool` instance.\n\n        !!! note\n\n            `EVChargerPool` instances are not meant to be created directly by users. Use\n            the\n            [`microgrid.new_ev_charger_pool`][frequenz.sdk.microgrid.new_ev_charger_pool]\n            method for creating `EVChargerPool` instances.\n\n        Args:\n            pool_ref_store: The EV charger pool reference store instance.\n            name: An optional name used to identify this instance of the pool or a\n                corresponding actor in the logs.\n            priority: The priority of the actor using this wrapper.\n            set_operating_point: Whether this instance sets the operating point power or\n                the normal power for the components.\n        \"\"\"\n        self._pool_ref_store = pool_ref_store\n        unique_id = str(uuid.uuid4())\n        self._source_id = unique_id if name is None else f\"{name}-{unique_id}\"\n        self._priority = priority\n        self._set_operating_point = set_operating_point\n\n    async def propose_power(\n        self,\n        power: Power | None,\n        *,\n        bounds: Bounds[Power | None] = Bounds(None, None),\n    ) -&gt; None:\n        \"\"\"Send a proposal to the power manager for the pool's set of EV chargers.\n\n        This proposal is for the maximum power that can be set for the EV chargers in\n        the pool.  The actual consumption might be lower based on the number of phases\n        an EV is drawing power from, and its current state of charge.\n\n        Power values need to follow the Passive Sign Convention (PSC). That is, positive\n        values indicate charge power and negative values indicate discharge power.\n        Discharging from EV chargers is currently not supported.\n\n        If the same EV chargers are shared by multiple actors, the power manager will\n        consider the priority of the actors, the bounds they set, and their preferred\n        power, when calculating the target power for the EV chargers\n\n        The preferred power of lower priority actors will take precedence as long as\n        they respect the bounds set by higher priority actors.  If lower priority actors\n        request power values outside of the bounds set by higher priority actors, the\n        target power will be the closest value to the preferred power that is within the\n        bounds.\n\n        When there are no other actors trying to use the same EV chargers, the actor's\n        preferred power would be set as the target power, as long as it falls within the\n        system power bounds for the EV chargers.\n\n        The result of the request can be accessed using the receiver returned from the\n        [`power_status`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.power_status]\n        method, which also streams the bounds that an actor should comply with, based on\n        its priority.\n\n        Args:\n            power: The power to propose for the EV chargers in the pool.  If `None`,\n                this proposal will not have any effect on the target power, unless\n                bounds are specified.  If both are `None`, it is equivalent to not\n                having a proposal or withdrawing a previous one.\n            bounds: The power bounds for the proposal.  These bounds will apply to\n                actors with a lower priority, and can be overridden by bounds from\n                actors with a higher priority.  If None, the power bounds will be set to\n                the maximum power of the batteries in the pool.  This is currently and\n                experimental feature.\n\n        Raises:\n            EVChargerPoolError: If a discharge power for EV chargers is requested.\n        \"\"\"\n        if power is not None and power &lt; Power.zero():\n            raise EVChargerPoolError(\n                \"Discharging from EV chargers is currently not supported.\"\n            )\n        await self._pool_ref_store.power_manager_requests_sender.send(\n            _power_managing.Proposal(\n                source_id=self._source_id,\n                preferred_power=power,\n                bounds=bounds,\n                component_ids=self._pool_ref_store.component_ids,\n                priority=self._priority,\n                creation_time=asyncio.get_running_loop().time(),\n                set_operating_point=self._set_operating_point,\n            )\n        )\n\n    @property\n    def component_ids(self) -&gt; abc.Set[int]:\n        \"\"\"Return component IDs of all EV Chargers managed by this EVChargerPool.\n\n        Returns:\n            Set of managed component IDs.\n        \"\"\"\n        return self._pool_ref_store.component_ids\n\n    @property\n    def current_per_phase(self) -&gt; FormulaEngine3Phase[Current]:\n        \"\"\"Fetch the total current for the EV Chargers in the pool.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate EV Charger current is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total current of all EV\n                Chargers.\n        \"\"\"\n        engine = (\n            self._pool_ref_store.formula_pool.from_3_phase_current_formula_generator(\n                \"ev_charger_total_current\",\n                EVChargerCurrentFormula,\n                FormulaGeneratorConfig(\n                    component_ids=self._pool_ref_store.component_ids\n                ),\n            )\n        )\n        assert isinstance(engine, FormulaEngine3Phase)\n        return engine\n\n    @property\n    def power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the total power for the EV Chargers in the pool.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate EV Charger power is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all EV\n                Chargers.\n        \"\"\"\n        engine = self._pool_ref_store.formula_pool.from_power_formula_generator(\n            \"ev_charger_power\",\n            EVChargerPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._pool_ref_store.component_ids,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def power_status(self) -&gt; ReceiverFetcher[EVChargerPoolReport]:\n        \"\"\"Get a receiver to receive new power status reports when they change.\n\n        These include\n          - the current inclusion/exclusion bounds available for the pool's priority,\n          - the current target power for the pool's set of batteries,\n          - the result of the last distribution request for the pool's set of batteries.\n\n        Returns:\n            A receiver that will stream power status reports for the pool's priority.\n        \"\"\"\n        sub = _power_managing.ReportRequest(\n            source_id=self._source_id,\n            priority=self._priority,\n            component_ids=self._pool_ref_store.component_ids,\n            set_operating_point=self._set_operating_point,\n        )\n        self._pool_ref_store.power_bounds_subs[sub.get_channel_name()] = (\n            asyncio.create_task(\n                self._pool_ref_store.power_manager_bounds_subs_sender.send(sub)\n            )\n        )\n        channel = self._pool_ref_store.channel_registry.get_or_create(\n            _power_managing._Report,  # pylint: disable=protected-access\n            sub.get_channel_name(),\n        )\n        channel.resend_latest = True\n\n        return channel\n\n    @property\n    def power_distribution_results(self) -&gt; ReceiverFetcher[power_distributing.Result]:\n        \"\"\"Get a receiver to receive power distribution results.\n\n        Returns:\n            A receiver that will stream power distribution results for the pool's set of\n            EV chargers.\n        \"\"\"\n        return MappingReceiverFetcher(\n            self._pool_ref_store.power_distribution_results_fetcher,\n            lambda recv: recv.filter(\n                lambda x: x.request.component_ids == self._pool_ref_store.component_ids\n            ),\n        )\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all tasks and channels owned by the EVChargerPool.\"\"\"\n        await self._pool_ref_store.stop()\n\n    @property\n    def _system_power_bounds(self) -&gt; ReceiverFetcher[SystemBounds]:\n        \"\"\"Return a receiver fetcher for the system power bounds.\"\"\"\n        return self._pool_ref_store.bounds_channel\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids: Set[int]\n</code></pre> <p>Return component IDs of all EV Chargers managed by this EVChargerPool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Set of managed component IDs.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.current_per_phase","title":"current_per_phase  <code>property</code>","text":"<pre><code>current_per_phase: FormulaEngine3Phase[Current]\n</code></pre> <p>Fetch the total current for the EV Chargers in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate EV Charger current is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine3Phase[Current]</code> <p>A FormulaEngine that will calculate and stream the total current of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the total power for the EV Chargers in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate EV Charger power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total power of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.power_distribution_results","title":"power_distribution_results  <code>property</code>","text":"<pre><code>power_distribution_results: ReceiverFetcher[Result]\n</code></pre> <p>Get a receiver to receive power distribution results.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Result]</code> <p>A receiver that will stream power distribution results for the pool's set of</p> <code>ReceiverFetcher[Result]</code> <p>EV chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.power_status","title":"power_status  <code>property</code>","text":"<pre><code>power_status: ReceiverFetcher[EVChargerPoolReport]\n</code></pre> <p>Get a receiver to receive new power status reports when they change.</p> <p>These include   - the current inclusion/exclusion bounds available for the pool's priority,   - the current target power for the pool's set of batteries,   - the result of the last distribution request for the pool's set of batteries.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[EVChargerPoolReport]</code> <p>A receiver that will stream power status reports for the pool's priority.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    pool_ref_store: EVChargerPoolReferenceStore,\n    name: str | None,\n    priority: int,\n    set_operating_point: bool\n) -&gt; None\n</code></pre> <p>Create an <code>EVChargerPool</code> instance.</p> <p>Note</p> <p><code>EVChargerPool</code> instances are not meant to be created directly by users. Use the <code>microgrid.new_ev_charger_pool</code> method for creating <code>EVChargerPool</code> instances.</p> PARAMETER DESCRIPTION <code>pool_ref_store</code> <p>The EV charger pool reference store instance.</p> <p> TYPE: <code>EVChargerPoolReferenceStore</code> </p> <code>name</code> <p>An optional name used to identify this instance of the pool or a corresponding actor in the logs.</p> <p> TYPE: <code>str | None</code> </p> <code>priority</code> <p>The priority of the actor using this wrapper.</p> <p> TYPE: <code>int</code> </p> <code>set_operating_point</code> <p>Whether this instance sets the operating point power or the normal power for the components.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    *,\n    pool_ref_store: EVChargerPoolReferenceStore,\n    name: str | None,\n    priority: int,\n    set_operating_point: bool,\n) -&gt; None:\n    \"\"\"Create an `EVChargerPool` instance.\n\n    !!! note\n\n        `EVChargerPool` instances are not meant to be created directly by users. Use\n        the\n        [`microgrid.new_ev_charger_pool`][frequenz.sdk.microgrid.new_ev_charger_pool]\n        method for creating `EVChargerPool` instances.\n\n    Args:\n        pool_ref_store: The EV charger pool reference store instance.\n        name: An optional name used to identify this instance of the pool or a\n            corresponding actor in the logs.\n        priority: The priority of the actor using this wrapper.\n        set_operating_point: Whether this instance sets the operating point power or\n            the normal power for the components.\n    \"\"\"\n    self._pool_ref_store = pool_ref_store\n    unique_id = str(uuid.uuid4())\n    self._source_id = unique_id if name is None else f\"{name}-{unique_id}\"\n    self._priority = priority\n    self._set_operating_point = set_operating_point\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.propose_power","title":"propose_power  <code>async</code>","text":"<pre><code>propose_power(\n    power: Power | None,\n    *,\n    bounds: Bounds[Power | None] = Bounds(None, None)\n) -&gt; None\n</code></pre> <p>Send a proposal to the power manager for the pool's set of EV chargers.</p> <p>This proposal is for the maximum power that can be set for the EV chargers in the pool.  The actual consumption might be lower based on the number of phases an EV is drawing power from, and its current state of charge.</p> <p>Power values need to follow the Passive Sign Convention (PSC). That is, positive values indicate charge power and negative values indicate discharge power. Discharging from EV chargers is currently not supported.</p> <p>If the same EV chargers are shared by multiple actors, the power manager will consider the priority of the actors, the bounds they set, and their preferred power, when calculating the target power for the EV chargers</p> <p>The preferred power of lower priority actors will take precedence as long as they respect the bounds set by higher priority actors.  If lower priority actors request power values outside of the bounds set by higher priority actors, the target power will be the closest value to the preferred power that is within the bounds.</p> <p>When there are no other actors trying to use the same EV chargers, the actor's preferred power would be set as the target power, as long as it falls within the system power bounds for the EV chargers.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_status</code> method, which also streams the bounds that an actor should comply with, based on its priority.</p> PARAMETER DESCRIPTION <code>power</code> <p>The power to propose for the EV chargers in the pool.  If <code>None</code>, this proposal will not have any effect on the target power, unless bounds are specified.  If both are <code>None</code>, it is equivalent to not having a proposal or withdrawing a previous one.</p> <p> TYPE: <code>Power | None</code> </p> <code>bounds</code> <p>The power bounds for the proposal.  These bounds will apply to actors with a lower priority, and can be overridden by bounds from actors with a higher priority.  If None, the power bounds will be set to the maximum power of the batteries in the pool.  This is currently and experimental feature.</p> <p> TYPE: <code>Bounds[Power | None]</code> DEFAULT: <code>Bounds(None, None)</code> </p> RAISES DESCRIPTION <code>EVChargerPoolError</code> <p>If a discharge power for EV chargers is requested.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>async def propose_power(\n    self,\n    power: Power | None,\n    *,\n    bounds: Bounds[Power | None] = Bounds(None, None),\n) -&gt; None:\n    \"\"\"Send a proposal to the power manager for the pool's set of EV chargers.\n\n    This proposal is for the maximum power that can be set for the EV chargers in\n    the pool.  The actual consumption might be lower based on the number of phases\n    an EV is drawing power from, and its current state of charge.\n\n    Power values need to follow the Passive Sign Convention (PSC). That is, positive\n    values indicate charge power and negative values indicate discharge power.\n    Discharging from EV chargers is currently not supported.\n\n    If the same EV chargers are shared by multiple actors, the power manager will\n    consider the priority of the actors, the bounds they set, and their preferred\n    power, when calculating the target power for the EV chargers\n\n    The preferred power of lower priority actors will take precedence as long as\n    they respect the bounds set by higher priority actors.  If lower priority actors\n    request power values outside of the bounds set by higher priority actors, the\n    target power will be the closest value to the preferred power that is within the\n    bounds.\n\n    When there are no other actors trying to use the same EV chargers, the actor's\n    preferred power would be set as the target power, as long as it falls within the\n    system power bounds for the EV chargers.\n\n    The result of the request can be accessed using the receiver returned from the\n    [`power_status`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.power_status]\n    method, which also streams the bounds that an actor should comply with, based on\n    its priority.\n\n    Args:\n        power: The power to propose for the EV chargers in the pool.  If `None`,\n            this proposal will not have any effect on the target power, unless\n            bounds are specified.  If both are `None`, it is equivalent to not\n            having a proposal or withdrawing a previous one.\n        bounds: The power bounds for the proposal.  These bounds will apply to\n            actors with a lower priority, and can be overridden by bounds from\n            actors with a higher priority.  If None, the power bounds will be set to\n            the maximum power of the batteries in the pool.  This is currently and\n            experimental feature.\n\n    Raises:\n        EVChargerPoolError: If a discharge power for EV chargers is requested.\n    \"\"\"\n    if power is not None and power &lt; Power.zero():\n        raise EVChargerPoolError(\n            \"Discharging from EV chargers is currently not supported.\"\n        )\n    await self._pool_ref_store.power_manager_requests_sender.send(\n        _power_managing.Proposal(\n            source_id=self._source_id,\n            preferred_power=power,\n            bounds=bounds,\n            component_ids=self._pool_ref_store.component_ids,\n            priority=self._priority,\n            creation_time=asyncio.get_running_loop().time(),\n            set_operating_point=self._set_operating_point,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all tasks and channels owned by the EVChargerPool.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all tasks and channels owned by the EVChargerPool.\"\"\"\n    await self._pool_ref_store.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolError","title":"frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolError","text":"<p>               Bases: <code>Exception</code></p> <p>An error that occurred in any of the EVChargerPool methods.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>class EVChargerPoolError(Exception):\n    \"\"\"An error that occurred in any of the EVChargerPool methods.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolReport","title":"frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolReport","text":"<p>               Bases: <code>Protocol</code></p> <p>A status report for an EV chargers pool.</p> Source code in <code>frequenz/sdk/timeseries/ev_charger_pool/_result_types.py</code> <pre><code>class EVChargerPoolReport(typing.Protocol):\n    \"\"\"A status report for an EV chargers pool.\"\"\"\n\n    @property\n    def target_power(self) -&gt; Power | None:\n        \"\"\"The currently set power for the EV chargers.\"\"\"\n\n    @property\n    def bounds(self) -&gt; Bounds[Power] | None:\n        \"\"\"The usable bounds for the EV chargers.\n\n        These bounds are adjusted to any restrictions placed by actors with higher\n        priorities.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolReport-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolReport.bounds","title":"bounds  <code>property</code>","text":"<pre><code>bounds: Bounds[Power] | None\n</code></pre> <p>The usable bounds for the EV chargers.</p> <p>These bounds are adjusted to any restrictions placed by actors with higher priorities.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolReport.target_power","title":"target_power  <code>property</code>","text":"<pre><code>target_power: Power | None\n</code></pre> <p>The currently set power for the EV chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/","title":"formula_engine","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine","title":"frequenz.sdk.timeseries.formula_engine","text":"<p>The formula engine module.</p> <p>This module exposes the FormulaEngine and FormulaEngine3Phase classes.</p>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine","title":"frequenz.sdk.timeseries.formula_engine.FormulaEngine","text":"<p>               Bases: <code>Generic[QuantityT]</code>, <code>_ComposableFormulaEngine['FormulaEngine', 'HigherOrderFormulaBuilder', QuantityT]</code></p> <p><code>FormulaEngine</code>s are a part of the SDK's data pipeline, and provide a way for the SDK to apply formulas on resampled data streams.</p> <p>They are used in the SDK to calculate and stream metrics like <code>grid_power</code>, <code>consumer_power</code>, etc., which are building blocks of the Frequenz SDK Microgrid Model.</p> <p>The SDK creates the formulas by analysing the configuration of components in the Component Graph.</p>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine.new_receiver()</code> method can be used to create a Receiver that streams the Samples calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\n\nbattery_pool = microgrid.new_battery_pool(priority=5)\n\nasync for power in battery_pool.power.new_receiver():\n    print(f\"{power=}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--composition","title":"Composition","text":"<p>Composite <code>FormulaEngine</code>s can be built using arithmetic operations on <code>FormulaEngine</code>s streaming the same type of data.</p> <p>For example, if you're interested in a particular composite metric that can be calculated by subtracting <code>new_battery_pool().power</code> and <code>new_ev_charger_pool().power</code> from the <code>grid().power</code>, we can build a <code>FormulaEngine</code> that provides a stream of this calculated metric as follows:</p> <pre><code>from frequenz.sdk import microgrid\n\nbattery_pool = microgrid.new_battery_pool(priority=5)\nev_charger_pool = microgrid.new_ev_charger_pool(priority=5)\ngrid = microgrid.grid()\n\n# apply operations on formula engines to create a formula engine that would\n# apply these operations on the corresponding data streams.\nnet_power = (\n    grid.power - (battery_pool.power + ev_charger_pool.power)\n).build(\"net_power\")\n\nasync for power in net_power.new_receiver():\n    print(f\"{power=}\")\n</code></pre> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>class FormulaEngine(\n    Generic[QuantityT],\n    _ComposableFormulaEngine[\n        \"FormulaEngine\",  # type: ignore[type-arg]\n        \"HigherOrderFormulaBuilder\",  # type: ignore[type-arg]\n        QuantityT,\n    ],\n):\n    \"\"\"[`FormulaEngine`][frequenz.sdk.timeseries.formula_engine.FormulaEngine]s are a\n    part of the SDK's data pipeline, and provide a way for the SDK to apply formulas on\n    resampled data streams.\n\n    They are used in the SDK to calculate and stream metrics like\n    [`grid_power`][frequenz.sdk.timeseries.grid.Grid.power],\n    [`consumer_power`][frequenz.sdk.timeseries.consumer.Consumer.power],\n    etc., which are building blocks of the\n    [Frequenz SDK Microgrid Model][frequenz.sdk.microgrid--frequenz-sdk-microgrid-model].\n\n    The SDK creates the formulas by analysing the configuration of components in the\n    {{glossary(\"Component Graph\")}}.\n\n    ### Streaming Interface\n\n    The\n    [`FormulaEngine.new_receiver()`][frequenz.sdk.timeseries.formula_engine.FormulaEngine.new_receiver]\n    method can be used to create a\n    [Receiver](https://frequenz-floss.github.io/frequenz-channels-python/latest/reference/frequenz/channels/#frequenz.channels.Receiver)\n    that streams the [Sample][frequenz.sdk.timeseries.Sample]s calculated by the formula\n    engine.\n\n    ```python\n    from frequenz.sdk import microgrid\n\n    battery_pool = microgrid.new_battery_pool(priority=5)\n\n    async for power in battery_pool.power.new_receiver():\n        print(f\"{power=}\")\n    ```\n\n    ### Composition\n\n    Composite `FormulaEngine`s can be built using arithmetic operations on\n    `FormulaEngine`s streaming the same type of data.\n\n    For example, if you're interested in a particular composite metric that can be\n    calculated by subtracting\n    [`new_battery_pool().power`][frequenz.sdk.timeseries.battery_pool.BatteryPool.power] and\n    [`new_ev_charger_pool().power`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool]\n    from the\n    [`grid().power`][frequenz.sdk.timeseries.grid.Grid.power],\n    we can build a `FormulaEngine` that provides a stream of this calculated metric as\n    follows:\n\n    ```python\n    from frequenz.sdk import microgrid\n\n    battery_pool = microgrid.new_battery_pool(priority=5)\n    ev_charger_pool = microgrid.new_ev_charger_pool(priority=5)\n    grid = microgrid.grid()\n\n    # apply operations on formula engines to create a formula engine that would\n    # apply these operations on the corresponding data streams.\n    net_power = (\n        grid.power - (battery_pool.power + ev_charger_pool.power)\n    ).build(\"net_power\")\n\n    async for power in net_power.new_receiver():\n        print(f\"{power=}\")\n    ```\n    \"\"\"  # noqa: D400, D205\n\n    def __init__(\n        self,\n        builder: FormulaBuilder[QuantityT],\n        create_method: Callable[[float], QuantityT],\n    ) -&gt; None:\n        \"\"\"Create a `FormulaEngine` instance.\n\n        Args:\n            builder: A `FormulaBuilder` instance to get the formula steps and metric\n                fetchers from.\n            create_method: A method to generate the output `Sample` value with.  If the\n                formula is for generating power values, this would be\n                `Power.from_watts`, for example.\n        \"\"\"\n        self._higher_order_builder = HigherOrderFormulaBuilder\n        self._name: str = builder.name\n        self._builder: FormulaBuilder[QuantityT] = builder\n        self._create_method = create_method\n        self._channel: Broadcast[Sample[QuantityT]] = Broadcast(name=self._name)\n\n    @classmethod\n    def from_receiver(\n        cls,\n        name: str,\n        receiver: Receiver[Sample[QuantityT]],\n        create_method: Callable[[float], QuantityT],\n        *,\n        nones_are_zeros: bool = False,\n    ) -&gt; FormulaEngine[QuantityT]:\n        \"\"\"\n        Create a formula engine from a receiver.\n\n        Can be used to compose a formula engine with a receiver. When composing\n        the new engine with other engines, make sure that receiver gets data\n        from the same resampler and that the `create_method`s match.\n\n        Example:\n            ```python\n            from frequenz.sdk import microgrid\n            from frequenz.sdk.timeseries import Power\n\n            async def run() -&gt; None:\n                producer_power_engine = microgrid.producer().power\n                consumer_power_recv = microgrid.consumer().power.new_receiver()\n\n                excess_power_recv = (\n                    (\n                        producer_power_engine\n                        + FormulaEngine.from_receiver(\n                            \"consumer power\",\n                            consumer_power_recv,\n                            Power.from_watts,\n                        )\n                    )\n                    .build(\"excess power\")\n                    .new_receiver()\n                )\n\n            asyncio.run(run())\n            ```\n\n        Args:\n            name: A name for the formula engine.\n            receiver: A receiver that streams `Sample`s.\n            create_method: A method to generate the output `Sample` value with,\n                e.g. `Power.from_watts`.\n            nones_are_zeros: If `True`, `None` values in the receiver are treated as 0.\n\n        Returns:\n            A formula engine that streams the `Sample`s from the receiver.\n        \"\"\"\n        builder = FormulaBuilder(name, create_method)\n        builder.push_metric(name, receiver, nones_are_zeros=nones_are_zeros)\n        return cls(builder, create_method)\n\n    async def _run(self) -&gt; None:\n        await self._builder.subscribe()\n        steps, metric_fetchers = self._builder.finalize()\n        evaluator = FormulaEvaluator[QuantityT](\n            self._name, steps, metric_fetchers, self._create_method\n        )\n        sender = self._channel.new_sender()\n        while True:\n            try:\n                msg = await evaluator.apply()\n            except asyncio.CancelledError:\n                _logger.exception(\"FormulaEngine task cancelled: %s\", self._name)\n                raise\n            except Exception as err:  # pylint: disable=broad-except\n                _logger.warning(\n                    \"Formula application failed: %s. Error: %s\", self._name, err\n                )\n            else:\n                await sender.send(msg)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the formula.\n\n        Returns:\n            A string representation of the formula.\n        \"\"\"\n        steps = (\n            self._builder._build_stack\n            if len(self._builder._build_stack) &gt; 0\n            else self._builder._steps\n        )\n        return format_formula(steps)\n\n    def new_receiver(\n        self, name: str | None = None, max_size: int = 50\n    ) -&gt; Receiver[Sample[QuantityT]]:\n        \"\"\"Create a new receiver that streams the output of the formula engine.\n\n        Args:\n            name: An optional name for the receiver.\n            max_size: The size of the receiver's buffer.\n\n        Returns:\n            A receiver that streams output `Sample`s from the formula engine.\n        \"\"\"\n        if self._task is None:\n            self._task = asyncio.create_task(self._run())\n\n        recv = self._channel.new_receiver(name=name, limit=max_size)\n\n        # This is a hack to ensure that the lifetime of the engine is tied to the\n        # lifetime of the receiver.  This is necessary because the engine is a task that\n        # runs forever, and in cases where higher order built for example with the below\n        # idiom, the user would hold no references to the engine and it could get\n        # garbage collected before the receiver.  This behaviour is explained in the\n        # `asyncio.create_task` docs here:\n        # https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task\n        #\n        #     formula = (grid_power_engine + bat_power_engine).build().new_receiver()\n        recv._engine_reference = self  # type: ignore # pylint: disable=protected-access\n        return recv\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__add__","title":"__add__","text":"<pre><code>__add__(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that adds (data in) <code>other</code> to <code>self</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __add__(\n    self,\n    other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT,\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that adds (data in) `other` to `self`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) + other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__init__","title":"__init__","text":"<pre><code>__init__(\n    builder: FormulaBuilder[QuantityT],\n    create_method: Callable[[float], QuantityT],\n) -&gt; None\n</code></pre> <p>Create a <code>FormulaEngine</code> instance.</p> PARAMETER DESCRIPTION <code>builder</code> <p>A <code>FormulaBuilder</code> instance to get the formula steps and metric fetchers from.</p> <p> TYPE: <code>FormulaBuilder[QuantityT]</code> </p> <code>create_method</code> <p>A method to generate the output <code>Sample</code> value with.  If the formula is for generating power values, this would be <code>Power.from_watts</code>, for example.</p> <p> TYPE: <code>Callable[[float], QuantityT]</code> </p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __init__(\n    self,\n    builder: FormulaBuilder[QuantityT],\n    create_method: Callable[[float], QuantityT],\n) -&gt; None:\n    \"\"\"Create a `FormulaEngine` instance.\n\n    Args:\n        builder: A `FormulaBuilder` instance to get the formula steps and metric\n            fetchers from.\n        create_method: A method to generate the output `Sample` value with.  If the\n            formula is for generating power values, this would be\n            `Power.from_watts`, for example.\n    \"\"\"\n    self._higher_order_builder = HigherOrderFormulaBuilder\n    self._name: str = builder.name\n    self._builder: FormulaBuilder[QuantityT] = builder\n    self._create_method = create_method\n    self._channel: Broadcast[Sample[QuantityT]] = Broadcast(name=self._name)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__mul__","title":"__mul__","text":"<pre><code>__mul__(\n    other: (\n        _GenericEngine | _GenericHigherOrderBuilder | float\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that multiplies (data in) <code>self</code> with <code>other</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __mul__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that multiplies (data in) `self` with `other`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) * other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of the formula.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of the formula.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the formula.\n\n    Returns:\n        A string representation of the formula.\n    \"\"\"\n    steps = (\n        self._builder._build_stack\n        if len(self._builder._build_stack) &gt; 0\n        else self._builder._steps\n    )\n    return format_formula(steps)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__sub__","title":"__sub__","text":"<pre><code>__sub__(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that subtracts (data in) <code>other</code> from <code>self</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __sub__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that subtracts (data in) `other` from `self`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) - other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(\n    other: (\n        _GenericEngine | _GenericHigherOrderBuilder | float\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that divides (data in) <code>self</code> by <code>other</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __truediv__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that divides (data in) `self` by `other`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) / other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.consumption","title":"consumption","text":"<pre><code>consumption() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the consumption operator on <code>self</code>.</p> <p>The consumption operator returns either the identity if the power value is positive or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def consumption(self) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"\n    Return a formula builder that applies the consumption operator on `self`.\n\n    The consumption operator returns either the identity if the power value is\n    positive or 0.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).consumption()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.from_receiver","title":"from_receiver  <code>classmethod</code>","text":"<pre><code>from_receiver(\n    name: str,\n    receiver: Receiver[Sample[QuantityT]],\n    create_method: Callable[[float], QuantityT],\n    *,\n    nones_are_zeros: bool = False\n) -&gt; FormulaEngine[QuantityT]\n</code></pre> <p>Create a formula engine from a receiver.</p> <p>Can be used to compose a formula engine with a receiver. When composing the new engine with other engines, make sure that receiver gets data from the same resampler and that the <code>create_method</code>s match.</p> Example <pre><code>from frequenz.sdk import microgrid\nfrom frequenz.sdk.timeseries import Power\n\nasync def run() -&gt; None:\n    producer_power_engine = microgrid.producer().power\n    consumer_power_recv = microgrid.consumer().power.new_receiver()\n\n    excess_power_recv = (\n        (\n            producer_power_engine\n            + FormulaEngine.from_receiver(\n                \"consumer power\",\n                consumer_power_recv,\n                Power.from_watts,\n            )\n        )\n        .build(\"excess power\")\n        .new_receiver()\n    )\n\nasyncio.run(run())\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>A name for the formula engine.</p> <p> TYPE: <code>str</code> </p> <code>receiver</code> <p>A receiver that streams <code>Sample</code>s.</p> <p> TYPE: <code>Receiver[Sample[QuantityT]]</code> </p> <code>create_method</code> <p>A method to generate the output <code>Sample</code> value with, e.g. <code>Power.from_watts</code>.</p> <p> TYPE: <code>Callable[[float], QuantityT]</code> </p> <code>nones_are_zeros</code> <p>If <code>True</code>, <code>None</code> values in the receiver are treated as 0.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>FormulaEngine[QuantityT]</code> <p>A formula engine that streams the <code>Sample</code>s from the receiver.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>@classmethod\ndef from_receiver(\n    cls,\n    name: str,\n    receiver: Receiver[Sample[QuantityT]],\n    create_method: Callable[[float], QuantityT],\n    *,\n    nones_are_zeros: bool = False,\n) -&gt; FormulaEngine[QuantityT]:\n    \"\"\"\n    Create a formula engine from a receiver.\n\n    Can be used to compose a formula engine with a receiver. When composing\n    the new engine with other engines, make sure that receiver gets data\n    from the same resampler and that the `create_method`s match.\n\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.timeseries import Power\n\n        async def run() -&gt; None:\n            producer_power_engine = microgrid.producer().power\n            consumer_power_recv = microgrid.consumer().power.new_receiver()\n\n            excess_power_recv = (\n                (\n                    producer_power_engine\n                    + FormulaEngine.from_receiver(\n                        \"consumer power\",\n                        consumer_power_recv,\n                        Power.from_watts,\n                    )\n                )\n                .build(\"excess power\")\n                .new_receiver()\n            )\n\n        asyncio.run(run())\n        ```\n\n    Args:\n        name: A name for the formula engine.\n        receiver: A receiver that streams `Sample`s.\n        create_method: A method to generate the output `Sample` value with,\n            e.g. `Power.from_watts`.\n        nones_are_zeros: If `True`, `None` values in the receiver are treated as 0.\n\n    Returns:\n        A formula engine that streams the `Sample`s from the receiver.\n    \"\"\"\n    builder = FormulaBuilder(name, create_method)\n    builder.push_metric(name, receiver, nones_are_zeros=nones_are_zeros)\n    return cls(builder, create_method)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.max","title":"max","text":"<pre><code>max(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the maximum of <code>self</code> and <code>other</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def max(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula engine that outputs the maximum of `self` and `other`.\n\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).max(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.min","title":"min","text":"<pre><code>min(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the minimum of <code>self</code> and <code>other</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def min(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula engine that outputs the minimum of `self` and `other`.\n\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).min(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver(\n    name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample[QuantityT]]\n</code></pre> <p>Create a new receiver that streams the output of the formula engine.</p> PARAMETER DESCRIPTION <code>name</code> <p>An optional name for the receiver.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>max_size</code> <p>The size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[Sample[QuantityT]]</code> <p>A receiver that streams output <code>Sample</code>s from the formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def new_receiver(\n    self, name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample[QuantityT]]:\n    \"\"\"Create a new receiver that streams the output of the formula engine.\n\n    Args:\n        name: An optional name for the receiver.\n        max_size: The size of the receiver's buffer.\n\n    Returns:\n        A receiver that streams output `Sample`s from the formula engine.\n    \"\"\"\n    if self._task is None:\n        self._task = asyncio.create_task(self._run())\n\n    recv = self._channel.new_receiver(name=name, limit=max_size)\n\n    # This is a hack to ensure that the lifetime of the engine is tied to the\n    # lifetime of the receiver.  This is necessary because the engine is a task that\n    # runs forever, and in cases where higher order built for example with the below\n    # idiom, the user would hold no references to the engine and it could get\n    # garbage collected before the receiver.  This behaviour is explained in the\n    # `asyncio.create_task` docs here:\n    # https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task\n    #\n    #     formula = (grid_power_engine + bat_power_engine).build().new_receiver()\n    recv._engine_reference = self  # type: ignore # pylint: disable=protected-access\n    return recv\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine.production","title":"production","text":"<pre><code>production() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the production operator on <code>self</code>.</p> <p>The production operator returns either the absolute value if the power value is negative or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def production(self) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"\n    Return a formula builder that applies the production operator on `self`.\n\n    The production operator returns either the absolute value if the power value is\n    negative or 0.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).production()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase","title":"frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase","text":"<p>               Bases: <code>_ComposableFormulaEngine['FormulaEngine3Phase', 'HigherOrderFormulaBuilder3Phase', QuantityT]</code></p> <p>A <code>FormulaEngine3Phase</code> is similar to a <code>FormulaEngine</code>, except that they stream 3-phase samples.  All the current formulas (like <code>Grid.current_per_phase</code>, <code>EVChargerPool.current_per_phase</code>, etc.) are implemented as per-phase formulas.</p>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine3Phase.new_receiver()</code> method can be used to create a Receiver that streams the Sample3Phase values calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\n\nev_charger_pool = microgrid.new_ev_charger_pool(priority=5)\n\nasync for sample in ev_charger_pool.current_per_phase.new_receiver():\n    print(f\"Current: {sample}\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--composition","title":"Composition","text":"<p><code>FormulaEngine3Phase</code> instances can be composed together, just like <code>FormulaEngine</code> instances.</p> <pre><code>from frequenz.sdk import microgrid\n\nev_charger_pool = microgrid.new_ev_charger_pool(priority=5)\ngrid = microgrid.grid()\n\n# Calculate grid consumption current that's not used by the EV chargers\nother_current = (grid.current_per_phase - ev_charger_pool.current_per_phase).build(\n    \"other_current\"\n)\n\nasync for sample in other_current.new_receiver():\n    print(f\"Other current: {sample}\")\n</code></pre> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>class FormulaEngine3Phase(\n    _ComposableFormulaEngine[\n        \"FormulaEngine3Phase\",  # type: ignore[type-arg]\n        \"HigherOrderFormulaBuilder3Phase\",  # type: ignore[type-arg]\n        QuantityT,\n    ]\n):\n    \"\"\"A\n    [`FormulaEngine3Phase`][frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase]\n    is similar to a\n    [`FormulaEngine`][frequenz.sdk.timeseries.formula_engine.FormulaEngine], except that\n    they stream [3-phase samples][frequenz.sdk.timeseries.Sample3Phase].  All the\n    current formulas (like\n    [`Grid.current_per_phase`][frequenz.sdk.timeseries.grid.Grid.current_per_phase],\n    [`EVChargerPool.current_per_phase`][frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.current_per_phase],\n    etc.) are implemented as per-phase formulas.\n\n    ### Streaming Interface\n\n    The\n    [`FormulaEngine3Phase.new_receiver()`][frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.new_receiver]\n    method can be used to create a\n    [Receiver](https://frequenz-floss.github.io/frequenz-channels-python/latest/reference/frequenz/channels/#frequenz.channels.Receiver)\n    that streams the [Sample3Phase][frequenz.sdk.timeseries.Sample3Phase] values\n    calculated by the formula engine.\n\n    ```python\n    from frequenz.sdk import microgrid\n\n    ev_charger_pool = microgrid.new_ev_charger_pool(priority=5)\n\n    async for sample in ev_charger_pool.current_per_phase.new_receiver():\n        print(f\"Current: {sample}\")\n    ```\n\n    ### Composition\n\n    `FormulaEngine3Phase` instances can be composed together, just like `FormulaEngine`\n    instances.\n\n    ```python\n    from frequenz.sdk import microgrid\n\n    ev_charger_pool = microgrid.new_ev_charger_pool(priority=5)\n    grid = microgrid.grid()\n\n    # Calculate grid consumption current that's not used by the EV chargers\n    other_current = (grid.current_per_phase - ev_charger_pool.current_per_phase).build(\n        \"other_current\"\n    )\n\n    async for sample in other_current.new_receiver():\n        print(f\"Other current: {sample}\")\n    ```\n    \"\"\"  # noqa: D205, D400\n\n    def __init__(\n        self,\n        name: str,\n        create_method: Callable[[float], QuantityT],\n        phase_streams: tuple[\n            FormulaEngine[QuantityT],\n            FormulaEngine[QuantityT],\n            FormulaEngine[QuantityT],\n        ],\n    ) -&gt; None:\n        \"\"\"Create a `FormulaEngine3Phase` instance.\n\n        Args:\n            name: A name for the formula.\n            create_method: A method to generate the output `Sample` value with.  If the\n                formula is for generating power values, this would be\n                `Power.from_watts`, for example.\n            phase_streams: output streams of formula engines running per-phase formulas.\n        \"\"\"\n        self._higher_order_builder = HigherOrderFormulaBuilder3Phase\n        self._name: str = name\n        self._create_method = create_method\n        self._channel: Broadcast[Sample3Phase[QuantityT]] = Broadcast(name=self._name)\n        self._task: asyncio.Task[None] | None = None\n        self._streams: tuple[\n            FormulaEngine[QuantityT],\n            FormulaEngine[QuantityT],\n            FormulaEngine[QuantityT],\n        ] = phase_streams\n\n    async def _run(self) -&gt; None:\n        sender = self._channel.new_sender()\n        phase_1_rx = self._streams[0].new_receiver()\n        phase_2_rx = self._streams[1].new_receiver()\n        phase_3_rx = self._streams[2].new_receiver()\n\n        while True:\n            try:\n                phase_1 = await phase_1_rx.receive()\n                phase_2 = await phase_2_rx.receive()\n                phase_3 = await phase_3_rx.receive()\n                msg = Sample3Phase(\n                    phase_1.timestamp,\n                    phase_1.value,\n                    phase_2.value,\n                    phase_3.value,\n                )\n            except asyncio.CancelledError:\n                _logger.exception(\"FormulaEngine task cancelled: %s\", self._name)\n                break\n            else:\n                await sender.send(msg)\n\n    def new_receiver(\n        self, name: str | None = None, max_size: int = 50\n    ) -&gt; Receiver[Sample3Phase[QuantityT]]:\n        \"\"\"Create a new receiver that streams the output of the formula engine.\n\n        Args:\n            name: An optional name for the receiver.\n            max_size: The size of the receiver's buffer.\n\n        Returns:\n            A receiver that streams output `Sample`s from the formula engine.\n        \"\"\"\n        if self._task is None:\n            self._task = asyncio.create_task(self._run())\n\n        return self._channel.new_receiver(name=name, limit=max_size)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__add__","title":"__add__","text":"<pre><code>__add__(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that adds (data in) <code>other</code> to <code>self</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __add__(\n    self,\n    other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT,\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that adds (data in) `other` to `self`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) + other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__init__","title":"__init__","text":"<pre><code>__init__(\n    name: str,\n    create_method: Callable[[float], QuantityT],\n    phase_streams: tuple[\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n    ],\n) -&gt; None\n</code></pre> <p>Create a <code>FormulaEngine3Phase</code> instance.</p> PARAMETER DESCRIPTION <code>name</code> <p>A name for the formula.</p> <p> TYPE: <code>str</code> </p> <code>create_method</code> <p>A method to generate the output <code>Sample</code> value with.  If the formula is for generating power values, this would be <code>Power.from_watts</code>, for example.</p> <p> TYPE: <code>Callable[[float], QuantityT]</code> </p> <code>phase_streams</code> <p>output streams of formula engines running per-phase formulas.</p> <p> TYPE: <code>tuple[FormulaEngine[QuantityT], FormulaEngine[QuantityT], FormulaEngine[QuantityT]]</code> </p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    create_method: Callable[[float], QuantityT],\n    phase_streams: tuple[\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n    ],\n) -&gt; None:\n    \"\"\"Create a `FormulaEngine3Phase` instance.\n\n    Args:\n        name: A name for the formula.\n        create_method: A method to generate the output `Sample` value with.  If the\n            formula is for generating power values, this would be\n            `Power.from_watts`, for example.\n        phase_streams: output streams of formula engines running per-phase formulas.\n    \"\"\"\n    self._higher_order_builder = HigherOrderFormulaBuilder3Phase\n    self._name: str = name\n    self._create_method = create_method\n    self._channel: Broadcast[Sample3Phase[QuantityT]] = Broadcast(name=self._name)\n    self._task: asyncio.Task[None] | None = None\n    self._streams: tuple[\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n        FormulaEngine[QuantityT],\n    ] = phase_streams\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__mul__","title":"__mul__","text":"<pre><code>__mul__(\n    other: (\n        _GenericEngine | _GenericHigherOrderBuilder | float\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that multiplies (data in) <code>self</code> with <code>other</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __mul__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that multiplies (data in) `self` with `other`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) * other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__sub__","title":"__sub__","text":"<pre><code>__sub__(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that subtracts (data in) <code>other</code> from <code>self</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __sub__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that subtracts (data in) `other` from `self`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) - other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(\n    other: (\n        _GenericEngine | _GenericHigherOrderBuilder | float\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that divides (data in) <code>self</code> by <code>other</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, or a formula builder instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | float</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def __truediv__(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | float\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula builder that divides (data in) `self` by `other`.\n\n    Args:\n        other: A formula receiver, or a formula builder instance corresponding to a\n            sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method) / other  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.consumption","title":"consumption","text":"<pre><code>consumption() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the consumption operator on <code>self</code>.</p> <p>The consumption operator returns either the identity if the power value is positive or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def consumption(self) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"\n    Return a formula builder that applies the consumption operator on `self`.\n\n    The consumption operator returns either the identity if the power value is\n    positive or 0.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).consumption()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.max","title":"max","text":"<pre><code>max(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the maximum of <code>self</code> and <code>other</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def max(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula engine that outputs the maximum of `self` and `other`.\n\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).max(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.min","title":"min","text":"<pre><code>min(\n    other: (\n        _GenericEngine\n        | _GenericHigherOrderBuilder\n        | QuantityT\n    ),\n) -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula engine that outputs the minimum of <code>self</code> and <code>other</code>.</p> PARAMETER DESCRIPTION <code>other</code> <p>A formula receiver, a formula builder or a QuantityT instance corresponding to a sub-expression.</p> <p> TYPE: <code>_GenericEngine | _GenericHigherOrderBuilder | QuantityT</code> </p> RETURNS DESCRIPTION <code>_GenericHigherOrderBuilder</code> <p>A formula builder that can take further expressions, or can be built into a formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def min(\n    self, other: _GenericEngine | _GenericHigherOrderBuilder | QuantityT\n) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"Return a formula engine that outputs the minimum of `self` and `other`.\n\n    Args:\n        other: A formula receiver, a formula builder or a QuantityT instance\n            corresponding to a sub-expression.\n\n\n    Returns:\n        A formula builder that can take further expressions, or can be built\n            into a formula engine.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).min(other)  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver(\n    name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample3Phase[QuantityT]]\n</code></pre> <p>Create a new receiver that streams the output of the formula engine.</p> PARAMETER DESCRIPTION <code>name</code> <p>An optional name for the receiver.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>max_size</code> <p>The size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[Sample3Phase[QuantityT]]</code> <p>A receiver that streams output <code>Sample</code>s from the formula engine.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def new_receiver(\n    self, name: str | None = None, max_size: int = 50\n) -&gt; Receiver[Sample3Phase[QuantityT]]:\n    \"\"\"Create a new receiver that streams the output of the formula engine.\n\n    Args:\n        name: An optional name for the receiver.\n        max_size: The size of the receiver's buffer.\n\n    Returns:\n        A receiver that streams output `Sample`s from the formula engine.\n    \"\"\"\n    if self._task is None:\n        self._task = asyncio.create_task(self._run())\n\n    return self._channel.new_receiver(name=name, limit=max_size)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/formula_engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase.production","title":"production","text":"<pre><code>production() -&gt; _GenericHigherOrderBuilder\n</code></pre> <p>Return a formula builder that applies the production operator on <code>self</code>.</p> <p>The production operator returns either the absolute value if the power value is negative or 0.</p> Source code in <code>frequenz/sdk/timeseries/formula_engine/_formula_engine.py</code> <pre><code>def production(self) -&gt; _GenericHigherOrderBuilder:\n    \"\"\"\n    Return a formula builder that applies the production operator on `self`.\n\n    The production operator returns either the absolute value if the power value is\n    negative or 0.\n    \"\"\"\n    return self._higher_order_builder(self, self._create_method).production()  # type: ignore\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/","title":"logical_meter","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter","title":"frequenz.sdk.timeseries.logical_meter","text":"<p>A logical meter for calculating high level metrics for a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter","title":"frequenz.sdk.timeseries.logical_meter.LogicalMeter","text":"<p>A logical meter for calculating high level metrics in a microgrid.</p> <p>LogicalMeter provides methods for fetching power values from different points in the microgrid.  These methods return <code>FormulaReceiver</code> objects, which can be used like normal <code>Receiver</code>s, but can also be composed to form higher-order formula streams.</p> <p>Note</p> <p><code>LogicalMeter</code> instances are not meant to be created directly by users.  Use the <code>microgrid.logical_meter</code> method for creating <code>LogicalMeter</code> instances.</p> Example <pre><code>from datetime import timedelta\n\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.actor import ResamplerConfig\nfrom frequenz.client.microgrid import ComponentMetricId\n\n\nawait microgrid.initialize(\n    \"grpc://microgrid.sandbox.api.frequenz.io:62060\",\n    ResamplerConfig(resampling_period=timedelta(seconds=1)),\n)\n\nlogical_meter = (\n    microgrid.logical_meter()\n    .start_formula(\"#1001 + #1002\", ComponentMetricId.ACTIVE_POWER)\n    .new_receiver()\n)\n\nasync for power in logical_meter:\n    print(power.value)\n</code></pre> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>class LogicalMeter:\n    \"\"\"A logical meter for calculating high level metrics in a microgrid.\n\n    LogicalMeter provides methods for fetching power values from different points in the\n    microgrid.  These methods return `FormulaReceiver` objects, which can be used like\n    normal `Receiver`s, but can also be composed to form higher-order formula streams.\n\n    !!! note\n        `LogicalMeter` instances are not meant to be created directly by users.  Use the\n        [`microgrid.logical_meter`][frequenz.sdk.microgrid.logical_meter] method for\n        creating `LogicalMeter` instances.\n\n    Example:\n        ```python\n        from datetime import timedelta\n\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.actor import ResamplerConfig\n        from frequenz.client.microgrid import ComponentMetricId\n\n\n        await microgrid.initialize(\n            \"grpc://microgrid.sandbox.api.frequenz.io:62060\",\n            ResamplerConfig(resampling_period=timedelta(seconds=1)),\n        )\n\n        logical_meter = (\n            microgrid.logical_meter()\n            .start_formula(\"#1001 + #1002\", ComponentMetricId.ACTIVE_POWER)\n            .new_receiver()\n        )\n\n        async for power in logical_meter:\n            print(power.value)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        channel_registry: ChannelRegistry,\n        resampler_subscription_sender: Sender[ComponentMetricRequest],\n    ) -&gt; None:\n        \"\"\"Create a `LogicalMeter` instance.\n\n        !!! note\n            `LogicalMeter` instances are not meant to be created directly by users.  Use\n            the [`microgrid.logical_meter`][frequenz.sdk.microgrid.logical_meter] method\n            for creating `LogicalMeter` instances.\n\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n        \"\"\"\n        self._channel_registry: ChannelRegistry = channel_registry\n        self._resampler_subscription_sender: Sender[ComponentMetricRequest] = (\n            resampler_subscription_sender\n        )\n\n        # Use a randomly generated uuid to create a unique namespace name for the local\n        # meter to use when communicating with the resampling actor.\n        self._namespace = f\"logical-meter-{uuid.uuid4()}\"\n        self._formula_pool = FormulaEnginePool(\n            self._namespace,\n            self._channel_registry,\n            self._resampler_subscription_sender,\n        )\n\n    def start_formula(\n        self,\n        formula: str,\n        component_metric_id: ComponentMetricId,\n        *,\n        nones_are_zeros: bool = False,\n    ) -&gt; FormulaEngine[Quantity]:\n        \"\"\"Start execution of the given formula.\n\n        Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and\n        these operators: +, -, *, /, (, ).\n\n        For example, the input string: \"#20 + #5\" is a formula for adding metrics from\n        two components with ids 20 and 5.\n\n        Args:\n            formula: formula to execute.\n            component_metric_id: The metric ID to use when fetching receivers from the\n                resampling actor.\n            nones_are_zeros: Whether to treat None values from the stream as 0s.  If\n                False, the returned value will be a None.\n\n        Returns:\n            A FormulaEngine that applies the formula and streams values.\n        \"\"\"\n        return self._formula_pool.from_string(\n            formula, component_metric_id, nones_are_zeros=nones_are_zeros\n        )\n\n    @property\n    def chp_power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the CHP power production in the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate CHP power production is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream CHP power production.\n        \"\"\"\n        engine = self._formula_pool.from_power_formula_generator(\n            \"chp_power\",\n            CHPPowerFormula,\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all formula engines.\"\"\"\n        await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.chp_power","title":"chp_power  <code>property</code>","text":"<pre><code>chp_power: FormulaEngine[Power]\n</code></pre> <p>Fetch the CHP power production in the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate CHP power production is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream CHP power production.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.__init__","title":"__init__","text":"<pre><code>__init__(\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[\n        ComponentMetricRequest\n    ],\n) -&gt; None\n</code></pre> <p>Create a <code>LogicalMeter</code> instance.</p> <p>Note</p> <p><code>LogicalMeter</code> instances are not meant to be created directly by users.  Use the <code>microgrid.logical_meter</code> method for creating <code>LogicalMeter</code> instances.</p> PARAMETER DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>def __init__(\n    self,\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n    \"\"\"Create a `LogicalMeter` instance.\n\n    !!! note\n        `LogicalMeter` instances are not meant to be created directly by users.  Use\n        the [`microgrid.logical_meter`][frequenz.sdk.microgrid.logical_meter] method\n        for creating `LogicalMeter` instances.\n\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n    \"\"\"\n    self._channel_registry: ChannelRegistry = channel_registry\n    self._resampler_subscription_sender: Sender[ComponentMetricRequest] = (\n        resampler_subscription_sender\n    )\n\n    # Use a randomly generated uuid to create a unique namespace name for the local\n    # meter to use when communicating with the resampling actor.\n    self._namespace = f\"logical-meter-{uuid.uuid4()}\"\n    self._formula_pool = FormulaEnginePool(\n        self._namespace,\n        self._channel_registry,\n        self._resampler_subscription_sender,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.start_formula","title":"start_formula","text":"<pre><code>start_formula(\n    formula: str,\n    component_metric_id: ComponentMetricId,\n    *,\n    nones_are_zeros: bool = False\n) -&gt; FormulaEngine[Quantity]\n</code></pre> <p>Start execution of the given formula.</p> <p>Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and these operators: +, -, *, /, (, ).</p> <p>For example, the input string: \"#20 + #5\" is a formula for adding metrics from two components with ids 20 and 5.</p> PARAMETER DESCRIPTION <code>formula</code> <p>formula to execute.</p> <p> TYPE: <code>str</code> </p> <code>component_metric_id</code> <p>The metric ID to use when fetching receivers from the resampling actor.</p> <p> TYPE: <code>ComponentMetricId</code> </p> <code>nones_are_zeros</code> <p>Whether to treat None values from the stream as 0s.  If False, the returned value will be a None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>FormulaEngine[Quantity]</code> <p>A FormulaEngine that applies the formula and streams values.</p> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>def start_formula(\n    self,\n    formula: str,\n    component_metric_id: ComponentMetricId,\n    *,\n    nones_are_zeros: bool = False,\n) -&gt; FormulaEngine[Quantity]:\n    \"\"\"Start execution of the given formula.\n\n    Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and\n    these operators: +, -, *, /, (, ).\n\n    For example, the input string: \"#20 + #5\" is a formula for adding metrics from\n    two components with ids 20 and 5.\n\n    Args:\n        formula: formula to execute.\n        component_metric_id: The metric ID to use when fetching receivers from the\n            resampling actor.\n        nones_are_zeros: Whether to treat None values from the stream as 0s.  If\n            False, the returned value will be a None.\n\n    Returns:\n        A FormulaEngine that applies the formula and streams values.\n    \"\"\"\n    return self._formula_pool.from_string(\n        formula, component_metric_id, nones_are_zeros=nones_are_zeros\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all formula engines.</p> Source code in <code>frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all formula engines.\"\"\"\n    await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/","title":"pv_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool","title":"frequenz.sdk.timeseries.pv_pool","text":"<p>Interactions with PV inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPool","title":"frequenz.sdk.timeseries.pv_pool.PVPool","text":"<p>An interface for interaction with pools of PV inverters.</p> Provides <ul> <li>Aggregate <code>power</code>   measurements of the PV inverters in the pool.</li> </ul> Source code in <code>frequenz/sdk/timeseries/pv_pool/_pv_pool.py</code> <pre><code>class PVPool:\n    \"\"\"An interface for interaction with pools of PV inverters.\n\n    Provides:\n      - Aggregate [`power`][frequenz.sdk.timeseries.pv_pool.PVPool.power]\n        measurements of the PV inverters in the pool.\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        *,\n        pool_ref_store: PVPoolReferenceStore,\n        name: str | None,\n        priority: int,\n        set_operating_point: bool,\n    ) -&gt; None:\n        \"\"\"Initialize the instance.\n\n        !!! note\n            `PVPool` instances are not meant to be created directly by users. Use the\n            [`microgrid.new_pv_pool`][frequenz.sdk.microgrid.new_pv_pool] method for\n            creating `PVPool` instances.\n\n        Args:\n            pool_ref_store: The reference store for the PV pool.\n            name: The name of the PV pool.\n            priority: The priority of the PV pool.\n            set_operating_point: Whether this instance sets the operating point power or\n                the normal power for the components.\n        \"\"\"\n        self._pool_ref_store = pool_ref_store\n        unique_id = uuid.uuid4()\n        self._source_id = str(unique_id) if name is None else f\"{name}-{unique_id}\"\n        self._priority = priority\n        self._set_operating_point = set_operating_point\n\n    async def propose_power(\n        self,\n        power: Power | None,\n        *,\n        bounds: Bounds[Power | None] = Bounds(None, None),\n    ) -&gt; None:\n        \"\"\"Send a proposal to the power manager for the pool's set of PV inverters.\n\n        This proposal is for the maximum power that can be set for the PV inverters in\n        the pool.  The actual production might be lower.\n\n        Power values need to follow the Passive Sign Convention (PSC). That is, positive\n        values indicate charge power and negative values indicate discharge power.\n        Only discharge powers are allowed for PV inverters.\n\n        If the same PV inverters are shared by multiple actors, the power manager will\n        consider the priority of the actors, the bounds they set, and their preferred\n        power, when calculating the target power for the PV inverters.\n\n        The preferred power of lower priority actors will take precedence as long as\n        they respect the bounds set by higher priority actors.  If lower priority actors\n        request power values outside of the bounds set by higher priority actors, the\n        target power will be the closest value to the preferred power that is within the\n        bounds.\n\n        When there are no other actors trying to use the same PV inverters, the actor's\n        preferred power would be set as the target power, as long as it falls within the\n        system power bounds for the PV inverters.\n\n        The result of the request can be accessed using the receiver returned from the\n        [`power_status`][frequenz.sdk.timeseries.pv_pool.PVPool.power_status]\n        method, which also streams the bounds that an actor should comply with, based on\n        its priority.\n\n        Args:\n            power: The power to propose for the PV inverters in the pool.  If `None`,\n                this proposal will not have any effect on the target power, unless\n                bounds are specified.  If both are `None`, it is equivalent to not\n                having a proposal or withdrawing a previous one.\n            bounds: The power bounds for the proposal.  These bounds will apply to\n                actors with a lower priority, and can be overridden by bounds from\n                actors with a higher priority.  If None, the power bounds will be set to\n                the maximum power of the batteries in the pool.  This is currently and\n                experimental feature.\n\n        Raises:\n            PVPoolError: If a charge power for PV inverters is requested.\n        \"\"\"\n        if power is not None and power &gt; Power.zero():\n            raise PVPoolError(\"Charge powers for PV inverters is not supported.\")\n        await self._pool_ref_store.power_manager_requests_sender.send(\n            _power_managing.Proposal(\n                source_id=self._source_id,\n                preferred_power=power,\n                bounds=bounds,\n                component_ids=self._pool_ref_store.component_ids,\n                priority=self._priority,\n                creation_time=asyncio.get_running_loop().time(),\n                set_operating_point=self._set_operating_point,\n            )\n        )\n\n    @property\n    def component_ids(self) -&gt; abc.Set[int]:\n        \"\"\"Return component IDs of all PV inverters managed by this PVPool.\n\n        Returns:\n            Set of managed component IDs.\n        \"\"\"\n        return self._pool_ref_store.component_ids\n\n    @property\n    def power(self) -&gt; FormulaEngine[Power]:\n        \"\"\"Fetch the total power for the PV Inverters in the pool.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate PV Inverter power is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all PV\n                Inverters.\n        \"\"\"\n        engine = self._pool_ref_store.formula_pool.from_power_formula_generator(\n            \"pv_power\",\n            PVPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._pool_ref_store.component_ids,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def power_status(self) -&gt; ReceiverFetcher[PVPoolReport]:\n        \"\"\"Get a receiver to receive new power status reports when they change.\n\n        These include\n          - the current inclusion/exclusion bounds available for the pool's priority,\n          - the current target power for the pool's set of batteries,\n          - the result of the last distribution request for the pool's set of batteries.\n\n        Returns:\n            A receiver that will stream power status reports for the pool's priority.\n        \"\"\"\n        sub = _power_managing.ReportRequest(\n            source_id=self._source_id,\n            priority=self._priority,\n            component_ids=self._pool_ref_store.component_ids,\n            set_operating_point=self._set_operating_point,\n        )\n        self._pool_ref_store.power_bounds_subs[sub.get_channel_name()] = (\n            asyncio.create_task(\n                self._pool_ref_store.power_manager_bounds_subs_sender.send(sub)\n            )\n        )\n        channel = self._pool_ref_store.channel_registry.get_or_create(\n            _power_managing._Report,  # pylint: disable=protected-access\n            sub.get_channel_name(),\n        )\n        channel.resend_latest = True\n\n        return channel\n\n    @property\n    def power_distribution_results(self) -&gt; ReceiverFetcher[power_distributing.Result]:\n        \"\"\"Get a receiver to receive power distribution results.\n\n        Returns:\n            A receiver that will stream power distribution results for the pool's set of\n            PV inverters.\n        \"\"\"\n        return MappingReceiverFetcher(\n            self._pool_ref_store.power_distribution_results_fetcher,\n            lambda recv: recv.filter(\n                lambda x: x.request.component_ids == self._pool_ref_store.component_ids\n            ),\n        )\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop all tasks and channels owned by the PVPool.\"\"\"\n        await self._pool_ref_store.stop()\n\n    @property\n    def _system_power_bounds(self) -&gt; ReceiverFetcher[SystemBounds]:\n        \"\"\"Return a receiver fetcher for the system power bounds.\"\"\"\n        return self._pool_ref_store.bounds_channel\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPool.component_ids","title":"component_ids  <code>property</code>","text":"<pre><code>component_ids: Set[int]\n</code></pre> <p>Return component IDs of all PV inverters managed by this PVPool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Set of managed component IDs.</p>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPool.power","title":"power  <code>property</code>","text":"<pre><code>power: FormulaEngine[Power]\n</code></pre> <p>Fetch the total power for the PV Inverters in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate PV Inverter power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total power of all PV Inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPool.power_distribution_results","title":"power_distribution_results  <code>property</code>","text":"<pre><code>power_distribution_results: ReceiverFetcher[Result]\n</code></pre> <p>Get a receiver to receive power distribution results.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[Result]</code> <p>A receiver that will stream power distribution results for the pool's set of</p> <code>ReceiverFetcher[Result]</code> <p>PV inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPool.power_status","title":"power_status  <code>property</code>","text":"<pre><code>power_status: ReceiverFetcher[PVPoolReport]\n</code></pre> <p>Get a receiver to receive new power status reports when they change.</p> <p>These include   - the current inclusion/exclusion bounds available for the pool's priority,   - the current target power for the pool's set of batteries,   - the result of the last distribution request for the pool's set of batteries.</p> RETURNS DESCRIPTION <code>ReceiverFetcher[PVPoolReport]</code> <p>A receiver that will stream power status reports for the pool's priority.</p>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPool.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    pool_ref_store: PVPoolReferenceStore,\n    name: str | None,\n    priority: int,\n    set_operating_point: bool\n) -&gt; None\n</code></pre> <p>Initialize the instance.</p> <p>Note</p> <p><code>PVPool</code> instances are not meant to be created directly by users. Use the <code>microgrid.new_pv_pool</code> method for creating <code>PVPool</code> instances.</p> PARAMETER DESCRIPTION <code>pool_ref_store</code> <p>The reference store for the PV pool.</p> <p> TYPE: <code>PVPoolReferenceStore</code> </p> <code>name</code> <p>The name of the PV pool.</p> <p> TYPE: <code>str | None</code> </p> <code>priority</code> <p>The priority of the PV pool.</p> <p> TYPE: <code>int</code> </p> <code>set_operating_point</code> <p>Whether this instance sets the operating point power or the normal power for the components.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>frequenz/sdk/timeseries/pv_pool/_pv_pool.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    *,\n    pool_ref_store: PVPoolReferenceStore,\n    name: str | None,\n    priority: int,\n    set_operating_point: bool,\n) -&gt; None:\n    \"\"\"Initialize the instance.\n\n    !!! note\n        `PVPool` instances are not meant to be created directly by users. Use the\n        [`microgrid.new_pv_pool`][frequenz.sdk.microgrid.new_pv_pool] method for\n        creating `PVPool` instances.\n\n    Args:\n        pool_ref_store: The reference store for the PV pool.\n        name: The name of the PV pool.\n        priority: The priority of the PV pool.\n        set_operating_point: Whether this instance sets the operating point power or\n            the normal power for the components.\n    \"\"\"\n    self._pool_ref_store = pool_ref_store\n    unique_id = uuid.uuid4()\n    self._source_id = str(unique_id) if name is None else f\"{name}-{unique_id}\"\n    self._priority = priority\n    self._set_operating_point = set_operating_point\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPool.propose_power","title":"propose_power  <code>async</code>","text":"<pre><code>propose_power(\n    power: Power | None,\n    *,\n    bounds: Bounds[Power | None] = Bounds(None, None)\n) -&gt; None\n</code></pre> <p>Send a proposal to the power manager for the pool's set of PV inverters.</p> <p>This proposal is for the maximum power that can be set for the PV inverters in the pool.  The actual production might be lower.</p> <p>Power values need to follow the Passive Sign Convention (PSC). That is, positive values indicate charge power and negative values indicate discharge power. Only discharge powers are allowed for PV inverters.</p> <p>If the same PV inverters are shared by multiple actors, the power manager will consider the priority of the actors, the bounds they set, and their preferred power, when calculating the target power for the PV inverters.</p> <p>The preferred power of lower priority actors will take precedence as long as they respect the bounds set by higher priority actors.  If lower priority actors request power values outside of the bounds set by higher priority actors, the target power will be the closest value to the preferred power that is within the bounds.</p> <p>When there are no other actors trying to use the same PV inverters, the actor's preferred power would be set as the target power, as long as it falls within the system power bounds for the PV inverters.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_status</code> method, which also streams the bounds that an actor should comply with, based on its priority.</p> PARAMETER DESCRIPTION <code>power</code> <p>The power to propose for the PV inverters in the pool.  If <code>None</code>, this proposal will not have any effect on the target power, unless bounds are specified.  If both are <code>None</code>, it is equivalent to not having a proposal or withdrawing a previous one.</p> <p> TYPE: <code>Power | None</code> </p> <code>bounds</code> <p>The power bounds for the proposal.  These bounds will apply to actors with a lower priority, and can be overridden by bounds from actors with a higher priority.  If None, the power bounds will be set to the maximum power of the batteries in the pool.  This is currently and experimental feature.</p> <p> TYPE: <code>Bounds[Power | None]</code> DEFAULT: <code>Bounds(None, None)</code> </p> RAISES DESCRIPTION <code>PVPoolError</code> <p>If a charge power for PV inverters is requested.</p> Source code in <code>frequenz/sdk/timeseries/pv_pool/_pv_pool.py</code> <pre><code>async def propose_power(\n    self,\n    power: Power | None,\n    *,\n    bounds: Bounds[Power | None] = Bounds(None, None),\n) -&gt; None:\n    \"\"\"Send a proposal to the power manager for the pool's set of PV inverters.\n\n    This proposal is for the maximum power that can be set for the PV inverters in\n    the pool.  The actual production might be lower.\n\n    Power values need to follow the Passive Sign Convention (PSC). That is, positive\n    values indicate charge power and negative values indicate discharge power.\n    Only discharge powers are allowed for PV inverters.\n\n    If the same PV inverters are shared by multiple actors, the power manager will\n    consider the priority of the actors, the bounds they set, and their preferred\n    power, when calculating the target power for the PV inverters.\n\n    The preferred power of lower priority actors will take precedence as long as\n    they respect the bounds set by higher priority actors.  If lower priority actors\n    request power values outside of the bounds set by higher priority actors, the\n    target power will be the closest value to the preferred power that is within the\n    bounds.\n\n    When there are no other actors trying to use the same PV inverters, the actor's\n    preferred power would be set as the target power, as long as it falls within the\n    system power bounds for the PV inverters.\n\n    The result of the request can be accessed using the receiver returned from the\n    [`power_status`][frequenz.sdk.timeseries.pv_pool.PVPool.power_status]\n    method, which also streams the bounds that an actor should comply with, based on\n    its priority.\n\n    Args:\n        power: The power to propose for the PV inverters in the pool.  If `None`,\n            this proposal will not have any effect on the target power, unless\n            bounds are specified.  If both are `None`, it is equivalent to not\n            having a proposal or withdrawing a previous one.\n        bounds: The power bounds for the proposal.  These bounds will apply to\n            actors with a lower priority, and can be overridden by bounds from\n            actors with a higher priority.  If None, the power bounds will be set to\n            the maximum power of the batteries in the pool.  This is currently and\n            experimental feature.\n\n    Raises:\n        PVPoolError: If a charge power for PV inverters is requested.\n    \"\"\"\n    if power is not None and power &gt; Power.zero():\n        raise PVPoolError(\"Charge powers for PV inverters is not supported.\")\n    await self._pool_ref_store.power_manager_requests_sender.send(\n        _power_managing.Proposal(\n            source_id=self._source_id,\n            preferred_power=power,\n            bounds=bounds,\n            component_ids=self._pool_ref_store.component_ids,\n            priority=self._priority,\n            creation_time=asyncio.get_running_loop().time(),\n            set_operating_point=self._set_operating_point,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPool.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop all tasks and channels owned by the PVPool.</p> Source code in <code>frequenz/sdk/timeseries/pv_pool/_pv_pool.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop all tasks and channels owned by the PVPool.\"\"\"\n    await self._pool_ref_store.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPoolError","title":"frequenz.sdk.timeseries.pv_pool.PVPoolError","text":"<p>               Bases: <code>Exception</code></p> <p>An error that occurred in any of the PVPool methods.</p> Source code in <code>frequenz/sdk/timeseries/pv_pool/_pv_pool.py</code> <pre><code>class PVPoolError(Exception):\n    \"\"\"An error that occurred in any of the PVPool methods.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPoolReport","title":"frequenz.sdk.timeseries.pv_pool.PVPoolReport","text":"<p>               Bases: <code>Protocol</code></p> <p>A status report for a PV pool.</p> Source code in <code>frequenz/sdk/timeseries/pv_pool/_result_types.py</code> <pre><code>class PVPoolReport(typing.Protocol):\n    \"\"\"A status report for a PV pool.\"\"\"\n\n    @property\n    def target_power(self) -&gt; Power | None:\n        \"\"\"The currently set power for the PV inverters.\"\"\"\n\n    @property\n    def bounds(self) -&gt; Bounds[Power] | None:\n        \"\"\"The usable bounds for the PV inverters.\n\n        These bounds are adjusted to any restrictions placed by actors with higher\n        priorities.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPoolReport-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPoolReport.bounds","title":"bounds  <code>property</code>","text":"<pre><code>bounds: Bounds[Power] | None\n</code></pre> <p>The usable bounds for the PV inverters.</p> <p>These bounds are adjusted to any restrictions placed by actors with higher priorities.</p>"},{"location":"reference/frequenz/sdk/timeseries/pv_pool/#frequenz.sdk.timeseries.pv_pool.PVPoolReport.target_power","title":"target_power  <code>property</code>","text":"<pre><code>target_power: Power | None\n</code></pre> <p>The currently set power for the PV inverters.</p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":""},{"location":"tutorials/getting_started/#prerequisites","title":"Prerequisites","text":"<ol> <li>Python 3.11 or newer installed on your system.</li> <li>Access to a microgrid system supported by the <code>frequenz.sdk</code> or you can use    the sandbox.</li> <li>Basic knowledge of microgrid concepts.</li> <li>Familiarity with Channels.</li> <li>Install the Frequenz SDK</li> </ol>"},{"location":"tutorials/getting_started/#create-a-project","title":"Create a project","text":""},{"location":"tutorials/getting_started/#create-a-python-file","title":"Create a Python file","text":"<p>You can start by simply creating a Python script (e.g., <code>pv_optimization.py</code>) using your favorite text editor.</p>"},{"location":"tutorials/getting_started/#use-frequenz-repository-configuration","title":"Use Frequenz Repository Configuration","text":"<p>As an alternative and specially for larger projects, it's recommended to set up the project using the Frequenz Repository Configuration.</p>"},{"location":"tutorials/getting_started/#import-necessary-modules","title":"Import necessary modules","text":"<p>You can now open the app's main file and start adding content. Begin by importing the necessary libraries.</p> <pre><code>import asyncio\n\nfrom datetime import timedelta\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.actor import ResamplerConfig\n</code></pre>"},{"location":"tutorials/getting_started/#create-the-application-skeleton","title":"Create the application skeleton","text":"<p>The main logic of your application will run within an async function. Let's create a skeleton that contains all the necessary code to initialize a microgrid.</p> <pre><code>async def run() -&gt; None:\n    # This points to the default Frequenz microgrid sandbox\n    server_url = \"grpc://microgrid.sandbox.api.frequenz.io:62060\"\n\n    # Initialize the microgrid\n    await microgrid.initialize(\n        server_url,\n        ResamplerConfig(resampling_period=timedelta(seconds=1)),\n    )\n\n    # Define your application logic here\n    # ...\n</code></pre>"},{"location":"tutorials/getting_started/#define-the-main-function","title":"Define the <code>main()</code> function","text":"<p>Create a <code>main()</code> function that will set up and run the <code>run()</code> function using asyncio.</p> <pre><code>def main() -&gt; None:\n    asyncio.run(run())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/getting_started/#implement-the-application-logic","title":"Implement the application logic","text":"<p>Inside the <code>run()</code> function, implement the core logic of your application. This will include creating receivers for data streams, processing the data, making decisions, and eventually sending control messages to the microgrid system. We will cover more details in the following tutorials. For now, let's simply read the power measurements from the microgrid's grid meter and print them on the screen. The grid meter is a meter that is directly connected to the grid connection point.</p> <pre><code>async def run() -&gt; None:\n    # This points to the default Frequenz microgrid sandbox\n    ...\n\n    # Define your application logic here\n    grid_meter = microgrid.grid().power.new_receiver()\n\n    async for power in grid_meter:\n        print(power.value)\n</code></pre>"},{"location":"tutorials/getting_started/#putting-it-all-together","title":"Putting it all together","text":"<p>Here is the full version of your first Frequenz SDK application.</p> <pre><code>import asyncio\n\nfrom datetime import timedelta\nfrom frequenz.sdk import microgrid\nfrom frequenz.sdk.actor import ResamplerConfig\n\nasync def run() -&gt; None:\n    # This points to the default Frequenz microgrid sandbox\n    server_url = \"grpc://microgrid.sandbox.api.frequenz.io:62060\"\n\n    # Initialize the microgrid\n    await microgrid.initialize(\n        server_url,\n        ResamplerConfig(resampling_period=timedelta(seconds=1)),\n    )\n\n    # Define your application logic here\n    grid_meter = microgrid.grid().power.new_receiver()\n\n    async for power in grid_meter:\n        print(power.value)\n\ndef main() -&gt; None:\n    asyncio.run(run())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/getting_started/#run-your-application","title":"Run your application","text":"<p>You're now ready to run your application. When working on an existing microgrid, make sure to update the <code>microgrid_host</code> and <code>microgrid_port</code> variables before running the script.</p> <pre><code># Example usage\npython pv_optimization.py\n</code></pre>"},{"location":"user-guide/","title":"Introduction","text":"<p>There are several fundamental concepts that one should comprehend before diving into the Frequenz SDK. These concepts encompass both general notions within the energy sector or microgrids and specific details regarding the SDK itself, such as asynchronous programming, use of channels for communication, the actor model, data pipelines, and the composition of a components graph.</p> <p>Given that users may possess diverse backgrounds and varying levels of familiarity with these subjects, the left menu is organized into sections, each dedicated to a particular topic.</p> <p>For individuals without prior knowledge, it is advisable to proceed through the sections sequentially to establish a solid foundation.</p>"},{"location":"user-guide/actors/","title":"Actors","text":"<p>Actors are a primitive unit of computation that runs autonomously.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--actor-programming-model","title":"Actor Programming Model","text":"<p>From Wikipedia</p> <p>The actor model in computer science is a mathematical model of concurrent computation that treats an actor as the basic building block of concurrent computation. In response to a message it receives, an actor can: make local decisions, create more actors, send more messages, and determine how to respond to the next message received. Actors may modify their own private state, but can only affect each other indirectly through messaging (removing the need for lock-based synchronization).</p> <p>We won't get into much more detail here because it is outside the scope of this documentation. However, if you are interested in learning more about the actor programming model, here are some useful resources:</p> <ul> <li>Actor Model (Wikipedia)</li> <li>How the Actor Model Meets the Needs of Modern, Distributed Systems   (Akka)</li> </ul>"},{"location":"user-guide/actors/#frequenz.sdk.actor--frequenz-sdk-actors","title":"Frequenz SDK Actors","text":"<p>The <code>Actor</code> class serves as the foundation for creating concurrent tasks and all actors in the SDK inherit from it. This class provides a straightforward way to implement actors. It shares similarities with the traditional actor programming model but also has some unique features:</p> <ul> <li> <p>Message Passing: Like traditional actors, our <code>Actor</code>   class communicates through message passing. Even when no particular message passing   mechanism is enforced, the SDK actors use <code>frequenz.channels</code> for communication.</p> </li> <li> <p>Automatic Restart: If an unhandled exception occurs in an actor's logic   (<code>_run()</code> method), the actor will be automatically restarted. This ensures   robustness in the face of errors.</p> </li> <li> <p>Simplified Task Management: Actors manage asynchronous tasks using   <code>asyncio</code>. You can create and manage tasks within the actor, and the   <code>Actor</code> class handles task cancellation and cleanup.</p> </li> <li> <p>Simplified lifecycle management: Actors are [async context managers] and also   a <code>run()</code> function is provided to easily run a group of   actors and wait for them to finish.</p> </li> </ul>"},{"location":"user-guide/actors/#frequenz.sdk.actor--lifecycle","title":"Lifecycle","text":"<p>Actors are not started when they are created. There are 3 main ways to start an actor (from most to least recommended):</p> <ol> <li>By using the <code>run()</code> function.</li> <li>By using the actor as an async context manager.</li> <li>By using the <code>start()</code> method.</li> </ol> <p>Warning</p> <ol> <li> <p>If an actor raises an unhandled exception, it will be restarted automatically.</p> </li> <li> <p>Actors manage <code>asyncio.Task</code> objects, so a reference to the actor object must    be held for as long as the actor is expected to be running, otherwise its tasks    will be cancelled and the actor will stop. For more information, please refer to    the Python <code>asyncio</code>    documentation.</p> </li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--the-run-function","title":"The <code>run()</code> Function","text":"<p>The <code>run()</code> function can start many actors at once and waits for them to finish. If any of the actors is stopped with errors, the errors will be logged.</p> Example <pre><code>from frequenz.sdk.actor import Actor, run\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nawait run(MyActor()) # (1)!\n</code></pre> <ol> <li>This line will block until the actor completes its execution or is manually stopped.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--async-context-manager","title":"Async Context Manager","text":"<p>When an actor is used as an async context manager, it is started when the <code>async with</code> block is entered and stopped automatically when the block is exited (even if an unhandled exception is raised).</p> Example <pre><code>from frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nasync with MyActor() as actor: # (1)!\n    print(\"The actor is running\")\n# (2)!\n</code></pre> <ol> <li><code>start()</code> is called automatically when entering     the <code>async with</code> block.</li> <li><code>stop()</code> is called automatically when exiting     the <code>async with</code> block.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--the-start-method","title":"The <code>start()</code> Method","text":"<p>When using the <code>start()</code> method, the actor is started in the background and the method returns immediately. The actor will continue to run until it is manually stopped or until it completes its execution.</p> Example <pre><code>from frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        print(\"Hello World!\")\n\nactor = MyActor() # (1)!\nactor.start() # (2)!\nprint(\"The actor is running\") # (3)!\nawait actor.stop() # (4)!\n</code></pre> <ol> <li>The actor is created but not started yet.</li> <li>The actor is started manually, it keeps running in the background.</li> <li> <p>Danger</p> <p>If this function would raise an exception, the actor will never be stopped!</p> </li> <li> <p>Until the actor is stopped manually.</p> </li> </ol> <p>Warning</p> <p>This method is not recommended because it is easy to forget to stop the actor manually, especially in error conditions.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--communication","title":"Communication","text":"<p>The <code>Actor</code> class doesn't impose any specific way to communicate between actors. However, <code>frequenz.channels</code> are always used as the communication mechanism between actors in the SDK.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--implementing-an-actor","title":"Implementing an Actor","text":"<p>To implement an actor, you must inherit from the <code>Actor</code> class and implement an initializer and the abstract <code>_run()</code> method.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--initialization","title":"Initialization","text":"<p>The initializer is called when the actor is created. The <code>Actor</code> class initializer (<code>__init__</code>) should be always called first in the class we are implementing to make sure actors are properly initialized.</p> <p>The <code>Actor.__init__()</code> takes one optional argument, a <code>name</code> that will be used to identify the actor in logs. If no name is provided, a default name will be generated, but it is recommended that <code>Actor</code> subclasses can also receive a name as an argument to make it easier to identify individual instances in logs more easily.</p> <p>The actor initializer normally also accepts as arguments the input channels receivers and output channels senders that will be used for communication. These channels should be created outside the actor and passed to it as arguments to ensure actors can be composed easily.</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass EchoActor(Actor):  # (1)!\n    def __init__(\n            self,\n            input: Receiver[int],  # (2)!\n            output: Sender[int],  # (3)!\n            name: str | None = None,  # (4)!\n    ) -&gt; None:\n        super().__init__(name=name) # (5)!\n        self._input: Receiver[int] = input  # (6)!\n        self._output: Sender[int] = output  # (7)!\n</code></pre> <ol> <li> <p>We define a new actor class called <code>EchoActor</code> that inherits from     <code>Actor</code>.</p> </li> <li> <p>We accept an <code>input</code> argument that will be used to receive messages from     a channel.</p> </li> <li>We accept an <code>output</code> argument that will be used to send messages to a channel.</li> <li>We accept an optional <code>name</code> argument that will be used to identify the actor in     logs.</li> <li>We call <code>Actor.__init__()</code> to make sure the     actor is properly initialized.</li> <li>We store the <code>input</code> argument in a private attribute to use it later.</li> <li>We store the <code>output</code> argument in a private attribute to use it later.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--the-_run-method","title":"The <code>_run()</code> Method","text":"<p>The abstract <code>_run()</code> method is called automatically by the base class when the actor is started.</p> <p>Normally an actor should run forever (or until it is stopped), so it is very common to have an infinite loop in the <code>_run()</code> method, typically receiving messages from one or more channels (receivers), processing them and sending the results to other channels (senders). However, it is worth noting that an actor can also be designed for a one-time execution or a limited number of runs, terminating upon completion.</p> Example echo actor <pre><code>from frequenz.channels import Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass EchoActor(Actor):\n    def __init__(\n            self,\n            input: Receiver[int],\n            output: Sender[int],\n            name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._input: Receiver[int] = input\n        self._output: Sender[int] = output\n\n    async def _run(self) -&gt; None:  # (1)!\n        async for msg in self._input:  # (2)!\n            await self._output.send(msg)  # (3)!\n</code></pre> <ol> <li>We implement the abstract <code>_run()</code> method.</li> <li>We receive messages from the <code>input</code> channel one by one.</li> <li>We send the received message to the <code>output</code> channel.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--stopping","title":"Stopping","text":"<p>By default, the <code>stop()</code> method will call the <code>cancel()</code> method (which will cancel all the tasks created by the actor) and will wait for them to finish.</p> <p>This means that when an actor is stopped, the <code>_run()</code> method will receive a <code>CancelledError</code> exception. You should have this in mind when implementing your actor and make sure to handle this exception properly if you need to do any cleanup.</p> <p>The actor will handle the <code>CancelledError</code> exception automatically if it is not handled in the <code>_run()</code> method, so if there is no need for extra cleanup, you don't need to worry about it.</p> <p>If an unhandled exception is raised in the <code>_run()</code> method, the actor will re-run the <code>_run()</code> method automatically. This ensures robustness in the face of errors, but you should also have this in mind if you need to do any cleanup to make sure the re-run doesn't cause any problems.</p> Tip <p>You could implement your own <code>stop()</code> method to, for example, send a message to a channel to notify that the actor should stop, or any other more graceful way to stop the actor if you need to make sure it can't be interrupted at any <code>await</code> point.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--spawning-extra-tasks","title":"Spawning Extra Tasks","text":"<p>Actors run at least one background task, created automatically by the <code>Actor</code> class. But <code>Actor</code> inherits from <code>BackgroundService</code>, which provides a few methods to create and manage extra tasks.</p> <p>If your actor needs to spawn extra tasks, you can use <code>BackgroundService</code> facilities to manage the tasks, so they are also automatically stopped when the actor is stopped.</p> <p>All you need to do is add the newly spawned tasks to the actor's <code>tasks</code> set.</p> Example <pre><code>import asyncio\nfrom frequenz.sdk.actor import Actor\n\nclass MyActor(Actor):\n    async def _run(self) -&gt; None:\n        extra_task = asyncio.create_task(self._extra_task())  # (1)!\n        self.tasks.add(extra_task)  # (2)!\n        while True:  # (3)!\n            print(\"_run() running\")\n            await asyncio.sleep(1)\n\n    async def _extra_task(self) -&gt; None:\n        while True:  # (4)!\n            print(\"_extra_task() running\")\n            await asyncio.sleep(1.1)\n\nasync with MyActor() as actor:  # (5)!\n    await asyncio.sleep(3)  # (6)!\n# (7)!\n</code></pre> <ol> <li>We create a new task using <code>asyncio.create_task()</code>.</li> <li>We add the task to the actor's <code>tasks</code> set.     This ensures the task will be cancelled and cleaned up when the actor is stopped.</li> <li>We leave the actor running forever.</li> <li>The extra task will also run forever.</li> <li>The actor is started.</li> <li>We wait for 3 seconds, the actor should print a bunch of \"_run() running\" and     \"_extra_task() running\" messages while it's running.</li> <li>The actor is stopped and the extra task is cancelled automatically.</li> </ol>"},{"location":"user-guide/actors/#frequenz.sdk.actor--examples","title":"Examples","text":"<p>Here are a few simple but complete examples to demonstrate how to create actors and connect them using channels.</p> <p>Tip</p> <p>The code examples are annotated with markers (like ), you can click on them to see the step-by-step explanation of what's going on. The annotations are numbered according to the order of execution.</p>"},{"location":"user-guide/actors/#frequenz.sdk.actor--composing-actors","title":"Composing actors","text":"<p>This example shows how to create two actors and connect them using broadcast channels.</p> compose.py<pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.sdk.actor import Actor\n\nclass Actor1(Actor):  # (1)!\n    def __init__(\n        self,\n        receiver: Receiver[str],\n        output: Sender[str],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver = receiver\n        self._output = output\n\n    async def _run(self) -&gt; None:\n        async for msg in self._receiver:\n            await self._output.send(f\"Actor1 forwarding: {msg!r}\")  # (8)!\n\n\nclass Actor2(Actor):\n    def __init__(\n        self,\n        receiver: Receiver[str],\n        output: Sender[str],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver = receiver\n        self._output = output\n\n    async def _run(self) -&gt; None:\n        async for msg in self._receiver:\n            await self._output.send(f\"Actor2 forwarding: {msg!r}\")  # (9)!\n\n\nasync def main() -&gt; None:  # (2)!\n    # (4)!\n    input_channel: Broadcast[str] = Broadcast(\"Input to Actor1\")\n    middle_channel: Broadcast[str] = Broadcast(\"Actor1 -&gt; Actor2 stream\")\n    output_channel: Broadcast[str] = Broadcast(\"Actor2 output\")\n\n    input_sender = input_channel.new_sender()\n    output_receiver = output_channel.new_receiver()\n\n    async with (  # (5)!\n        Actor1(input_channel.new_receiver(), middle_channel.new_sender(), \"actor1\"),\n        Actor2(middle_channel.new_receiver(), output_channel.new_sender(), \"actor2\"),\n    ):\n        await input_sender.send(\"Hello\")  # (6)!\n        msg = await output_receiver.receive()  # (7)!\n        print(msg)  # (10)!\n    # (11)!\n\nif __name__ == \"__main__\":  # (3)!\n    asyncio.run(main())\n</code></pre> <ol> <li> <p>We define 2 actors: <code>Actor1</code> and <code>Actor2</code> that will just forward a message    from an input channel to an output channel, adding some text.</p> </li> <li> <p>We define an async <code>main()</code> function within the main logic of our asyncio program.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We create a bunch of broadcast channels to connect our actors.</p> <ul> <li><code>input_channel</code> is the input channel for <code>Actor1</code>.</li> <li><code>middle_channel</code> is the channel that connects <code>Actor1</code> and <code>Actor2</code>.</li> <li><code>output_channel</code> is the output channel for <code>Actor2</code>.</li> </ul> </li> <li> <p>We create two actors and use them as async context managers, <code>Actor1</code> and     <code>Actor2</code>, and connect them by creating new     senders and     receivers from the channels.</p> <p>Note</p> <p>We don't use the <code>run()</code> function here because we want to stop the actors when we are done with them, but the actors will run forever (as long as the channel is not closed). So the async context manager is a better fit for this example.</p> </li> <li> <p>We schedule the sending of the message    <code>Hello</code> to <code>Actor1</code> via <code>input_channel</code>.</p> </li> <li> <p>We receive (await) the response from    <code>Actor2</code> via <code>output_channel</code>. Between this and the previous steps the    <code>async</code> calls in the actors will be executed.</p> </li> <li> <p><code>Actor1</code> sends the re-formatted message (<code>Actor1 forwarding: Hello</code>) to    <code>Actor2</code> via the <code>middle_channel</code>.</p> </li> <li> <p><code>Actor2</code> sends the re-formatted message (<code>Actor2 forwarding: \"Actor1    forwarding: 'Hello'\"</code>) to the <code>output_channel</code>.</p> </li> <li> <p>Finally, we print the received message, which will still be <code>Actor2     forwarding: \"Actor1 forwarding: 'Hello'\"</code>.</p> </li> <li> <p>The actors are stopped and cleaned up automatically when the <code>async with</code>     block ends.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Actor2 forwarding: \"Actor1 forwarding: 'Hello'\"\n</code></pre>"},{"location":"user-guide/actors/#frequenz.sdk.actor--receiving-from-multiple-channels","title":"Receiving from multiple channels","text":"<p>This example shows how to create an actor that receives messages from multiple broadcast channels using <code>select()</code>.</p> select.py<pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.channels.util import select, selected_from\nfrom frequenz.sdk.actor import Actor, run\n\n\nclass EchoActor(Actor):  # (1)!\n    def __init__(\n        self,\n        receiver_1: Receiver[bool],\n        receiver_2: Receiver[bool],\n        output: Sender[bool],\n        name: str | None = None,\n    ) -&gt; None:\n        super().__init__(name=name)\n        self._receiver_1 = receiver_1\n        self._receiver_2 = receiver_2\n        self._output = output\n\n    async def _run(self) -&gt; None:  # (2)!\n        async for selected in select(self._receiver_1, self._receiver_2):  # (10)!\n            if selected_from(selected, self._receiver_1):  # (11)!\n                print(f\"Received from receiver_1: {selected.value}\")\n                await self._output.send(selected.value)\n                if not selected.value:  # (12)!\n                    break\n            elif selected_from(selected, self._receiver_2):  # (13)!\n                print(f\"Received from receiver_2: {selected.value}\")\n                await self._output.send(selected.value)\n                if not selected.value:  # (14)!\n                    break\n            else:\n                assert False, \"Unknown selected channel\"\n        print(\"EchoActor finished\")\n    # (15)!\n\n\n# (3)!\ninput_channel_1 = Broadcast[bool](\"input_channel_1\")\ninput_channel_2 = Broadcast[bool](\"input_channel_2\")\necho_channel = Broadcast[bool](\"echo_channel\")\n\necho_actor = EchoActor(  # (4)!\n    input_channel_1.new_receiver(),\n    input_channel_2.new_receiver(),\n    echo_channel.new_sender(),\n    \"echo-actor\",\n)\n\necho_receiver = echo_channel.new_receiver()  # (5)!\n\nasync def main() -&gt; None:  # (6)!\n    # (8)!\n    await input_channel_1.new_sender().send(True)\n    await input_channel_2.new_sender().send(False)\n\n    await run(echo_actor)  # (9)!\n\n    await echo_channel.close()  # (16)!\n\n    async for message in echo_receiver:  # (17)!\n        print(f\"Received {message=}\")\n\n\nif __name__ == \"__main__\":  # (7)!\n    asyncio.run(main())\n</code></pre> <ol> <li> <p>We define an <code>EchoActor</code> that receives messages from two channels and sends     them to another channel.</p> </li> <li> <p>We implement the <code>_run()</code> method that will receive messages from the two     channels using <code>select()</code> and send them to the     output channel. The <code>run()</code> method will stop if a <code>False</code> message is received.</p> </li> <li> <p>We create the channels that will be used with the actor.</p> </li> <li> <p>We create the actor and connect it to the channels by creating new receivers and     senders from the channels.</p> </li> <li> <p>We create a receiver for the <code>echo_channel</code> to eventually receive the messages sent     by the actor.</p> </li> <li> <p>We define the <code>main()</code> function that will run the actor.</p> </li> <li> <p>We start the <code>main()</code> function in the async loop using <code>asyncio.run()</code>.</p> </li> <li> <p>We send a message to each of the input channels. These messages will be queued in     the channels until they are consumed by the actor.</p> </li> <li> <p>We start the actor and wait for it to finish using the     <code>run()</code> function.</p> </li> <li> <p>The <code>select()</code> function will get the first message     available from the two channels. The order in which they will be handled is     unknown, but in this example we assume that the first message will be from     <code>input_channel_1</code> (<code>True</code>) and the second from <code>input_channel_1</code> (<code>False</code>).</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>True</code> for the <code>input_channel_1</code> receiver. <code>selected.value</code> holds the received     message, so <code>\"Received from receiver_1: True\"</code> will be printed and <code>True</code> will be     sent to the <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>True</code>, the loop will continue, going back to the     <code>select()</code> function.</p> </li> <li> <p>The <code>selected_from()</code> function will return     <code>False</code> for the <code>input_channel_1</code> receiver and <code>True</code> for the <code>input_channel_2</code>     receiver. The message stored in <code>selected.value</code> will now be <code>False</code>, so     <code>\"Received from receiver_2: False\"</code> will be printed and <code>False</code> will be sent to the     <code>output</code> channel.</p> </li> <li> <p>Since <code>selected.value</code> is <code>False</code>, the loop will break.</p> </li> <li> <p>The <code>_run()</code> method will finish normally and the actor will be stopped, so     the <code>run()</code> function will return.</p> </li> <li> <p>We close the <code>echo_channel</code> to make sure the <code>echo_receiver</code> will stop receiving     messages after all the queued messages are consumed (otherwise the step 17 will     never end!).</p> </li> <li> <p>We receive the messages sent by the actor to the <code>echo_channel</code> one by one and print     them, it should print first <code>Received message=True</code> and then <code>Received     message=False</code>.</p> </li> </ol> <p>The expected output is:</p> <pre><code>Received from receiver_1: True\nReceived from receiver_2: False\nReceived message=True\nReceived message=False\n</code></pre>"},{"location":"user-guide/formula-engine/","title":"Formula Engine","text":""},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine","title":"FormulaEngine","text":"<p><code>FormulaEngine</code>s are a part of the SDK's data pipeline, and provide a way for the SDK to apply formulas on resampled data streams.</p> <p>They are used in the SDK to calculate and stream metrics like <code>grid_power</code>, <code>consumer_power</code>, etc., which are building blocks of the Frequenz SDK Microgrid Model.</p> <p>The SDK creates the formulas by analysing the configuration of components in the Component Graph.</p>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine.new_receiver()</code> method can be used to create a Receiver that streams the Samples calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\n\nbattery_pool = microgrid.new_battery_pool(priority=5)\n\nasync for power in battery_pool.power.new_receiver():\n    print(f\"{power=}\")\n</code></pre>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine--composition","title":"Composition","text":"<p>Composite <code>FormulaEngine</code>s can be built using arithmetic operations on <code>FormulaEngine</code>s streaming the same type of data.</p> <p>For example, if you're interested in a particular composite metric that can be calculated by subtracting <code>new_battery_pool().power</code> and <code>new_ev_charger_pool().power</code> from the <code>grid().power</code>, we can build a <code>FormulaEngine</code> that provides a stream of this calculated metric as follows:</p> <pre><code>from frequenz.sdk import microgrid\n\nbattery_pool = microgrid.new_battery_pool(priority=5)\nev_charger_pool = microgrid.new_ev_charger_pool(priority=5)\ngrid = microgrid.grid()\n\n# apply operations on formula engines to create a formula engine that would\n# apply these operations on the corresponding data streams.\nnet_power = (\n    grid.power - (battery_pool.power + ev_charger_pool.power)\n).build(\"net_power\")\n\nasync for power in net_power.new_receiver():\n    print(f\"{power=}\")\n</code></pre>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase","title":"FormulaEngine3Phase","text":"<p>A <code>FormulaEngine3Phase</code> is similar to a <code>FormulaEngine</code>, except that they stream 3-phase samples.  All the current formulas (like <code>Grid.current_per_phase</code>, <code>EVChargerPool.current_per_phase</code>, etc.) are implemented as per-phase formulas.</p>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--streaming-interface","title":"Streaming Interface","text":"<p>The <code>FormulaEngine3Phase.new_receiver()</code> method can be used to create a Receiver that streams the Sample3Phase values calculated by the formula engine.</p> <pre><code>from frequenz.sdk import microgrid\n\nev_charger_pool = microgrid.new_ev_charger_pool(priority=5)\n\nasync for sample in ev_charger_pool.current_per_phase.new_receiver():\n    print(f\"Current: {sample}\")\n</code></pre>"},{"location":"user-guide/formula-engine/#frequenz.sdk.timeseries.formula_engine.FormulaEngine3Phase--composition","title":"Composition","text":"<p><code>FormulaEngine3Phase</code> instances can be composed together, just like <code>FormulaEngine</code> instances.</p> <pre><code>from frequenz.sdk import microgrid\n\nev_charger_pool = microgrid.new_ev_charger_pool(priority=5)\ngrid = microgrid.grid()\n\n# Calculate grid consumption current that's not used by the EV chargers\nother_current = (grid.current_per_phase - ev_charger_pool.current_per_phase).build(\n    \"other_current\"\n)\n\nasync for sample in other_current.new_receiver():\n    print(f\"Other current: {sample}\")\n</code></pre>"},{"location":"user-guide/glossary/","title":"Glossary","text":"<p>This glossary provides definitions for common terminology used in the Frequenz SDK, focusing on microgrid components, metrics, measurements, and power-related terms.</p>"},{"location":"user-guide/glossary/#common-acronyms","title":"Common Acronyms","text":""},{"location":"user-guide/glossary/#ac","title":"AC","text":"<p>Alternating current. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#bms","title":"BMS","text":"<p>Battery management system. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#chp","title":"CHP","text":"<p>Combined heat and power. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#dc","title":"DC","text":"<p>Direct current. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#ev","title":"EV","text":"<p>Electric vehicle. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#psc","title":"PSC","text":"<p>Passive sign convention. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#pv","title":"PV","text":"<p>Photovoltaic. See the Wikipedia article for more details.</p> <p>In the SDK it is normally used as a synonym for solar panel.</p>"},{"location":"user-guide/glossary/#soc","title":"SoC","text":"<p>State of charge. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#sop","title":"SoP","text":"<p>State of power.</p>"},{"location":"user-guide/glossary/#microgrid","title":"Microgrid","text":"<p>A local electrical grid that connects a set of different types of components together. It can be connected to the public grid, or be completely isolated, in which case it is known as an island.</p> <p>Components can be grouped into assets and devices. Assets are core components like generators or storage systems that are crucial from a business perspective, whereas devices are the supporting infrastructure essential for the functionality of these assets.</p>"},{"location":"user-guide/glossary/#component-category","title":"Component Category","text":"<p>The category components of a microgrid belong to.</p> <p>Components of the same category have the same characteristics (for example offer the same set of metrics).</p> <p>Examples of categories are meters, inverters or batteries.</p> <p>A category can be further divided into types. For instance, PV inverters and battery inverters are types under the inverter category.</p>"},{"location":"user-guide/glossary/#assets","title":"Assets","text":""},{"location":"user-guide/glossary/#battery","title":"Battery","text":"<p>A storage system for electrical energy.</p>"},{"location":"user-guide/glossary/#chp-plant","title":"CHP Plant","text":"<p>A generator that produces combined heat and power (CHP). Usually powered via combustion of some form of fuel.</p>"},{"location":"user-guide/glossary/#consumer","title":"Consumer","text":"<p>Typically used in context with a metric, i.e. consumer power or consumer current. This aggregates all remaining electrical energy consumption in a microgrid that are not covered by other asset types and components. Under normal circumstances this is expected to correspond to the gross consumption of the site excluding active parts and battery. In Passive-sign convention consumer power is usually positive, but negative values can occur in exotic site topologies (e.g. unidentified generators) and or due to sudden short-term effects.</p>"},{"location":"user-guide/glossary/#ev-charger","title":"EV Charger","text":"<p>A station for charging EVs.</p>"},{"location":"user-guide/glossary/#electrolyzer","title":"Electrolyzer","text":"<p>A device that converts water into hydrogen and oxygen.</p>"},{"location":"user-guide/glossary/#grid","title":"Grid","text":"<p>A point where the local microgrid is connected to the public electricity grid.</p>"},{"location":"user-guide/glossary/#pv-array","title":"PV Array","text":"<p>A collection of PV panels.</p>"},{"location":"user-guide/glossary/#solar-panel","title":"Solar Panel","text":"<p>A panel with PV cells that generates DC electricity from sunlight.</p>"},{"location":"user-guide/glossary/#wind-turbine","title":"Wind Turbine","text":"<p>A device that converts the wind's kinetic energy into electrical energy.</p>"},{"location":"user-guide/glossary/#devices","title":"Devices","text":""},{"location":"user-guide/glossary/#converter","title":"Converter","text":"<p>Generally refers to DC-to-DC converter.</p>"},{"location":"user-guide/glossary/#dc-to-dc-converter","title":"DC-to-DC Converter","text":"<p>An electronic circuit or electromechanical device that converts a source of DC from one voltage level to another.</p>"},{"location":"user-guide/glossary/#inverter","title":"Inverter","text":"<p>A device or circuitry that converts DC electricity to AC electricity.</p>"},{"location":"user-guide/glossary/#meter","title":"Meter","text":"<p>A device for measuring electrical metrics (for example current, voltage, etc.).</p>"},{"location":"user-guide/glossary/#pre-charge-module","title":"Pre-charge module","text":"<p>A device that gradually ramp the DC voltage up to prevent any potential damage to sensitive electrical components, like capacitors.</p> <p>While many inverters and batteries come equipped with in-built pre-charging mechanisms, some may lack this feature. In such cases, external pre-charging modules can be used.</p>"},{"location":"user-guide/glossary/#relay","title":"Relay","text":"<p>A device that generally have two states: open (connected) and closed (disconnected).</p> <p>They are generally placed in front of another component, e.g., an inverter, to control whether the component is connected to the microgrid or not.</p>"},{"location":"user-guide/glossary/#sensor","title":"Sensor","text":"<p>A device for [measuring](#measurement] ambient metrics (for example temperature, humidity, etc.).</p>"},{"location":"user-guide/glossary/#component","title":"Component","text":"<p>A device (of a particular category) within a microgrid.</p>"},{"location":"user-guide/glossary/#component-id","title":"Component ID","text":"<p>A numeric identifier uniquely representing an instance of a component in a particular microgrid. It is always of type <code>int</code>.</p> <p>For example, a battery with a component ID of 5.</p>"},{"location":"user-guide/glossary/#component-graph","title":"Component Graph","text":"<p>A graph representation of the configuration in which the electrical components in a microgrid are connected with each other.  Some of the ways in which the SDK uses the component graph are:</p> <ul> <li>figure out how to calculate high level metrics like <code>grid_power</code>, <code>consumer_power</code>, etc. for a microgrid, using the available components.</li> <li>identify the available batteries or     EV chargers at a site that can be controlled.</li> </ul>"},{"location":"user-guide/glossary/#island","title":"Island","text":"<p>A microgrid that is not connected to the public electricity grid.</p>"},{"location":"user-guide/glossary/#passive-sign-convention","title":"Passive Sign Convention","text":"<p>A convention for the direction of power flow in a circuit. When the electricity is flowing into a component the value is positive, and when it is flowing out of a component the value is negative.</p> <p>In microgrids that have a grid connection, power flowing away from the grid is positive, and power flowing towards the grid is negative.</p>"},{"location":"user-guide/glossary/#component-data","title":"Component Data","text":""},{"location":"user-guide/glossary/#metric","title":"Metric","text":"<p>A quantifiable attribute of a component.</p> <p>For example, the metric capacity of a battery.</p>"},{"location":"user-guide/glossary/#measurement","title":"Measurement","text":"<p>An individual numeric value obtained from a metric of a component instance. It is consistently of type <code>float</code>, but it is often expressed in specific units.</p> <p>In the context of a sample, this is commonly referred to as a sample value.</p> <p>For example, a measurement of the capacity of a battery with component ID 5 can be 400, typically measured in Watt-hours (Wh).</p>"},{"location":"user-guide/glossary/#timestamp","title":"Timestamp","text":"<p>A specific point in time, always represented as a <code>datetime</code> with a <code>timezone</code> attached.</p> <p>For example, 2022-01-01 22:00:00.000 UTC.</p>"},{"location":"user-guide/glossary/#sample","title":"Sample","text":"<p>A measurement recorded at a particular timestamp, typically represented as a tuple <code>(timestamp, value)</code>.</p> <p>For example, recording a measurement of 400 from the capacity of a battery at 2022-01-01 22:00:00.000 UTC would constitute a sample <code>(2022-01-01 22:00:00.000 UTC, 400)</code>.</p>"},{"location":"user-guide/glossary/#sample-value","title":"Sample Value","text":"<p>A measurement stored in a sample.</p>"},{"location":"user-guide/glossary/#time-series","title":"Time Series","text":"<p>A sequence of samples, often organized by timestamp and typically with regular intervals. However, irregular (event-based) time series are also possible.</p> <p>For example, a time series representing measurements of a battery's capacity at 2022-01-01 22:00:00.000 UTC every second for 5 seconds would appear as follows:</p> <pre><code>(2022-01-01 22:00:00.000 UTC, 400)\n(2022-01-01 22:00:01.000 UTC, 401)\n(2022-01-01 22:00:02.000 UTC, 403)\n(2022-01-01 22:00:03.000 UTC, 402)\n(2022-01-01 22:00:04.000 UTC, 403)\n</code></pre>"},{"location":"user-guide/glossary/#timeseries","title":"Timeseries","text":"<p>Same as time series.</p>"},{"location":"user-guide/glossary/#metric-id","title":"Metric ID","text":"<p>An identifier for a component's metric, typically a string (<code>str</code>).</p> <p>Components belonging to the same category have the same set of metric IDs.</p> <p>For example, the metric ID for the capacity of a battery is simply <code>capacity</code>.</p>"},{"location":"user-guide/glossary/#time-series-id","title":"Time Series ID","text":"<p>An identifier for a time series originating from a metric of a specific component. Typically a string (<code>str</code>) derived from the tuple (component ID, metric ID) for components.</p> <p>For example, a time series for the capacity of a battery with component ID 5 has the ID (component_id, metric_id) (or <code>f\"{component_id}_{metric_id}\"</code>).</p>"},{"location":"user-guide/glossary/#timeseries-id","title":"Timeseries ID","text":"<p>Same as time series ID.</p>"},{"location":"user-guide/glossary/#metrics","title":"Metrics","text":"<p>All metrics related to power, energy, current, etc. use the PSC to determine the sign of the value.</p>"},{"location":"user-guide/glossary/#consumption","title":"Consumption","text":"<p>The amount of electricity flowing into a component. It is the clipped positive value when using the PSC, so if the electricity is flowing out of the component instead, this will be zero.</p>"},{"location":"user-guide/glossary/#gross-consumption","title":"Gross Consumption","text":"<p>Consumption before accounting for any local generation from solar, wind or CHP.</p>"},{"location":"user-guide/glossary/#instantaneous-power","title":"Instantaneous Power","text":"<p>Same as power.</p>"},{"location":"user-guide/glossary/#load","title":"Load","text":"<p>Typically refers to a device that consumes electricity, but also to the amount of electricity consumed by such a device. In a microgrid context, it is often used to refer to all the electrical devices that are doing active work, for example a light bulb, a motor, a cooler, etc.</p> <p>When using the PSC, this is the same as consumption and it is a positive value. If a load generates electricity instead, it is a negative value but it wouldn't typically be called a load.</p>"},{"location":"user-guide/glossary/#net-consumption","title":"Net Consumption","text":"<p>This term traditionally refers to the difference between the gross consumption and the local generation (like PV production). It is the electricity consumption that needs to be provided by the battery or from the public grid.</p>"},{"location":"user-guide/glossary/#net-load","title":"Net Load","text":"<p>Same as net consumption.</p>"},{"location":"user-guide/glossary/#power","title":"Power","text":"<p>The rate of energy transfer, i.e. the amount of energy transferred per unit of time. It is typically measured in Watts (W).</p> <p>For AC electricity, there are three types of power: active, reactive, and apparent (P, Q and |S| respectively in power triangle).</p> <p>See the Wikipedia article for more information.</p>"},{"location":"user-guide/glossary/#power-triangle","title":"Power Triangle","text":"<p>The visual representation of the relationship between the three types of AC power and phase of voltage relative to current.</p> <p></p> <p>(CC-BY-SA 3.0, Wikimedia Commons)</p>"},{"location":"user-guide/glossary/#active-power","title":"Active Power","text":"<p>The AC power that is actually consumed by the load. It is the real part of the apparent power, P in the power triangle.</p>"},{"location":"user-guide/glossary/#apparent-power","title":"Apparent Power","text":"<p>The AC power that is actually supplied to the load. The magnitude of the vector sum of the active and reactive power, |S| in the power-triangle.</p>"},{"location":"user-guide/glossary/#phase-of-voltage-relative-to-current","title":"Phase of Voltage Relative to Current","text":"<p>The angle of difference (in degrees) between current and voltage in an AC circuit, \u03c6 in the power triangle.</p>"},{"location":"user-guide/glossary/#power-factor","title":"Power Factor","text":"<p>The ratio of real power to apparent power in an AC circuit. Can be obtained by computing the cosine of \u03c6, in the power triangle. See the Wikipedia article for more details.</p>"},{"location":"user-guide/glossary/#reactive-power","title":"Reactive Power","text":"<p>The AC power that is not consumed by the load, but is alternately stored and returned to the source. It is the imaginary part of the apparent power, Q in the power triangle.</p>"},{"location":"user-guide/glossary/#real-power","title":"Real Power","text":"<p>Same as active power.</p>"},{"location":"user-guide/glossary/#production","title":"Production","text":"<p>The amount of electricity flowing out of a component. It is the clipped negative value when using the PSC, so if the electricity is flowing into the component instead, this will be zero.</p>"},{"location":"user-guide/glossary/#residual-consumption","title":"Residual Consumption","text":"<p>In microgrid context sometimes used as the remaining difference between the net consumption and the battery power, i.e. what we define as grid power.</p>"},{"location":"user-guide/glossary/#residual-load","title":"Residual Load","text":"<p>Same as residual consumption.</p>"},{"location":"user-guide/glossary/#state-of-charge","title":"State of Charge","text":"<p>The level of charge of a battery relative to its capacity, expressed in percentage points. Calculated as the ratio between the remaining energy in the battery at a given time and the maximum possible energy under similar health conditions. Source</p>"},{"location":"user-guide/glossary/#state-of-power","title":"State of Power","text":"<p>The ratio of peak power to nominal power. Peak power is the maximum power that can be sustained for a specific duration without violating preset operational design limits on battery voltage, SoC, power, or current.</p> <p>This indicator is crucial to ensure that charge or discharge power remains within specific limits, optimizing the battery's lifespan. It is particularly useful in peak power applications to define battery conditions for substantial charges or discharges.</p> <p>The state of power depends on the state of charge, battery capacity, initial characteristics, chemistry, and battery voltage, as well as external factors like temperature and humidity, which can also have a significant impact on it. Source</p>"},{"location":"user-guide/microgrid-concepts/","title":"Microgrid Concepts","text":"<p>A microgrid is a local electrical grid that connects a set of electrical components together.  They are often built around a passive power consumer, to supplement the electricity consumed from the public grid with on-site power generation or storage systems.</p> <p>Microgrids can also function in island-mode, without a grid connection, or without a local power consumer, but they have to have at least one of the two, to be meaningful.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--frequenz-sdk-microgrid-model","title":"Frequenz SDK Microgrid Model","text":"<p>The SDK aims to provide an abstract model of the microgrid that enables high-level interactions with microgrid components, without having to worry about (or even be aware of) location-specific details such as:</p> <ul> <li>where the meters are placed,</li> <li>how many batteries,</li> <li>whether there's a grid connection or a passive consumer,</li> <li>what models the inverters are, etc.</li> <li>whether components are having downtimes, because metrics and   limits get adjusted automatically when components are having downtimes.</li> </ul> <p>Users of the SDK can develop applications around this interface once and deploy anywhere, and the SDK will take care of translating the requests and instructions to correspond to the specific microgrid configurations.</p> <pre><code>flowchart LR\n\nsubgraph Left[Measurements only]\ndirection LR\n  grid[\"Grid Connection\"]\n  consumer[\"Consumer\"]\n  pv[\"PV Arrays\"]\n  chp[\"CHP\"]\nend\n\njunction(( ))\n\nsubgraph Right[Measurements and control]\ndirection LR\n  bat[\"Batteries\"]\n  ev[\"EV Chargers\"]\nend\n\ngrid --- junction\nconsumer --- junction\npv --- junction\nchp --- junction\n\njunction --- bat\njunction --- ev</code></pre>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--grid","title":"Grid","text":"<p>This refers to a microgrid's connection to the external Grid.  The power flowing through this connection can be streamed through <code>grid_power</code>.</p> <p>In locations without a grid connection, this method remains accessible, and streams zero values.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--consumer","title":"Consumer","text":"<p>This is the main power consumer at the site of a microgrid, and often the load the microgrid is built to support.  The power drawn by the consumer is available through <code>consumer_power</code></p> <p>In locations without a consumer, this method streams zero values.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--producers-pv-arrays-chp","title":"Producers: PV Arrays, CHP","text":"<p>The total CHP production in a site can be streamed through <code>chp_power</code>.  PV Power is available through the PV pool described below.  And total producer power is available through <code>microgrid.producer().power</code>.</p> <p>As is the case with the other methods, if PV Arrays or CHPs are not available in a microgrid, the corresponding methods stream zero values.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--pv-arrays","title":"PV Arrays","text":"<p>The total PV power production is available through <code>pv_pool</code>'s <code>power</code>.  The PV pool by default uses all PV inverters available at a location, but PV pool instances can be created for subsets of PV inverters if necessary, by specifying the inverter ids.</p> <p>The <code>pv_pool</code> also provides available power bounds through the <code>power_status</code> method.</p> <p>The <code>pv_pool</code> also provides a control method <code>propose_power</code>, which accepts values in the Passive Sign Convention and supports only production.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--batteries","title":"Batteries","text":"<p>The total Battery power is available through the <code>battery_pool</code>'s <code>power</code>.  The battery pool by default uses all batteries available at a location, but battery pool instances can be created for subsets of batteries if necessary, by specifying the battery ids.</p> <p>The <code>battery_pool</code> also provides <code>soc</code>, <code>capacity</code>, <code>temperature</code> and available power bounds through the <code>power_status</code> method.</p> <p>The <code>battery_pool</code> also provides control methods <code>propose_power</code> (which accepts values in the Passive Sign Convention and supports both charging and discharging), or through <code>propose_charge</code>, or <code>propose_discharge</code>.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--ev-chargers","title":"EV Chargers","text":"<p>The <code>ev_charger_pool</code> offers a <code>power</code> method that streams the total power measured for all the EV Chargers at a site.</p> <p>The <code>ev_charger_pool</code> also provides available power bounds through the <code>power_status</code> method.</p> <p>The <code>ev_charger_pool</code> also provides a control method <code>propose_power</code>, which accepts values in the Passive Sign Convention and supports only charging.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--component-pools","title":"Component pools","text":"<p>The SDK provides a unified interface for interacting with sets of Batteries, EV chargers and PV arrays, through their corresponding <code>Pool</code>s.</p> <ul> <li>Battery pool</li> <li>EV charger pool</li> <li>PV pool</li> </ul> <p>All of them provide support for streaming aggregated data and for setting the power values of the components.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--streaming-component-data","title":"Streaming component data","text":"<p>All pools have a <code>power</code> property, which is a <code>FormulaEngine</code> that can</p> <ul> <li> <p>provide a stream of resampled power values, which correspond to the sum of the power measured from all the components in the pool together.</p> </li> <li> <p>be composed with other power streams to for composite formulas.</p> </li> </ul> <p>In addition, the battery pool has some additional properties that can be used as streams for metrics specific to batteries: <code>soc</code>, <code>capacity</code> and <code>temperature</code>.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--setting-power","title":"Setting power","text":"<p>All pools provide a <code>propose_power</code> method for setting power for the pool.  This would then be distributed to the individual components in the pool, using an algorithm that's suitable for the category of the components.  For example, when controlling batteries, power could be distributed based on the <code>SoC</code> of the individual batteries, to keep the batteries in balance.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--resolving-conflicting-power-proposals","title":"Resolving conflicting power proposals","text":"<p>When there are multiple actors trying to control the same set of batteries, a target power is calculated based on the priorities of the actors making the requests.  Actors need to specify their priorities as parameters when creating the <code>*Pool</code> instances using the constructors mentioned above.</p> <p>The algorithm used for resolving power conflicts based on actor priority can be found in the documentation for any of the <code>propose_power</code> methods.</p>"},{"location":"user-guide/microgrid-concepts/#frequenz.sdk.microgrid--shifting-the-target-power-by-an-operating-point-power","title":"Shifting the target power by an Operating Point power","text":"<p>There are cases where the target power needs to be shifted by an operating point.  This can be done by designating some actors to be able to set only the operating point power.</p> <p>When creating a <code>*Pool</code> instance using the above-mentioned constructors, an optional <code>set_operating_point</code> parameter can be passed to specify that this actor is special, and the target power of the regular actors will be shifted by the target power of all actors with <code>set_operating_point</code> together.</p> <p>In a location with 2 regular actors and 1 <code>set_operating_point</code> actor, here's how things would play out:</p> <ol> <li>When only regular actors have made proposals, the power bounds available from the    batteries are available to them exactly.</li> </ol> actor priority in op group? proposed power/bounds available bounds 3 No 1000, -4000..2500 -3000..3000 2 No 2500 -3000..2500 1 Yes None -3000..3000 <p>Power actually distributed to the batteries: 2500W</p> <ol> <li>When the <code>set_operating_point</code> actor has made proposals, the bounds available to the    regular actors gets shifted, and the final power that actually gets distributed to    the batteries is also shifted.</li> </ol> actor priority in op group? proposed power/bounds available bounds 3 No 1000, -4000..2500 -2000..4000 2 No 2500 -2000..2500 1 Yes -1000 -3000..3000 <p>Power actually distributed to the batteries: 1500W</p>"}]}