{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Python SDK","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The Frequenz Python SDK is a development kit for interacting with the Frequenz development platform.</p>"},{"location":"#installation","title":"Installation","text":"<p>First, you need to make sure you have Python installed (at least version 3.11):</p> <pre><code>$ python3 --version\nPython 3.11.4\n</code></pre> <p>Note</p> <p>These instructions assume you are using a POSIX compatible <code>sh</code> shell.</p> <p>If that command doesn't print a version newer than 3.11.0, you'll need to download and install Python first.</p> <p>To install the SDK, you probably want to create a new virtual environment first:</p> <pre><code>mkdir my-sdk-project\ncd my-sdk-project\npython3 -m venv .venv\n. .venv/bin/activate\n</code></pre> <p>Tip</p> <p>Using <code>direnv</code> can greatly simplify this process as it automates the creation, activation, and deactivation of the virtual environment. The first time you enable <code>direnv</code>, the virtual environment will be created, and each time you enter or leave a subdirectory, it will be activated and deactivated, respectively.</p> <pre><code>sudo apt install direnv # if you use Debian/Ubuntu\nmkdir my-sdk-project\ncd my-sdk-project\necho \"layout python python3\" &gt; .envrc\ndirenv allow\n</code></pre> <p>This will create the virtual environment and activate it automatically for you.</p> <p>Now you can install the SDK by using <code>pip</code>:</p> <pre><code>python3 -m pip install frequenz-sdk\n</code></pre> <p>To verify that the installation worked, you can invoke the Python interpreter and import the SDK:</p> <pre><code>$ python3\nPython 3.11.4 (main, Jun  7 2023, 10:13:09) [GCC 12.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import frequenz.sdk\n&gt;&gt;&gt; \n</code></pre>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Python SDK","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>sdk<ul> <li>actor<ul> <li>power_distributing<ul> <li>power_distributing</li> <li>request</li> <li>result</li> </ul> </li> </ul> </li> <li>config</li> <li>microgrid<ul> <li>client</li> <li>component</li> <li>connection_manager</li> <li>fuse</li> <li>grid</li> </ul> </li> <li>timeseries<ul> <li>battery_pool<ul> <li>battery_pool</li> </ul> </li> <li>ev_charger_pool</li> <li>logical_meter</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/sdk/","title":"sdk","text":""},{"location":"reference/frequenz/sdk/#frequenz.sdk","title":"<code>frequenz.sdk</code>","text":"<p>Frequenz Python SDK.</p>"},{"location":"reference/frequenz/sdk/actor/","title":"actor","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor","title":"<code>frequenz.sdk.actor</code>","text":"<p>A base class for creating simple composable actors.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor","title":"<code>frequenz.sdk.actor.Actor</code>","text":"<p>             Bases: <code>BackgroundService</code>, <code>ABC</code></p> <p>A primitive unit of computation that runs autonomously.</p> <p>From Wikipedia, an actor is:</p> <p>[...] the basic building block of concurrent computation. In response to a message it receives, an actor can: make local decisions, create more actors, send more messages, and determine how to respond to the next message received. Actors may modify their own private state, but can only affect each other indirectly through messaging (removing the need for lock-based synchronization).</p> <p>Channels can be used to implement communication between actors, as shown in the examples below.</p> <p>To implement an actor, subclasses must implement the <code>_run()</code> method, which should run the actor's logic. The <code>_run()</code> method is called by the base class when the actor is started, and is expected to run until the actor is stopped.</p> <p>If an unhandled exception is raised in the <code>_run()</code> method, the actor will be restarted automatically. Unhandled <code>BaseException</code>s will cause the actor to stop immediately and will be re-raised.</p> <p>Warning</p> <p>As actors manage <code>asyncio.Task</code> objects, a reference to them must be held for as long as the actor is expected to be running, otherwise its tasks will be cancelled and the actor will stop. For more information, please refer to the Python <code>asyncio</code> documentation.</p> <p>Example: Example of an actor receiving from two receivers</p> <pre><code>```python\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.channels.util import select, selected_from\n\nclass EchoActor(Actor):\n    def __init__(\n        self,\n        recv1: Receiver[bool],\n        recv2: Receiver[bool],\n        output: Sender[bool],\n    ) -&gt; None:\n        super().__init__()\n        self._recv1 = recv1\n        self._recv2 = recv2\n        self._output = output\n\n    async def _run(self) -&gt; None:\n        async for selected in select(self._recv1, self._recv2):\n            if selected_from(selected, self._recv1):\n                await self._output.send(selected.value)\n            elif selected_from(selected, self._recv1):\n                await self._output.send(selected.value)\n            else:\n                assert False, \"Unknown selected channel\"\n\n\ninput_channel_1 = Broadcast[bool](\"input_channel_1\")\ninput_channel_2 = Broadcast[bool](\"input_channel_2\")\ninput_channel_2_sender = input_channel_2.new_sender()\n\necho_channel = Broadcast[bool](\"EchoChannel\")\necho_receiver = echo_channel.new_receiver()\n\nasync with EchoActor(\n    input_channel_1.new_receiver(),\n    input_channel_2.new_receiver(),\n    echo_channel.new_sender(),\n):\n    await input_channel_2_sender.send(True)\n    print(await echo_receiver.receive())\n```\n</code></pre> <p>Example: Example of composing two actors</p> <pre><code>```python\nfrom frequenz.channels import Broadcast, Receiver, Sender\n\nclass Actor1(Actor):\n    def __init__(\n        self,\n        recv: Receiver[bool],\n        output: Sender[bool],\n    ) -&gt; None:\n        super().__init__()\n        self._recv = recv\n        self._output = output\n\n    async def _run(self) -&gt; None:\n        async for msg in self._recv:\n            await self._output.send(msg)\n\n\nclass Actor2(Actor):\n    def __init__(\n        self,\n        recv: Receiver[bool],\n        output: Sender[bool],\n    ) -&gt; None:\n        super().__init__()\n        self._recv = recv\n        self._output = output\n\n    async def _run(self) -&gt; None:\n        async for msg in self._recv:\n            await self._output.send(msg)\n\ninput_channel: Broadcast[bool] = Broadcast(\"Input to Actor1\")\nmiddle_channel: Broadcast[bool] = Broadcast(\"Actor1 -&gt; Actor2 stream\")\noutput_channel: Broadcast[bool] = Broadcast(\"Actor2 output\")\n\ninput_sender = input_channel.new_sender()\noutput_receiver = output_channel.new_receiver()\n\nasync with (\n    Actor1(input_channel.new_receiver(), middle_channel.new_sender()),\n    Actor2(middle_channel.new_receiver(), output_channel.new_sender()),\n):\n    await input_sender.send(True)\n    print(await output_receiver.receive())\n```\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_actor.py</code> <pre><code>class Actor(BackgroundService, abc.ABC):\n\"\"\"A primitive unit of computation that runs autonomously.\n    From [Wikipedia](https://en.wikipedia.org/wiki/Actor_model), an actor is:\n    &gt; [...] the basic building block of concurrent computation. In response to\n    &gt; a message it receives, an actor can: make local decisions, create more actors,\n    &gt; send more messages, and determine how to respond to the next message received.\n    &gt; Actors may modify their own private state, but can only affect each other\n    &gt; indirectly through messaging (removing the need for lock-based synchronization).\n    [Channels](https://github.com/frequenz-floss/frequenz-channels-python/) can be used\n    to implement communication between actors, as shown in the examples below.\n    To implement an actor, subclasses must implement the `_run()` method, which should\n    run the actor's logic. The `_run()` method is called by the base class when the\n    actor is started, and is expected to run until the actor is stopped.\n    If an unhandled exception is raised in the `_run()` method, the actor will be\n    restarted automatically. Unhandled [`BaseException`][]s will cause the actor to stop\n    immediately and will be re-raised.\n    !!! warning\n        As actors manage [`asyncio.Task`][] objects, a reference to them must be held\n        for as long as the actor is expected to be running, otherwise its tasks will be\n        cancelled and the actor will stop. For more information, please refer to the\n        [Python `asyncio`\n        documentation](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task).\n    Example: Example of an actor receiving from two receivers\n        ```python\n        from frequenz.channels import Broadcast, Receiver, Sender\n        from frequenz.channels.util import select, selected_from\n        class EchoActor(Actor):\n            def __init__(\n                self,\n                recv1: Receiver[bool],\n                recv2: Receiver[bool],\n                output: Sender[bool],\n            ) -&gt; None:\n                super().__init__()\n                self._recv1 = recv1\n                self._recv2 = recv2\n                self._output = output\n            async def _run(self) -&gt; None:\n                async for selected in select(self._recv1, self._recv2):\n                    if selected_from(selected, self._recv1):\n                        await self._output.send(selected.value)\n                    elif selected_from(selected, self._recv1):\n                        await self._output.send(selected.value)\n                    else:\n                        assert False, \"Unknown selected channel\"\n        input_channel_1 = Broadcast[bool](\"input_channel_1\")\n        input_channel_2 = Broadcast[bool](\"input_channel_2\")\n        input_channel_2_sender = input_channel_2.new_sender()\n        echo_channel = Broadcast[bool](\"EchoChannel\")\n        echo_receiver = echo_channel.new_receiver()\n        async with EchoActor(\n            input_channel_1.new_receiver(),\n            input_channel_2.new_receiver(),\n            echo_channel.new_sender(),\n        ):\n            await input_channel_2_sender.send(True)\n            print(await echo_receiver.receive())\n        ```\n    Example: Example of composing two actors\n        ```python\n        from frequenz.channels import Broadcast, Receiver, Sender\n        class Actor1(Actor):\n            def __init__(\n                self,\n                recv: Receiver[bool],\n                output: Sender[bool],\n            ) -&gt; None:\n                super().__init__()\n                self._recv = recv\n                self._output = output\n            async def _run(self) -&gt; None:\n                async for msg in self._recv:\n                    await self._output.send(msg)\n        class Actor2(Actor):\n            def __init__(\n                self,\n                recv: Receiver[bool],\n                output: Sender[bool],\n            ) -&gt; None:\n                super().__init__()\n                self._recv = recv\n                self._output = output\n            async def _run(self) -&gt; None:\n                async for msg in self._recv:\n                    await self._output.send(msg)\n        input_channel: Broadcast[bool] = Broadcast(\"Input to Actor1\")\n        middle_channel: Broadcast[bool] = Broadcast(\"Actor1 -&gt; Actor2 stream\")\n        output_channel: Broadcast[bool] = Broadcast(\"Actor2 output\")\n        input_sender = input_channel.new_sender()\n        output_receiver = output_channel.new_receiver()\n        async with (\n            Actor1(input_channel.new_receiver(), middle_channel.new_sender()),\n            Actor2(middle_channel.new_receiver(), output_channel.new_sender()),\n        ):\n            await input_sender.send(True)\n            print(await output_receiver.receive())\n        ```\n    \"\"\"\n_restart_limit: int | None = None\n\"\"\"The number of times actors can be restarted when they are stopped by unhandled exceptions.\n    If this is bigger than 0 or `None`, the actor will be restarted when there is an\n    unhanded exception in the `_run()` method.\n    If `None`, the actor will be restarted an unlimited number of times.\n    !!! note\n        This is mostly used for testing purposes and shouldn't be set in production.\n    \"\"\"\ndef start(self) -&gt; None:\n\"\"\"Start this actor.\n        If this actor is already running, this method does nothing.\n        \"\"\"\nif self.is_running:\nreturn\nself._tasks.clear()\nself._tasks.add(asyncio.create_task(self._run_loop()))\n@abc.abstractmethod\nasync def _run(self) -&gt; None:\n\"\"\"Run this actor's logic.\"\"\"\nasync def _run_loop(self) -&gt; None:\n\"\"\"Run this actor's task in a loop until `_restart_limit` is reached.\n        Raises:\n            asyncio.CancelledError: If this actor's `_run()` gets cancelled.\n            Exception: If this actor's `_run()` raises any other `Exception` and reached\n                the maximum number of restarts.\n            BaseException: If this actor's `_run()` raises any other `BaseException`.\n        \"\"\"\n_logger.info(\"Actor %s: Started.\", self)\nn_restarts = 0\nwhile True:\ntry:\nawait self._run()\n_logger.info(\"Actor %s: _run() returned without error.\", self)\nexcept asyncio.CancelledError:\n_logger.info(\"Actor %s: Cancelled.\", self)\nraise\nexcept Exception:  # pylint: disable=broad-except\n_logger.exception(\"Actor %s: Raised an unhandled exception.\", self)\nlimit_str = \"\u221e\" if self._restart_limit is None else self._restart_limit\nlimit_str = f\"({n_restarts}/{limit_str})\"\nif self._restart_limit is None or n_restarts &lt; self._restart_limit:\nn_restarts += 1\n_logger.info(\"Actor %s: Restarting %s...\", self._name, limit_str)\ncontinue\n_logger.info(\n\"Actor %s: Maximum restarts attempted %s, bailing out...\",\nself,\nlimit_str,\n)\nraise\nexcept BaseException:  # pylint: disable=broad-except\n_logger.exception(\"Actor %s: Raised a BaseException.\", self)\nraise\nbreak\n_logger.info(\"Actor %s: Stopped.\", self)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.Actor.start","title":"<code>start()</code>","text":"<p>Start this actor.</p> <p>If this actor is already running, this method does nothing.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_actor.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start this actor.\n    If this actor is already running, this method does nothing.\n    \"\"\"\nif self.is_running:\nreturn\nself._tasks.clear()\nself._tasks.add(asyncio.create_task(self._run_loop()))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService","title":"<code>frequenz.sdk.actor.BackgroundService</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A background service that can be started and stopped.</p> <p>A background service is a service that runs in the background spawning one or more tasks. The service can be started and stopped and can work as an async context manager to provide deterministic cleanup.</p> <p>To implement a background service, subclasses must implement the <code>start()</code> method, which should start the background tasks needed by the service, and add them to the <code>_tasks</code> protected attribute.</p> <p>If you need to collect results or handle exceptions of the tasks when stopping the service, then you need to also override the <code>stop()</code> method, as the base implementation does not collect any results and re-raises all exceptions.</p> <p>Warning</p> <p>As background services manage <code>asyncio.Task</code> objects, a reference to them must be held for as long as the background service is expected to be running, otherwise its tasks will be cancelled and the service will stop. For more information, please refer to the Python <code>asyncio</code> documentation.</p> Example <pre><code>import datetime\nimport asyncio\nclass Clock(BackgroundService):\ndef __init__(self, resolution_s: float, *, name: str | None = None) -&gt; None:\nsuper().__init__(name=name)\nself._resolution_s = resolution_s\ndef start(self) -&gt; None:\nself._tasks.add(asyncio.create_task(self._tick()))\nasync def _tick(self) -&gt; None:\nwhile True:\nawait asyncio.sleep(self._resolution_s)\nprint(datetime.datetime.now())\nasync def main() -&gt; None:\n# As an async context manager\nasync with Clock(resolution_s=1):\nawait asyncio.sleep(5)\n# Manual start/stop (only use if necessary, as cleanup is more complicated)\nclock = Clock(resolution_s=1)\nclock.start()\nawait asyncio.sleep(5)\nawait clock.stop()\nasyncio.run(main())\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>class BackgroundService(abc.ABC):\n\"\"\"A background service that can be started and stopped.\n    A background service is a service that runs in the background spawning one or more\n    tasks. The service can be [started][frequenz.sdk.actor.BackgroundService.start]\n    and [stopped][frequenz.sdk.actor.BackgroundService.stop] and can work as an\n    async context manager to provide deterministic cleanup.\n    To implement a background service, subclasses must implement the\n    [`start()`][frequenz.sdk.actor.BackgroundService.start] method, which should\n    start the background tasks needed by the service, and add them to the `_tasks`\n    protected attribute.\n    If you need to collect results or handle exceptions of the tasks when stopping the\n    service, then you need to also override the\n    [`stop()`][frequenz.sdk.actor.BackgroundService.stop] method, as the base\n    implementation does not collect any results and re-raises all exceptions.\n    !!! warning\n        As background services manage [`asyncio.Task`][] objects, a reference to them\n        must be held for as long as the background service is expected to be running,\n        otherwise its tasks will be cancelled and the service will stop. For more\n        information, please refer to the [Python `asyncio`\n        documentation](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task).\n    Example:\n        ```python\n        import datetime\n        import asyncio\n        class Clock(BackgroundService):\n            def __init__(self, resolution_s: float, *, name: str | None = None) -&gt; None:\n                super().__init__(name=name)\n                self._resolution_s = resolution_s\n            def start(self) -&gt; None:\n                self._tasks.add(asyncio.create_task(self._tick()))\n            async def _tick(self) -&gt; None:\n                while True:\n                    await asyncio.sleep(self._resolution_s)\n                    print(datetime.datetime.now())\n        async def main() -&gt; None:\n            # As an async context manager\n            async with Clock(resolution_s=1):\n                await asyncio.sleep(5)\n            # Manual start/stop (only use if necessary, as cleanup is more complicated)\n            clock = Clock(resolution_s=1)\n            clock.start()\n            await asyncio.sleep(5)\n            await clock.stop()\n        asyncio.run(main())\n        ```\n    \"\"\"\ndef __init__(self, *, name: str | None = None) -&gt; None:\n\"\"\"Initialize this BackgroundService.\n        Args:\n            name: The name of this background service. If `None`, `str(id(self))` will\n                be used. This is used mostly for debugging purposes.\n        \"\"\"\nself._name: str = str(id(self)) if name is None else name\nself._tasks: set[asyncio.Task[Any]] = set()\n@abc.abstractmethod\ndef start(self) -&gt; None:\n\"\"\"Start this background service.\"\"\"\n@property\ndef name(self) -&gt; str:\n\"\"\"The name of this background service.\n        Returns:\n            The name of this background service.\n        \"\"\"\nreturn self._name\n@property\ndef tasks(self) -&gt; collections.abc.Set[asyncio.Task[Any]]:\n\"\"\"Return the set of running tasks spawned by this background service.\n        Users typically should not modify the tasks in the returned set and only use\n        them for informational purposes.\n        !!! danger\n            Changing the returned tasks may lead to unexpected behavior, don't do it\n            unless the class explicitly documents it is safe to do so.\n        Returns:\n            The set of running tasks spawned by this background service.\n        \"\"\"\nreturn self._tasks\n@property\ndef is_running(self) -&gt; bool:\n\"\"\"Return whether this background service is running.\n        A service is considered running when at least one task is running.\n        Returns:\n            Whether this background service is running.\n        \"\"\"\nreturn any(not task.done() for task in self._tasks)\ndef cancel(self, msg: str | None = None) -&gt; None:\n\"\"\"Cancel all running tasks spawned by this background service.\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\nfor task in self._tasks:\ntask.cancel(msg)\nasync def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this background service.\n        This method cancels all running tasks spawned by this service and waits for them\n        to finish.\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception.\n        [//]: # (# noqa: DAR401 rest)\n        \"\"\"\nif not self._tasks:\nreturn\nself.cancel(msg)\ntry:\nawait self.wait()\nexcept BaseExceptionGroup as exc_group:\n# We want to ignore CancelledError here as we explicitly cancelled all the\n# tasks.\n_, rest = exc_group.split(asyncio.CancelledError)\nif rest is not None:\n# We are filtering out from an exception group, we really don't want to\n# add the exceptions we just filtered by adding a from clause here.\nraise rest  # pylint: disable=raise-missing-from\nasync def __aenter__(self) -&gt; Self:\n\"\"\"Enter an async context.\n        Start this background service.\n        Returns:\n            This background service.\n        \"\"\"\nself.start()\nreturn self\nasync def __aexit__(\nself,\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Exit an async context.\n        Stop this background service.\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception raised, if any.\n            exc_tb: The traceback of the exception raised, if any.\n        \"\"\"\nawait self.stop()\nasync def wait(self) -&gt; None:\n\"\"\"Wait this background service to finish.\n        Wait until all background service tasks are finished.\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception (`CancelError` is not considered an error and not returned in\n                the exception group).\n        \"\"\"\n# We need to account for tasks that were created between when we started\n# awaiting and we finished awaiting.\nwhile self._tasks:\ndone, pending = await asyncio.wait(self._tasks)\nassert not pending\n# We remove the done tasks, but there might be new ones created after we\n# started waiting.\nself._tasks = self._tasks - done\nexceptions: list[BaseException] = []\nfor task in done:\ntry:\n# This will raise a CancelledError if the task was cancelled or any\n# other exception if the task raised one.\n_ = task.result()\nexcept BaseException as error:  # pylint: disable=broad-except\nexceptions.append(error)\nif exceptions:\nraise BaseExceptionGroup(\nf\"Error while stopping background service {self}\", exceptions\n)\ndef __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n\"\"\"Await this background service.\n        An awaited background service will wait for all its tasks to finish.\n        Returns:\n            An implementation-specific generator for the awaitable.\n        \"\"\"\nreturn self.wait().__await__()\ndef __del__(self) -&gt; None:\n\"\"\"Destroy this instance.\n        Cancel all running tasks spawned by this background service.\n        \"\"\"\nself.cancel(\"{self!r} was deleted\")\ndef __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n        Returns:\n            A string representation of this instance.\n        \"\"\"\nreturn f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\ndef __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n        Returns:\n            A string representation of this instance.\n        \"\"\"\nreturn f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.is_running","title":"<code>is_running: bool</code>  <code>property</code>","text":"<p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The name of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.tasks","title":"<code>tasks: collections.abc.Set[asyncio.Task[Any]]</code>  <code>property</code>","text":"<p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n\"\"\"Enter an async context.\n    Start this background service.\n    Returns:\n        This background service.\n    \"\"\"\nself.start()\nreturn self\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>async def __aexit__(\nself,\nexc_type: type[BaseException] | None,\nexc_val: BaseException | None,\nexc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Exit an async context.\n    Stop this background service.\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\nawait self.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__await__","title":"<code>__await__()</code>","text":"<p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n\"\"\"Await this background service.\n    An awaited background service will wait for all its tasks to finish.\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\nreturn self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__del__","title":"<code>__del__()</code>","text":"<p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>def __del__(self) -&gt; None:\n\"\"\"Destroy this instance.\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\nself.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__init__","title":"<code>__init__(*, name=None)</code>","text":"<p>Initialize this BackgroundService.</p> PARAMETER  DESCRIPTION <code>name</code> <p>The name of this background service. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>def __init__(self, *, name: str | None = None) -&gt; None:\n\"\"\"Initialize this BackgroundService.\n    Args:\n        name: The name of this background service. If `None`, `str(id(self))` will\n            be used. This is used mostly for debugging purposes.\n    \"\"\"\nself._name: str = str(id(self)) if name is None else name\nself._tasks: set[asyncio.Task[Any]] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}(name={self._name!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this instance.\n    Returns:\n        A string representation of this instance.\n    \"\"\"\nreturn f\"{type(self).__name__}[{self._name}]\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.cancel","title":"<code>cancel(msg=None)</code>","text":"<p>Cancel all running tasks spawned by this background service.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n\"\"\"Cancel all running tasks spawned by this background service.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nfor task in self._tasks:\ntask.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.start","title":"<code>start()</code>  <code>abstractmethod</code>","text":"<p>Start this background service.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>@abc.abstractmethod\ndef start(self) -&gt; None:\n\"\"\"Start this background service.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.stop","title":"<code>stop(msg=None)</code>  <code>async</code>","text":"<p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this background service.\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    [//]: # (# noqa: DAR401 rest)\n    \"\"\"\nif not self._tasks:\nreturn\nself.cancel(msg)\ntry:\nawait self.wait()\nexcept BaseExceptionGroup as exc_group:\n# We want to ignore CancelledError here as we explicitly cancelled all the\n# tasks.\n_, rest = exc_group.split(asyncio.CancelledError)\nif rest is not None:\n# We are filtering out from an exception group, we really don't want to\n# add the exceptions we just filtered by adding a from clause here.\nraise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.BackgroundService.wait","title":"<code>wait()</code>  <code>async</code>","text":"<p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_background_service.py</code> <pre><code>async def wait(self) -&gt; None:\n\"\"\"Wait this background service to finish.\n    Wait until all background service tasks are finished.\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n# We need to account for tasks that were created between when we started\n# awaiting and we finished awaiting.\nwhile self._tasks:\ndone, pending = await asyncio.wait(self._tasks)\nassert not pending\n# We remove the done tasks, but there might be new ones created after we\n# started waiting.\nself._tasks = self._tasks - done\nexceptions: list[BaseException] = []\nfor task in done:\ntry:\n# This will raise a CancelledError if the task was cancelled or any\n# other exception if the task raised one.\n_ = task.result()\nexcept BaseException as error:  # pylint: disable=broad-except\nexceptions.append(error)\nif exceptions:\nraise BaseExceptionGroup(\nf\"Error while stopping background service {self}\", exceptions\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry","title":"<code>frequenz.sdk.actor.ChannelRegistry</code>","text":"<p>Dynamically creates, own and provide access to channels.</p> <p>It can be used by actors to dynamically establish a communication channel between each other.  Channels are identified by string names.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_channel_registry.py</code> <pre><code>class ChannelRegistry:\n\"\"\"Dynamically creates, own and provide access to channels.\n    It can be used by actors to dynamically establish a communication channel\n    between each other.  Channels are identified by string names.\n    \"\"\"\ndef __init__(self, *, name: str) -&gt; None:\n\"\"\"Create a `ChannelRegistry` instance.\n        Args:\n            name: A unique name for the registry.\n        \"\"\"\nself._name = name\nself._channels: Dict[str, Broadcast[Any]] = {}\ndef new_sender(self, key: str) -&gt; Sender[Any]:\n\"\"\"Get a sender to a dynamically created channel with the given key.\n        Args:\n            key: A key to identify the channel.\n        Returns:\n            A sender to a dynamically created channel with the given key.\n        \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\nreturn self._channels[key].new_sender()\ndef new_receiver(self, key: str) -&gt; Receiver[Any]:\n\"\"\"Get a receiver to a dynamically created channel with the given key.\n        Args:\n            key: A key to identify the channel.\n        Returns:\n            A receiver for a dynamically created channel with the given key.\n        \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\nreturn self._channels[key].new_receiver()\nasync def _close_channel(self, key: str) -&gt; None:\n\"\"\"Close a channel with the given key.\n        This method is private and should only be used in special cases.\n        Args:\n            key: A key to identify the channel.\n        \"\"\"\nif key in self._channels:\nif channel := self._channels.pop(key, None):\nawait channel.close()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.__init__","title":"<code>__init__(*, name)</code>","text":"<p>Create a <code>ChannelRegistry</code> instance.</p> PARAMETER  DESCRIPTION <code>name</code> <p>A unique name for the registry.</p> <p> TYPE: <code>str</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def __init__(self, *, name: str) -&gt; None:\n\"\"\"Create a `ChannelRegistry` instance.\n    Args:\n        name: A unique name for the registry.\n    \"\"\"\nself._name = name\nself._channels: Dict[str, Broadcast[Any]] = {}\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.new_receiver","title":"<code>new_receiver(key)</code>","text":"<p>Get a receiver to a dynamically created channel with the given key.</p> PARAMETER  DESCRIPTION <code>key</code> <p>A key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Receiver[Any]</code> <p>A receiver for a dynamically created channel with the given key.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def new_receiver(self, key: str) -&gt; Receiver[Any]:\n\"\"\"Get a receiver to a dynamically created channel with the given key.\n    Args:\n        key: A key to identify the channel.\n    Returns:\n        A receiver for a dynamically created channel with the given key.\n    \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\nreturn self._channels[key].new_receiver()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry.new_sender","title":"<code>new_sender(key)</code>","text":"<p>Get a sender to a dynamically created channel with the given key.</p> PARAMETER  DESCRIPTION <code>key</code> <p>A key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Sender[Any]</code> <p>A sender to a dynamically created channel with the given key.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def new_sender(self, key: str) -&gt; Sender[Any]:\n\"\"\"Get a sender to a dynamically created channel with the given key.\n    Args:\n        key: A key to identify the channel.\n    Returns:\n        A sender to a dynamically created channel with the given key.\n    \"\"\"\nif key not in self._channels:\nself._channels[key] = Broadcast(f\"{self._name}-{key}\")\nreturn self._channels[key].new_sender()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest","title":"<code>frequenz.sdk.actor.ComponentMetricRequest</code>  <code>dataclass</code>","text":"<p>A request object to start streaming a metric for a component.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_data_sourcing/_component_metric_request.py</code> <pre><code>@dataclass\nclass ComponentMetricRequest:\n\"\"\"A request object to start streaming a metric for a component.\"\"\"\nnamespace: str\n\"\"\"The namespace that this request belongs to.\n    Metric requests with a shared namespace enable the reuse of channels within\n    that namespace.\n    If for example, an actor making a multiple requests, uses the name of the\n    actor as the namespace, then requests from the actor will get reused when\n    possible.\n    \"\"\"\ncomponent_id: int\n\"\"\"The ID of the requested component.\"\"\"\nmetric_id: ComponentMetricId\n\"\"\"The ID of the requested component's metric.\"\"\"\nstart_time: datetime | None\n\"\"\"The start time from which data is required.\n    When None, we will stream only live data.\n    \"\"\"\ndef get_channel_name(self) -&gt; str:\n\"\"\"Return a channel name constructed from Self.\n        This channel name can be used by the sending side and receiving sides to\n        identify the right channel from the ChannelRegistry.\n        Returns:\n            A string denoting a channel name.\n        \"\"\"\nreturn (\nf\"component-stream::{self.component_id}::{self.metric_id.name}::\"\nf\"{self.start_time}::{self.namespace}\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.component_id","title":"<code>component_id: int</code>  <code>instance-attribute</code>","text":"<p>The ID of the requested component.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.metric_id","title":"<code>metric_id: ComponentMetricId</code>  <code>instance-attribute</code>","text":"<p>The ID of the requested component's metric.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.namespace","title":"<code>namespace: str</code>  <code>instance-attribute</code>","text":"<p>The namespace that this request belongs to.</p> <p>Metric requests with a shared namespace enable the reuse of channels within that namespace.</p> <p>If for example, an actor making a multiple requests, uses the name of the actor as the namespace, then requests from the actor will get reused when possible.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.start_time","title":"<code>start_time: datetime | None</code>  <code>instance-attribute</code>","text":"<p>The start time from which data is required.</p> <p>When None, we will stream only live data.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest.get_channel_name","title":"<code>get_channel_name()</code>","text":"<p>Return a channel name constructed from Self.</p> <p>This channel name can be used by the sending side and receiving sides to identify the right channel from the ChannelRegistry.</p> RETURNS DESCRIPTION <code>str</code> <p>A string denoting a channel name.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_data_sourcing/_component_metric_request.py</code> <pre><code>def get_channel_name(self) -&gt; str:\n\"\"\"Return a channel name constructed from Self.\n    This channel name can be used by the sending side and receiving sides to\n    identify the right channel from the ChannelRegistry.\n    Returns:\n        A string denoting a channel name.\n    \"\"\"\nreturn (\nf\"component-stream::{self.component_id}::{self.metric_id.name}::\"\nf\"{self.start_time}::{self.namespace}\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor","title":"<code>frequenz.sdk.actor.ComponentMetricsResamplingActor</code>","text":"<p>             Bases: <code>Actor</code></p> <p>An actor to resample microgrid component metrics.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_resampling.py</code> <pre><code>class ComponentMetricsResamplingActor(Actor):\n\"\"\"An actor to resample microgrid component metrics.\"\"\"\ndef __init__(  # pylint: disable=too-many-arguments\nself,\n*,\nchannel_registry: ChannelRegistry,\ndata_sourcing_request_sender: Sender[ComponentMetricRequest],\nresampling_request_receiver: Receiver[ComponentMetricRequest],\nconfig: ResamplerConfig,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Initialize an instance.\n        Args:\n            channel_registry: The channel registry used to get senders and\n                receivers for data sourcing subscriptions.\n            data_sourcing_request_sender: The sender used to send requests to\n                the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor]\n                to subscribe to component metrics.\n            resampling_request_receiver: The receiver to use to receive new\n                resampling subscription requests.\n            config: The configuration for the resampler.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\nsuper().__init__(name=name)\nself._channel_registry: ChannelRegistry = channel_registry\nself._data_sourcing_request_sender: Sender[\nComponentMetricRequest\n] = data_sourcing_request_sender\nself._resampling_request_receiver: Receiver[\nComponentMetricRequest\n] = resampling_request_receiver\nself._resampler: Resampler = Resampler(config)\nself._active_req_channels: set[str] = set()\nasync def _subscribe(self, request: ComponentMetricRequest) -&gt; None:\n\"\"\"Request data for a component metric.\n        Args:\n            request: The request for component metric data.\n        \"\"\"\nrequest_channel_name = request.get_channel_name()\n# If we are already handling this request, there is nothing to do.\nif request_channel_name in self._active_req_channels:\nreturn\nself._active_req_channels.add(request_channel_name)\ndata_source_request = dataclasses.replace(\nrequest, namespace=request.namespace + \":Source\"\n)\ndata_source_channel_name = data_source_request.get_channel_name()\nawait self._data_sourcing_request_sender.send(data_source_request)\nreceiver = self._channel_registry.new_receiver(data_source_channel_name)\n# This is a temporary hack until the Sender implementation uses\n# exceptions to report errors.\nsender = self._channel_registry.new_sender(request_channel_name)\nasync def sink_adapter(sample: Sample[Quantity]) -&gt; None:\nawait sender.send(sample)\nself._resampler.add_timeseries(request_channel_name, receiver, sink_adapter)\nasync def _process_resampling_requests(self) -&gt; None:\n\"\"\"Process resampling data requests.\"\"\"\nasync for request in self._resampling_request_receiver:\nawait self._subscribe(request)\nasync def _run(self) -&gt; None:\n\"\"\"Resample known component metrics and process resampling requests.\n        If there is a resampling error while resampling some component metric,\n        then that metric will be discarded and not resampled any more. Any\n        other error will be propagated (most likely ending in the actor being\n        restarted).\n        This method creates 2 main tasks:\n        - One task to process incoming subscription requests to resample new metrics.\n        - One task to run the resampler.\n        Raises:\n            RuntimeError: If there is some unexpected error while resampling or\n                handling requests.\n        [//]: # (# noqa: DAR401 error)\n        \"\"\"\ntasks_to_cancel: set[asyncio.Task[None]] = set()\ntry:\nsubscriptions_task = asyncio.create_task(\nself._process_resampling_requests()\n)\ntasks_to_cancel.add(subscriptions_task)\nwhile True:\nresampling_task = asyncio.create_task(self._resampler.resample())\ntasks_to_cancel.add(resampling_task)\ndone, _ = await asyncio.wait(\n[resampling_task, subscriptions_task],\nreturn_when=asyncio.FIRST_COMPLETED,\n)\nif subscriptions_task in done:\ntasks_to_cancel.remove(subscriptions_task)\nraise RuntimeError(\n\"There was a problem with the subscriptions channel.\"\n)\nif resampling_task in done:\ntasks_to_cancel.remove(resampling_task)\n# The resampler shouldn't end without an exception\nerror = resampling_task.exception()\nassert (\nerror is not None\n), \"The resample() function shouldn't exit normally.\"\n# We don't know what to do with something other than\n# ResamplingError, so propagate the exception if that is the\n# case.\nif not isinstance(error, ResamplingError):\nraise error\nfor source, source_error in error.exceptions.items():\n_logger.error(\n\"Error resampling source %s, removing source...\", source\n)\nremoved = self._resampler.remove_timeseries(source)\nif not removed:\n_logger.warning(\n\"Got an exception from an unknown source: \"\n\"source=%r, exception=%r\",\nsource,\nsource_error,\n)\n# The resampling_task will be re-created if we reached this point\nfinally:\nawait asyncio.gather(*[cancel_and_await(t) for t in tasks_to_cancel])\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor.__init__","title":"<code>__init__(*, channel_registry, data_sourcing_request_sender, resampling_request_receiver, config, name=None)</code>","text":"<p>Initialize an instance.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>The channel registry used to get senders and receivers for data sourcing subscriptions.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>data_sourcing_request_sender</code> <p>The sender used to send requests to the <code>DataSourcingActor</code> to subscribe to component metrics.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>resampling_request_receiver</code> <p>The receiver to use to receive new resampling subscription requests.</p> <p> TYPE: <code>Receiver[ComponentMetricRequest]</code> </p> <code>config</code> <p>The configuration for the resampler.</p> <p> TYPE: <code>ResamplerConfig</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_resampling.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\nself,\n*,\nchannel_registry: ChannelRegistry,\ndata_sourcing_request_sender: Sender[ComponentMetricRequest],\nresampling_request_receiver: Receiver[ComponentMetricRequest],\nconfig: ResamplerConfig,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Initialize an instance.\n    Args:\n        channel_registry: The channel registry used to get senders and\n            receivers for data sourcing subscriptions.\n        data_sourcing_request_sender: The sender used to send requests to\n            the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor]\n            to subscribe to component metrics.\n        resampling_request_receiver: The receiver to use to receive new\n            resampling subscription requests.\n        config: The configuration for the resampler.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\nsuper().__init__(name=name)\nself._channel_registry: ChannelRegistry = channel_registry\nself._data_sourcing_request_sender: Sender[\nComponentMetricRequest\n] = data_sourcing_request_sender\nself._resampling_request_receiver: Receiver[\nComponentMetricRequest\n] = resampling_request_receiver\nself._resampler: Resampler = Resampler(config)\nself._active_req_channels: set[str] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor","title":"<code>frequenz.sdk.actor.ConfigManagingActor</code>","text":"<p>             Bases: <code>Actor</code></p> <p>An actor that monitors a TOML configuration file for updates.</p> <p>When the file is updated, the new configuration is sent, as a <code>dict</code>, to the <code>output</code> sender.</p> <p>When the actor is started, if a configuration file already exists, then it will be read and sent to the <code>output</code> sender before the actor starts monitoring the file for updates. This way users can rely on the actor to do the initial configuration reading too.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_config_managing.py</code> <pre><code>class ConfigManagingActor(Actor):\n\"\"\"An actor that monitors a TOML configuration file for updates.\n    When the file is updated, the new configuration is sent, as a [`dict`][], to the\n    `output` sender.\n    When the actor is started, if a configuration file already exists, then it will be\n    read and sent to the `output` sender before the actor starts monitoring the file\n    for updates. This way users can rely on the actor to do the initial configuration\n    reading too.\n    \"\"\"\ndef __init__(\nself,\nconfig_path: pathlib.Path | str,\noutput: Sender[Config],\nevent_types: abc.Set[FileWatcher.EventType] = frozenset(FileWatcher.EventType),\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Initialize this instance.\n        Args:\n            config_path: The path to the TOML file with the configuration.\n            output: The sender to send the config to.\n            event_types: The set of event types to monitor.\n            name: The name of the actor. If `None`, `str(id(self))` will\n                be used. This is used mostly for debugging purposes.\n        \"\"\"\nsuper().__init__(name=name)\nself._config_path: pathlib.Path = (\nconfig_path\nif isinstance(config_path, pathlib.Path)\nelse pathlib.Path(config_path)\n)\n# FileWatcher can't watch for non-existing files, so we need to watch for the\n# parent directory instead just in case a configuration file doesn't exist yet\n# or it is deleted and recreated again.\nself._file_watcher: FileWatcher = FileWatcher(\npaths=[self._config_path.parent], event_types=event_types\n)\nself._output: Sender[Config] = output\ndef _read_config(self) -&gt; dict[str, Any]:\n\"\"\"Read the contents of the configuration file.\n        Returns:\n            A dictionary containing configuration variables.\n        Raises:\n            ValueError: If config file cannot be read.\n        \"\"\"\ntry:\nwith self._config_path.open(\"rb\") as toml_file:\nreturn tomllib.load(toml_file)\nexcept ValueError as err:\nlogging.error(\"%s: Can't read config file, err: %s\", self, err)\nraise\nasync def send_config(self) -&gt; None:\n\"\"\"Send the configuration to the output sender.\"\"\"\nconf_vars = self._read_config()\nconfig = Config(conf_vars)\nawait self._output.send(config)\nasync def _run(self) -&gt; None:\n\"\"\"Monitor for and send configuration file updates.\n        At startup, the Config Manager sends the current config so that it\n        can be cache in the Broadcast channel and served to receivers even if\n        there hasn't been any change to the config file itself.\n        \"\"\"\nawait self.send_config()\nasync for event in self._file_watcher:\n# Since we are watching the whole parent directory, we need to make sure\n# we only react to events related to the configuration file.\nif event.path != self._config_path:\ncontinue\nmatch event.type:\ncase FileWatcher.EventType.CREATE:\n_logger.info(\n\"%s: The configuration file %s was created, sending new config...\",\nself,\nself._config_path,\n)\nawait self.send_config()\ncase FileWatcher.EventType.MODIFY:\n_logger.info(\n\"%s: The configuration file %s was modified, sending update...\",\nself,\nself._config_path,\n)\nawait self.send_config()\ncase FileWatcher.EventType.DELETE:\n_logger.info(\n\"%s: The configuration file %s was deleted, ignoring...\",\nself,\nself._config_path,\n)\ncase _:\nassert_never(event.type)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.__init__","title":"<code>__init__(config_path, output, event_types=frozenset(FileWatcher.EventType), *, name=None)</code>","text":"<p>Initialize this instance.</p> PARAMETER  DESCRIPTION <code>config_path</code> <p>The path to the TOML file with the configuration.</p> <p> TYPE: <code>Path | str</code> </p> <code>output</code> <p>The sender to send the config to.</p> <p> TYPE: <code>Sender[Config]</code> </p> <code>event_types</code> <p>The set of event types to monitor.</p> <p> TYPE: <code>Set[EventType]</code> DEFAULT: <code>frozenset(EventType)</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_config_managing.py</code> <pre><code>def __init__(\nself,\nconfig_path: pathlib.Path | str,\noutput: Sender[Config],\nevent_types: abc.Set[FileWatcher.EventType] = frozenset(FileWatcher.EventType),\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Initialize this instance.\n    Args:\n        config_path: The path to the TOML file with the configuration.\n        output: The sender to send the config to.\n        event_types: The set of event types to monitor.\n        name: The name of the actor. If `None`, `str(id(self))` will\n            be used. This is used mostly for debugging purposes.\n    \"\"\"\nsuper().__init__(name=name)\nself._config_path: pathlib.Path = (\nconfig_path\nif isinstance(config_path, pathlib.Path)\nelse pathlib.Path(config_path)\n)\n# FileWatcher can't watch for non-existing files, so we need to watch for the\n# parent directory instead just in case a configuration file doesn't exist yet\n# or it is deleted and recreated again.\nself._file_watcher: FileWatcher = FileWatcher(\npaths=[self._config_path.parent], event_types=event_types\n)\nself._output: Sender[Config] = output\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor.send_config","title":"<code>send_config()</code>  <code>async</code>","text":"<p>Send the configuration to the output sender.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_config_managing.py</code> <pre><code>async def send_config(self) -&gt; None:\n\"\"\"Send the configuration to the output sender.\"\"\"\nconf_vars = self._read_config()\nconfig = Config(conf_vars)\nawait self._output.send(config)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor","title":"<code>frequenz.sdk.actor.DataSourcingActor</code>","text":"<p>             Bases: <code>Actor</code></p> <p>An actor that provides data streams of metrics as time series.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_data_sourcing/data_sourcing.py</code> <pre><code>class DataSourcingActor(Actor):\n\"\"\"An actor that provides data streams of metrics as time series.\"\"\"\ndef __init__(\nself,\nrequest_receiver: Receiver[ComponentMetricRequest],\nregistry: ChannelRegistry,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create a `DataSourcingActor` instance.\n        Args:\n            request_receiver: A channel receiver to accept metric requests from.\n            registry: A channel registry.  To be replaced by a singleton\n                instance.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\nsuper().__init__(name=name)\nself._request_receiver = request_receiver\nself._microgrid_api_source = MicrogridApiSource(registry)\nasync def _run(self) -&gt; None:\n\"\"\"Run the actor.\"\"\"\nasync for request in self._request_receiver:\nawait self._microgrid_api_source.add_metric(request)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor.__init__","title":"<code>__init__(request_receiver, registry, *, name=None)</code>","text":"<p>Create a <code>DataSourcingActor</code> instance.</p> PARAMETER  DESCRIPTION <code>request_receiver</code> <p>A channel receiver to accept metric requests from.</p> <p> TYPE: <code>Receiver[ComponentMetricRequest]</code> </p> <code>registry</code> <p>A channel registry.  To be replaced by a singleton instance.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_data_sourcing/data_sourcing.py</code> <pre><code>def __init__(\nself,\nrequest_receiver: Receiver[ComponentMetricRequest],\nregistry: ChannelRegistry,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create a `DataSourcingActor` instance.\n    Args:\n        request_receiver: A channel receiver to accept metric requests from.\n        registry: A channel registry.  To be replaced by a singleton\n            instance.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\nsuper().__init__(name=name)\nself._request_receiver = request_receiver\nself._microgrid_api_source = MicrogridApiSource(registry)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig","title":"<code>frequenz.sdk.actor.ResamplerConfig</code>  <code>dataclass</code>","text":"<p>Resampler configuration.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_resampling.py</code> <pre><code>@dataclass(frozen=True)\nclass ResamplerConfig:\n\"\"\"Resampler configuration.\"\"\"\nresampling_period: timedelta\n\"\"\"The resampling period.\n    This is the time it passes between resampled data should be calculated.\n    It must be a positive time span.\n    \"\"\"\nmax_data_age_in_periods: float = 3.0\n\"\"\"The maximum age a sample can have to be considered *relevant* for resampling.\n    Expressed in number of periods, where period is the `resampling_period`\n    if we are downsampling (resampling period bigger than the input period) or\n    the input sampling period if we are upsampling (input period bigger than\n    the resampling period).\n    It must be bigger than 1.0.\n    Example:\n        If `resampling_period` is 3 seconds, the input sampling period is\n        1 and `max_data_age_in_periods` is 2, then data older than 3*2\n        = 6 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n        If `resampling_period` is 3 seconds, the input sampling period is\n        5 and `max_data_age_in_periods` is 2, then data older than 5*2\n        = 10 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n    \"\"\"\nresampling_function: ResamplingFunction = average\n\"\"\"The resampling function.\n    This function will be applied to the sequence of relevant samples at\n    a given time. The result of the function is what is sent as the resampled\n    value.\n    \"\"\"\ninitial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n\"\"\"The initial length of the resampling buffer.\n    The buffer could grow or shrink depending on the source properties,\n    like sampling rate, to make sure all the requested past sampling periods\n    can be stored.\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\nwarn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n\"\"\"The minimum length of the resampling buffer that will emit a warning.\n    If a buffer grows bigger than this value, it will emit a warning in the\n    logs, so buffers don't grow too big inadvertently.\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\nmax_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n\"\"\"The maximum length of the resampling buffer.\n    Buffers won't be allowed to grow beyond this point even if it would be\n    needed to keep all the requested past sampling periods. An error will be\n    emitted in the logs if the buffer length needs to be truncated to this\n    value.\n    It must be at bigger than `warn_buffer_len`.\n    \"\"\"\nalign_to: datetime | None = UNIX_EPOCH\n\"\"\"The time to align the resampling period to.\n    The resampling period will be aligned to this time, so the first resampled\n    sample will be at the first multiple of `resampling_period` starting from\n    `align_to`. It must be an aware datetime and can be in the future too.\n    If `align_to` is `None`, the resampling period will be aligned to the\n    time the resampler is created.\n    \"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n        Raises:\n            ValueError: If any value is out of range.\n        \"\"\"\nif self.resampling_period.total_seconds() &lt; 0.0:\nraise ValueError(\nf\"resampling_period ({self.resampling_period}) must be positive\"\n)\nif self.max_data_age_in_periods &lt; 1.0:\nraise ValueError(\nf\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n)\nif self.warn_buffer_len &lt; 1:\nraise ValueError(\nf\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n)\nif self.max_buffer_len &lt;= self.warn_buffer_len:\nraise ValueError(\nf\"max_buffer_len ({self.max_buffer_len}) should \"\nf\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n)\nif self.initial_buffer_len &lt; 1:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n)\nif self.initial_buffer_len &gt; self.max_buffer_len:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\nf\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n\"initial_buffer_len or a bigger max_buffer_len\"\n)\nif self.initial_buffer_len &gt; self.warn_buffer_len:\n_logger.warning(\n\"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\nself.initial_buffer_len,\nself.warn_buffer_len,\n)\nif self.align_to is not None and self.align_to.tzinfo is None:\nraise ValueError(\nf\"align_to ({self.align_to}) should be a timezone aware datetime\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.align_to","title":"<code>align_to: datetime | None = UNIX_EPOCH</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The time to align the resampling period to.</p> <p>The resampling period will be aligned to this time, so the first resampled sample will be at the first multiple of <code>resampling_period</code> starting from <code>align_to</code>. It must be an aware datetime and can be in the future too.</p> <p>If <code>align_to</code> is <code>None</code>, the resampling period will be aligned to the time the resampler is created.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.initial_buffer_len","title":"<code>initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The initial length of the resampling buffer.</p> <p>The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.max_buffer_len","title":"<code>max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The maximum length of the resampling buffer.</p> <p>Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value.</p> <p>It must be at bigger than <code>warn_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.max_data_age_in_periods","title":"<code>max_data_age_in_periods: float = 3.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The maximum age a sample can have to be considered relevant for resampling.</p> <p>Expressed in number of periods, where period is the <code>resampling_period</code> if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period).</p> <p>It must be bigger than 1.0.</p> Example <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 1 and <code>max_data_age_in_periods</code> is 2, then data older than 3*2 = 6 seconds will be discarded when creating a new sample and never passed to the resampling function.</p> <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 5 and <code>max_data_age_in_periods</code> is 2, then data older than 5*2 = 10 seconds will be discarded when creating a new sample and never passed to the resampling function.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.resampling_function","title":"<code>resampling_function: ResamplingFunction = average</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The resampling function.</p> <p>This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.resampling_period","title":"<code>resampling_period: timedelta</code>  <code>instance-attribute</code>","text":"<p>The resampling period.</p> <p>This is the time it passes between resampled data should be calculated.</p> <p>It must be a positive time span.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.warn_buffer_len","title":"<code>warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The minimum length of the resampling buffer that will emit a warning.</p> <p>If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertently.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check that config values are valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any value is out of range.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_resampling.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n    Raises:\n        ValueError: If any value is out of range.\n    \"\"\"\nif self.resampling_period.total_seconds() &lt; 0.0:\nraise ValueError(\nf\"resampling_period ({self.resampling_period}) must be positive\"\n)\nif self.max_data_age_in_periods &lt; 1.0:\nraise ValueError(\nf\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n)\nif self.warn_buffer_len &lt; 1:\nraise ValueError(\nf\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n)\nif self.max_buffer_len &lt;= self.warn_buffer_len:\nraise ValueError(\nf\"max_buffer_len ({self.max_buffer_len}) should \"\nf\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n)\nif self.initial_buffer_len &lt; 1:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n)\nif self.initial_buffer_len &gt; self.max_buffer_len:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\nf\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n\"initial_buffer_len or a bigger max_buffer_len\"\n)\nif self.initial_buffer_len &gt; self.warn_buffer_len:\n_logger.warning(\n\"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\nself.initial_buffer_len,\nself.warn_buffer_len,\n)\nif self.align_to is not None and self.align_to.tzinfo is None:\nraise ValueError(\nf\"align_to ({self.align_to}) should be a timezone aware datetime\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.run","title":"<code>frequenz.sdk.actor.run(*actors)</code>  <code>async</code>","text":"<p>Await the completion of all actors.</p> PARAMETER  DESCRIPTION <code>*actors</code> <p>the actors to be awaited.</p> <p> TYPE: <code>Actor</code> DEFAULT: <code>()</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_run_utils.py</code> <pre><code>async def run(*actors: Actor) -&gt; None:\n\"\"\"Await the completion of all actors.\n    Args:\n        *actors: the actors to be awaited.\n    \"\"\"\n_logger.info(\"Starting %s actor(s)...\", len(actors))\nfor actor in actors:\nif actor.is_running:\n_logger.info(\"Actor %s: Already running, skipping start.\", actor)\nelse:\n_logger.info(\"Actor %s: Starting...\", actor)\nactor.start()\n# Wait until all actors are done\npending_tasks = set(asyncio.create_task(a.wait(), name=str(a)) for a in actors)\nwhile pending_tasks:\ndone_tasks, pending_tasks = await asyncio.wait(\npending_tasks, return_when=asyncio.FIRST_COMPLETED\n)\n# This should always be only one task, but we handle many for extra safety\nfor task in done_tasks:\n# Cancellation needs to be checked first, otherwise the other methods\n# could raise a CancelledError\nif task.cancelled():\n_logger.info(\"Actor %s: Cancelled while running.\", task.get_name())\nelif exception := task.exception():\n_logger.error(\n\"Actor %s: Raised an exception while running.\",\ntask.get_name(),\nexc_info=exception,\n)\nelse:\n_logger.info(\"Actor %s: Finished normally.\", task.get_name())\n_logger.info(\"All %s actor(s) finished.\", len(actors))\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/","title":"power_distributing","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing","title":"<code>frequenz.sdk.actor.power_distributing</code>","text":"<p>This module provides feature to set power between many batteries.</p> <p>Distributing power is very important to keep the microgrid ready for the power requirements. This module provides PowerDistributingActor that knows how to distribute power. It also provides all the secondary features that should be used to communicate with PowerDistributingActor and send requests for charging or discharging power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus","title":"<code>frequenz.sdk.actor.power_distributing.BatteryStatus</code>  <code>dataclass</code>","text":"<p>Status of the batteries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/_battery_pool_status.py</code> <pre><code>@dataclass\nclass BatteryStatus:\n\"\"\"Status of the batteries.\"\"\"\nworking: Set[int]\n\"\"\"Set of working battery ids.\"\"\"\nuncertain: Set[int]\n\"\"\"Set of batteries that should be used only if there are no working batteries.\"\"\"\ndef get_working_batteries(self, batteries: abc.Set[int]) -&gt; Set[int]:\n\"\"\"From the given set of batteries return working batteries.\n        Args:\n            batteries: Set of batteries\n        Returns:\n            Subset with working batteries.\n        \"\"\"\nworking = self.working.intersection(batteries)\nif len(working) &gt; 0:\nreturn working\nreturn self.uncertain.intersection(batteries)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus.uncertain","title":"<code>uncertain: Set[int]</code>  <code>instance-attribute</code>","text":"<p>Set of batteries that should be used only if there are no working batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus.working","title":"<code>working: Set[int]</code>  <code>instance-attribute</code>","text":"<p>Set of working battery ids.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus.get_working_batteries","title":"<code>get_working_batteries(batteries)</code>","text":"<p>From the given set of batteries return working batteries.</p> PARAMETER  DESCRIPTION <code>batteries</code> <p>Set of batteries</p> <p> TYPE: <code>Set[int]</code> </p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Subset with working batteries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/_battery_pool_status.py</code> <pre><code>def get_working_batteries(self, batteries: abc.Set[int]) -&gt; Set[int]:\n\"\"\"From the given set of batteries return working batteries.\n    Args:\n        batteries: Set of batteries\n    Returns:\n        Subset with working batteries.\n    \"\"\"\nworking = self.working.intersection(batteries)\nif len(working) &gt; 0:\nreturn working\nreturn self.uncertain.intersection(batteries)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error","title":"<code>frequenz.sdk.actor.power_distributing.Error</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Result</code></p> <p>Result returned when an error occurred and power was not set at all.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Error(Result):\n\"\"\"Result returned when an error occurred and power was not set at all.\"\"\"\nmsg: str\n\"\"\"The error message explaining why error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error.msg","title":"<code>msg: str</code>  <code>instance-attribute</code>","text":"<p>The error message explaining why error happened.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds","title":"<code>frequenz.sdk.actor.power_distributing.OutOfBounds</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Result</code></p> <p>Result returned when the power was not set because it was out of bounds.</p> <p>This result happens when the originating request was done with <code>adjust_power = False</code> and the requested power is not within the batteries bounds.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass OutOfBounds(Result):\n\"\"\"Result returned when the power was not set because it was out of bounds.\n    This result happens when the originating request was done with\n    `adjust_power = False` and the requested power is not within the batteries bounds.\n    \"\"\"\nbounds: PowerBounds\n\"\"\"The power bounds for the requested batteries.\n    If the requested power negative, then this value is the lower bound.\n    Otherwise it is upper bound.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBounds.bounds","title":"<code>bounds: PowerBounds</code>  <code>instance-attribute</code>","text":"<p>The power bounds for the requested batteries.</p> <p>If the requested power negative, then this value is the lower bound. Otherwise it is upper bound.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure","title":"<code>frequenz.sdk.actor.power_distributing.PartialFailure</code>  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>Result</code></p> <p>Result returned when any battery failed to perform the request.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PartialFailure(_BaseSuccessMixin, Result):\n\"\"\"Result returned when any battery failed to perform the request.\"\"\"\nfailed_power: Power\n\"\"\"The part of the requested power that failed to be set.\"\"\"\nfailed_batteries: set[int]\n\"\"\"The subset of batteries for which the request failed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.failed_batteries","title":"<code>failed_batteries: set[int]</code>  <code>instance-attribute</code>","text":"<p>The subset of batteries for which the request failed.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure.failed_power","title":"<code>failed_power: Power</code>  <code>instance-attribute</code>","text":"<p>The part of the requested power that failed to be set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor","title":"<code>frequenz.sdk.actor.power_distributing.PowerDistributingActor</code>","text":"<p>             Bases: <code>Actor</code></p> <p>Actor to distribute the power between batteries in a microgrid.</p> <p>The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time.</p> <p>For each user a bidirectional channel needs to be created through which they can send and receive requests and responses.</p> <p>It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout + time for processing the request.</p> <p>Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED.</p> <ul> <li>If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed.</li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>class PowerDistributingActor(Actor):\n# pylint: disable=too-many-instance-attributes\n\"\"\"Actor to distribute the power between batteries in a microgrid.\n    The purpose of this tool is to keep an equal SoC level in all batteries.\n    The PowerDistributingActor can have many concurrent users which at this time\n    need to be known at construction time.\n    For each user a bidirectional channel needs to be created through which\n    they can send and receive requests and responses.\n    It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if\n    the processing function fails then the response will never come.\n    The timeout should be Result:request_timeout + time for processing the request.\n    Edge cases:\n    * If there are 2 requests to be processed for the same subset of batteries, then\n    only the latest request will be processed. Older request will be ignored. User with\n    older request will get response with Result.Status.IGNORED.\n    * If there are 2 requests and their subset of batteries is different but they\n    overlap (they have at least one common battery), then then both batteries\n    will be processed. However it is not expected so the proper error log will be\n    printed.\n    \"\"\"\ndef __init__(\nself,\nrequests_receiver: Receiver[Request],\nchannel_registry: ChannelRegistry,\nbattery_status_sender: Sender[BatteryStatus],\nwait_for_data_sec: float = 2,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create class instance.\n        Args:\n            requests_receiver: Receiver for receiving power requests from other actors.\n            channel_registry: Channel registry for creating result channels dynamically\n                for each request namespace.\n            battery_status_sender: Channel for sending information which batteries are\n                working.\n            wait_for_data_sec: How long actor should wait before processing first\n                request. It is a time needed to collect first components data.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\nsuper().__init__(name=name)\nself._requests_receiver = requests_receiver\nself._channel_registry = channel_registry\nself._wait_for_data_sec = wait_for_data_sec\nself._result_senders: Dict[str, Sender[Result]] = {}\n\"\"\"Dictionary of result senders for each request namespace.\n        They are for channels owned by the channel registry, we just hold a reference\n        to their senders, for fast access.\n        \"\"\"\n# NOTE: power_distributor_exponent should be received from ConfigManager\nself.power_distributor_exponent: float = 1.0\n\"\"\"The exponent for the power distribution algorithm.\n        The exponent determines how fast the batteries should strive to the\n        equal SoC level.\n        \"\"\"\nself.distribution_algorithm = DistributionAlgorithm(\nself.power_distributor_exponent\n)\n\"\"\"The distribution algorithm used to distribute power between batteries.\"\"\"\nself._bat_inv_map, self._inv_bat_map = self._get_components_pairs(\nconnection_manager.get().component_graph\n)\nself._battery_receivers: Dict[int, Peekable[BatteryData]] = {}\nself._inverter_receivers: Dict[int, Peekable[InverterData]] = {}\nself._all_battery_status = BatteryPoolStatus(\nbattery_ids=set(self._bat_inv_map.keys()),\nbattery_status_sender=battery_status_sender,\nmax_blocking_duration_sec=30.0,\nmax_data_age_sec=10.0,\n)\nself._cached_metrics: dict[int, _CacheEntry | None] = {\nbat_id: None for bat_id, _ in self._bat_inv_map.items()\n}\ndef _get_bounds(\nself,\npairs_data: list[InvBatPair],\n) -&gt; PowerBounds:\n\"\"\"Get power bounds for given batteries.\n        Args:\n            pairs_data: list of battery and adjacent inverter data pairs.\n        Returns:\n            Power bounds for given batteries.\n        \"\"\"\nreturn PowerBounds(\ninclusion_lower=sum(\nmax(\nbattery.power_inclusion_lower_bound,\ninverter.active_power_inclusion_lower_bound,\n)\nfor battery, inverter in pairs_data\n),\ninclusion_upper=sum(\nmin(\nbattery.power_inclusion_upper_bound,\ninverter.active_power_inclusion_upper_bound,\n)\nfor battery, inverter in pairs_data\n),\nexclusion_lower=sum(\nmin(\nbattery.power_exclusion_lower_bound,\ninverter.active_power_exclusion_lower_bound,\n)\nfor battery, inverter in pairs_data\n),\nexclusion_upper=sum(\nmax(\nbattery.power_exclusion_upper_bound,\ninverter.active_power_exclusion_upper_bound,\n)\nfor battery, inverter in pairs_data\n),\n)\nasync def _send_result(self, namespace: str, result: Result) -&gt; None:\n\"\"\"Send result to the user.\n        Args:\n            namespace: namespace of the sender, to identify the result channel with.\n            result: Result to send out.\n        \"\"\"\nif namespace not in self._result_senders:\nself._result_senders[namespace] = self._channel_registry.new_sender(\nnamespace\n)\nawait self._result_senders[namespace].send(result)\nasync def _run(self) -&gt; None:\n\"\"\"Run actor main function.\n        It waits for new requests in task_queue and process it, and send\n        `set_power` request with distributed power.\n        The output of the `set_power` method is processed.\n        Every battery and inverter that failed or didn't respond in time will be marked\n        as broken for some time.\n        \"\"\"\nawait self._create_channels()\napi = connection_manager.get().api_client\n# Wait few seconds to get data from the channels created above.\nawait asyncio.sleep(self._wait_for_data_sec)\nasync for request in self._requests_receiver:\ntry:\npairs_data: List[InvBatPair] = self._get_components_data(\nrequest.batteries, request.include_broken_batteries\n)\nexcept KeyError as err:\nawait self._send_result(\nrequest.namespace, Error(request=request, msg=str(err))\n)\ncontinue\nif not pairs_data and not request.include_broken_batteries:\nerror_msg = f\"No data for the given batteries {str(request.batteries)}\"\nawait self._send_result(\nrequest.namespace, Error(request=request, msg=str(error_msg))\n)\ncontinue\nerror = self._check_request(request, pairs_data)\nif error:\nawait self._send_result(request.namespace, error)\ncontinue\ntry:\ndistribution = self._get_power_distribution(request, pairs_data)\nexcept ValueError as err:\n_logger.exception(\"Couldn't distribute power\")\nerror_msg = f\"Couldn't distribute power, error: {str(err)}\"\nawait self._send_result(\nrequest.namespace, Error(request=request, msg=str(error_msg))\n)\ncontinue\ndistributed_power_value = (\nrequest.power.as_watts() - distribution.remaining_power\n)\nbattery_distribution = {\nself._inv_bat_map[bat_id]: dist\nfor bat_id, dist in distribution.distribution.items()\n}\n_logger.debug(\n\"Distributing power %d between the batteries %s\",\ndistributed_power_value,\nstr(battery_distribution),\n)\nfailed_power, failed_batteries = await self._set_distributed_power(\napi, distribution, request.request_timeout\n)\nresponse: Success | PartialFailure\nif len(failed_batteries) &gt; 0:\nsucceed_batteries = set(battery_distribution.keys()) - failed_batteries\nresponse = PartialFailure(\nrequest=request,\nsucceeded_power=Power.from_watts(distributed_power_value),\nsucceeded_batteries=succeed_batteries,\nfailed_power=Power.from_watts(failed_power),\nfailed_batteries=failed_batteries,\nexcess_power=Power.from_watts(distribution.remaining_power),\n)\nelse:\nsucceed_batteries = set(battery_distribution.keys())\nresponse = Success(\nrequest=request,\nsucceeded_power=Power.from_watts(distributed_power_value),\nsucceeded_batteries=succeed_batteries,\nexcess_power=Power.from_watts(distribution.remaining_power),\n)\nasyncio.gather(\n*[\nself._all_battery_status.update_status(\nsucceed_batteries, failed_batteries\n),\nself._send_result(request.namespace, response),\n]\n)\nasync def _set_distributed_power(\nself,\napi: MicrogridApiClient,\ndistribution: DistributionResult,\ntimeout: timedelta,\n) -&gt; Tuple[float, Set[int]]:\n\"\"\"Send distributed power to the inverters.\n        Args:\n            api: Microgrid api client\n            distribution: Distribution result\n            timeout: How long wait for the response\n        Returns:\n            Tuple where first element is total failed power, and the second element\n            set of batteries that failed.\n        \"\"\"\ntasks = {\ninverter_id: asyncio.create_task(api.set_power(inverter_id, power))\nfor inverter_id, power in distribution.distribution.items()\n}\n_, pending = await asyncio.wait(\ntasks.values(),\ntimeout=timeout.total_seconds(),\nreturn_when=ALL_COMPLETED,\n)\nawait self._cancel_tasks(pending)\nreturn self._parse_result(tasks, distribution.distribution, timeout)\ndef _get_power_distribution(\nself, request: Request, inv_bat_pairs: List[InvBatPair]\n) -&gt; DistributionResult:\n\"\"\"Get power distribution result for the batteries in the request.\n        Args:\n            request: the power request to process.\n            inv_bat_pairs: the battery and adjacent inverter data pairs.\n        Returns:\n            the power distribution result.\n        \"\"\"\navailable_bat_ids = {battery.component_id for battery, _ in inv_bat_pairs}\nunavailable_bat_ids = request.batteries - available_bat_ids\nunavailable_inv_ids = {\nself._bat_inv_map[battery_id] for battery_id in unavailable_bat_ids\n}\nif request.include_broken_batteries and not available_bat_ids:\nreturn self.distribution_algorithm.distribute_power_equally(\nrequest.power.as_watts(), unavailable_inv_ids\n)\nresult = self.distribution_algorithm.distribute_power(\nrequest.power.as_watts(), inv_bat_pairs\n)\nif request.include_broken_batteries and unavailable_inv_ids:\nadditional_result = self.distribution_algorithm.distribute_power_equally(\nresult.remaining_power, unavailable_inv_ids\n)\nfor inv_id, power in additional_result.distribution.items():\nresult.distribution[inv_id] = power\nresult.remaining_power = 0.0\nreturn result\ndef _check_request(\nself,\nrequest: Request,\npairs_data: List[InvBatPair],\n) -&gt; Optional[Result]:\n\"\"\"Check whether the given request if correct.\n        Args:\n            request: request to check\n            pairs_data: list of battery and adjacent inverter data pairs.\n        Returns:\n            Result for the user if the request is wrong, None otherwise.\n        \"\"\"\nif not request.batteries:\nreturn Error(request=request, msg=\"Empty battery IDs in the request\")\nfor battery in request.batteries:\nif battery not in self._battery_receivers:\nmsg = (\nf\"No battery {battery}, available batteries: \"\nf\"{list(self._battery_receivers.keys())}\"\n)\nreturn Error(request=request, msg=msg)\nbounds = self._get_bounds(pairs_data)\npower = request.power.as_watts()\n# Zero power requests are always forwarded to the microgrid API, even if they\n# are outside the exclusion bounds.\nif is_close_to_zero(power):\nreturn None\nif request.adjust_power:\n# Automatic power adjustments can only bring down the requested power down\n# to the inclusion bounds.\n#\n# If the requested power is in the exclusion bounds, it is NOT possible to\n# increase it so that it is outside the exclusion bounds.\nif bounds.exclusion_lower &lt; power &lt; bounds.exclusion_upper:\nreturn OutOfBounds(request=request, bounds=bounds)\nelse:\nin_lower_range = bounds.inclusion_lower &lt;= power &lt;= bounds.exclusion_lower\nin_upper_range = bounds.exclusion_upper &lt;= power &lt;= bounds.inclusion_upper\nif not (in_lower_range or in_upper_range):\nreturn OutOfBounds(request=request, bounds=bounds)\nreturn None\ndef _get_components_pairs(\nself, component_graph: ComponentGraph\n) -&gt; Tuple[Dict[int, int], Dict[int, int]]:\n\"\"\"Create maps between battery and adjacent inverter.\n        Args:\n            component_graph: component graph\n        Returns:\n            Tuple where first element is map between battery and adjacent inverter,\n                second element of the tuple is map between inverter and adjacent\n                battery.\n        \"\"\"\nbat_inv_map: Dict[int, int] = {}\ninv_bat_map: Dict[int, int] = {}\nbatteries: Iterable[Component] = component_graph.components(\ncomponent_category={ComponentCategory.BATTERY}\n)\nfor battery in batteries:\ninverters: List[Component] = [\ncomponent\nfor component in component_graph.predecessors(battery.component_id)\nif component.category == ComponentCategory.INVERTER\n]\nif len(inverters) == 0:\n_logger.error(\"No inverters for battery %d\", battery.component_id)\ncontinue\nif len(inverters) &gt; 1:\n_logger.error(\n\"Battery %d has more then one inverter. It is not supported now.\",\nbattery.component_id,\n)\nbat_inv_map[battery.component_id] = inverters[0].component_id\ninv_bat_map[inverters[0].component_id] = battery.component_id\nreturn bat_inv_map, inv_bat_map\ndef _get_components_data(\nself, batteries: abc.Set[int], include_broken: bool\n) -&gt; List[InvBatPair]:\n\"\"\"Get data for the given batteries and adjacent inverters.\n        Args:\n            batteries: Batteries that needs data.\n            include_broken: whether all batteries in the batteries set in the\n                request must be used regardless the status.\n        Raises:\n            KeyError: If any battery in the given list doesn't exists in microgrid.\n        Returns:\n            Pairs of battery and adjacent inverter data.\n        \"\"\"\npairs_data: List[InvBatPair] = []\nworking_batteries = (\nbatteries\nif include_broken\nelse self._all_battery_status.get_working_batteries(batteries)\n)\nfor battery_id in working_batteries:\nif battery_id not in self._battery_receivers:\nraise KeyError(\nf\"No battery {battery_id}, \"\nf\"available batteries: {list(self._battery_receivers.keys())}\"\n)\ninverter_id: int = self._bat_inv_map[battery_id]\ndata = self._get_battery_inverter_data(battery_id, inverter_id)\nif not data and include_broken:\ncached_entry = self._cached_metrics[battery_id]\nif cached_entry and not cached_entry.has_expired():\ndata = cached_entry.inv_bat_pair\nelse:\ndata = None\nif data is None:\n_logger.warning(\n\"Skipping battery %d because its message isn't correct.\",\nbattery_id,\n)\ncontinue\npairs_data.append(data)\nreturn pairs_data\ndef _get_battery_inverter_data(\nself, battery_id: int, inverter_id: int\n) -&gt; Optional[InvBatPair]:\n\"\"\"Get battery and inverter data if they are correct.\n        Each float data from the microgrid can be \"NaN\".\n        We can't do math operations on \"NaN\".\n        So check all the metrics and:\n        * if power bounds are NaN, then try to replace it with the corresponding\n          power bounds from the adjacent component. If metric in the adjacent component\n          is also NaN, then return None.\n        * if other metrics are NaN then return None. We can't assume anything for other\n          metrics.\n        Args:\n            battery_id: battery id\n            inverter_id: inverter id\n        Returns:\n            Data for the battery and adjacent inverter without NaN values.\n                Return None if we could not replace NaN values.\n        \"\"\"\nbattery_data = self._battery_receivers[battery_id].peek()\ninverter_data = self._inverter_receivers[inverter_id].peek()\n# It means that nothing has been send on this channels, yet.\n# This should be handled by BatteryStatus. BatteryStatus should not return\n# this batteries as working.\nif battery_data is None or inverter_data is None:\n_logger.error(\n\"Battery %d or inverter %d send no data, yet. They should be not used.\",\nbattery_id,\ninverter_id,\n)\nreturn None\nnot_replaceable_metrics = [\nbattery_data.soc,\nbattery_data.soc_lower_bound,\nbattery_data.soc_upper_bound,\n# We could replace capacity with 0, but it won't change distribution.\n# This battery will be ignored in distribution anyway.\nbattery_data.capacity,\n]\nif any(map(isnan, not_replaceable_metrics)):\n_logger.debug(\"Some metrics for battery %d are NaN\", battery_id)\nreturn None\nreplaceable_metrics = [\nbattery_data.power_inclusion_lower_bound,\nbattery_data.power_inclusion_upper_bound,\ninverter_data.active_power_inclusion_lower_bound,\ninverter_data.active_power_inclusion_upper_bound,\n]\n# If all values are ok then return them.\nif not any(map(isnan, replaceable_metrics)):\ninv_bat_pair = InvBatPair(battery_data, inverter_data)\nself._cached_metrics[battery_id] = _CacheEntry.from_ttl(inv_bat_pair)\nreturn inv_bat_pair\n# Replace NaN with the corresponding value in the adjacent component.\n# If both metrics are None, return None to ignore this battery.\nreplaceable_pairs = [\n(\"power_inclusion_lower_bound\", \"active_power_inclusion_lower_bound\"),\n(\"power_inclusion_upper_bound\", \"active_power_inclusion_upper_bound\"),\n]\nbattery_new_metrics = {}\ninverter_new_metrics = {}\nfor bat_attr, inv_attr in replaceable_pairs:\nbat_bound = getattr(battery_data, bat_attr)\ninv_bound = getattr(inverter_data, inv_attr)\nif isnan(bat_bound) and isnan(inv_bound):\n_logger.debug(\"Some metrics for battery %d are NaN\", battery_id)\nreturn None\nif isnan(bat_bound):\nbattery_new_metrics[bat_attr] = inv_bound\nelif isnan(inv_bound):\ninverter_new_metrics[inv_attr] = bat_bound\ninv_bat_pair = InvBatPair(\nreplace(battery_data, **battery_new_metrics),\nreplace(inverter_data, **inverter_new_metrics),\n)\nself._cached_metrics[battery_id] = _CacheEntry.from_ttl(inv_bat_pair)\nreturn inv_bat_pair\nasync def _create_channels(self) -&gt; None:\n\"\"\"Create channels to get data of components in microgrid.\"\"\"\napi = connection_manager.get().api_client\nfor battery_id, inverter_id in self._bat_inv_map.items():\nbat_recv: Receiver[BatteryData] = await api.battery_data(battery_id)\nself._battery_receivers[battery_id] = bat_recv.into_peekable()\ninv_recv: Receiver[InverterData] = await api.inverter_data(inverter_id)\nself._inverter_receivers[inverter_id] = inv_recv.into_peekable()\ndef _parse_result(\nself,\ntasks: Dict[int, asyncio.Task[None]],\ndistribution: Dict[int, float],\nrequest_timeout: timedelta,\n) -&gt; Tuple[float, Set[int]]:\n\"\"\"Parse the results of `set_power` requests.\n        Check if any task has failed and determine the reason for failure.\n        If any task did not succeed, then the corresponding battery is marked as broken.\n        Args:\n            tasks: A dictionary where the key is the inverter ID and the value is the task that\n                set the power for this inverter. Each task should be finished or cancelled.\n            distribution: A dictionary where the key is the inverter ID and the value is how much\n                power was set to the corresponding inverter.\n            request_timeout: The timeout that was used for the request.\n        Returns:\n            A tuple where the first element is the total failed power, and the second element is\n            the set of batteries that failed.\n        \"\"\"\nfailed_power: float = 0.0\nfailed_batteries: Set[int] = set()\nfor inverter_id, aws in tasks.items():\nbattery_id = self._inv_bat_map[inverter_id]\ntry:\naws.result()\nexcept grpc.aio.AioRpcError as err:\nfailed_power += distribution[inverter_id]\nfailed_batteries.add(battery_id)\nif err.code() == grpc.StatusCode.OUT_OF_RANGE:\n_logger.debug(\n\"Set power for battery %d failed, error %s\",\nbattery_id,\nstr(err),\n)\nelse:\n_logger.warning(\n\"Set power for battery %d failed, error %s. Mark it as broken.\",\nbattery_id,\nstr(err),\n)\nexcept asyncio.exceptions.CancelledError:\nfailed_power += distribution[inverter_id]\nfailed_batteries.add(battery_id)\n_logger.warning(\n\"Battery %d didn't respond in %f sec. Mark it as broken.\",\nbattery_id,\nrequest_timeout.total_seconds(),\n)\nreturn failed_power, failed_batteries\nasync def _cancel_tasks(self, tasks: Iterable[asyncio.Task[Any]]) -&gt; None:\n\"\"\"Cancel given asyncio tasks and wait for them.\n        Args:\n            tasks: tasks to cancel.\n        \"\"\"\nfor aws in tasks:\naws.cancel()\nawait asyncio.gather(*tasks, return_exceptions=True)\nasync def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this actor.\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\nawait self._all_battery_status.stop()\nawait super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.distribution_algorithm","title":"<code>distribution_algorithm = DistributionAlgorithm(self.power_distributor_exponent)</code>  <code>instance-attribute</code>","text":"<p>The distribution algorithm used to distribute power between batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.power_distributor_exponent","title":"<code>power_distributor_exponent: float = 1.0</code>  <code>instance-attribute</code>","text":"<p>The exponent for the power distribution algorithm.</p> <p>The exponent determines how fast the batteries should strive to the equal SoC level.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.__init__","title":"<code>__init__(requests_receiver, channel_registry, battery_status_sender, wait_for_data_sec=2, *, name=None)</code>","text":"<p>Create class instance.</p> PARAMETER  DESCRIPTION <code>requests_receiver</code> <p>Receiver for receiving power requests from other actors.</p> <p> TYPE: <code>Receiver[Request]</code> </p> <code>channel_registry</code> <p>Channel registry for creating result channels dynamically for each request namespace.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>battery_status_sender</code> <p>Channel for sending information which batteries are working.</p> <p> TYPE: <code>Sender[BatteryStatus]</code> </p> <code>wait_for_data_sec</code> <p>How long actor should wait before processing first request. It is a time needed to collect first components data.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>def __init__(\nself,\nrequests_receiver: Receiver[Request],\nchannel_registry: ChannelRegistry,\nbattery_status_sender: Sender[BatteryStatus],\nwait_for_data_sec: float = 2,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create class instance.\n    Args:\n        requests_receiver: Receiver for receiving power requests from other actors.\n        channel_registry: Channel registry for creating result channels dynamically\n            for each request namespace.\n        battery_status_sender: Channel for sending information which batteries are\n            working.\n        wait_for_data_sec: How long actor should wait before processing first\n            request. It is a time needed to collect first components data.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\nsuper().__init__(name=name)\nself._requests_receiver = requests_receiver\nself._channel_registry = channel_registry\nself._wait_for_data_sec = wait_for_data_sec\nself._result_senders: Dict[str, Sender[Result]] = {}\n\"\"\"Dictionary of result senders for each request namespace.\n    They are for channels owned by the channel registry, we just hold a reference\n    to their senders, for fast access.\n    \"\"\"\n# NOTE: power_distributor_exponent should be received from ConfigManager\nself.power_distributor_exponent: float = 1.0\n\"\"\"The exponent for the power distribution algorithm.\n    The exponent determines how fast the batteries should strive to the\n    equal SoC level.\n    \"\"\"\nself.distribution_algorithm = DistributionAlgorithm(\nself.power_distributor_exponent\n)\n\"\"\"The distribution algorithm used to distribute power between batteries.\"\"\"\nself._bat_inv_map, self._inv_bat_map = self._get_components_pairs(\nconnection_manager.get().component_graph\n)\nself._battery_receivers: Dict[int, Peekable[BatteryData]] = {}\nself._inverter_receivers: Dict[int, Peekable[InverterData]] = {}\nself._all_battery_status = BatteryPoolStatus(\nbattery_ids=set(self._bat_inv_map.keys()),\nbattery_status_sender=battery_status_sender,\nmax_blocking_duration_sec=30.0,\nmax_data_age_sec=10.0,\n)\nself._cached_metrics: dict[int, _CacheEntry | None] = {\nbat_id: None for bat_id, _ in self._bat_inv_map.items()\n}\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor.stop","title":"<code>stop(msg=None)</code>  <code>async</code>","text":"<p>Stop this actor.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this actor.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nawait self._all_battery_status.stop()\nawait super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request","title":"<code>frequenz.sdk.actor.power_distributing.Request</code>  <code>dataclass</code>","text":"<p>Request to set power to the <code>PowerDistributingActor</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/request.py</code> <pre><code>@dataclasses.dataclass\nclass Request:\n\"\"\"Request to set power to the `PowerDistributingActor`.\"\"\"\nnamespace: str\n\"\"\"The namespace of the request.\n    This will be used to identify the channel for sending the response into, in the\n    channel registry.\n    \"\"\"\npower: Power\n\"\"\"The requested power.\"\"\"\nbatteries: abc.Set[int]\n\"\"\"The component ids of the batteries to be used for this request.\"\"\"\nrequest_timeout: timedelta = timedelta(seconds=5.0)\n\"\"\"The maximum amount of time to wait for the request to be fulfilled.\"\"\"\nadjust_power: bool = True\n\"\"\"Whether to adjust the power to match the bounds.\n    If `True`, the power will be adjusted (lowered) to match the bounds, so\n    only the reduced power will be set.\n    If `False` and the power is outside the batteries' bounds, the request will\n    fail and be replied to with an `OutOfBound` result.\n    \"\"\"\ninclude_broken_batteries: bool = False\n\"\"\"Whether to use all batteries included in the batteries set regardless the status.\n    If set to `True`, the power distribution algorithm will consider all batteries,\n    including the broken ones, when distributing power.  In such cases, any remaining\n    power after distributing among the available batteries will be distributed equally\n    among the unavailable (broken) batteries.  If all batteries in the set are\n    unavailable, the power will be equally distributed among all the unavailable\n    batteries in the request.\n    If set to `False`, the power distribution will only take into account the available\n    batteries, excluding any broken ones.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.adjust_power","title":"<code>adjust_power: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to adjust the power to match the bounds.</p> <p>If <code>True</code>, the power will be adjusted (lowered) to match the bounds, so only the reduced power will be set.</p> <p>If <code>False</code> and the power is outside the batteries' bounds, the request will fail and be replied to with an <code>OutOfBound</code> result.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.batteries","title":"<code>batteries: abc.Set[int]</code>  <code>instance-attribute</code>","text":"<p>The component ids of the batteries to be used for this request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.include_broken_batteries","title":"<code>include_broken_batteries: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to use all batteries included in the batteries set regardless the status.</p> <p>If set to <code>True</code>, the power distribution algorithm will consider all batteries, including the broken ones, when distributing power.  In such cases, any remaining power after distributing among the available batteries will be distributed equally among the unavailable (broken) batteries.  If all batteries in the set are unavailable, the power will be equally distributed among all the unavailable batteries in the request.</p> <p>If set to <code>False</code>, the power distribution will only take into account the available batteries, excluding any broken ones.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.namespace","title":"<code>namespace: str</code>  <code>instance-attribute</code>","text":"<p>The namespace of the request.</p> <p>This will be used to identify the channel for sending the response into, in the channel registry.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.power","title":"<code>power: Power</code>  <code>instance-attribute</code>","text":"<p>The requested power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request.request_timeout","title":"<code>request_timeout: timedelta = timedelta(seconds=5.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The maximum amount of time to wait for the request to be fulfilled.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Result","title":"<code>frequenz.sdk.actor.power_distributing.Result</code>  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseResultMixin</code></p> <p>Power distribution result.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Result(_BaseResultMixin):\n\"\"\"Power distribution result.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success","title":"<code>frequenz.sdk.actor.power_distributing.Success</code>  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>Result</code></p> <p>Result returned when setting the power succeeded for all batteries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Success(_BaseSuccessMixin, Result):  # Order matters here. See above.\n\"\"\"Result returned when setting the power succeeded for all batteries.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/","title":"power_distributing","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing","title":"<code>frequenz.sdk.actor.power_distributing.power_distributing</code>","text":"<p>Actor to distribute power between batteries.</p> <p>When charge/discharge method is called the power should be distributed so that the SoC in batteries stays at the same level. That way of distribution prevents using only one battery, increasing temperature, and maximize the total amount power to charge/discharge.</p> <p>Purpose of this actor is to keep SoC level of each component at the equal level.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor","title":"<code>frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor</code>","text":"<p>             Bases: <code>Actor</code></p> <p>Actor to distribute the power between batteries in a microgrid.</p> <p>The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time.</p> <p>For each user a bidirectional channel needs to be created through which they can send and receive requests and responses.</p> <p>It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout + time for processing the request.</p> <p>Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED.</p> <ul> <li>If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed.</li> </ul> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>class PowerDistributingActor(Actor):\n# pylint: disable=too-many-instance-attributes\n\"\"\"Actor to distribute the power between batteries in a microgrid.\n    The purpose of this tool is to keep an equal SoC level in all batteries.\n    The PowerDistributingActor can have many concurrent users which at this time\n    need to be known at construction time.\n    For each user a bidirectional channel needs to be created through which\n    they can send and receive requests and responses.\n    It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if\n    the processing function fails then the response will never come.\n    The timeout should be Result:request_timeout + time for processing the request.\n    Edge cases:\n    * If there are 2 requests to be processed for the same subset of batteries, then\n    only the latest request will be processed. Older request will be ignored. User with\n    older request will get response with Result.Status.IGNORED.\n    * If there are 2 requests and their subset of batteries is different but they\n    overlap (they have at least one common battery), then then both batteries\n    will be processed. However it is not expected so the proper error log will be\n    printed.\n    \"\"\"\ndef __init__(\nself,\nrequests_receiver: Receiver[Request],\nchannel_registry: ChannelRegistry,\nbattery_status_sender: Sender[BatteryStatus],\nwait_for_data_sec: float = 2,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create class instance.\n        Args:\n            requests_receiver: Receiver for receiving power requests from other actors.\n            channel_registry: Channel registry for creating result channels dynamically\n                for each request namespace.\n            battery_status_sender: Channel for sending information which batteries are\n                working.\n            wait_for_data_sec: How long actor should wait before processing first\n                request. It is a time needed to collect first components data.\n            name: The name of the actor. If `None`, `str(id(self))` will be used. This\n                is used mostly for debugging purposes.\n        \"\"\"\nsuper().__init__(name=name)\nself._requests_receiver = requests_receiver\nself._channel_registry = channel_registry\nself._wait_for_data_sec = wait_for_data_sec\nself._result_senders: Dict[str, Sender[Result]] = {}\n\"\"\"Dictionary of result senders for each request namespace.\n        They are for channels owned by the channel registry, we just hold a reference\n        to their senders, for fast access.\n        \"\"\"\n# NOTE: power_distributor_exponent should be received from ConfigManager\nself.power_distributor_exponent: float = 1.0\n\"\"\"The exponent for the power distribution algorithm.\n        The exponent determines how fast the batteries should strive to the\n        equal SoC level.\n        \"\"\"\nself.distribution_algorithm = DistributionAlgorithm(\nself.power_distributor_exponent\n)\n\"\"\"The distribution algorithm used to distribute power between batteries.\"\"\"\nself._bat_inv_map, self._inv_bat_map = self._get_components_pairs(\nconnection_manager.get().component_graph\n)\nself._battery_receivers: Dict[int, Peekable[BatteryData]] = {}\nself._inverter_receivers: Dict[int, Peekable[InverterData]] = {}\nself._all_battery_status = BatteryPoolStatus(\nbattery_ids=set(self._bat_inv_map.keys()),\nbattery_status_sender=battery_status_sender,\nmax_blocking_duration_sec=30.0,\nmax_data_age_sec=10.0,\n)\nself._cached_metrics: dict[int, _CacheEntry | None] = {\nbat_id: None for bat_id, _ in self._bat_inv_map.items()\n}\ndef _get_bounds(\nself,\npairs_data: list[InvBatPair],\n) -&gt; PowerBounds:\n\"\"\"Get power bounds for given batteries.\n        Args:\n            pairs_data: list of battery and adjacent inverter data pairs.\n        Returns:\n            Power bounds for given batteries.\n        \"\"\"\nreturn PowerBounds(\ninclusion_lower=sum(\nmax(\nbattery.power_inclusion_lower_bound,\ninverter.active_power_inclusion_lower_bound,\n)\nfor battery, inverter in pairs_data\n),\ninclusion_upper=sum(\nmin(\nbattery.power_inclusion_upper_bound,\ninverter.active_power_inclusion_upper_bound,\n)\nfor battery, inverter in pairs_data\n),\nexclusion_lower=sum(\nmin(\nbattery.power_exclusion_lower_bound,\ninverter.active_power_exclusion_lower_bound,\n)\nfor battery, inverter in pairs_data\n),\nexclusion_upper=sum(\nmax(\nbattery.power_exclusion_upper_bound,\ninverter.active_power_exclusion_upper_bound,\n)\nfor battery, inverter in pairs_data\n),\n)\nasync def _send_result(self, namespace: str, result: Result) -&gt; None:\n\"\"\"Send result to the user.\n        Args:\n            namespace: namespace of the sender, to identify the result channel with.\n            result: Result to send out.\n        \"\"\"\nif namespace not in self._result_senders:\nself._result_senders[namespace] = self._channel_registry.new_sender(\nnamespace\n)\nawait self._result_senders[namespace].send(result)\nasync def _run(self) -&gt; None:\n\"\"\"Run actor main function.\n        It waits for new requests in task_queue and process it, and send\n        `set_power` request with distributed power.\n        The output of the `set_power` method is processed.\n        Every battery and inverter that failed or didn't respond in time will be marked\n        as broken for some time.\n        \"\"\"\nawait self._create_channels()\napi = connection_manager.get().api_client\n# Wait few seconds to get data from the channels created above.\nawait asyncio.sleep(self._wait_for_data_sec)\nasync for request in self._requests_receiver:\ntry:\npairs_data: List[InvBatPair] = self._get_components_data(\nrequest.batteries, request.include_broken_batteries\n)\nexcept KeyError as err:\nawait self._send_result(\nrequest.namespace, Error(request=request, msg=str(err))\n)\ncontinue\nif not pairs_data and not request.include_broken_batteries:\nerror_msg = f\"No data for the given batteries {str(request.batteries)}\"\nawait self._send_result(\nrequest.namespace, Error(request=request, msg=str(error_msg))\n)\ncontinue\nerror = self._check_request(request, pairs_data)\nif error:\nawait self._send_result(request.namespace, error)\ncontinue\ntry:\ndistribution = self._get_power_distribution(request, pairs_data)\nexcept ValueError as err:\n_logger.exception(\"Couldn't distribute power\")\nerror_msg = f\"Couldn't distribute power, error: {str(err)}\"\nawait self._send_result(\nrequest.namespace, Error(request=request, msg=str(error_msg))\n)\ncontinue\ndistributed_power_value = (\nrequest.power.as_watts() - distribution.remaining_power\n)\nbattery_distribution = {\nself._inv_bat_map[bat_id]: dist\nfor bat_id, dist in distribution.distribution.items()\n}\n_logger.debug(\n\"Distributing power %d between the batteries %s\",\ndistributed_power_value,\nstr(battery_distribution),\n)\nfailed_power, failed_batteries = await self._set_distributed_power(\napi, distribution, request.request_timeout\n)\nresponse: Success | PartialFailure\nif len(failed_batteries) &gt; 0:\nsucceed_batteries = set(battery_distribution.keys()) - failed_batteries\nresponse = PartialFailure(\nrequest=request,\nsucceeded_power=Power.from_watts(distributed_power_value),\nsucceeded_batteries=succeed_batteries,\nfailed_power=Power.from_watts(failed_power),\nfailed_batteries=failed_batteries,\nexcess_power=Power.from_watts(distribution.remaining_power),\n)\nelse:\nsucceed_batteries = set(battery_distribution.keys())\nresponse = Success(\nrequest=request,\nsucceeded_power=Power.from_watts(distributed_power_value),\nsucceeded_batteries=succeed_batteries,\nexcess_power=Power.from_watts(distribution.remaining_power),\n)\nasyncio.gather(\n*[\nself._all_battery_status.update_status(\nsucceed_batteries, failed_batteries\n),\nself._send_result(request.namespace, response),\n]\n)\nasync def _set_distributed_power(\nself,\napi: MicrogridApiClient,\ndistribution: DistributionResult,\ntimeout: timedelta,\n) -&gt; Tuple[float, Set[int]]:\n\"\"\"Send distributed power to the inverters.\n        Args:\n            api: Microgrid api client\n            distribution: Distribution result\n            timeout: How long wait for the response\n        Returns:\n            Tuple where first element is total failed power, and the second element\n            set of batteries that failed.\n        \"\"\"\ntasks = {\ninverter_id: asyncio.create_task(api.set_power(inverter_id, power))\nfor inverter_id, power in distribution.distribution.items()\n}\n_, pending = await asyncio.wait(\ntasks.values(),\ntimeout=timeout.total_seconds(),\nreturn_when=ALL_COMPLETED,\n)\nawait self._cancel_tasks(pending)\nreturn self._parse_result(tasks, distribution.distribution, timeout)\ndef _get_power_distribution(\nself, request: Request, inv_bat_pairs: List[InvBatPair]\n) -&gt; DistributionResult:\n\"\"\"Get power distribution result for the batteries in the request.\n        Args:\n            request: the power request to process.\n            inv_bat_pairs: the battery and adjacent inverter data pairs.\n        Returns:\n            the power distribution result.\n        \"\"\"\navailable_bat_ids = {battery.component_id for battery, _ in inv_bat_pairs}\nunavailable_bat_ids = request.batteries - available_bat_ids\nunavailable_inv_ids = {\nself._bat_inv_map[battery_id] for battery_id in unavailable_bat_ids\n}\nif request.include_broken_batteries and not available_bat_ids:\nreturn self.distribution_algorithm.distribute_power_equally(\nrequest.power.as_watts(), unavailable_inv_ids\n)\nresult = self.distribution_algorithm.distribute_power(\nrequest.power.as_watts(), inv_bat_pairs\n)\nif request.include_broken_batteries and unavailable_inv_ids:\nadditional_result = self.distribution_algorithm.distribute_power_equally(\nresult.remaining_power, unavailable_inv_ids\n)\nfor inv_id, power in additional_result.distribution.items():\nresult.distribution[inv_id] = power\nresult.remaining_power = 0.0\nreturn result\ndef _check_request(\nself,\nrequest: Request,\npairs_data: List[InvBatPair],\n) -&gt; Optional[Result]:\n\"\"\"Check whether the given request if correct.\n        Args:\n            request: request to check\n            pairs_data: list of battery and adjacent inverter data pairs.\n        Returns:\n            Result for the user if the request is wrong, None otherwise.\n        \"\"\"\nif not request.batteries:\nreturn Error(request=request, msg=\"Empty battery IDs in the request\")\nfor battery in request.batteries:\nif battery not in self._battery_receivers:\nmsg = (\nf\"No battery {battery}, available batteries: \"\nf\"{list(self._battery_receivers.keys())}\"\n)\nreturn Error(request=request, msg=msg)\nbounds = self._get_bounds(pairs_data)\npower = request.power.as_watts()\n# Zero power requests are always forwarded to the microgrid API, even if they\n# are outside the exclusion bounds.\nif is_close_to_zero(power):\nreturn None\nif request.adjust_power:\n# Automatic power adjustments can only bring down the requested power down\n# to the inclusion bounds.\n#\n# If the requested power is in the exclusion bounds, it is NOT possible to\n# increase it so that it is outside the exclusion bounds.\nif bounds.exclusion_lower &lt; power &lt; bounds.exclusion_upper:\nreturn OutOfBounds(request=request, bounds=bounds)\nelse:\nin_lower_range = bounds.inclusion_lower &lt;= power &lt;= bounds.exclusion_lower\nin_upper_range = bounds.exclusion_upper &lt;= power &lt;= bounds.inclusion_upper\nif not (in_lower_range or in_upper_range):\nreturn OutOfBounds(request=request, bounds=bounds)\nreturn None\ndef _get_components_pairs(\nself, component_graph: ComponentGraph\n) -&gt; Tuple[Dict[int, int], Dict[int, int]]:\n\"\"\"Create maps between battery and adjacent inverter.\n        Args:\n            component_graph: component graph\n        Returns:\n            Tuple where first element is map between battery and adjacent inverter,\n                second element of the tuple is map between inverter and adjacent\n                battery.\n        \"\"\"\nbat_inv_map: Dict[int, int] = {}\ninv_bat_map: Dict[int, int] = {}\nbatteries: Iterable[Component] = component_graph.components(\ncomponent_category={ComponentCategory.BATTERY}\n)\nfor battery in batteries:\ninverters: List[Component] = [\ncomponent\nfor component in component_graph.predecessors(battery.component_id)\nif component.category == ComponentCategory.INVERTER\n]\nif len(inverters) == 0:\n_logger.error(\"No inverters for battery %d\", battery.component_id)\ncontinue\nif len(inverters) &gt; 1:\n_logger.error(\n\"Battery %d has more then one inverter. It is not supported now.\",\nbattery.component_id,\n)\nbat_inv_map[battery.component_id] = inverters[0].component_id\ninv_bat_map[inverters[0].component_id] = battery.component_id\nreturn bat_inv_map, inv_bat_map\ndef _get_components_data(\nself, batteries: abc.Set[int], include_broken: bool\n) -&gt; List[InvBatPair]:\n\"\"\"Get data for the given batteries and adjacent inverters.\n        Args:\n            batteries: Batteries that needs data.\n            include_broken: whether all batteries in the batteries set in the\n                request must be used regardless the status.\n        Raises:\n            KeyError: If any battery in the given list doesn't exists in microgrid.\n        Returns:\n            Pairs of battery and adjacent inverter data.\n        \"\"\"\npairs_data: List[InvBatPair] = []\nworking_batteries = (\nbatteries\nif include_broken\nelse self._all_battery_status.get_working_batteries(batteries)\n)\nfor battery_id in working_batteries:\nif battery_id not in self._battery_receivers:\nraise KeyError(\nf\"No battery {battery_id}, \"\nf\"available batteries: {list(self._battery_receivers.keys())}\"\n)\ninverter_id: int = self._bat_inv_map[battery_id]\ndata = self._get_battery_inverter_data(battery_id, inverter_id)\nif not data and include_broken:\ncached_entry = self._cached_metrics[battery_id]\nif cached_entry and not cached_entry.has_expired():\ndata = cached_entry.inv_bat_pair\nelse:\ndata = None\nif data is None:\n_logger.warning(\n\"Skipping battery %d because its message isn't correct.\",\nbattery_id,\n)\ncontinue\npairs_data.append(data)\nreturn pairs_data\ndef _get_battery_inverter_data(\nself, battery_id: int, inverter_id: int\n) -&gt; Optional[InvBatPair]:\n\"\"\"Get battery and inverter data if they are correct.\n        Each float data from the microgrid can be \"NaN\".\n        We can't do math operations on \"NaN\".\n        So check all the metrics and:\n        * if power bounds are NaN, then try to replace it with the corresponding\n          power bounds from the adjacent component. If metric in the adjacent component\n          is also NaN, then return None.\n        * if other metrics are NaN then return None. We can't assume anything for other\n          metrics.\n        Args:\n            battery_id: battery id\n            inverter_id: inverter id\n        Returns:\n            Data for the battery and adjacent inverter without NaN values.\n                Return None if we could not replace NaN values.\n        \"\"\"\nbattery_data = self._battery_receivers[battery_id].peek()\ninverter_data = self._inverter_receivers[inverter_id].peek()\n# It means that nothing has been send on this channels, yet.\n# This should be handled by BatteryStatus. BatteryStatus should not return\n# this batteries as working.\nif battery_data is None or inverter_data is None:\n_logger.error(\n\"Battery %d or inverter %d send no data, yet. They should be not used.\",\nbattery_id,\ninverter_id,\n)\nreturn None\nnot_replaceable_metrics = [\nbattery_data.soc,\nbattery_data.soc_lower_bound,\nbattery_data.soc_upper_bound,\n# We could replace capacity with 0, but it won't change distribution.\n# This battery will be ignored in distribution anyway.\nbattery_data.capacity,\n]\nif any(map(isnan, not_replaceable_metrics)):\n_logger.debug(\"Some metrics for battery %d are NaN\", battery_id)\nreturn None\nreplaceable_metrics = [\nbattery_data.power_inclusion_lower_bound,\nbattery_data.power_inclusion_upper_bound,\ninverter_data.active_power_inclusion_lower_bound,\ninverter_data.active_power_inclusion_upper_bound,\n]\n# If all values are ok then return them.\nif not any(map(isnan, replaceable_metrics)):\ninv_bat_pair = InvBatPair(battery_data, inverter_data)\nself._cached_metrics[battery_id] = _CacheEntry.from_ttl(inv_bat_pair)\nreturn inv_bat_pair\n# Replace NaN with the corresponding value in the adjacent component.\n# If both metrics are None, return None to ignore this battery.\nreplaceable_pairs = [\n(\"power_inclusion_lower_bound\", \"active_power_inclusion_lower_bound\"),\n(\"power_inclusion_upper_bound\", \"active_power_inclusion_upper_bound\"),\n]\nbattery_new_metrics = {}\ninverter_new_metrics = {}\nfor bat_attr, inv_attr in replaceable_pairs:\nbat_bound = getattr(battery_data, bat_attr)\ninv_bound = getattr(inverter_data, inv_attr)\nif isnan(bat_bound) and isnan(inv_bound):\n_logger.debug(\"Some metrics for battery %d are NaN\", battery_id)\nreturn None\nif isnan(bat_bound):\nbattery_new_metrics[bat_attr] = inv_bound\nelif isnan(inv_bound):\ninverter_new_metrics[inv_attr] = bat_bound\ninv_bat_pair = InvBatPair(\nreplace(battery_data, **battery_new_metrics),\nreplace(inverter_data, **inverter_new_metrics),\n)\nself._cached_metrics[battery_id] = _CacheEntry.from_ttl(inv_bat_pair)\nreturn inv_bat_pair\nasync def _create_channels(self) -&gt; None:\n\"\"\"Create channels to get data of components in microgrid.\"\"\"\napi = connection_manager.get().api_client\nfor battery_id, inverter_id in self._bat_inv_map.items():\nbat_recv: Receiver[BatteryData] = await api.battery_data(battery_id)\nself._battery_receivers[battery_id] = bat_recv.into_peekable()\ninv_recv: Receiver[InverterData] = await api.inverter_data(inverter_id)\nself._inverter_receivers[inverter_id] = inv_recv.into_peekable()\ndef _parse_result(\nself,\ntasks: Dict[int, asyncio.Task[None]],\ndistribution: Dict[int, float],\nrequest_timeout: timedelta,\n) -&gt; Tuple[float, Set[int]]:\n\"\"\"Parse the results of `set_power` requests.\n        Check if any task has failed and determine the reason for failure.\n        If any task did not succeed, then the corresponding battery is marked as broken.\n        Args:\n            tasks: A dictionary where the key is the inverter ID and the value is the task that\n                set the power for this inverter. Each task should be finished or cancelled.\n            distribution: A dictionary where the key is the inverter ID and the value is how much\n                power was set to the corresponding inverter.\n            request_timeout: The timeout that was used for the request.\n        Returns:\n            A tuple where the first element is the total failed power, and the second element is\n            the set of batteries that failed.\n        \"\"\"\nfailed_power: float = 0.0\nfailed_batteries: Set[int] = set()\nfor inverter_id, aws in tasks.items():\nbattery_id = self._inv_bat_map[inverter_id]\ntry:\naws.result()\nexcept grpc.aio.AioRpcError as err:\nfailed_power += distribution[inverter_id]\nfailed_batteries.add(battery_id)\nif err.code() == grpc.StatusCode.OUT_OF_RANGE:\n_logger.debug(\n\"Set power for battery %d failed, error %s\",\nbattery_id,\nstr(err),\n)\nelse:\n_logger.warning(\n\"Set power for battery %d failed, error %s. Mark it as broken.\",\nbattery_id,\nstr(err),\n)\nexcept asyncio.exceptions.CancelledError:\nfailed_power += distribution[inverter_id]\nfailed_batteries.add(battery_id)\n_logger.warning(\n\"Battery %d didn't respond in %f sec. Mark it as broken.\",\nbattery_id,\nrequest_timeout.total_seconds(),\n)\nreturn failed_power, failed_batteries\nasync def _cancel_tasks(self, tasks: Iterable[asyncio.Task[Any]]) -&gt; None:\n\"\"\"Cancel given asyncio tasks and wait for them.\n        Args:\n            tasks: tasks to cancel.\n        \"\"\"\nfor aws in tasks:\naws.cancel()\nawait asyncio.gather(*tasks, return_exceptions=True)\nasync def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this actor.\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\nawait self._all_battery_status.stop()\nawait super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.distribution_algorithm","title":"<code>distribution_algorithm = DistributionAlgorithm(self.power_distributor_exponent)</code>  <code>instance-attribute</code>","text":"<p>The distribution algorithm used to distribute power between batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.power_distributor_exponent","title":"<code>power_distributor_exponent: float = 1.0</code>  <code>instance-attribute</code>","text":"<p>The exponent for the power distribution algorithm.</p> <p>The exponent determines how fast the batteries should strive to the equal SoC level.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__init__","title":"<code>__init__(requests_receiver, channel_registry, battery_status_sender, wait_for_data_sec=2, *, name=None)</code>","text":"<p>Create class instance.</p> PARAMETER  DESCRIPTION <code>requests_receiver</code> <p>Receiver for receiving power requests from other actors.</p> <p> TYPE: <code>Receiver[Request]</code> </p> <code>channel_registry</code> <p>Channel registry for creating result channels dynamically for each request namespace.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>battery_status_sender</code> <p>Channel for sending information which batteries are working.</p> <p> TYPE: <code>Sender[BatteryStatus]</code> </p> <code>wait_for_data_sec</code> <p>How long actor should wait before processing first request. It is a time needed to collect first components data.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2</code> </p> <code>name</code> <p>The name of the actor. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>def __init__(\nself,\nrequests_receiver: Receiver[Request],\nchannel_registry: ChannelRegistry,\nbattery_status_sender: Sender[BatteryStatus],\nwait_for_data_sec: float = 2,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"Create class instance.\n    Args:\n        requests_receiver: Receiver for receiving power requests from other actors.\n        channel_registry: Channel registry for creating result channels dynamically\n            for each request namespace.\n        battery_status_sender: Channel for sending information which batteries are\n            working.\n        wait_for_data_sec: How long actor should wait before processing first\n            request. It is a time needed to collect first components data.\n        name: The name of the actor. If `None`, `str(id(self))` will be used. This\n            is used mostly for debugging purposes.\n    \"\"\"\nsuper().__init__(name=name)\nself._requests_receiver = requests_receiver\nself._channel_registry = channel_registry\nself._wait_for_data_sec = wait_for_data_sec\nself._result_senders: Dict[str, Sender[Result]] = {}\n\"\"\"Dictionary of result senders for each request namespace.\n    They are for channels owned by the channel registry, we just hold a reference\n    to their senders, for fast access.\n    \"\"\"\n# NOTE: power_distributor_exponent should be received from ConfigManager\nself.power_distributor_exponent: float = 1.0\n\"\"\"The exponent for the power distribution algorithm.\n    The exponent determines how fast the batteries should strive to the\n    equal SoC level.\n    \"\"\"\nself.distribution_algorithm = DistributionAlgorithm(\nself.power_distributor_exponent\n)\n\"\"\"The distribution algorithm used to distribute power between batteries.\"\"\"\nself._bat_inv_map, self._inv_bat_map = self._get_components_pairs(\nconnection_manager.get().component_graph\n)\nself._battery_receivers: Dict[int, Peekable[BatteryData]] = {}\nself._inverter_receivers: Dict[int, Peekable[InverterData]] = {}\nself._all_battery_status = BatteryPoolStatus(\nbattery_ids=set(self._bat_inv_map.keys()),\nbattery_status_sender=battery_status_sender,\nmax_blocking_duration_sec=30.0,\nmax_data_age_sec=10.0,\n)\nself._cached_metrics: dict[int, _CacheEntry | None] = {\nbat_id: None for bat_id, _ in self._bat_inv_map.items()\n}\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.stop","title":"<code>stop(msg=None)</code>  <code>async</code>","text":"<p>Stop this actor.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n\"\"\"Stop this actor.\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\nawait self._all_battery_status.stop()\nawait super().stop(msg)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/","title":"request","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request","title":"<code>frequenz.sdk.actor.power_distributing.request</code>","text":"<p>Definition of the user request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request","title":"<code>frequenz.sdk.actor.power_distributing.request.Request</code>  <code>dataclass</code>","text":"<p>Request to set power to the <code>PowerDistributingActor</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/request.py</code> <pre><code>@dataclasses.dataclass\nclass Request:\n\"\"\"Request to set power to the `PowerDistributingActor`.\"\"\"\nnamespace: str\n\"\"\"The namespace of the request.\n    This will be used to identify the channel for sending the response into, in the\n    channel registry.\n    \"\"\"\npower: Power\n\"\"\"The requested power.\"\"\"\nbatteries: abc.Set[int]\n\"\"\"The component ids of the batteries to be used for this request.\"\"\"\nrequest_timeout: timedelta = timedelta(seconds=5.0)\n\"\"\"The maximum amount of time to wait for the request to be fulfilled.\"\"\"\nadjust_power: bool = True\n\"\"\"Whether to adjust the power to match the bounds.\n    If `True`, the power will be adjusted (lowered) to match the bounds, so\n    only the reduced power will be set.\n    If `False` and the power is outside the batteries' bounds, the request will\n    fail and be replied to with an `OutOfBound` result.\n    \"\"\"\ninclude_broken_batteries: bool = False\n\"\"\"Whether to use all batteries included in the batteries set regardless the status.\n    If set to `True`, the power distribution algorithm will consider all batteries,\n    including the broken ones, when distributing power.  In such cases, any remaining\n    power after distributing among the available batteries will be distributed equally\n    among the unavailable (broken) batteries.  If all batteries in the set are\n    unavailable, the power will be equally distributed among all the unavailable\n    batteries in the request.\n    If set to `False`, the power distribution will only take into account the available\n    batteries, excluding any broken ones.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.adjust_power","title":"<code>adjust_power: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to adjust the power to match the bounds.</p> <p>If <code>True</code>, the power will be adjusted (lowered) to match the bounds, so only the reduced power will be set.</p> <p>If <code>False</code> and the power is outside the batteries' bounds, the request will fail and be replied to with an <code>OutOfBound</code> result.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.batteries","title":"<code>batteries: abc.Set[int]</code>  <code>instance-attribute</code>","text":"<p>The component ids of the batteries to be used for this request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.include_broken_batteries","title":"<code>include_broken_batteries: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to use all batteries included in the batteries set regardless the status.</p> <p>If set to <code>True</code>, the power distribution algorithm will consider all batteries, including the broken ones, when distributing power.  In such cases, any remaining power after distributing among the available batteries will be distributed equally among the unavailable (broken) batteries.  If all batteries in the set are unavailable, the power will be equally distributed among all the unavailable batteries in the request.</p> <p>If set to <code>False</code>, the power distribution will only take into account the available batteries, excluding any broken ones.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.namespace","title":"<code>namespace: str</code>  <code>instance-attribute</code>","text":"<p>The namespace of the request.</p> <p>This will be used to identify the channel for sending the response into, in the channel registry.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.power","title":"<code>power: Power</code>  <code>instance-attribute</code>","text":"<p>The requested power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.request_timeout","title":"<code>request_timeout: timedelta = timedelta(seconds=5.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The maximum amount of time to wait for the request to be fulfilled.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/","title":"result","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result","title":"<code>frequenz.sdk.actor.power_distributing.result</code>","text":"<p>Results from PowerDistributingActor.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error","title":"<code>frequenz.sdk.actor.power_distributing.result.Error</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Result</code></p> <p>Result returned when an error occurred and power was not set at all.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Error(Result):\n\"\"\"Result returned when an error occurred and power was not set at all.\"\"\"\nmsg: str\n\"\"\"The error message explaining why error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error.msg","title":"<code>msg: str</code>  <code>instance-attribute</code>","text":"<p>The error message explaining why error happened.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds","title":"<code>frequenz.sdk.actor.power_distributing.result.OutOfBounds</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Result</code></p> <p>Result returned when the power was not set because it was out of bounds.</p> <p>This result happens when the originating request was done with <code>adjust_power = False</code> and the requested power is not within the batteries bounds.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass OutOfBounds(Result):\n\"\"\"Result returned when the power was not set because it was out of bounds.\n    This result happens when the originating request was done with\n    `adjust_power = False` and the requested power is not within the batteries bounds.\n    \"\"\"\nbounds: PowerBounds\n\"\"\"The power bounds for the requested batteries.\n    If the requested power negative, then this value is the lower bound.\n    Otherwise it is upper bound.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBounds.bounds","title":"<code>bounds: PowerBounds</code>  <code>instance-attribute</code>","text":"<p>The power bounds for the requested batteries.</p> <p>If the requested power negative, then this value is the lower bound. Otherwise it is upper bound.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure","title":"<code>frequenz.sdk.actor.power_distributing.result.PartialFailure</code>  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>Result</code></p> <p>Result returned when any battery failed to perform the request.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PartialFailure(_BaseSuccessMixin, Result):\n\"\"\"Result returned when any battery failed to perform the request.\"\"\"\nfailed_power: Power\n\"\"\"The part of the requested power that failed to be set.\"\"\"\nfailed_batteries: set[int]\n\"\"\"The subset of batteries for which the request failed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_batteries","title":"<code>failed_batteries: set[int]</code>  <code>instance-attribute</code>","text":"<p>The subset of batteries for which the request failed.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_power","title":"<code>failed_power: Power</code>  <code>instance-attribute</code>","text":"<p>The part of the requested power that failed to be set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds","title":"<code>frequenz.sdk.actor.power_distributing.result.PowerBounds</code>  <code>dataclass</code>","text":"<p>Inclusion and exclusion power bounds for requested batteries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PowerBounds:\n\"\"\"Inclusion and exclusion power bounds for requested batteries.\"\"\"\ninclusion_lower: float\n\"\"\"The lower value of the inclusion power bounds for the requested batteries.\"\"\"\nexclusion_lower: float\n\"\"\"The lower value of the exclusion power bounds for the requested batteries.\"\"\"\nexclusion_upper: float\n\"\"\"The upper value of the exclusion power bounds for the requested batteries.\"\"\"\ninclusion_upper: float\n\"\"\"The upper value of the inclusion power bounds for the requested batteries.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.exclusion_lower","title":"<code>exclusion_lower: float</code>  <code>instance-attribute</code>","text":"<p>The lower value of the exclusion power bounds for the requested batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.exclusion_upper","title":"<code>exclusion_upper: float</code>  <code>instance-attribute</code>","text":"<p>The upper value of the exclusion power bounds for the requested batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.inclusion_lower","title":"<code>inclusion_lower: float</code>  <code>instance-attribute</code>","text":"<p>The lower value of the inclusion power bounds for the requested batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PowerBounds.inclusion_upper","title":"<code>inclusion_upper: float</code>  <code>instance-attribute</code>","text":"<p>The upper value of the inclusion power bounds for the requested batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Result","title":"<code>frequenz.sdk.actor.power_distributing.result.Result</code>  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseResultMixin</code></p> <p>Power distribution result.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Result(_BaseResultMixin):\n\"\"\"Power distribution result.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success","title":"<code>frequenz.sdk.actor.power_distributing.result.Success</code>  <code>dataclass</code>","text":"<p>             Bases: <code>_BaseSuccessMixin</code>, <code>Result</code></p> <p>Result returned when setting the power succeeded for all batteries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Success(_BaseSuccessMixin, Result):  # Order matters here. See above.\n\"\"\"Result returned when setting the power succeeded for all batteries.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/config/","title":"config","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config","title":"<code>frequenz.sdk.config</code>","text":"<p>Config interface.</p>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config","title":"<code>frequenz.sdk.config.Config</code>","text":"<p>Stores config variables.</p> <p>Config variables are read from a file. Only single file can be read. If new file is read, then previous configs will be forgotten.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>class Config:\n\"\"\"\n    Stores config variables.\n    Config variables are read from a file.\n    Only single file can be read.\n    If new file is read, then previous configs will be forgotten.\n    \"\"\"\ndef __init__(self, conf_vars: Dict[str, Any]):\n\"\"\"Instantiate the config store and read config variables from the file.\n        Args:\n            conf_vars: Dict containing configuration variables\n        \"\"\"\nself._conf_store: Dict[str, Any] = conf_vars\ndef get(self, key: str, default: Any = None) -&gt; Any:\n\"\"\"Get the value for the specified key.\n        If the key is not in the configs, then return default.\n        Args:\n            key: Key to be searched.\n            default: Value to be returned if the key is not found.  Defaults to\n                None.\n        Returns:\n            value in str format or default.\n        \"\"\"\nreturn self._conf_store.get(key, default)\ndef get_dict(\nself, key_prefix: str, expected_values_type: Optional[T]\n) -&gt; Dict[str, Any]:\n\"\"\"Get a dictionary based on config key prefixes.\n        For example, if key_prefix is \"my_dict\", then the following config store:\n            {\n                'some_key': 'some_value',\n                'my_dict_key1': 'value1',\n                'my_dict_key2': 'value2',\n            }\n        Will return:\n            {\n                'key1': 'value1',\n                'key2': 'value2',\n            }\n        Args:\n            key_prefix: Only get configuration variables starting with this\n                prefix.\n            expected_values_type: If provided, the value will be validated against\n                this type.\n        Returns:\n            A dictionary containing the keys prefixed with `key_prefix` as keys\n                (but with the prefix removed) and the values as values.\n        \"\"\"\nresult: Dict[str, Any] = {}\nfor key, value in self._conf_store.items():\nif key.startswith(key_prefix):\nnew_key = key[len(key_prefix) :]\nif expected_values_type is not None:\nvalue = self.get_as(key, expected_values_type)\nresult[new_key] = value\nreturn result\ndef get_as(self, key: str, expected_type: Any) -&gt; Any:\n\"\"\"Get and convert the value to specified type.\n        Check if type of the value is as expected.  If type is correct, then\n        return converted value.  Otherwise Raise ValueError.\n        Type can be:\n            * Any typing module type.\n            * Any pydantic strict types (e.g. pydantic.StrictInt)\n        Args:\n            key: Key to be search\n            expected_type: type for the value\n        Raises:\n            ValueError: If can't convert value to the expected type.\n            KeyError: If specified key is not in config.\n        Returns:\n            Value for the specified key, converted to specified type.\n        Example:\n            For `var1='[1, 2.0, 3.5]'`:\n                * `get_as(\"var1\", List[int])` -&gt; `[1,2,3]`\n                * `get_as(\"var1\", List[float])` -&gt; `[1.0,2.0,3.5]`\n                * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; [ValueError][]\n                * `get_as(\"var1\", List[pydantic.StrictFloat])` -&gt; [ValueError][]\n            For `var1='[1,2,3]'`:\n                * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; `[1,2,3]`\n        \"\"\"\nvalue = self[key]\nif str is expected_type:\nreturn value\ntry:\nparsed_value: Any = parse_raw_as(expected_type, value)\nexcept (ValidationError, ValueError) as err:\nraise ValueError(\nf\"Could not convert config variable: {key} = '{value}' \"\nf\"to type {str(expected_type)}, err:\" + str(err)\n) from err\nreturn parsed_value\ndef __getitem__(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified key.\n        If the key is not in the configs, then raise KeyError.\n        Args:\n            key: key to be searched.\n        Raises:\n            KeyError: If key is not in found.\n        Returns:\n            Dictionary if the corresponding value is a subsection in the .toml\n                file or a primitive type it is a simple value.\n        \"\"\"\nvalue = self._conf_store.get(key, None)\nif value is None:\nraise KeyError(f\"Unknown config name {key}\")\nreturn value\ndef __contains__(self, key: str) -&gt; bool:\n\"\"\"Return whether the specified key is in the storage.\n        Args:\n            key: Config variable name.\n        Returns:\n            True if key is in the storage, otherwise returns False.\n        \"\"\"\nreturn key in self._conf_store\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Return whether the specified key is in the storage.</p> PARAMETER  DESCRIPTION <code>key</code> <p>Config variable name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if key is in the storage, otherwise returns False.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n\"\"\"Return whether the specified key is in the storage.\n    Args:\n        key: Config variable name.\n    Returns:\n        True if key is in the storage, otherwise returns False.\n    \"\"\"\nreturn key in self._conf_store\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get the value for the specified key.</p> <p>If the key is not in the configs, then raise KeyError.</p> PARAMETER  DESCRIPTION <code>key</code> <p>key to be searched.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If key is not in found.</p> RETURNS DESCRIPTION <code>Any</code> <p>Dictionary if the corresponding value is a subsection in the .toml file or a primitive type it is a simple value.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified key.\n    If the key is not in the configs, then raise KeyError.\n    Args:\n        key: key to be searched.\n    Raises:\n        KeyError: If key is not in found.\n    Returns:\n        Dictionary if the corresponding value is a subsection in the .toml\n            file or a primitive type it is a simple value.\n    \"\"\"\nvalue = self._conf_store.get(key, None)\nif value is None:\nraise KeyError(f\"Unknown config name {key}\")\nreturn value\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.__init__","title":"<code>__init__(conf_vars)</code>","text":"<p>Instantiate the config store and read config variables from the file.</p> PARAMETER  DESCRIPTION <code>conf_vars</code> <p>Dict containing configuration variables</p> <p> TYPE: <code>Dict[str, Any]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def __init__(self, conf_vars: Dict[str, Any]):\n\"\"\"Instantiate the config store and read config variables from the file.\n    Args:\n        conf_vars: Dict containing configuration variables\n    \"\"\"\nself._conf_store: Dict[str, Any] = conf_vars\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.get","title":"<code>get(key, default=None)</code>","text":"<p>Get the value for the specified key.</p> <p>If the key is not in the configs, then return default.</p> PARAMETER  DESCRIPTION <code>key</code> <p>Key to be searched.</p> <p> TYPE: <code>str</code> </p> <code>default</code> <p>Value to be returned if the key is not found.  Defaults to None.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>value in str format or default.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n\"\"\"Get the value for the specified key.\n    If the key is not in the configs, then return default.\n    Args:\n        key: Key to be searched.\n        default: Value to be returned if the key is not found.  Defaults to\n            None.\n    Returns:\n        value in str format or default.\n    \"\"\"\nreturn self._conf_store.get(key, default)\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.get_as","title":"<code>get_as(key, expected_type)</code>","text":"<p>Get and convert the value to specified type.</p> <p>Check if type of the value is as expected.  If type is correct, then return converted value.  Otherwise Raise ValueError.</p> Type can be <ul> <li>Any typing module type.</li> <li>Any pydantic strict types (e.g. pydantic.StrictInt)</li> </ul> PARAMETER  DESCRIPTION <code>key</code> <p>Key to be search</p> <p> TYPE: <code>str</code> </p> <code>expected_type</code> <p>type for the value</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If can't convert value to the expected type.</p> <code>KeyError</code> <p>If specified key is not in config.</p> RETURNS DESCRIPTION <code>Any</code> <p>Value for the specified key, converted to specified type.</p> Example <p>For <code>var1='[1, 2.0, 3.5]'</code>:     * <code>get_as(\"var1\", List[int])</code> -&gt; <code>[1,2,3]</code>     * <code>get_as(\"var1\", List[float])</code> -&gt; <code>[1.0,2.0,3.5]</code>     * <code>get_as(\"var1\", List[pydantic.StrictInt])</code> -&gt; ValueError     * <code>get_as(\"var1\", List[pydantic.StrictFloat])</code> -&gt; ValueError</p> <p>For <code>var1='[1,2,3]'</code>:     * <code>get_as(\"var1\", List[pydantic.StrictInt])</code> -&gt; <code>[1,2,3]</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def get_as(self, key: str, expected_type: Any) -&gt; Any:\n\"\"\"Get and convert the value to specified type.\n    Check if type of the value is as expected.  If type is correct, then\n    return converted value.  Otherwise Raise ValueError.\n    Type can be:\n        * Any typing module type.\n        * Any pydantic strict types (e.g. pydantic.StrictInt)\n    Args:\n        key: Key to be search\n        expected_type: type for the value\n    Raises:\n        ValueError: If can't convert value to the expected type.\n        KeyError: If specified key is not in config.\n    Returns:\n        Value for the specified key, converted to specified type.\n    Example:\n        For `var1='[1, 2.0, 3.5]'`:\n            * `get_as(\"var1\", List[int])` -&gt; `[1,2,3]`\n            * `get_as(\"var1\", List[float])` -&gt; `[1.0,2.0,3.5]`\n            * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; [ValueError][]\n            * `get_as(\"var1\", List[pydantic.StrictFloat])` -&gt; [ValueError][]\n        For `var1='[1,2,3]'`:\n            * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; `[1,2,3]`\n    \"\"\"\nvalue = self[key]\nif str is expected_type:\nreturn value\ntry:\nparsed_value: Any = parse_raw_as(expected_type, value)\nexcept (ValidationError, ValueError) as err:\nraise ValueError(\nf\"Could not convert config variable: {key} = '{value}' \"\nf\"to type {str(expected_type)}, err:\" + str(err)\n) from err\nreturn parsed_value\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config.get_dict","title":"<code>get_dict(key_prefix, expected_values_type)</code>","text":"<p>Get a dictionary based on config key prefixes.</p> <p>For example, if key_prefix is \"my_dict\", then the following config store:     {         'some_key': 'some_value',         'my_dict_key1': 'value1',         'my_dict_key2': 'value2',     } Will return:     {         'key1': 'value1',         'key2': 'value2',     }</p> PARAMETER  DESCRIPTION <code>key_prefix</code> <p>Only get configuration variables starting with this prefix.</p> <p> TYPE: <code>str</code> </p> <code>expected_values_type</code> <p>If provided, the value will be validated against this type.</p> <p> TYPE: <code>Optional[T]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>A dictionary containing the keys prefixed with <code>key_prefix</code> as keys (but with the prefix removed) and the values as values.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def get_dict(\nself, key_prefix: str, expected_values_type: Optional[T]\n) -&gt; Dict[str, Any]:\n\"\"\"Get a dictionary based on config key prefixes.\n    For example, if key_prefix is \"my_dict\", then the following config store:\n        {\n            'some_key': 'some_value',\n            'my_dict_key1': 'value1',\n            'my_dict_key2': 'value2',\n        }\n    Will return:\n        {\n            'key1': 'value1',\n            'key2': 'value2',\n        }\n    Args:\n        key_prefix: Only get configuration variables starting with this\n            prefix.\n        expected_values_type: If provided, the value will be validated against\n            this type.\n    Returns:\n        A dictionary containing the keys prefixed with `key_prefix` as keys\n            (but with the prefix removed) and the values as values.\n    \"\"\"\nresult: Dict[str, Any] = {}\nfor key, value in self._conf_store.items():\nif key.startswith(key_prefix):\nnew_key = key[len(key_prefix) :]\nif expected_values_type is not None:\nvalue = self.get_as(key, expected_values_type)\nresult[new_key] = value\nreturn result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/","title":"microgrid","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid","title":"<code>frequenz.sdk.microgrid</code>","text":"<p>Microgrid monitoring and control system.</p> <p>This package provides a complete suite of data structures and functionality for monitoring and adjusting the state of a microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph","title":"<code>frequenz.sdk.microgrid.ComponentGraph</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Interface for component graph implementations.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>class ComponentGraph(ABC):\n\"\"\"Interface for component graph implementations.\"\"\"\n@abstractmethod\ndef components(\nself,\ncomponent_id: Optional[Set[int]] = None,\ncomponent_category: Optional[Set[ComponentCategory]] = None,\n) -&gt; Set[Component]:\n\"\"\"Fetch the components of the microgrid.\n        Args:\n            component_id: filter out any components not matching one of the provided IDs\n            component_category: filter out any components not matching one of the\n                provided types\n        Returns:\n            Set of the components currently connected to the microgrid, filtered by\n                the provided `component_id` and `component_category` values.\n        \"\"\"\n@abstractmethod\ndef connections(\nself,\nstart: Optional[Set[int]] = None,\nend: Optional[Set[int]] = None,\n) -&gt; Set[Connection]:\n\"\"\"Fetch the connections between microgrid components.\n        Args:\n            start: filter out any connections whose `start` does not match one of these\n                component IDs\n            end: filter out any connections whose `end` does not match one of these\n                component IDs\n        Returns:\n            Set of the connections between components in the microgrid, filtered by\n                the provided `start`/`end` choices.\n        \"\"\"\n@abstractmethod\ndef predecessors(self, component_id: int) -&gt; Set[Component]:\n\"\"\"Fetch the graph predecessors of the specified component.\n        Args:\n            component_id: numerical ID of the component whose predecessors should be\n                fetched\n        Returns:\n            Set of IDs of the components that are predecessors of `component_id`,\n                i.e. for which there is a connection from each of these components to\n                `component_id`.\n        Raises:\n            KeyError: if the specified `component_id` is not in the graph\n        \"\"\"\n@abstractmethod\ndef successors(self, component_id: int) -&gt; Set[Component]:\n\"\"\"Fetch the graph successors of the specified component.\n        Args:\n            component_id: numerical ID of the component whose successors should be\n                fetched\n        Returns:\n            Set of IDs of the components that are successors of `component_id`,\n                i.e. for which there is a connection from `component_id` to each of\n                these components.\n        Raises:\n            KeyError: if the specified `component_id` is not in the graph\n        \"\"\"\n@abstractmethod\ndef is_pv_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV inverter.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a PV inverter.\n        \"\"\"\n@abstractmethod\ndef is_pv_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV meter.\n        This is done by checking if the component has only PV inverters as its\n        successors.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a PV meter.\n        \"\"\"\n@abstractmethod\ndef is_pv_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a PV chain.\n        A component is part of a PV chain if it is a PV meter or a PV inverter.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is part of a PV chain.\n        \"\"\"\n@abstractmethod\ndef is_battery_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery inverter.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a battery inverter.\n        \"\"\"\n@abstractmethod\ndef is_battery_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery meter.\n        This is done by checking if the component has only battery inverters as its\n        predecessors.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a battery meter.\n        \"\"\"\n@abstractmethod\ndef is_battery_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a battery chain.\n        A component is part of a battery chain if it is a battery meter or a battery\n        inverter.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is part of a battery chain.\n        \"\"\"\n@abstractmethod\ndef is_ev_charger(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is an EV charger.\n        \"\"\"\n@abstractmethod\ndef is_ev_charger_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger meter.\n        This is done by checking if the component has only EV chargers as its\n        successors.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is an EV charger meter.\n        \"\"\"\n@abstractmethod\ndef is_ev_charger_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of an EV charger chain.\n        A component is part of an EV charger chain if it is an EV charger meter or an\n        EV charger.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is part of an EV charger chain.\n        \"\"\"\n@abstractmethod\ndef is_chp(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a CHP.\n        \"\"\"\n@abstractmethod\ndef is_chp_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP meter.\n        This is done by checking if the component has only CHPs as its successors.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is a CHP meter.\n        \"\"\"\n@abstractmethod\ndef is_chp_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a CHP chain.\n        A component is part of a CHP chain if it is a CHP meter or a CHP.\n        Args:\n            component: component to check.\n        Returns:\n            Whether the specified component is part of a CHP chain.\n        \"\"\"\n@abstractmethod\ndef dfs(\nself,\ncurrent_node: Component,\nvisited: Set[Component],\ncondition: Callable[[Component], bool],\n) -&gt; Set[Component]:\n\"\"\"\n        Search for components that fulfill the condition in the Graph.\n        DFS is used for searching the graph. The graph traversal is stopped\n        once a component fulfills the condition.\n        Args:\n            current_node: The current node to search from.\n            visited: The set of visited nodes.\n            condition: The condition function to check for.\n        Returns:\n            A set of component ids where the corresponding components fulfill\n            the condition function.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.components","title":"<code>components(component_id=None, component_category=None)</code>  <code>abstractmethod</code>","text":"<p>Fetch the components of the microgrid.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>filter out any components not matching one of the provided IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> <code>component_category</code> <p>filter out any components not matching one of the provided types</p> <p> TYPE: <code>Optional[Set[ComponentCategory]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Set[Component]</code> <p>Set of the components currently connected to the microgrid, filtered by the provided <code>component_id</code> and <code>component_category</code> values.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef components(\nself,\ncomponent_id: Optional[Set[int]] = None,\ncomponent_category: Optional[Set[ComponentCategory]] = None,\n) -&gt; Set[Component]:\n\"\"\"Fetch the components of the microgrid.\n    Args:\n        component_id: filter out any components not matching one of the provided IDs\n        component_category: filter out any components not matching one of the\n            provided types\n    Returns:\n        Set of the components currently connected to the microgrid, filtered by\n            the provided `component_id` and `component_category` values.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.connections","title":"<code>connections(start=None, end=None)</code>  <code>abstractmethod</code>","text":"<p>Fetch the connections between microgrid components.</p> PARAMETER  DESCRIPTION <code>start</code> <p>filter out any connections whose <code>start</code> does not match one of these component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> <code>end</code> <p>filter out any connections whose <code>end</code> does not match one of these component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Set[Connection]</code> <p>Set of the connections between components in the microgrid, filtered by the provided <code>start</code>/<code>end</code> choices.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef connections(\nself,\nstart: Optional[Set[int]] = None,\nend: Optional[Set[int]] = None,\n) -&gt; Set[Connection]:\n\"\"\"Fetch the connections between microgrid components.\n    Args:\n        start: filter out any connections whose `start` does not match one of these\n            component IDs\n        end: filter out any connections whose `end` does not match one of these\n            component IDs\n    Returns:\n        Set of the connections between components in the microgrid, filtered by\n            the provided `start`/`end` choices.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.dfs","title":"<code>dfs(current_node, visited, condition)</code>  <code>abstractmethod</code>","text":"<p>Search for components that fulfill the condition in the Graph.</p> <p>DFS is used for searching the graph. The graph traversal is stopped once a component fulfills the condition.</p> PARAMETER  DESCRIPTION <code>current_node</code> <p>The current node to search from.</p> <p> TYPE: <code>Component</code> </p> <code>visited</code> <p>The set of visited nodes.</p> <p> TYPE: <code>Set[Component]</code> </p> <code>condition</code> <p>The condition function to check for.</p> <p> TYPE: <code>Callable[[Component], bool]</code> </p> RETURNS DESCRIPTION <code>Set[Component]</code> <p>A set of component ids where the corresponding components fulfill</p> <code>Set[Component]</code> <p>the condition function.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef dfs(\nself,\ncurrent_node: Component,\nvisited: Set[Component],\ncondition: Callable[[Component], bool],\n) -&gt; Set[Component]:\n\"\"\"\n    Search for components that fulfill the condition in the Graph.\n    DFS is used for searching the graph. The graph traversal is stopped\n    once a component fulfills the condition.\n    Args:\n        current_node: The current node to search from.\n        visited: The set of visited nodes.\n        condition: The condition function to check for.\n    Returns:\n        A set of component ids where the corresponding components fulfill\n        the condition function.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_battery_chain","title":"<code>is_battery_chain(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is part of a battery chain.</p> <p>A component is part of a battery chain if it is a battery meter or a battery inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a battery chain.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a battery chain.\n    A component is part of a battery chain if it is a battery meter or a battery\n    inverter.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is part of a battery chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_battery_inverter","title":"<code>is_battery_inverter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a battery inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a battery inverter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery inverter.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a battery inverter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_battery_meter","title":"<code>is_battery_meter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a battery meter.</p> <p>This is done by checking if the component has only battery inverters as its predecessors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a battery meter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery meter.\n    This is done by checking if the component has only battery inverters as its\n    predecessors.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a battery meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_chp","title":"<code>is_chp(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a CHP.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a CHP.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_chp(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a CHP.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_chp_chain","title":"<code>is_chp_chain(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is part of a CHP chain.</p> <p>A component is part of a CHP chain if it is a CHP meter or a CHP.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a CHP chain.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_chp_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a CHP chain.\n    A component is part of a CHP chain if it is a CHP meter or a CHP.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is part of a CHP chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_chp_meter","title":"<code>is_chp_meter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a CHP meter.</p> <p>This is done by checking if the component has only CHPs as its successors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a CHP meter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_chp_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP meter.\n    This is done by checking if the component has only CHPs as its successors.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a CHP meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_ev_charger","title":"<code>is_ev_charger(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is an EV charger.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is an EV charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is an EV charger.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_ev_charger_chain","title":"<code>is_ev_charger_chain(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is part of an EV charger chain.</p> <p>A component is part of an EV charger chain if it is an EV charger meter or an EV charger.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of an EV charger chain.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of an EV charger chain.\n    A component is part of an EV charger chain if it is an EV charger meter or an\n    EV charger.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is part of an EV charger chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_ev_charger_meter","title":"<code>is_ev_charger_meter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is an EV charger meter.</p> <p>This is done by checking if the component has only EV chargers as its successors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is an EV charger meter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger meter.\n    This is done by checking if the component has only EV chargers as its\n    successors.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is an EV charger meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_pv_chain","title":"<code>is_pv_chain(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is part of a PV chain.</p> <p>A component is part of a PV chain if it is a PV meter or a PV inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a PV chain.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a PV chain.\n    A component is part of a PV chain if it is a PV meter or a PV inverter.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is part of a PV chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_pv_inverter","title":"<code>is_pv_inverter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a PV inverter.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a PV inverter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV inverter.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a PV inverter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.is_pv_meter","title":"<code>is_pv_meter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a PV meter.</p> <p>This is done by checking if the component has only PV inverters as its successors.</p> PARAMETER  DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a PV meter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV meter.\n    This is done by checking if the component has only PV inverters as its\n    successors.\n    Args:\n        component: component to check.\n    Returns:\n        Whether the specified component is a PV meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.predecessors","title":"<code>predecessors(component_id)</code>  <code>abstractmethod</code>","text":"<p>Fetch the graph predecessors of the specified component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>numerical ID of the component whose predecessors should be fetched</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Set[Component]</code> <p>Set of IDs of the components that are predecessors of <code>component_id</code>, i.e. for which there is a connection from each of these components to <code>component_id</code>.</p> RAISES DESCRIPTION <code>KeyError</code> <p>if the specified <code>component_id</code> is not in the graph</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef predecessors(self, component_id: int) -&gt; Set[Component]:\n\"\"\"Fetch the graph predecessors of the specified component.\n    Args:\n        component_id: numerical ID of the component whose predecessors should be\n            fetched\n    Returns:\n        Set of IDs of the components that are predecessors of `component_id`,\n            i.e. for which there is a connection from each of these components to\n            `component_id`.\n    Raises:\n        KeyError: if the specified `component_id` is not in the graph\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph.successors","title":"<code>successors(component_id)</code>  <code>abstractmethod</code>","text":"<p>Fetch the graph successors of the specified component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>numerical ID of the component whose successors should be fetched</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Set[Component]</code> <p>Set of IDs of the components that are successors of <code>component_id</code>, i.e. for which there is a connection from <code>component_id</code> to each of these components.</p> RAISES DESCRIPTION <code>KeyError</code> <p>if the specified <code>component_id</code> is not in the graph</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef successors(self, component_id: int) -&gt; Set[Component]:\n\"\"\"Fetch the graph successors of the specified component.\n    Args:\n        component_id: numerical ID of the component whose successors should be\n            fetched\n    Returns:\n        Set of IDs of the components that are successors of `component_id`,\n            i.e. for which there is a connection from `component_id` to each of\n            these components.\n    Raises:\n        KeyError: if the specified `component_id` is not in the graph\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.battery_pool","title":"<code>frequenz.sdk.microgrid.battery_pool(battery_ids=None)</code>","text":"<p>Return the corresponding BatteryPool instance for the given ids.</p> <p>If a BatteryPool instance for the given ids doesn't exist, a new one is created and returned.</p> PARAMETER  DESCRIPTION <code>battery_ids</code> <p>Optional set of IDs of batteries to be managed by the BatteryPool.  If not specified, all batteries available in the component graph are used.</p> <p> TYPE: <code>Set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>BatteryPool</code> <p>A BatteryPool instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def battery_pool(battery_ids: abc.Set[int] | None = None) -&gt; BatteryPool:\n\"\"\"Return the corresponding BatteryPool instance for the given ids.\n    If a BatteryPool instance for the given ids doesn't exist, a new one is\n    created and returned.\n    Args:\n        battery_ids: Optional set of IDs of batteries to be managed by the\n            BatteryPool.  If not specified, all batteries available in the\n            component graph are used.\n    Returns:\n        A BatteryPool instance.\n    \"\"\"\nreturn _get().battery_pool(battery_ids)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ev_charger_pool","title":"<code>frequenz.sdk.microgrid.ev_charger_pool(ev_charger_ids=None)</code>","text":"<p>Return the corresponding EVChargerPool instance for the given ids.</p> <p>If an EVChargerPool instance for the given ids doesn't exist, a new one is created and returned.</p> PARAMETER  DESCRIPTION <code>ev_charger_ids</code> <p>Optional set of IDs of EV Chargers to be managed by the EVChargerPool.  If not specified, all EV Chargers available in the component graph are used.</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>EVChargerPool</code> <p>An EVChargerPool instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def ev_charger_pool(ev_charger_ids: set[int] | None = None) -&gt; EVChargerPool:\n\"\"\"Return the corresponding EVChargerPool instance for the given ids.\n    If an EVChargerPool instance for the given ids doesn't exist, a new one is\n    created and returned.\n    Args:\n        ev_charger_ids: Optional set of IDs of EV Chargers to be managed by the\n            EVChargerPool.  If not specified, all EV Chargers available in the\n            component graph are used.\n    Returns:\n        An EVChargerPool instance.\n    \"\"\"\nreturn _get().ev_charger_pool(ev_charger_ids)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.frequency","title":"<code>frequenz.sdk.microgrid.frequency(component=None)</code>","text":"<p>Return the grid frequency.</p> PARAMETER  DESCRIPTION <code>component</code> <p>Optional component to get the frequency for. If not specified, the frequency of the grid is returned.</p> <p> TYPE: <code>Component | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>GridFrequency</code> <p>The grid frequency.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def frequency(component: Component | None = None) -&gt; GridFrequency:\n\"\"\"Return the grid frequency.\n    Args:\n        component: Optional component to get the frequency for. If not specified,\n            the frequency of the grid is returned.\n    Returns:\n        The grid frequency.\n    \"\"\"\nreturn _get().frequency(component)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.initialize","title":"<code>frequenz.sdk.microgrid.initialize(host, port, resampler_config)</code>  <code>async</code>","text":"<p>Initialize the microgrid connection manager and the data pipeline.</p> PARAMETER  DESCRIPTION <code>host</code> <p>Host to connect to, to reach the microgrid API.</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>port to connect to.</p> <p> TYPE: <code>int</code> </p> <code>resampler_config</code> <p>Configuration for the resampling actor.</p> <p> TYPE: <code>ResamplerConfig</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/__init__.py</code> <pre><code>async def initialize(host: str, port: int, resampler_config: ResamplerConfig) -&gt; None:\n\"\"\"Initialize the microgrid connection manager and the data pipeline.\n    Args:\n        host: Host to connect to, to reach the microgrid API.\n        port: port to connect to.\n        resampler_config: Configuration for the resampling actor.\n    \"\"\"\nawait connection_manager.initialize(host, port)\napi_client = connection_manager.get().api_client\ncomponents = await api_client.components()\ngrid.initialize(components)\nawait _data_pipeline.initialize(resampler_config)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.logical_meter","title":"<code>frequenz.sdk.microgrid.logical_meter()</code>","text":"<p>Return the logical meter instance.</p> <p>If a LogicalMeter instance doesn't exist, a new one is created and returned.</p> RETURNS DESCRIPTION <code>LogicalMeter</code> <p>A logical meter instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def logical_meter() -&gt; LogicalMeter:\n\"\"\"Return the logical meter instance.\n    If a LogicalMeter instance doesn't exist, a new one is created and returned.\n    Returns:\n        A logical meter instance.\n    \"\"\"\nreturn _get().logical_meter()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/","title":"connection_manager","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager","title":"<code>frequenz.sdk.microgrid.connection_manager</code>","text":"<p>Microgrid Connection Manager singleton abstraction.</p> <p>This module provides a singleton abstraction over the microgrid. The main purpose is to provide the connection the microgrid API client and the microgrid component graph.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager","title":"<code>frequenz.sdk.microgrid.connection_manager.ConnectionManager</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Creates and stores core features.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>class ConnectionManager(ABC):\n\"\"\"Creates and stores core features.\"\"\"\ndef __init__(self, host: str, port: int) -&gt; None:\n\"\"\"Create object instance.\n        Args:\n            host: server host\n            port: server port\n        \"\"\"\nsuper().__init__()\nself._host: str = host\nself._port: int = port\n@property\ndef host(self) -&gt; str:\n\"\"\"Get host of the currently connected server.\n        Returns:\n            host\n        \"\"\"\nreturn self._host\n@property\ndef port(self) -&gt; int:\n\"\"\"Get port of the currently connected server.\n        Returns:\n            port\n        \"\"\"\nreturn self._port\n@property\n@abstractmethod\ndef api_client(self) -&gt; MicrogridApiClient:\n\"\"\"Get MicrogridApiClient.\n        Returns:\n            api client\n        \"\"\"\n@property\n@abstractmethod\ndef component_graph(self) -&gt; ComponentGraph:\n\"\"\"Get component graph.\n        Returns:\n            component graph\n        \"\"\"\nasync def _update_api(self, host: str, port: int) -&gt; None:\nself._host = host\nself._port = port\n@abstractmethod\nasync def _initialize(self) -&gt; None:\n\"\"\"Initialize the object. This function should be called only once.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.api_client","title":"<code>api_client: MicrogridApiClient</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get MicrogridApiClient.</p> RETURNS DESCRIPTION <code>MicrogridApiClient</code> <p>api client</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.component_graph","title":"<code>component_graph: ComponentGraph</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get component graph.</p> RETURNS DESCRIPTION <code>ComponentGraph</code> <p>component graph</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.host","title":"<code>host: str</code>  <code>property</code>","text":"<p>Get host of the currently connected server.</p> RETURNS DESCRIPTION <code>str</code> <p>host</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.port","title":"<code>port: int</code>  <code>property</code>","text":"<p>Get port of the currently connected server.</p> RETURNS DESCRIPTION <code>int</code> <p>port</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.__init__","title":"<code>__init__(host, port)</code>","text":"<p>Create object instance.</p> PARAMETER  DESCRIPTION <code>host</code> <p>server host</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>server port</p> <p> TYPE: <code>int</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n\"\"\"Create object instance.\n    Args:\n        host: server host\n        port: server port\n    \"\"\"\nsuper().__init__()\nself._host: str = host\nself._port: int = port\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.get","title":"<code>frequenz.sdk.microgrid.connection_manager.get()</code>","text":"<p>Get the MicrogridApi instance created by initialize().</p> <p>This function should be only called after initialize().</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Raised when: * If <code>initialize()</code> method was not called before this call. * If <code>initialize()</code> methods was called but was not awaited and instance was     not created yet.</p> RETURNS DESCRIPTION <code>ConnectionManager</code> <p>MicrogridApi instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>def get() -&gt; ConnectionManager:\n\"\"\"Get the MicrogridApi instance created by initialize().\n    This function should be only called after initialize().\n    Raises:\n        RuntimeError: Raised when:\n            * If `initialize()` method was not called before this call.\n            * If `initialize()` methods was called but was not awaited and instance was\n                not created yet.\n    Returns:\n        MicrogridApi instance.\n    \"\"\"\nif _CONNECTION_MANAGER is None:\nraise RuntimeError(\n\"ConnectionManager is not initialized. \"\n\"Call `await microgrid.initialize()` first.\"\n)\nreturn _CONNECTION_MANAGER\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.initialize","title":"<code>frequenz.sdk.microgrid.connection_manager.initialize(host, port)</code>  <code>async</code>","text":"<p>Initialize the MicrogridApi. This function should be called only once.</p> PARAMETER  DESCRIPTION <code>host</code> <p>Microgrid host</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Microgrid port</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If method was called more then once.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>async def initialize(host: str, port: int) -&gt; None:\n\"\"\"Initialize the MicrogridApi. This function should be called only once.\n    Args:\n        host: Microgrid host\n        port: Microgrid port\n    Raises:\n        AssertionError: If method was called more then once.\n    \"\"\"\n# From Doc: pylint just try to discourage this usage.\n# That doesn't mean you cannot use it.\nglobal _CONNECTION_MANAGER  # pylint: disable=global-statement\nif _CONNECTION_MANAGER is not None:\nraise AssertionError(\"MicrogridApi was already initialized.\")\n_logger.info(\"Connecting to microgrid at %s:%s\", host, port)\nmicrogrid_api = _InsecureConnectionManager(host, port)\nawait microgrid_api._initialize()  # pylint: disable=protected-access\n# Check again that _MICROGRID_API is None in case somebody had the great idea of\n# calling initialize() twice and in parallel.\nif _CONNECTION_MANAGER is not None:\nraise AssertionError(\"MicrogridApi was already initialized.\")\n_CONNECTION_MANAGER = microgrid_api\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/fuse/","title":"fuse","text":""},{"location":"reference/frequenz/sdk/microgrid/fuse/#frequenz.sdk.microgrid.fuse","title":"<code>frequenz.sdk.microgrid.fuse</code>","text":"<p>Fuse data class.</p>"},{"location":"reference/frequenz/sdk/microgrid/fuse/#frequenz.sdk.microgrid.fuse-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/fuse/#frequenz.sdk.microgrid.fuse.Fuse","title":"<code>frequenz.sdk.microgrid.fuse.Fuse</code>  <code>dataclass</code>","text":"<p>Fuse data class.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/fuse.py</code> <pre><code>@dataclass(frozen=True)\nclass Fuse:\n\"\"\"Fuse data class.\"\"\"\nmax_current: Current\n\"\"\"Rated current of the fuse.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/fuse/#frequenz.sdk.microgrid.fuse.Fuse-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/fuse/#frequenz.sdk.microgrid.fuse.Fuse.max_current","title":"<code>max_current: Current</code>  <code>instance-attribute</code>","text":"<p>Rated current of the fuse.</p>"},{"location":"reference/frequenz/sdk/microgrid/grid/","title":"grid","text":""},{"location":"reference/frequenz/sdk/microgrid/grid/#frequenz.sdk.microgrid.grid","title":"<code>frequenz.sdk.microgrid.grid</code>","text":"<p>Grid connection point.</p> <p>This module provides the <code>Grid</code> type, which represents a grid connection point in a microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/grid/#frequenz.sdk.microgrid.grid-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/grid/#frequenz.sdk.microgrid.grid.Grid","title":"<code>frequenz.sdk.microgrid.grid.Grid</code>  <code>dataclass</code>","text":"<p>A grid connection point.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/grid.py</code> <pre><code>@dataclass(frozen=True)\nclass Grid:\n\"\"\"A grid connection point.\"\"\"\nfuse: Fuse\n\"\"\"The fuse protecting the grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/grid/#frequenz.sdk.microgrid.grid.Grid-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/grid/#frequenz.sdk.microgrid.grid.Grid.fuse","title":"<code>fuse: Fuse</code>  <code>instance-attribute</code>","text":"<p>The fuse protecting the grid connection point.</p>"},{"location":"reference/frequenz/sdk/microgrid/grid/#frequenz.sdk.microgrid.grid-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/grid/#frequenz.sdk.microgrid.grid.get","title":"<code>frequenz.sdk.microgrid.grid.get()</code>","text":"<p>Get the grid connection.</p> <p>Note that a microgrid configured as an island will not have a grid connection point. For such microgrids, this function will return <code>None</code>.</p> RETURNS DESCRIPTION <code>Grid | None</code> <p>The grid connection.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/grid.py</code> <pre><code>def get() -&gt; Grid | None:\n\"\"\"Get the grid connection.\n    Note that a microgrid configured as an island will not have a grid\n    connection point. For such microgrids, this function will return `None`.\n    Returns:\n        The grid connection.\n    \"\"\"\nreturn _GRID\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/grid/#frequenz.sdk.microgrid.grid.initialize","title":"<code>frequenz.sdk.microgrid.grid.initialize(components)</code>","text":"<p>Initialize the grid connection.</p> PARAMETER  DESCRIPTION <code>components</code> <p>The components in the microgrid.</p> <p> TYPE: <code>Iterable[Component]</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If there is more than 1 grid connection point in the microgrid, or if the grid connection point is not initialized, or if the grid connection point does not have a fuse.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/grid.py</code> <pre><code>def initialize(components: Iterable[Component]) -&gt; None:\n\"\"\"Initialize the grid connection.\n    Args:\n        components: The components in the microgrid.\n    Raises:\n        RuntimeError: If there is more than 1 grid connection point in the\n            microgrid, or if the grid connection point is not initialized,\n            or if the grid connection point does not have a fuse.\n    \"\"\"\nglobal _GRID  # pylint: disable=global-statement\ngrid_connections = list(\ncomponent\nfor component in components\nif component.category == ComponentCategory.GRID\n)\ngrid_connections_count = len(grid_connections)\nif grid_connections_count == 0:\nlogging.info(\n\"No grid connection found for this microgrid. This is normal for an islanded microgrid.\"\n)\nelif grid_connections_count &gt; 1:\nraise RuntimeError(\nf\"Expected at most one grid connection, got {grid_connections_count}\"\n)\nelse:\nif grid_connections[0].metadata is None:\nraise RuntimeError(\"Grid metadata is None\")\nfuse = grid_connections[0].metadata.fuse\nif fuse is None:\nraise RuntimeError(\"Grid fuse is None\")\n_GRID = Grid(fuse)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/","title":"client","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client","title":"<code>frequenz.sdk.microgrid.client</code>","text":"<p>Microgrid API client.</p> <p>This package provides an easy way to connect to the microgrid API.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection","title":"<code>frequenz.sdk.microgrid.client.Connection</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Metadata for a connection between microgrid components.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_connection.py</code> <pre><code>class Connection(NamedTuple):\n\"\"\"Metadata for a connection between microgrid components.\"\"\"\nstart: int\n\"\"\"The component ID that represents the start component of the connection.\"\"\"\nend: int\n\"\"\"The component ID that represents the end component of the connection.\"\"\"\ndef is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n        Returns:\n            `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n                otherwise.\n        \"\"\"\nreturn self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection.end","title":"<code>end: int</code>  <code>instance-attribute</code>","text":"<p>The component ID that represents the end component of the connection.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection.start","title":"<code>start: int</code>  <code>instance-attribute</code>","text":"<p>The component ID that represents the start component of the connection.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection.is_valid","title":"<code>is_valid()</code>","text":"<p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>start &gt;= 0</code>, <code>end &gt; 0</code>, and <code>start != end</code>, <code>False</code> otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_connection.py</code> <pre><code>def is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n    Returns:\n        `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n            otherwise.\n    \"\"\"\nreturn self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff","title":"<code>frequenz.sdk.microgrid.client.ExponentialBackoff</code>","text":"<p>             Bases: <code>RetryStrategy</code></p> <p>Provides methods for calculating the exponential interval between retries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class ExponentialBackoff(RetryStrategy):\n\"\"\"Provides methods for calculating the exponential interval between retries.\"\"\"\nDEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL\n\"\"\"Default retry interval, in seconds.\"\"\"\nDEFAULT_MAX_INTERVAL = 60.0\n\"\"\"Default maximum retry interval, in seconds.\"\"\"\nDEFAULT_MULTIPLIER = 2.0\n\"\"\"Default multiplier for exponential increment.\"\"\"\n# pylint: disable=too-many-arguments\ndef __init__(\nself,\ninitial_interval: float = DEFAULT_INTERVAL,\nmax_interval: float = DEFAULT_MAX_INTERVAL,\nmultiplier: float = DEFAULT_MULTIPLIER,\njitter: float = DEFAULT_RETRY_JITTER,\nlimit: Optional[int] = None,\n) -&gt; None:\n\"\"\"Create a `ExponentialBackoff` instance.\n        Args:\n            initial_interval: time to wait for before the first retry, in\n                seconds.\n            max_interval: maximum interval, in seconds.\n            multiplier: exponential increment for interval.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\nself._initial = initial_interval\nself._max = max_interval\nself._multiplier = multiplier\nself._jitter = jitter\nself._limit = limit\nself._count = 0\ndef next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nexp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\nreturn min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.DEFAULT_INTERVAL","title":"<code>DEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default retry interval, in seconds.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.DEFAULT_MAX_INTERVAL","title":"<code>DEFAULT_MAX_INTERVAL = 60.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default maximum retry interval, in seconds.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.DEFAULT_MULTIPLIER","title":"<code>DEFAULT_MULTIPLIER = 2.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default multiplier for exponential increment.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.__init__","title":"<code>__init__(initial_interval=DEFAULT_INTERVAL, max_interval=DEFAULT_MAX_INTERVAL, multiplier=DEFAULT_MULTIPLIER, jitter=DEFAULT_RETRY_JITTER, limit=None)</code>","text":"<p>Create a <code>ExponentialBackoff</code> instance.</p> PARAMETER  DESCRIPTION <code>initial_interval</code> <p>time to wait for before the first retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_INTERVAL</code> </p> <code>max_interval</code> <p>maximum interval, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MAX_INTERVAL</code> </p> <code>multiplier</code> <p>exponential increment for interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MULTIPLIER</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __init__(\nself,\ninitial_interval: float = DEFAULT_INTERVAL,\nmax_interval: float = DEFAULT_MAX_INTERVAL,\nmultiplier: float = DEFAULT_MULTIPLIER,\njitter: float = DEFAULT_RETRY_JITTER,\nlimit: Optional[int] = None,\n) -&gt; None:\n\"\"\"Create a `ExponentialBackoff` instance.\n    Args:\n        initial_interval: time to wait for before the first retry, in\n            seconds.\n        max_interval: maximum interval, in seconds.\n        multiplier: exponential increment for interval.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\nself._initial = initial_interval\nself._max = max_interval\nself._multiplier = multiplier\nself._jitter = jitter\nself._limit = limit\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff.next_interval","title":"<code>next_interval()</code>","text":"<p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nexp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\nreturn min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff","title":"<code>frequenz.sdk.microgrid.client.LinearBackoff</code>","text":"<p>             Bases: <code>RetryStrategy</code></p> <p>Provides methods for calculating the interval between retries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class LinearBackoff(RetryStrategy):\n\"\"\"Provides methods for calculating the interval between retries.\"\"\"\ndef __init__(\nself,\ninterval: float = DEFAULT_RETRY_INTERVAL,\njitter: float = DEFAULT_RETRY_JITTER,\nlimit: Optional[int] = None,\n) -&gt; None:\n\"\"\"Create a `LinearBackoff` instance.\n        Args:\n            interval: time to wait for before the next retry, in seconds.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\nself._interval = interval\nself._jitter = jitter\nself._limit = limit\nself._count = 0\ndef next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nreturn self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.__init__","title":"<code>__init__(interval=DEFAULT_RETRY_INTERVAL, jitter=DEFAULT_RETRY_JITTER, limit=None)</code>","text":"<p>Create a <code>LinearBackoff</code> instance.</p> PARAMETER  DESCRIPTION <code>interval</code> <p>time to wait for before the next retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_INTERVAL</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __init__(\nself,\ninterval: float = DEFAULT_RETRY_INTERVAL,\njitter: float = DEFAULT_RETRY_JITTER,\nlimit: Optional[int] = None,\n) -&gt; None:\n\"\"\"Create a `LinearBackoff` instance.\n    Args:\n        interval: time to wait for before the next retry, in seconds.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\nself._interval = interval\nself._jitter = jitter\nself._limit = limit\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff.next_interval","title":"<code>next_interval()</code>","text":"<p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nreturn self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient","title":"<code>frequenz.sdk.microgrid.client.MicrogridApiClient</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base interface for microgrid API clients to implement.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>class MicrogridApiClient(ABC):\n\"\"\"Base interface for microgrid API clients to implement.\"\"\"\n@abstractmethod\nasync def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n        Returns:\n            Iterator whose elements are all the components in the microgrid.\n        \"\"\"\n@abstractmethod\nasync def connections(\nself,\nstarts: Optional[Set[int]] = None,\nends: Optional[Set[int]] = None,\n) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n        Args:\n            starts: if set and non-empty, only include connections whose start\n                value matches one of the provided component IDs\n            ends: if set and non-empty, only include connections whose end value\n                matches one of the provided component IDs\n        Returns:\n            Microgrid connections matching the provided start and end filters.\n        \"\"\"\n@abstractmethod\nasync def meter_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Args:\n            component_id: id of the meter to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime meter data.\n        \"\"\"\n@abstractmethod\nasync def battery_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Args:\n            component_id: id of the battery to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime battery data.\n        \"\"\"\n@abstractmethod\nasync def inverter_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Args:\n            component_id: id of the inverter to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime inverter data.\n        \"\"\"\n@abstractmethod\nasync def ev_charger_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Args:\n            component_id: id of the ev charger to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime ev charger data.\n        \"\"\"\n@abstractmethod\nasync def set_power(self, component_id: int, power_w: float) -&gt; None:\n\"\"\"Send request to the Microgrid to set power for component.\n        If power &gt; 0, then component will be charged with this power.\n        If power &lt; 0, then component will be discharged with this power.\n        If power == 0, then stop charging or discharging component.\n        Args:\n            component_id: id of the component to set power.\n            power_w: power to set for the component.\n        \"\"\"\n@abstractmethod\nasync def set_bounds(self, component_id: int, lower: float, upper: float) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to nitrogen.\n        Args:\n            component_id: ID of the component to set bounds for.\n            lower: Lower bound to be set for the component.\n            upper: Upper bound to be set for the component.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.battery_data","title":"<code>battery_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Return a channel receiver that provides a <code>BatteryData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the battery to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[BatteryData]</code> <p>A channel receiver that provides realtime battery data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def battery_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Args:\n        component_id: id of the battery to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime battery data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.components","title":"<code>components()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Fetch all the components present in the microgrid.</p> RETURNS DESCRIPTION <code>Iterable[Component]</code> <p>Iterator whose elements are all the components in the microgrid.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n    Returns:\n        Iterator whose elements are all the components in the microgrid.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.connections","title":"<code>connections(starts=None, ends=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Fetch the connections between components in the microgrid.</p> PARAMETER  DESCRIPTION <code>starts</code> <p>if set and non-empty, only include connections whose start value matches one of the provided component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> <code>ends</code> <p>if set and non-empty, only include connections whose end value matches one of the provided component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[Connection]</code> <p>Microgrid connections matching the provided start and end filters.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def connections(\nself,\nstarts: Optional[Set[int]] = None,\nends: Optional[Set[int]] = None,\n) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n    Args:\n        starts: if set and non-empty, only include connections whose start\n            value matches one of the provided component IDs\n        ends: if set and non-empty, only include connections whose end value\n            matches one of the provided component IDs\n    Returns:\n        Microgrid connections matching the provided start and end filters.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.ev_charger_data","title":"<code>ev_charger_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Return a channel receiver that provides an <code>EvChargeData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the ev charger to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A channel receiver that provides realtime ev charger data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def ev_charger_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Args:\n        component_id: id of the ev charger to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime ev charger data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.inverter_data","title":"<code>inverter_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Return a channel receiver that provides an <code>InverterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the inverter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[InverterData]</code> <p>A channel receiver that provides realtime inverter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def inverter_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Args:\n        component_id: id of the inverter to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime inverter data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.meter_data","title":"<code>meter_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Return a channel receiver that provides a <code>MeterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the meter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[MeterData]</code> <p>A channel receiver that provides realtime meter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def meter_data(\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Args:\n        component_id: id of the meter to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime meter data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.set_bounds","title":"<code>set_bounds(component_id, lower, upper)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Send <code>SetBoundsParam</code>s received from a channel to nitrogen.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>ID of the component to set bounds for.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>Lower bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> <code>upper</code> <p>Upper bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def set_bounds(self, component_id: int, lower: float, upper: float) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to nitrogen.\n    Args:\n        component_id: ID of the component to set bounds for.\n        lower: Lower bound to be set for the component.\n        upper: Upper bound to be set for the component.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient.set_power","title":"<code>set_power(component_id, power_w)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Send request to the Microgrid to set power for component.</p> <p>If power &gt; 0, then component will be charged with this power. If power &lt; 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the component to set power.</p> <p> TYPE: <code>int</code> </p> <code>power_w</code> <p>power to set for the component.</p> <p> TYPE: <code>float</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def set_power(self, component_id: int, power_w: float) -&gt; None:\n\"\"\"Send request to the Microgrid to set power for component.\n    If power &gt; 0, then component will be charged with this power.\n    If power &lt; 0, then component will be discharged with this power.\n    If power == 0, then stop charging or discharging component.\n    Args:\n        component_id: id of the component to set power.\n        power_w: power to set for the component.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient","title":"<code>frequenz.sdk.microgrid.client.MicrogridGrpcClient</code>","text":"<p>             Bases: <code>MicrogridApiClient</code></p> <p>Microgrid API client implementation using gRPC as the underlying protocol.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>class MicrogridGrpcClient(MicrogridApiClient):\n\"\"\"Microgrid API client implementation using gRPC as the underlying protocol.\"\"\"\ndef __init__(\nself,\ngrpc_channel: grpc.aio.Channel,\ntarget: str,\nretry_spec: RetryStrategy = LinearBackoff(),\n) -&gt; None:\n\"\"\"Initialize the class instance.\n        Args:\n            grpc_channel: asyncio-supporting gRPC channel\n            target: server (host:port) to be used for asyncio-supporting gRPC\n                channel that the client should use to contact the API\n            retry_spec: Specs on how to retry if the connection to a streaming\n                method gets lost.\n        \"\"\"\nself.target = target\n\"\"\"The location (as \"host:port\") of the microgrid API gRPC server.\"\"\"\nself.api = MicrogridStub(grpc_channel)\n\"\"\"The gRPC stub for the microgrid API.\"\"\"\nself._component_streams: Dict[int, Broadcast[Any]] = {}\nself._streaming_tasks: Dict[int, asyncio.Task[None]] = {}\nself._retry_spec = retry_spec\nasync def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n        Returns:\n            Iterator whose elements are all the components in the microgrid.\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\ntry:\n# grpc.aio is missing types and mypy thinks this is not awaitable,\n# but it is\ncomponent_list = await self.api.ListComponents(\nmicrogrid_pb.ComponentFilter(),\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n)  # type: ignore[misc]\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to list components. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\ncomponents_only = filter(\nlambda c: c.category\nis not components_pb.ComponentCategory.COMPONENT_CATEGORY_SENSOR,\ncomponent_list.components,\n)\nresult: Iterable[Component] = map(\nlambda c: Component(\nc.id,\n_component_category_from_protobuf(c.category),\n_component_type_from_protobuf(c.category, c.inverter),\n_component_metadata_from_protobuf(c.category, c.grid),\n),\ncomponents_only,\n)\nreturn result\nasync def connections(\nself,\nstarts: Optional[Set[int]] = None,\nends: Optional[Set[int]] = None,\n) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n        Args:\n            starts: if set and non-empty, only include connections whose start\n                value matches one of the provided component IDs\n            ends: if set and non-empty, only include connections whose end value\n                matches one of the provided component IDs\n        Returns:\n            Microgrid connections matching the provided start and end filters.\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\nconnection_filter = microgrid_pb.ConnectionFilter(starts=starts, ends=ends)\ntry:\nvalid_components, all_connections = await asyncio.gather(\nself.components(),\n# grpc.aio is missing types and mypy thinks this is not\n# awaitable, but it is\ncast(\nAwaitable[microgrid_pb.ConnectionList],\nself.api.ListConnections(\nconnection_filter,\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n),\n),\n)\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to list connections. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\n# Filter out the components filtered in `components` method.\n# id=0 is an exception indicating grid component.\nvalid_ids = {c.component_id for c in valid_components}\nvalid_ids.add(0)\nconnections = filter(\nlambda c: (c.start in valid_ids and c.end in valid_ids),\nall_connections.connections,\n)\nresult: Iterable[Connection] = map(\nlambda c: Connection(c.start, c.end), connections\n)\nreturn result\nasync def _component_data_task(\nself,\ncomponent_id: int,\ntransform: Callable[[microgrid_pb.ComponentData], _GenericComponentData],\nsender: Sender[_GenericComponentData],\n) -&gt; None:\n\"\"\"Read data from the microgrid API and send to a channel.\n        Args:\n            component_id: id of the component to get data for.\n            transform: A method for transforming raw component data into the\n                desired output type.\n            sender: A channel sender, to send the component data to.\n        \"\"\"\nretry_spec: RetryStrategy = self._retry_spec.copy()\nwhile True:\n_logger.debug(\n\"Making call to `GetComponentData`, for component_id=%d\", component_id\n)\ntry:\ncall = self.api.StreamComponentData(\nmicrogrid_pb.ComponentIdParam(id=component_id),\n)\n# grpc.aio is missing types and mypy thinks this is not\n# async iterable, but it is\nasync for msg in call:  # type: ignore[attr-defined]\nawait sender.send(transform(msg))\nexcept grpc.aio.AioRpcError as err:\napi_details = f\"Microgrid API: {self.target}.\"\n_logger.exception(\n\"`GetComponentData`, for component_id=%d: exception: %s api: %s\",\ncomponent_id,\nerr,\napi_details,\n)\nif interval := retry_spec.next_interval():\n_logger.warning(\n\"`GetComponentData`, for component_id=%d: connection ended, \"\n\"retrying %s in %0.3f seconds.\",\ncomponent_id,\nretry_spec.get_progress(),\ninterval,\n)\nawait asyncio.sleep(interval)\nelse:\n_logger.warning(\n\"`GetComponentData`, for component_id=%d: connection ended, \"\n\"retry limit exceeded %s.\",\ncomponent_id,\nretry_spec.get_progress(),\n)\nbreak\ndef _get_component_data_channel(\nself,\ncomponent_id: int,\ntransform: Callable[[microgrid_pb.ComponentData], _GenericComponentData],\n) -&gt; Broadcast[_GenericComponentData]:\n\"\"\"Return the broadcast channel for a given component_id.\n        If a broadcast channel for the given component_id doesn't exist, create\n        a new channel and a task for reading data from the microgrid api and\n        sending them to the channel.\n        Args:\n            component_id: id of the component to get data for.\n            transform: A method for transforming raw component data into the\n                desired output type.\n        Returns:\n            The channel for the given component_id.\n        \"\"\"\nif component_id in self._component_streams:\nreturn self._component_streams[component_id]\ntask_name = f\"raw-component-data-{component_id}\"\nchan = Broadcast[_GenericComponentData](task_name)\nself._component_streams[component_id] = chan\nself._streaming_tasks[component_id] = asyncio.create_task(\nself._component_data_task(\ncomponent_id,\ntransform,\nchan.new_sender(),\n),\nname=task_name,\n)\nreturn chan\nasync def _expect_category(\nself,\ncomponent_id: int,\nexpected_category: ComponentCategory,\n) -&gt; None:\n\"\"\"Check if the given component_id is of the expected type.\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n        Args:\n            component_id: Component id to check.\n            expected_category: Component category that the given id is expected\n                to have.\n        \"\"\"\ntry:\ncomp = next(\ncomp\nfor comp in await self.components()\nif comp.component_id == component_id\n)\nexcept StopIteration as exc:\nraise ValueError(\nf\"Unable to find component with id {component_id}\"\n) from exc\nif comp.category != expected_category:\nraise ValueError(\nf\"Component id {component_id} is a {comp.category}\"\nf\", not a {expected_category}.\"\n)\nasync def meter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n        Args:\n            component_id: id of the meter to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime meter data.\n        \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.METER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nMeterData.from_proto,\n).new_receiver(maxsize=maxsize)\nasync def battery_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n        Args:\n            component_id: id of the battery to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime battery data.\n        \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.BATTERY,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nBatteryData.from_proto,\n).new_receiver(maxsize=maxsize)\nasync def inverter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n        Args:\n            component_id: id of the inverter to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime inverter data.\n        \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.INVERTER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nInverterData.from_proto,\n).new_receiver(maxsize=maxsize)\nasync def ev_charger_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n        Args:\n            component_id: id of the ev charger to get data for.\n            maxsize: Size of the receiver's buffer.\n        Returns:\n            A channel receiver that provides realtime ev charger data.\n        \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.EV_CHARGER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nEVChargerData.from_proto,\n).new_receiver(maxsize=maxsize)\nasync def set_power(self, component_id: int, power_w: float) -&gt; None:\n\"\"\"Send request to the Microgrid to set power for component.\n        If power &gt; 0, then component will be charged with this power.\n        If power &lt; 0, then component will be discharged with this power.\n        If power == 0, then stop charging or discharging component.\n        Args:\n            component_id: id of the component to set power.\n            power_w: power to set for the component.\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\ntry:\nawait self.api.SetPowerActive(\nmicrogrid_pb.SetPowerActiveParam(\ncomponent_id=component_id, power=power_w\n),\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n)  # type: ignore[misc]\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to set power. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\nasync def set_bounds(\nself,\ncomponent_id: int,\nlower: float,\nupper: float,\n) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to nitrogen.\n        Args:\n            component_id: ID of the component to set bounds for.\n            lower: Lower bound to be set for the component.\n            upper: Upper bound to be set for the component.\n        Raises:\n            ValueError: when upper bound is less than 0, or when lower bound is\n                greater than 0.\n            grpc.aio.AioRpcError: if connection to Microgrid API cannot be established\n                or when the api call exceeded timeout\n        \"\"\"\napi_details = f\"Microgrid API: {self.target}.\"\nif upper &lt; 0:\nraise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\nif lower &gt; 0:\nraise ValueError(f\"Lower bound {upper} must be less than or equal to 0.\")\ntarget_metric = (\nmicrogrid_pb.SetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE\n)\ntry:\nself.api.AddInclusionBounds(\nmicrogrid_pb.SetBoundsParam(\ncomponent_id=component_id,\ntarget_metric=target_metric,\nbounds=metrics_pb.Bounds(lower=lower, upper=upper),\n),\n)\nexcept grpc.aio.AioRpcError as err:\n_logger.error(\n\"set_bounds write failed: %s, for message: %s, api: %s. Err: %s\",\nerr,\nnext,\napi_details,\nerr.details(),\n)\nraise\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.api","title":"<code>api = MicrogridStub(grpc_channel)</code>  <code>instance-attribute</code>","text":"<p>The gRPC stub for the microgrid API.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.target","title":"<code>target = target</code>  <code>instance-attribute</code>","text":"<p>The location (as \"host:port\") of the microgrid API gRPC server.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.__init__","title":"<code>__init__(grpc_channel, target, retry_spec=LinearBackoff())</code>","text":"<p>Initialize the class instance.</p> PARAMETER  DESCRIPTION <code>grpc_channel</code> <p>asyncio-supporting gRPC channel</p> <p> TYPE: <code>Channel</code> </p> <code>target</code> <p>server (host:port) to be used for asyncio-supporting gRPC channel that the client should use to contact the API</p> <p> TYPE: <code>str</code> </p> <code>retry_spec</code> <p>Specs on how to retry if the connection to a streaming method gets lost.</p> <p> TYPE: <code>RetryStrategy</code> DEFAULT: <code>LinearBackoff()</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>def __init__(\nself,\ngrpc_channel: grpc.aio.Channel,\ntarget: str,\nretry_spec: RetryStrategy = LinearBackoff(),\n) -&gt; None:\n\"\"\"Initialize the class instance.\n    Args:\n        grpc_channel: asyncio-supporting gRPC channel\n        target: server (host:port) to be used for asyncio-supporting gRPC\n            channel that the client should use to contact the API\n        retry_spec: Specs on how to retry if the connection to a streaming\n            method gets lost.\n    \"\"\"\nself.target = target\n\"\"\"The location (as \"host:port\") of the microgrid API gRPC server.\"\"\"\nself.api = MicrogridStub(grpc_channel)\n\"\"\"The gRPC stub for the microgrid API.\"\"\"\nself._component_streams: Dict[int, Broadcast[Any]] = {}\nself._streaming_tasks: Dict[int, asyncio.Task[None]] = {}\nself._retry_spec = retry_spec\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.battery_data","title":"<code>battery_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>async</code>","text":"<p>Return a channel receiver that provides a <code>BatteryData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the battery to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[BatteryData]</code> <p>A channel receiver that provides realtime battery data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def battery_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n    Args:\n        component_id: id of the battery to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime battery data.\n    \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.BATTERY,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nBatteryData.from_proto,\n).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.components","title":"<code>components()</code>  <code>async</code>","text":"<p>Fetch all the components present in the microgrid.</p> RETURNS DESCRIPTION <code>Iterable[Component]</code> <p>Iterator whose elements are all the components in the microgrid.</p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n    Returns:\n        Iterator whose elements are all the components in the microgrid.\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\ntry:\n# grpc.aio is missing types and mypy thinks this is not awaitable,\n# but it is\ncomponent_list = await self.api.ListComponents(\nmicrogrid_pb.ComponentFilter(),\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n)  # type: ignore[misc]\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to list components. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\ncomponents_only = filter(\nlambda c: c.category\nis not components_pb.ComponentCategory.COMPONENT_CATEGORY_SENSOR,\ncomponent_list.components,\n)\nresult: Iterable[Component] = map(\nlambda c: Component(\nc.id,\n_component_category_from_protobuf(c.category),\n_component_type_from_protobuf(c.category, c.inverter),\n_component_metadata_from_protobuf(c.category, c.grid),\n),\ncomponents_only,\n)\nreturn result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.connections","title":"<code>connections(starts=None, ends=None)</code>  <code>async</code>","text":"<p>Fetch the connections between components in the microgrid.</p> PARAMETER  DESCRIPTION <code>starts</code> <p>if set and non-empty, only include connections whose start value matches one of the provided component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> <code>ends</code> <p>if set and non-empty, only include connections whose end value matches one of the provided component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[Connection]</code> <p>Microgrid connections matching the provided start and end filters.</p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def connections(\nself,\nstarts: Optional[Set[int]] = None,\nends: Optional[Set[int]] = None,\n) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n    Args:\n        starts: if set and non-empty, only include connections whose start\n            value matches one of the provided component IDs\n        ends: if set and non-empty, only include connections whose end value\n            matches one of the provided component IDs\n    Returns:\n        Microgrid connections matching the provided start and end filters.\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\nconnection_filter = microgrid_pb.ConnectionFilter(starts=starts, ends=ends)\ntry:\nvalid_components, all_connections = await asyncio.gather(\nself.components(),\n# grpc.aio is missing types and mypy thinks this is not\n# awaitable, but it is\ncast(\nAwaitable[microgrid_pb.ConnectionList],\nself.api.ListConnections(\nconnection_filter,\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n),\n),\n)\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to list connections. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\n# Filter out the components filtered in `components` method.\n# id=0 is an exception indicating grid component.\nvalid_ids = {c.component_id for c in valid_components}\nvalid_ids.add(0)\nconnections = filter(\nlambda c: (c.start in valid_ids and c.end in valid_ids),\nall_connections.connections,\n)\nresult: Iterable[Connection] = map(\nlambda c: Connection(c.start, c.end), connections\n)\nreturn result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.ev_charger_data","title":"<code>ev_charger_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>async</code>","text":"<p>Return a channel receiver that provides an <code>EvChargeData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the ev charger to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A channel receiver that provides realtime ev charger data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def ev_charger_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n    Args:\n        component_id: id of the ev charger to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime ev charger data.\n    \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.EV_CHARGER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nEVChargerData.from_proto,\n).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.inverter_data","title":"<code>inverter_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>async</code>","text":"<p>Return a channel receiver that provides an <code>InverterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the inverter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[InverterData]</code> <p>A channel receiver that provides realtime inverter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def inverter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n    Args:\n        component_id: id of the inverter to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime inverter data.\n    \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.INVERTER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nInverterData.from_proto,\n).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.meter_data","title":"<code>meter_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>async</code>","text":"<p>Return a channel receiver that provides a <code>MeterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the meter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[MeterData]</code> <p>A channel receiver that provides realtime meter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def meter_data(  # noqa: DOC502 (ValueError is raised indirectly by _expect_category)\nself,\ncomponent_id: int,\nmaxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n    Args:\n        component_id: id of the meter to get data for.\n        maxsize: Size of the receiver's buffer.\n    Returns:\n        A channel receiver that provides realtime meter data.\n    \"\"\"\nawait self._expect_category(\ncomponent_id,\nComponentCategory.METER,\n)\nreturn self._get_component_data_channel(\ncomponent_id,\nMeterData.from_proto,\n).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.set_bounds","title":"<code>set_bounds(component_id, lower, upper)</code>  <code>async</code>","text":"<p>Send <code>SetBoundsParam</code>s received from a channel to nitrogen.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>ID of the component to set bounds for.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>Lower bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> <code>upper</code> <p>Upper bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>when upper bound is less than 0, or when lower bound is greater than 0.</p> <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def set_bounds(\nself,\ncomponent_id: int,\nlower: float,\nupper: float,\n) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to nitrogen.\n    Args:\n        component_id: ID of the component to set bounds for.\n        lower: Lower bound to be set for the component.\n        upper: Upper bound to be set for the component.\n    Raises:\n        ValueError: when upper bound is less than 0, or when lower bound is\n            greater than 0.\n        grpc.aio.AioRpcError: if connection to Microgrid API cannot be established\n            or when the api call exceeded timeout\n    \"\"\"\napi_details = f\"Microgrid API: {self.target}.\"\nif upper &lt; 0:\nraise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\nif lower &gt; 0:\nraise ValueError(f\"Lower bound {upper} must be less than or equal to 0.\")\ntarget_metric = (\nmicrogrid_pb.SetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE\n)\ntry:\nself.api.AddInclusionBounds(\nmicrogrid_pb.SetBoundsParam(\ncomponent_id=component_id,\ntarget_metric=target_metric,\nbounds=metrics_pb.Bounds(lower=lower, upper=upper),\n),\n)\nexcept grpc.aio.AioRpcError as err:\n_logger.error(\n\"set_bounds write failed: %s, for message: %s, api: %s. Err: %s\",\nerr,\nnext,\napi_details,\nerr.details(),\n)\nraise\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient.set_power","title":"<code>set_power(component_id, power_w)</code>  <code>async</code>","text":"<p>Send request to the Microgrid to set power for component.</p> <p>If power &gt; 0, then component will be charged with this power. If power &lt; 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the component to set power.</p> <p> TYPE: <code>int</code> </p> <code>power_w</code> <p>power to set for the component.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def set_power(self, component_id: int, power_w: float) -&gt; None:\n\"\"\"Send request to the Microgrid to set power for component.\n    If power &gt; 0, then component will be charged with this power.\n    If power &lt; 0, then component will be discharged with this power.\n    If power == 0, then stop charging or discharging component.\n    Args:\n        component_id: id of the component to set power.\n        power_w: power to set for the component.\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\ntry:\nawait self.api.SetPowerActive(\nmicrogrid_pb.SetPowerActiveParam(\ncomponent_id=component_id, power=power_w\n),\ntimeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n)  # type: ignore[misc]\nexcept grpc.aio.AioRpcError as err:\nmsg = f\"Failed to set power. Microgrid API: {self.target}. Err: {err.details()}\"\nraise grpc.aio.AioRpcError(\ncode=err.code(),\ninitial_metadata=err.initial_metadata(),\ntrailing_metadata=err.trailing_metadata(),\ndetails=msg,\ndebug_error_string=err.debug_error_string(),\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy","title":"<code>frequenz.sdk.microgrid.client.RetryStrategy</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Interface for implementing retry strategies.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class RetryStrategy(ABC):\n\"\"\"Interface for implementing retry strategies.\"\"\"\n_limit: Optional[int]\n_count: int\n@abstractmethod\ndef next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\ndef get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n        Returns:\n            String denoting retry progress in the form \"(count/limit)\"\n        \"\"\"\nif self._limit is None:\nreturn f\"({self._count}/\u221e)\"\nreturn f\"({self._count}/{self._limit})\"\ndef reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n        To be called as soon as a connection is successful.\n        \"\"\"\nself._count = 0\ndef copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n        Returns:\n            A deepcopy of `self`.\n        \"\"\"\nret = deepcopy(self)\nret.reset()\nreturn ret\ndef __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n        Yields:\n            Next retry interval in seconds.\n        \"\"\"\nwhile True:\ninterval = self.next_interval()\nif interval is None:\nbreak\nyield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\nwhile True:\ninterval = self.next_interval()\nif interval is None:\nbreak\nyield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.copy","title":"<code>copy()</code>","text":"<p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>RetryStrategy</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\nret = deepcopy(self)\nret.reset()\nreturn ret\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.get_progress","title":"<code>get_progress()</code>","text":"<p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\nif self._limit is None:\nreturn f\"({self._count}/\u221e)\"\nreturn f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.next_interval","title":"<code>next_interval()</code>  <code>abstractmethod</code>","text":"<p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>@abstractmethod\ndef next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy.reset","title":"<code>reset()</code>","text":"<p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n    To be called as soon as a connection is successful.\n    \"\"\"\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/","title":"component","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component","title":"<code>frequenz.sdk.microgrid.component</code>","text":"<p>Microgrid component abstractions.</p> <p>This package provides classes to operate con microgrid components.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData","title":"<code>frequenz.sdk.microgrid.component.BatteryData</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding battery data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass BatteryData(ComponentData):\n\"\"\"A wrapper class for holding battery data.\"\"\"\nsoc: float\n\"\"\"Battery's overall SoC in percent (%).\"\"\"\nsoc_lower_bound: float\n\"\"\"The SoC below which discharge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\nsoc_upper_bound: float\n\"\"\"The SoC above which charge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\ncapacity: float\n\"\"\"The capacity of the battery in Wh (Watt-hour).\"\"\"\n# pylint: disable=line-too-long\npower_inclusion_lower_bound: float\n\"\"\"Lower inclusion bound for battery power in watts.\n    This is the lower limit of the range within which power requests are allowed for the\n    battery.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\npower_exclusion_lower_bound: float\n\"\"\"Lower exclusion bound for battery power in watts.\n    This is the lower limit of the range within which power requests are not allowed for\n    the battery.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\npower_inclusion_upper_bound: float\n\"\"\"Upper inclusion bound for battery power in watts.\n    This is the upper limit of the range within which power requests are allowed for the\n    battery.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\npower_exclusion_upper_bound: float\n\"\"\"Upper exclusion bound for battery power in watts.\n    This is the upper limit of the range within which power requests are not allowed for\n    the battery.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n# pylint: enable=line-too-long\ntemperature: float\n\"\"\"The (average) temperature reported by the battery, in Celsius (\u00b0C).\"\"\"\n_relay_state: battery_pb.RelayState.ValueType\n\"\"\"State of the battery relay.\"\"\"\n_component_state: battery_pb.ComponentState.ValueType\n\"\"\"State of the battery.\"\"\"\n_errors: List[battery_pb.Error]\n\"\"\"List of errors in protobuf struct.\"\"\"\n@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; BatteryData:\n\"\"\"Create BatteryData from a protobuf message.\n        Args:\n            raw: raw component data as decoded from the wire.\n        Returns:\n            Instance of BatteryData created from the protobuf message.\n        \"\"\"\nraw_power = raw.battery.data.dc.power\nbattery_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nsoc=raw.battery.data.soc.avg,\nsoc_lower_bound=raw.battery.data.soc.system_inclusion_bounds.lower,\nsoc_upper_bound=raw.battery.data.soc.system_inclusion_bounds.upper,\ncapacity=raw.battery.properties.capacity,\npower_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\npower_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\npower_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\npower_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\ntemperature=raw.battery.data.temperature.avg,\n_relay_state=raw.battery.state.relay_state,\n_component_state=raw.battery.state.component_state,\n_errors=list(raw.battery.errors),\n)\nbattery_data._set_raw(raw=raw)\nreturn battery_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.capacity","title":"<code>capacity: float</code>  <code>instance-attribute</code>","text":"<p>The capacity of the battery in Wh (Watt-hour).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_exclusion_lower_bound","title":"<code>power_exclusion_lower_bound: float</code>  <code>instance-attribute</code>","text":"<p>Lower exclusion bound for battery power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_exclusion_upper_bound","title":"<code>power_exclusion_upper_bound: float</code>  <code>instance-attribute</code>","text":"<p>Upper exclusion bound for battery power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_inclusion_lower_bound","title":"<code>power_inclusion_lower_bound: float</code>  <code>instance-attribute</code>","text":"<p>Lower inclusion bound for battery power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.power_inclusion_upper_bound","title":"<code>power_inclusion_upper_bound: float</code>  <code>instance-attribute</code>","text":"<p>Upper inclusion bound for battery power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the battery.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.soc","title":"<code>soc: float</code>  <code>instance-attribute</code>","text":"<p>Battery's overall SoC in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.soc_lower_bound","title":"<code>soc_lower_bound: float</code>  <code>instance-attribute</code>","text":"<p>The SoC below which discharge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.soc_upper_bound","title":"<code>soc_upper_bound: float</code>  <code>instance-attribute</code>","text":"<p>The SoC above which charge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.temperature","title":"<code>temperature: float</code>  <code>instance-attribute</code>","text":"<p>The (average) temperature reported by the battery, in Celsius (\u00b0C).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData.from_proto","title":"<code>from_proto(raw)</code>  <code>classmethod</code>","text":"<p>Create BatteryData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>BatteryData</code> <p>Instance of BatteryData created from the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; BatteryData:\n\"\"\"Create BatteryData from a protobuf message.\n    Args:\n        raw: raw component data as decoded from the wire.\n    Returns:\n        Instance of BatteryData created from the protobuf message.\n    \"\"\"\nraw_power = raw.battery.data.dc.power\nbattery_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nsoc=raw.battery.data.soc.avg,\nsoc_lower_bound=raw.battery.data.soc.system_inclusion_bounds.lower,\nsoc_upper_bound=raw.battery.data.soc.system_inclusion_bounds.upper,\ncapacity=raw.battery.properties.capacity,\npower_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\npower_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\npower_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\npower_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\ntemperature=raw.battery.data.temperature.avg,\n_relay_state=raw.battery.state.relay_state,\n_component_state=raw.battery.state.component_state,\n_errors=list(raw.battery.errors),\n)\nbattery_data._set_raw(raw=raw)\nreturn battery_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component","title":"<code>frequenz.sdk.microgrid.component.Component</code>  <code>dataclass</code>","text":"<p>Metadata for a single microgrid component.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass Component:\n\"\"\"Metadata for a single microgrid component.\"\"\"\ncomponent_id: int\n\"\"\"The ID of this component.\"\"\"\ncategory: ComponentCategory\n\"\"\"The category of this component.\"\"\"\ntype: ComponentType | None = None\n\"\"\"The type of this component.\"\"\"\nmetadata: ComponentMetadata | None = None\n\"\"\"The metadata of this component.\"\"\"\ndef is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n        Returns:\n            `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n                == 0` and `type` is `GRID`, `False` otherwise\n        \"\"\"\nreturn (\nself.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\ndef __hash__(self) -&gt; int:\n\"\"\"Compute a hash of this instance, obtained by hashing the `component_id` field.\n        Returns:\n            Hash of this instance.\n        \"\"\"\nreturn hash(self.component_id)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.category","title":"<code>category: ComponentCategory</code>  <code>instance-attribute</code>","text":"<p>The category of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.component_id","title":"<code>component_id: int</code>  <code>instance-attribute</code>","text":"<p>The ID of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.metadata","title":"<code>metadata: ComponentMetadata | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The metadata of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.type","title":"<code>type: ComponentType | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of this component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.__hash__","title":"<code>__hash__()</code>","text":"<p>Compute a hash of this instance, obtained by hashing the <code>component_id</code> field.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of this instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"Compute a hash of this instance, obtained by hashing the `component_id` field.\n    Returns:\n        Hash of this instance.\n    \"\"\"\nreturn hash(self.component_id)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component.is_valid","title":"<code>is_valid()</code>","text":"<p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>id &gt; 0</code> and <code>type</code> is a valid <code>ComponentCategory</code>, or if <code>id == 0</code> and <code>type</code> is <code>GRID</code>, <code>False</code> otherwise</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>def is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n    Returns:\n        `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n            == 0` and `type` is `GRID`, `False` otherwise\n    \"\"\"\nreturn (\nself.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory","title":"<code>frequenz.sdk.microgrid.component.ComponentCategory</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Possible types of microgrid component.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class ComponentCategory(Enum):\n\"\"\"Possible types of microgrid component.\"\"\"\nNONE = components_pb.ComponentCategory.COMPONENT_CATEGORY_UNSPECIFIED\n\"\"\"Unspecified component category.\"\"\"\nGRID = components_pb.ComponentCategory.COMPONENT_CATEGORY_GRID\n\"\"\"Grid component.\"\"\"\nMETER = components_pb.ComponentCategory.COMPONENT_CATEGORY_METER\n\"\"\"Meter component.\"\"\"\nINVERTER = components_pb.ComponentCategory.COMPONENT_CATEGORY_INVERTER\n\"\"\"Inverter component.\"\"\"\nBATTERY = components_pb.ComponentCategory.COMPONENT_CATEGORY_BATTERY\n\"\"\"Battery component.\"\"\"\nEV_CHARGER = components_pb.ComponentCategory.COMPONENT_CATEGORY_EV_CHARGER\n\"\"\"EV charger component.\"\"\"\nCHP = components_pb.ComponentCategory.COMPONENT_CATEGORY_CHP\n\"\"\"CHP component.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.BATTERY","title":"<code>BATTERY = components_pb.ComponentCategory.COMPONENT_CATEGORY_BATTERY</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.CHP","title":"<code>CHP = components_pb.ComponentCategory.COMPONENT_CATEGORY_CHP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>CHP component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.EV_CHARGER","title":"<code>EV_CHARGER = components_pb.ComponentCategory.COMPONENT_CATEGORY_EV_CHARGER</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>EV charger component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.GRID","title":"<code>GRID = components_pb.ComponentCategory.COMPONENT_CATEGORY_GRID</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Grid component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.INVERTER","title":"<code>INVERTER = components_pb.ComponentCategory.COMPONENT_CATEGORY_INVERTER</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Inverter component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.METER","title":"<code>METER = components_pb.ComponentCategory.COMPONENT_CATEGORY_METER</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Meter component.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory.NONE","title":"<code>NONE = components_pb.ComponentCategory.COMPONENT_CATEGORY_UNSPECIFIED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unspecified component category.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData","title":"<code>frequenz.sdk.microgrid.component.ComponentData</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A private base class for strongly typed component data classes.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentData(ABC):\n\"\"\"A private base class for strongly typed component data classes.\"\"\"\ncomponent_id: int\n\"\"\"The ID identifying this component in the microgrid.\"\"\"\ntimestamp: datetime\n\"\"\"The timestamp of when the data was measured.\"\"\"\n# The `raw` attribute is excluded from the constructor as it can only be provided\n# when instantiating `ComponentData` using the `from_proto` method, which reads\n# data from a protobuf message. The whole protobuf message is stored as the `raw`\n# attribute. When `ComponentData` is not instantiated from a protobuf message,\n# i.e. using the constructor, `raw` will be set to `None`.\nraw: Optional[microgrid_pb.ComponentData] = field(default=None, init=False)\n\"\"\"Raw component data as decoded from the wire.\"\"\"\ndef _set_raw(self, raw: microgrid_pb.ComponentData) -&gt; None:\n\"\"\"Store raw protobuf message.\n        It is preferred to keep the dataclasses immutable (frozen) and make the `raw`\n            attribute read-only, which is why the approach of writing to `__dict__`\n            was used, instead of mutating the `self.raw = raw` attribute directly.\n        Args:\n            raw: raw component data as decoded from the wire.\n        \"\"\"\nself.__dict__[\"raw\"] = raw\n@classmethod\n@abstractmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; ComponentData:\n\"\"\"Create ComponentData from a protobuf message.\n        Args:\n            raw: raw component data as decoded from the wire.\n        Returns:\n            The instance created from the protobuf message.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.component_id","title":"<code>component_id: int</code>  <code>instance-attribute</code>","text":"<p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.raw","title":"<code>raw: Optional[microgrid_pb.ComponentData] = field(default=None, init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.timestamp","title":"<code>timestamp: datetime</code>  <code>instance-attribute</code>","text":"<p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData.from_proto","title":"<code>from_proto(raw)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create ComponentData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>ComponentData</code> <p>The instance created from the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; ComponentData:\n\"\"\"Create ComponentData from a protobuf message.\n    Args:\n        raw: raw component data as decoded from the wire.\n    Returns:\n        The instance created from the protobuf message.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetadata","title":"<code>frequenz.sdk.microgrid.component.ComponentMetadata</code>  <code>dataclass</code>","text":"<p>Base class for component metadata classes.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentMetadata:\n\"\"\"Base class for component metadata classes.\"\"\"\nfuse: Fuse | None = None\n\"\"\"The fuse at the grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetadata-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetadata.fuse","title":"<code>fuse: Fuse | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The fuse at the grid connection point.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId","title":"<code>frequenz.sdk.microgrid.component.ComponentMetricId</code>","text":"<p>             Bases: <code>Enum</code></p> <p>An enum representing the various metrics available in the microgrid.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class ComponentMetricId(Enum):\n\"\"\"An enum representing the various metrics available in the microgrid.\"\"\"\nACTIVE_POWER = \"active_power\"\n\"\"\"Active power.\"\"\"\nCURRENT_PHASE_1 = \"current_phase_1\"\n\"\"\"Current in phase 1.\"\"\"\nCURRENT_PHASE_2 = \"current_phase_2\"\n\"\"\"Current in phase 2.\"\"\"\nCURRENT_PHASE_3 = \"current_phase_3\"\n\"\"\"Current in phase 3.\"\"\"\nVOLTAGE_PHASE_1 = \"voltage_phase_1\"\n\"\"\"Voltage in phase 1.\"\"\"\nVOLTAGE_PHASE_2 = \"voltage_phase_2\"\n\"\"\"Voltage in phase 2.\"\"\"\nVOLTAGE_PHASE_3 = \"voltage_phase_3\"\n\"\"\"Voltage in phase 3.\"\"\"\nFREQUENCY = \"frequency\"\nSOC = \"soc\"\n\"\"\"State of charge.\"\"\"\nSOC_LOWER_BOUND = \"soc_lower_bound\"\n\"\"\"Lower bound of state of charge.\"\"\"\nSOC_UPPER_BOUND = \"soc_upper_bound\"\n\"\"\"Upper bound of state of charge.\"\"\"\nCAPACITY = \"capacity\"\n\"\"\"Capacity.\"\"\"\nPOWER_INCLUSION_LOWER_BOUND = \"power_inclusion_lower_bound\"\n\"\"\"Power inclusion lower bound.\"\"\"\nPOWER_EXCLUSION_LOWER_BOUND = \"power_exclusion_lower_bound\"\n\"\"\"Power exclusion lower bound.\"\"\"\nPOWER_EXCLUSION_UPPER_BOUND = \"power_exclusion_upper_bound\"\n\"\"\"Power exclusion upper bound.\"\"\"\nPOWER_INCLUSION_UPPER_BOUND = \"power_inclusion_upper_bound\"\n\"\"\"Power inclusion upper bound.\"\"\"\nACTIVE_POWER_INCLUSION_LOWER_BOUND = \"active_power_inclusion_lower_bound\"\n\"\"\"Active power inclusion lower bound.\"\"\"\nACTIVE_POWER_EXCLUSION_LOWER_BOUND = \"active_power_exclusion_lower_bound\"\n\"\"\"Active power exclusion lower bound.\"\"\"\nACTIVE_POWER_EXCLUSION_UPPER_BOUND = \"active_power_exclusion_upper_bound\"\n\"\"\"Active power exclusion upper bound.\"\"\"\nACTIVE_POWER_INCLUSION_UPPER_BOUND = \"active_power_inclusion_upper_bound\"\n\"\"\"Active power inclusion upper bound.\"\"\"\nTEMPERATURE = \"temperature\"\n\"\"\"Temperature.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER","title":"<code>ACTIVE_POWER = 'active_power'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Active power.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_EXCLUSION_LOWER_BOUND","title":"<code>ACTIVE_POWER_EXCLUSION_LOWER_BOUND = 'active_power_exclusion_lower_bound'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Active power exclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_EXCLUSION_UPPER_BOUND","title":"<code>ACTIVE_POWER_EXCLUSION_UPPER_BOUND = 'active_power_exclusion_upper_bound'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Active power exclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_INCLUSION_LOWER_BOUND","title":"<code>ACTIVE_POWER_INCLUSION_LOWER_BOUND = 'active_power_inclusion_lower_bound'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Active power inclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.ACTIVE_POWER_INCLUSION_UPPER_BOUND","title":"<code>ACTIVE_POWER_INCLUSION_UPPER_BOUND = 'active_power_inclusion_upper_bound'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Active power inclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CAPACITY","title":"<code>CAPACITY = 'capacity'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Capacity.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CURRENT_PHASE_1","title":"<code>CURRENT_PHASE_1 = 'current_phase_1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current in phase 1.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CURRENT_PHASE_2","title":"<code>CURRENT_PHASE_2 = 'current_phase_2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current in phase 2.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.CURRENT_PHASE_3","title":"<code>CURRENT_PHASE_3 = 'current_phase_3'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current in phase 3.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_EXCLUSION_LOWER_BOUND","title":"<code>POWER_EXCLUSION_LOWER_BOUND = 'power_exclusion_lower_bound'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Power exclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_EXCLUSION_UPPER_BOUND","title":"<code>POWER_EXCLUSION_UPPER_BOUND = 'power_exclusion_upper_bound'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Power exclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_INCLUSION_LOWER_BOUND","title":"<code>POWER_INCLUSION_LOWER_BOUND = 'power_inclusion_lower_bound'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Power inclusion lower bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.POWER_INCLUSION_UPPER_BOUND","title":"<code>POWER_INCLUSION_UPPER_BOUND = 'power_inclusion_upper_bound'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Power inclusion upper bound.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.SOC","title":"<code>SOC = 'soc'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>State of charge.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.SOC_LOWER_BOUND","title":"<code>SOC_LOWER_BOUND = 'soc_lower_bound'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Lower bound of state of charge.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.SOC_UPPER_BOUND","title":"<code>SOC_UPPER_BOUND = 'soc_upper_bound'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Upper bound of state of charge.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.TEMPERATURE","title":"<code>TEMPERATURE = 'temperature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Temperature.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.VOLTAGE_PHASE_1","title":"<code>VOLTAGE_PHASE_1 = 'voltage_phase_1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Voltage in phase 1.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.VOLTAGE_PHASE_2","title":"<code>VOLTAGE_PHASE_2 = 'voltage_phase_2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Voltage in phase 2.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId.VOLTAGE_PHASE_3","title":"<code>VOLTAGE_PHASE_3 = 'voltage_phase_3'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Voltage in phase 3.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState","title":"<code>frequenz.sdk.microgrid.component.EVChargerCableState</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Cable states of an EV Charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>class EVChargerCableState(Enum):\n\"\"\"Cable states of an EV Charger.\"\"\"\nUNSPECIFIED = ev_charger_pb.CableState.CABLE_STATE_UNSPECIFIED\n\"\"\"Unspecified cable state.\"\"\"\nUNPLUGGED = ev_charger_pb.CableState.CABLE_STATE_UNPLUGGED\n\"\"\"The cable is unplugged.\"\"\"\nCHARGING_STATION_PLUGGED = (\nev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_PLUGGED\n)\n\"\"\"The cable is plugged into the charging station.\"\"\"\nCHARGING_STATION_LOCKED = (\nev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_LOCKED\n)\n\"\"\"The cable is plugged into the charging station and locked.\"\"\"\nEV_PLUGGED = ev_charger_pb.CableState.CABLE_STATE_EV_PLUGGED\n\"\"\"The cable is plugged into the EV.\"\"\"\nEV_LOCKED = ev_charger_pb.CableState.CABLE_STATE_EV_LOCKED\n\"\"\"The cable is plugged into the EV and locked.\"\"\"\n@classmethod\ndef from_pb(\ncls, evc_state: ev_charger_pb.CableState.ValueType\n) -&gt; EVChargerCableState:\n\"\"\"Convert a protobuf CableState value to EVChargerCableState enum.\n        Args:\n            evc_state: protobuf cable state to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(t.value == evc_state for t in EVChargerCableState):\nreturn cls.UNSPECIFIED\nreturn EVChargerCableState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.CHARGING_STATION_LOCKED","title":"<code>CHARGING_STATION_LOCKED = ev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_LOCKED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cable is plugged into the charging station and locked.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.CHARGING_STATION_PLUGGED","title":"<code>CHARGING_STATION_PLUGGED = ev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_PLUGGED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cable is plugged into the charging station.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.EV_LOCKED","title":"<code>EV_LOCKED = ev_charger_pb.CableState.CABLE_STATE_EV_LOCKED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cable is plugged into the EV and locked.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.EV_PLUGGED","title":"<code>EV_PLUGGED = ev_charger_pb.CableState.CABLE_STATE_EV_PLUGGED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cable is plugged into the EV.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.UNPLUGGED","title":"<code>UNPLUGGED = ev_charger_pb.CableState.CABLE_STATE_UNPLUGGED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cable is unplugged.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.UNSPECIFIED","title":"<code>UNSPECIFIED = ev_charger_pb.CableState.CABLE_STATE_UNSPECIFIED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unspecified cable state.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState.from_pb","title":"<code>from_pb(evc_state)</code>  <code>classmethod</code>","text":"<p>Convert a protobuf CableState value to EVChargerCableState enum.</p> PARAMETER  DESCRIPTION <code>evc_state</code> <p>protobuf cable state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>EVChargerCableState</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, evc_state: ev_charger_pb.CableState.ValueType\n) -&gt; EVChargerCableState:\n\"\"\"Convert a protobuf CableState value to EVChargerCableState enum.\n    Args:\n        evc_state: protobuf cable state to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(t.value == evc_state for t in EVChargerCableState):\nreturn cls.UNSPECIFIED\nreturn EVChargerCableState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState","title":"<code>frequenz.sdk.microgrid.component.EVChargerComponentState</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Component State of an EV Charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>class EVChargerComponentState(Enum):\n\"\"\"Component State of an EV Charger.\"\"\"\nUNSPECIFIED = ev_charger_pb.ComponentState.COMPONENT_STATE_UNSPECIFIED\n\"\"\"Unspecified component state.\"\"\"\nSTARTING = ev_charger_pb.ComponentState.COMPONENT_STATE_STARTING\n\"\"\"The component is starting.\"\"\"\nNOT_READY = ev_charger_pb.ComponentState.COMPONENT_STATE_NOT_READY\n\"\"\"The component is not ready.\"\"\"\nREADY = ev_charger_pb.ComponentState.COMPONENT_STATE_READY\n\"\"\"The component is ready.\"\"\"\nCHARGING = ev_charger_pb.ComponentState.COMPONENT_STATE_CHARGING\n\"\"\"The component is charging.\"\"\"\nDISCHARGING = ev_charger_pb.ComponentState.COMPONENT_STATE_DISCHARGING\n\"\"\"The component is discharging.\"\"\"\nERROR = ev_charger_pb.ComponentState.COMPONENT_STATE_ERROR\n\"\"\"The component is in error state.\"\"\"\nAUTHORIZATION_REJECTED = (\nev_charger_pb.ComponentState.COMPONENT_STATE_AUTHORIZATION_REJECTED\n)\n\"\"\"The component rejected authorization.\"\"\"\nINTERRUPTED = ev_charger_pb.ComponentState.COMPONENT_STATE_INTERRUPTED\n\"\"\"The component is interrupted.\"\"\"\n@classmethod\ndef from_pb(\ncls, evc_state: ev_charger_pb.ComponentState.ValueType\n) -&gt; EVChargerComponentState:\n\"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum.\n        Args:\n            evc_state: protobuf component state to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(t.value == evc_state for t in EVChargerComponentState):\nreturn cls.UNSPECIFIED\nreturn EVChargerComponentState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.AUTHORIZATION_REJECTED","title":"<code>AUTHORIZATION_REJECTED = ev_charger_pb.ComponentState.COMPONENT_STATE_AUTHORIZATION_REJECTED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The component rejected authorization.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.CHARGING","title":"<code>CHARGING = ev_charger_pb.ComponentState.COMPONENT_STATE_CHARGING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The component is charging.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.DISCHARGING","title":"<code>DISCHARGING = ev_charger_pb.ComponentState.COMPONENT_STATE_DISCHARGING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The component is discharging.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.ERROR","title":"<code>ERROR = ev_charger_pb.ComponentState.COMPONENT_STATE_ERROR</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The component is in error state.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.INTERRUPTED","title":"<code>INTERRUPTED = ev_charger_pb.ComponentState.COMPONENT_STATE_INTERRUPTED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The component is interrupted.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.NOT_READY","title":"<code>NOT_READY = ev_charger_pb.ComponentState.COMPONENT_STATE_NOT_READY</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The component is not ready.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.READY","title":"<code>READY = ev_charger_pb.ComponentState.COMPONENT_STATE_READY</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The component is ready.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.STARTING","title":"<code>STARTING = ev_charger_pb.ComponentState.COMPONENT_STATE_STARTING</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The component is starting.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.UNSPECIFIED","title":"<code>UNSPECIFIED = ev_charger_pb.ComponentState.COMPONENT_STATE_UNSPECIFIED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unspecified component state.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState.from_pb","title":"<code>from_pb(evc_state)</code>  <code>classmethod</code>","text":"<p>Convert a protobuf ComponentState value to EVChargerComponentState enum.</p> PARAMETER  DESCRIPTION <code>evc_state</code> <p>protobuf component state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>EVChargerComponentState</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, evc_state: ev_charger_pb.ComponentState.ValueType\n) -&gt; EVChargerComponentState:\n\"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum.\n    Args:\n        evc_state: protobuf component state to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(t.value == evc_state for t in EVChargerComponentState):\nreturn cls.UNSPECIFIED\nreturn EVChargerComponentState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData","title":"<code>frequenz.sdk.microgrid.component.EVChargerData</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding ev_charger data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass EVChargerData(ComponentData):\n\"\"\"A wrapper class for holding ev_charger data.\"\"\"\nactive_power: float\n\"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n        +ve current means consumption, away from the grid.\n        -ve current means supply into the grid.\n    \"\"\"\ncurrent_per_phase: Tuple[float, float, float]\n\"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n        +ve current means consumption, away from the grid.\n        -ve current means supply into the grid.\n    \"\"\"\nvoltage_per_phase: Tuple[float, float, float]\n\"\"\"The AC voltage in Volts (V) between the line and the neutral\n        wire for phase/line 1,2 and 3 respectively.\n    \"\"\"\nfrequency: float\n\"\"\"AC frequency, in Hertz (Hz).\"\"\"\ncable_state: EVChargerCableState\n\"\"\"The state of the ev charger's cable.\"\"\"\ncomponent_state: EVChargerComponentState\n\"\"\"The state of the ev charger.\"\"\"\n@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; EVChargerData:\n\"\"\"Create EVChargerData from a protobuf message.\n        Args:\n            raw: raw component data as decoded from the wire.\n        Returns:\n            Instance of EVChargerData created from the protobuf message.\n        \"\"\"\nev_charger_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.ev_charger.data.ac.power_active.value,\ncurrent_per_phase=(\nraw.ev_charger.data.ac.phase_1.current.value,\nraw.ev_charger.data.ac.phase_2.current.value,\nraw.ev_charger.data.ac.phase_3.current.value,\n),\nvoltage_per_phase=(\nraw.ev_charger.data.ac.phase_1.voltage.value,\nraw.ev_charger.data.ac.phase_2.voltage.value,\nraw.ev_charger.data.ac.phase_3.voltage.value,\n),\ncable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\ncomponent_state=EVChargerComponentState.from_pb(\nraw.ev_charger.state.component_state\n),\nfrequency=raw.ev_charger.data.ac.frequency.value,\n)\nev_charger_data._set_raw(raw=raw)\nreturn ev_charger_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.active_power","title":"<code>active_power: float</code>  <code>instance-attribute</code>","text":"<p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.cable_state","title":"<code>cable_state: EVChargerCableState</code>  <code>instance-attribute</code>","text":"<p>The state of the ev charger's cable.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.component_state","title":"<code>component_state: EVChargerComponentState</code>  <code>instance-attribute</code>","text":"<p>The state of the ev charger.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.current_per_phase","title":"<code>current_per_phase: Tuple[float, float, float]</code>  <code>instance-attribute</code>","text":"<p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.frequency","title":"<code>frequency: float</code>  <code>instance-attribute</code>","text":"<p>AC frequency, in Hertz (Hz).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.voltage_per_phase","title":"<code>voltage_per_phase: Tuple[float, float, float]</code>  <code>instance-attribute</code>","text":"<p>The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData.from_proto","title":"<code>from_proto(raw)</code>  <code>classmethod</code>","text":"<p>Create EVChargerData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>EVChargerData</code> <p>Instance of EVChargerData created from the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; EVChargerData:\n\"\"\"Create EVChargerData from a protobuf message.\n    Args:\n        raw: raw component data as decoded from the wire.\n    Returns:\n        Instance of EVChargerData created from the protobuf message.\n    \"\"\"\nev_charger_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.ev_charger.data.ac.power_active.value,\ncurrent_per_phase=(\nraw.ev_charger.data.ac.phase_1.current.value,\nraw.ev_charger.data.ac.phase_2.current.value,\nraw.ev_charger.data.ac.phase_3.current.value,\n),\nvoltage_per_phase=(\nraw.ev_charger.data.ac.phase_1.voltage.value,\nraw.ev_charger.data.ac.phase_2.voltage.value,\nraw.ev_charger.data.ac.phase_3.voltage.value,\n),\ncable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\ncomponent_state=EVChargerComponentState.from_pb(\nraw.ev_charger.state.component_state\n),\nfrequency=raw.ev_charger.data.ac.frequency.value,\n)\nev_charger_data._set_raw(raw=raw)\nreturn ev_charger_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.GridMetadata","title":"<code>frequenz.sdk.microgrid.component.GridMetadata</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentMetadata</code></p> <p>Metadata for a grid connection point.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass GridMetadata(ComponentMetadata):\n\"\"\"Metadata for a grid connection point.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData","title":"<code>frequenz.sdk.microgrid.component.InverterData</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding inverter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass InverterData(ComponentData):\n\"\"\"A wrapper class for holding inverter data.\"\"\"\nactive_power: float\n\"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\n# pylint: disable=line-too-long\nactive_power_inclusion_lower_bound: float\n\"\"\"Lower inclusion bound for inverter power in watts.\n    This is the lower limit of the range within which power requests are allowed for the\n    inverter.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\nactive_power_exclusion_lower_bound: float\n\"\"\"Lower exclusion bound for inverter power in watts.\n    This is the lower limit of the range within which power requests are not allowed for\n    the inverter.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\nactive_power_inclusion_upper_bound: float\n\"\"\"Upper inclusion bound for inverter power in watts.\n    This is the upper limit of the range within which power requests are allowed for the\n    inverter.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\nactive_power_exclusion_upper_bound: float\n\"\"\"Upper exclusion bound for inverter power in watts.\n    This is the upper limit of the range within which power requests are not allowed for\n    the inverter.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n# pylint: enable=line-too-long\nfrequency: float\n\"\"\"AC frequency, in Hertz (Hz).\"\"\"\n_component_state: inverter_pb.ComponentState.ValueType\n\"\"\"State of the inverter.\"\"\"\n_errors: List[inverter_pb.Error]\n\"\"\"List of errors from the component.\"\"\"\n@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; InverterData:\n\"\"\"Create InverterData from a protobuf message.\n        Args:\n            raw: raw component data as decoded from the wire.\n        Returns:\n            Instance of InverterData created from the protobuf message.\n        \"\"\"\nraw_power = raw.inverter.data.ac.power_active\ninverter_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.inverter.data.ac.power_active.value,\nactive_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\nactive_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\nactive_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\nactive_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\nfrequency=raw.inverter.data.ac.frequency.value,\n_component_state=raw.inverter.state.component_state,\n_errors=list(raw.inverter.errors),\n)\ninverter_data._set_raw(raw=raw)\nreturn inverter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power","title":"<code>active_power: float</code>  <code>instance-attribute</code>","text":"<p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_exclusion_lower_bound","title":"<code>active_power_exclusion_lower_bound: float</code>  <code>instance-attribute</code>","text":"<p>Lower exclusion bound for inverter power in watts.</p> <p>This is the lower limit of the range within which power requests are not allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_exclusion_upper_bound","title":"<code>active_power_exclusion_upper_bound: float</code>  <code>instance-attribute</code>","text":"<p>Upper exclusion bound for inverter power in watts.</p> <p>This is the upper limit of the range within which power requests are not allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_inclusion_lower_bound","title":"<code>active_power_inclusion_lower_bound: float</code>  <code>instance-attribute</code>","text":"<p>Lower inclusion bound for inverter power in watts.</p> <p>This is the lower limit of the range within which power requests are allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.active_power_inclusion_upper_bound","title":"<code>active_power_inclusion_upper_bound: float</code>  <code>instance-attribute</code>","text":"<p>Upper inclusion bound for inverter power in watts.</p> <p>This is the upper limit of the range within which power requests are allowed for the inverter.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.frequency","title":"<code>frequency: float</code>  <code>instance-attribute</code>","text":"<p>AC frequency, in Hertz (Hz).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData.from_proto","title":"<code>from_proto(raw)</code>  <code>classmethod</code>","text":"<p>Create InverterData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>InverterData</code> <p>Instance of InverterData created from the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; InverterData:\n\"\"\"Create InverterData from a protobuf message.\n    Args:\n        raw: raw component data as decoded from the wire.\n    Returns:\n        Instance of InverterData created from the protobuf message.\n    \"\"\"\nraw_power = raw.inverter.data.ac.power_active\ninverter_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.inverter.data.ac.power_active.value,\nactive_power_inclusion_lower_bound=raw_power.system_inclusion_bounds.lower,\nactive_power_exclusion_lower_bound=raw_power.system_exclusion_bounds.lower,\nactive_power_inclusion_upper_bound=raw_power.system_inclusion_bounds.upper,\nactive_power_exclusion_upper_bound=raw_power.system_exclusion_bounds.upper,\nfrequency=raw.inverter.data.ac.frequency.value,\n_component_state=raw.inverter.state.component_state,\n_errors=list(raw.inverter.errors),\n)\ninverter_data._set_raw(raw=raw)\nreturn inverter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType","title":"<code>frequenz.sdk.microgrid.component.InverterType</code>","text":"<p>             Bases: <code>ComponentType</code></p> <p>Enum representing inverter types.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class InverterType(ComponentType):\n\"\"\"Enum representing inverter types.\"\"\"\nNONE = inverter_pb.Type.TYPE_UNSPECIFIED\n\"\"\"Unspecified inverter type.\"\"\"\nBATTERY = inverter_pb.Type.TYPE_BATTERY\n\"\"\"Battery inverter.\"\"\"\nSOLAR = inverter_pb.Type.TYPE_SOLAR\n\"\"\"Solar inverter.\"\"\"\nHYBRID = inverter_pb.Type.TYPE_HYBRID\n\"\"\"Hybrid inverter.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.BATTERY","title":"<code>BATTERY = inverter_pb.Type.TYPE_BATTERY</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Battery inverter.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.HYBRID","title":"<code>HYBRID = inverter_pb.Type.TYPE_HYBRID</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hybrid inverter.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.NONE","title":"<code>NONE = inverter_pb.Type.TYPE_UNSPECIFIED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unspecified inverter type.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType.SOLAR","title":"<code>SOLAR = inverter_pb.Type.TYPE_SOLAR</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Solar inverter.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData","title":"<code>frequenz.sdk.microgrid.component.MeterData</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ComponentData</code></p> <p>A wrapper class for holding meter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass MeterData(ComponentData):\n\"\"\"A wrapper class for holding meter data.\"\"\"\nactive_power: float\n\"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\ncurrent_per_phase: Tuple[float, float, float]\n\"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\nvoltage_per_phase: Tuple[float, float, float]\n\"\"\"The ac voltage in volts (v) between the line and the neutral wire for phase/line\n        1,2 and 3 respectively.\n    \"\"\"\nfrequency: float\n\"\"\"The AC power frequency in Hertz (Hz).\"\"\"\n@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; MeterData:\n\"\"\"Create MeterData from a protobuf message.\n        Args:\n            raw: raw component data as decoded from the wire.\n        Returns:\n            Instance of MeterData created from the protobuf message.\n        \"\"\"\nmeter_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.meter.data.ac.power_active.value,\ncurrent_per_phase=(\nraw.meter.data.ac.phase_1.current.value,\nraw.meter.data.ac.phase_2.current.value,\nraw.meter.data.ac.phase_3.current.value,\n),\nvoltage_per_phase=(\nraw.meter.data.ac.phase_1.voltage.value,\nraw.meter.data.ac.phase_2.voltage.value,\nraw.meter.data.ac.phase_3.voltage.value,\n),\nfrequency=raw.meter.data.ac.frequency.value,\n)\nmeter_data._set_raw(raw=raw)\nreturn meter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.active_power","title":"<code>active_power: float</code>  <code>instance-attribute</code>","text":"<p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.current_per_phase","title":"<code>current_per_phase: Tuple[float, float, float]</code>  <code>instance-attribute</code>","text":"<p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.frequency","title":"<code>frequency: float</code>  <code>instance-attribute</code>","text":"<p>The AC power frequency in Hertz (Hz).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.voltage_per_phase","title":"<code>voltage_per_phase: Tuple[float, float, float]</code>  <code>instance-attribute</code>","text":"<p>The ac voltage in volts (v) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData.from_proto","title":"<code>from_proto(raw)</code>  <code>classmethod</code>","text":"<p>Create MeterData from a protobuf message.</p> PARAMETER  DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>ComponentData</code> </p> RETURNS DESCRIPTION <code>MeterData</code> <p>Instance of MeterData created from the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; MeterData:\n\"\"\"Create MeterData from a protobuf message.\n    Args:\n        raw: raw component data as decoded from the wire.\n    Returns:\n        Instance of MeterData created from the protobuf message.\n    \"\"\"\nmeter_data = cls(\ncomponent_id=raw.id,\ntimestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\nactive_power=raw.meter.data.ac.power_active.value,\ncurrent_per_phase=(\nraw.meter.data.ac.phase_1.current.value,\nraw.meter.data.ac.phase_2.current.value,\nraw.meter.data.ac.phase_3.current.value,\n),\nvoltage_per_phase=(\nraw.meter.data.ac.phase_1.voltage.value,\nraw.meter.data.ac.phase_2.voltage.value,\nraw.meter.data.ac.phase_3.voltage.value,\n),\nfrequency=raw.meter.data.ac.frequency.value,\n)\nmeter_data._set_raw(raw=raw)\nreturn meter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/","title":"timeseries","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries","title":"<code>frequenz.sdk.timeseries</code>","text":"<p>Handling of timeseries streams.</p> <p>A timeseries is a stream (normally an async iterator) of <code>Sample</code>s.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries--periodicity-and-alignment","title":"Periodicity and alignment","text":"<p>All the data produced by this package is always periodic and aligned to the <code>UNIX_EPOCH</code> (by default).</p> <p>Classes normally take a (re)sampling period as and argument and, optionally, an <code>align_to</code> argument.</p> <p>This means timestamps are always separated exactly by a period, and that this timestamp falls always at multiples of the period, starting at the <code>align_to</code>.</p> <p>This ensures that the data is predictable and consistent among restarts.</p> Example <p>If we have a period of 10 seconds, and are aligning to the UNIX epoch. Assuming the following timeline starts in 1970-01-01 00:00:00 UTC and our current <code>now</code> is 1970-01-01 00:00:32 UTC, then the next timestamp will be at 1970-01-01 00:00:40 UTC:</p> <pre><code>align_to = 1970-01-01 00:00:00         next event = 1970-01-01 00:00:40\n|                                       |\n|---------|---------|---------|-|-------|---------|---------|---------|\n0        10        20        30 |      40        50        60        70\n                               now = 1970-01-01 00:00:32\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.UNIX_EPOCH","title":"<code>frequenz.sdk.timeseries.UNIX_EPOCH = datetime.fromtimestamp(0.0, tz=timezone.utc)</code>  <code>module-attribute</code>","text":"<p>The UNIX epoch (in UTC).</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current","title":"<code>frequenz.sdk.timeseries.Current</code>","text":"<p>             Bases: <code>Quantity</code></p> <p>A current quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Current(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={\n-3: \"mA\",\n0: \"A\",\n},\n):\n\"\"\"A current quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_amperes(cls, amperes: float) -&gt; Self:\n\"\"\"Initialize a new current quantity.\n        Args:\n            amperes: The current in amperes.\n        Returns:\n            A new current quantity.\n        \"\"\"\ncurrent = cls.__new__(cls)\ncurrent._base_value = amperes\nreturn current\n@classmethod\ndef from_milliamperes(cls, milliamperes: float) -&gt; Self:\n\"\"\"Initialize a new current quantity.\n        Args:\n            milliamperes: The current in milliamperes.\n        Returns:\n            A new current quantity.\n        \"\"\"\ncurrent = cls.__new__(cls)\ncurrent._base_value = milliamperes * 10**-3\nreturn current\ndef as_amperes(self) -&gt; float:\n\"\"\"Return the current in amperes.\n        Returns:\n            The current in amperes.\n        \"\"\"\nreturn self._base_value\ndef as_milliamperes(self) -&gt; float:\n\"\"\"Return the current in milliamperes.\n        Returns:\n            The current in milliamperes.\n        \"\"\"\nreturn self._base_value * 1e3\n@overload  # type: ignore\ndef __mul__(self, other: Percentage) -&gt; Self:\n\"\"\"Scale this current by a percentage.\n        Args:\n            other: The percentage by which to scale this current.\n        Returns:\n            The scaled current.\n        \"\"\"\n@overload\ndef __mul__(self, other: Voltage) -&gt; Power:\n\"\"\"Multiply the current by a voltage to get a power.\n        Args:\n            other: The voltage.\n        Returns:\n            The calculated power.\n        \"\"\"\ndef __mul__(self, other: Percentage | Voltage) -&gt; Self | Power:\n\"\"\"Return a current or power from multiplying this current by the given value.\n        Args:\n            other: The percentage or voltage to multiply by.\n        Returns:\n            A current or power.\n        \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, Voltage):\nreturn Power.from_watts(self._base_value * other._base_value)\nreturn NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Return a current or power from multiplying this current by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The percentage or voltage to multiply by.</p> <p> TYPE: <code>Percentage | Voltage</code> </p> RETURNS DESCRIPTION <code>Self | Power</code> <p>A current or power.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: Percentage | Voltage) -&gt; Self | Power:\n\"\"\"Return a current or power from multiplying this current by the given value.\n    Args:\n        other: The percentage or voltage to multiply by.\n    Returns:\n        A current or power.\n    \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, Voltage):\nreturn Power.from_watts(self._base_value * other._base_value)\nreturn NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.as_amperes","title":"<code>as_amperes()</code>","text":"<p>Return the current in amperes.</p> RETURNS DESCRIPTION <code>float</code> <p>The current in amperes.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_amperes(self) -&gt; float:\n\"\"\"Return the current in amperes.\n    Returns:\n        The current in amperes.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.as_milliamperes","title":"<code>as_milliamperes()</code>","text":"<p>Return the current in milliamperes.</p> RETURNS DESCRIPTION <code>float</code> <p>The current in milliamperes.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_milliamperes(self) -&gt; float:\n\"\"\"Return the current in milliamperes.\n    Returns:\n        The current in milliamperes.\n    \"\"\"\nreturn self._base_value * 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.from_amperes","title":"<code>from_amperes(amperes)</code>  <code>classmethod</code>","text":"<p>Initialize a new current quantity.</p> PARAMETER  DESCRIPTION <code>amperes</code> <p>The current in amperes.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new current quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_amperes(cls, amperes: float) -&gt; Self:\n\"\"\"Initialize a new current quantity.\n    Args:\n        amperes: The current in amperes.\n    Returns:\n        A new current quantity.\n    \"\"\"\ncurrent = cls.__new__(cls)\ncurrent._base_value = amperes\nreturn current\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Current.from_milliamperes","title":"<code>from_milliamperes(milliamperes)</code>  <code>classmethod</code>","text":"<p>Initialize a new current quantity.</p> PARAMETER  DESCRIPTION <code>milliamperes</code> <p>The current in milliamperes.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new current quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_milliamperes(cls, milliamperes: float) -&gt; Self:\n\"\"\"Initialize a new current quantity.\n    Args:\n        milliamperes: The current in milliamperes.\n    Returns:\n        A new current quantity.\n    \"\"\"\ncurrent = cls.__new__(cls)\ncurrent._base_value = milliamperes * 10**-3\nreturn current\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy","title":"<code>frequenz.sdk.timeseries.Energy</code>","text":"<p>             Bases: <code>Quantity</code></p> <p>An energy quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Energy(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={\n0: \"Wh\",\n3: \"kWh\",\n6: \"MWh\",\n},\n):\n\"\"\"An energy quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_watt_hours(cls, watt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n        Args:\n            watt_hours: The energy in watt hours.\n        Returns:\n            A new energy quantity.\n        \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = watt_hours\nreturn energy\n@classmethod\ndef from_kilowatt_hours(cls, kilowatt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n        Args:\n            kilowatt_hours: The energy in kilowatt hours.\n        Returns:\n            A new energy quantity.\n        \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = kilowatt_hours * 10**3\nreturn energy\n@classmethod\ndef from_megawatt_hours(cls, megawatt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n        Args:\n            megawatt_hours: The energy in megawatt hours.\n        Returns:\n            A new energy quantity.\n        \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = megawatt_hours * 10**6\nreturn energy\ndef as_watt_hours(self) -&gt; float:\n\"\"\"Return the energy in watt hours.\n        Returns:\n            The energy in watt hours.\n        \"\"\"\nreturn self._base_value\ndef as_kilowatt_hours(self) -&gt; float:\n\"\"\"Return the energy in kilowatt hours.\n        Returns:\n            The energy in kilowatt hours.\n        \"\"\"\nreturn self._base_value / 1e3\ndef as_megawatt_hours(self) -&gt; float:\n\"\"\"Return the energy in megawatt hours.\n        Returns:\n            The energy in megawatt hours.\n        \"\"\"\nreturn self._base_value / 1e6\n@overload\ndef __truediv__(self, other: timedelta) -&gt; Power:\n\"\"\"Return a power from dividing this energy by the given duration.\n        Args:\n            other: The duration to divide by.\n        Returns:\n            A power from dividing this energy by the given duration.\n        \"\"\"\n@overload\ndef __truediv__(self, other: Power) -&gt; timedelta:\n\"\"\"Return a duration from dividing this energy by the given power.\n        Args:\n            other: The power to divide by.\n        Returns:\n            A duration from dividing this energy by the given power.\n        \"\"\"\ndef __truediv__(self, other: timedelta | Power) -&gt; Power | timedelta:\n\"\"\"Return a power or duration from dividing this energy by the given value.\n        Args:\n            other: The power or duration to divide by.\n        Returns:\n            A power or duration from dividing this energy by the given value.\n        Raises:\n            TypeError: If the given value is not a power or duration.\n        \"\"\"\nif isinstance(other, timedelta):\nreturn Power.from_watts(self._base_value / (other.total_seconds() / 3600.0))\nif isinstance(other, Power):\nreturn timedelta(seconds=(self._base_value / other._base_value) * 3600.0)\nraise TypeError(\nf\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Return a power or duration from dividing this energy by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The power or duration to divide by.</p> <p> TYPE: <code>timedelta | Power</code> </p> RETURNS DESCRIPTION <code>Power | timedelta</code> <p>A power or duration from dividing this energy by the given value.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given value is not a power or duration.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, other: timedelta | Power) -&gt; Power | timedelta:\n\"\"\"Return a power or duration from dividing this energy by the given value.\n    Args:\n        other: The power or duration to divide by.\n    Returns:\n        A power or duration from dividing this energy by the given value.\n    Raises:\n        TypeError: If the given value is not a power or duration.\n    \"\"\"\nif isinstance(other, timedelta):\nreturn Power.from_watts(self._base_value / (other.total_seconds() / 3600.0))\nif isinstance(other, Power):\nreturn timedelta(seconds=(self._base_value / other._base_value) * 3600.0)\nraise TypeError(\nf\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_kilowatt_hours","title":"<code>as_kilowatt_hours()</code>","text":"<p>Return the energy in kilowatt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in kilowatt hours.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilowatt_hours(self) -&gt; float:\n\"\"\"Return the energy in kilowatt hours.\n    Returns:\n        The energy in kilowatt hours.\n    \"\"\"\nreturn self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_megawatt_hours","title":"<code>as_megawatt_hours()</code>","text":"<p>Return the energy in megawatt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in megawatt hours.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megawatt_hours(self) -&gt; float:\n\"\"\"Return the energy in megawatt hours.\n    Returns:\n        The energy in megawatt hours.\n    \"\"\"\nreturn self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.as_watt_hours","title":"<code>as_watt_hours()</code>","text":"<p>Return the energy in watt hours.</p> RETURNS DESCRIPTION <code>float</code> <p>The energy in watt hours.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_watt_hours(self) -&gt; float:\n\"\"\"Return the energy in watt hours.\n    Returns:\n        The energy in watt hours.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_kilowatt_hours","title":"<code>from_kilowatt_hours(kilowatt_hours)</code>  <code>classmethod</code>","text":"<p>Initialize a new energy quantity.</p> PARAMETER  DESCRIPTION <code>kilowatt_hours</code> <p>The energy in kilowatt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilowatt_hours(cls, kilowatt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n    Args:\n        kilowatt_hours: The energy in kilowatt hours.\n    Returns:\n        A new energy quantity.\n    \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = kilowatt_hours * 10**3\nreturn energy\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_megawatt_hours","title":"<code>from_megawatt_hours(megawatt_hours)</code>  <code>classmethod</code>","text":"<p>Initialize a new energy quantity.</p> PARAMETER  DESCRIPTION <code>megawatt_hours</code> <p>The energy in megawatt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megawatt_hours(cls, megawatt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n    Args:\n        megawatt_hours: The energy in megawatt hours.\n    Returns:\n        A new energy quantity.\n    \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = megawatt_hours * 10**6\nreturn energy\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Energy.from_watt_hours","title":"<code>from_watt_hours(watt_hours)</code>  <code>classmethod</code>","text":"<p>Initialize a new energy quantity.</p> PARAMETER  DESCRIPTION <code>watt_hours</code> <p>The energy in watt hours.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new energy quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_watt_hours(cls, watt_hours: float) -&gt; Self:\n\"\"\"Initialize a new energy quantity.\n    Args:\n        watt_hours: The energy in watt hours.\n    Returns:\n        A new energy quantity.\n    \"\"\"\nenergy = cls.__new__(cls)\nenergy._base_value = watt_hours\nreturn energy\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency","title":"<code>frequenz.sdk.timeseries.Frequency</code>","text":"<p>             Bases: <code>Quantity</code></p> <p>A frequency quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Frequency(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={0: \"Hz\", 3: \"kHz\", 6: \"MHz\", 9: \"GHz\"},\n):\n\"\"\"A frequency quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_hertz(cls, hertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n        Args:\n            hertz: The frequency in hertz.\n        Returns:\n            A new frequency quantity.\n        \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = hertz\nreturn frequency\n@classmethod\ndef from_kilohertz(cls, kilohertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n        Args:\n            kilohertz: The frequency in kilohertz.\n        Returns:\n            A new frequency quantity.\n        \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = kilohertz * 10**3\nreturn frequency\n@classmethod\ndef from_megahertz(cls, megahertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n        Args:\n            megahertz: The frequency in megahertz.\n        Returns:\n            A new frequency quantity.\n        \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = megahertz * 10**6\nreturn frequency\n@classmethod\ndef from_gigahertz(cls, gigahertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n        Args:\n            gigahertz: The frequency in gigahertz.\n        Returns:\n            A new frequency quantity.\n        \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = gigahertz * 10**9\nreturn frequency\ndef as_hertz(self) -&gt; float:\n\"\"\"Return the frequency in hertz.\n        Returns:\n            The frequency in hertz.\n        \"\"\"\nreturn self._base_value\ndef as_kilohertz(self) -&gt; float:\n\"\"\"Return the frequency in kilohertz.\n        Returns:\n            The frequency in kilohertz.\n        \"\"\"\nreturn self._base_value / 1e3\ndef as_megahertz(self) -&gt; float:\n\"\"\"Return the frequency in megahertz.\n        Returns:\n            The frequency in megahertz.\n        \"\"\"\nreturn self._base_value / 1e6\ndef as_gigahertz(self) -&gt; float:\n\"\"\"Return the frequency in gigahertz.\n        Returns:\n            The frequency in gigahertz.\n        \"\"\"\nreturn self._base_value / 1e9\ndef period(self) -&gt; timedelta:\n\"\"\"Return the period of the frequency.\n        Returns:\n            The period of the frequency.\n        \"\"\"\nreturn timedelta(seconds=1.0 / self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_gigahertz","title":"<code>as_gigahertz()</code>","text":"<p>Return the frequency in gigahertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in gigahertz.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_gigahertz(self) -&gt; float:\n\"\"\"Return the frequency in gigahertz.\n    Returns:\n        The frequency in gigahertz.\n    \"\"\"\nreturn self._base_value / 1e9\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_hertz","title":"<code>as_hertz()</code>","text":"<p>Return the frequency in hertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in hertz.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_hertz(self) -&gt; float:\n\"\"\"Return the frequency in hertz.\n    Returns:\n        The frequency in hertz.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_kilohertz","title":"<code>as_kilohertz()</code>","text":"<p>Return the frequency in kilohertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in kilohertz.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilohertz(self) -&gt; float:\n\"\"\"Return the frequency in kilohertz.\n    Returns:\n        The frequency in kilohertz.\n    \"\"\"\nreturn self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.as_megahertz","title":"<code>as_megahertz()</code>","text":"<p>Return the frequency in megahertz.</p> RETURNS DESCRIPTION <code>float</code> <p>The frequency in megahertz.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megahertz(self) -&gt; float:\n\"\"\"Return the frequency in megahertz.\n    Returns:\n        The frequency in megahertz.\n    \"\"\"\nreturn self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_gigahertz","title":"<code>from_gigahertz(gigahertz)</code>  <code>classmethod</code>","text":"<p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>gigahertz</code> <p>The frequency in gigahertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_gigahertz(cls, gigahertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n    Args:\n        gigahertz: The frequency in gigahertz.\n    Returns:\n        A new frequency quantity.\n    \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = gigahertz * 10**9\nreturn frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_hertz","title":"<code>from_hertz(hertz)</code>  <code>classmethod</code>","text":"<p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>hertz</code> <p>The frequency in hertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_hertz(cls, hertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n    Args:\n        hertz: The frequency in hertz.\n    Returns:\n        A new frequency quantity.\n    \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = hertz\nreturn frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_kilohertz","title":"<code>from_kilohertz(kilohertz)</code>  <code>classmethod</code>","text":"<p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>kilohertz</code> <p>The frequency in kilohertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilohertz(cls, kilohertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n    Args:\n        kilohertz: The frequency in kilohertz.\n    Returns:\n        A new frequency quantity.\n    \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = kilohertz * 10**3\nreturn frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.from_megahertz","title":"<code>from_megahertz(megahertz)</code>  <code>classmethod</code>","text":"<p>Initialize a new frequency quantity.</p> PARAMETER  DESCRIPTION <code>megahertz</code> <p>The frequency in megahertz.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new frequency quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megahertz(cls, megahertz: float) -&gt; Self:\n\"\"\"Initialize a new frequency quantity.\n    Args:\n        megahertz: The frequency in megahertz.\n    Returns:\n        A new frequency quantity.\n    \"\"\"\nfrequency = cls.__new__(cls)\nfrequency._base_value = megahertz * 10**6\nreturn frequency\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Frequency.period","title":"<code>period()</code>","text":"<p>Return the period of the frequency.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The period of the frequency.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def period(self) -&gt; timedelta:\n\"\"\"Return the period of the frequency.\n    Returns:\n        The period of the frequency.\n    \"\"\"\nreturn timedelta(seconds=1.0 / self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow","title":"<code>frequenz.sdk.timeseries.MovingWindow</code>","text":"<p>             Bases: <code>BackgroundService</code></p> <p>A data window that moves with the latest datapoints of a data stream.</p> <p>After initialization the <code>MovingWindow</code> can be accessed by an integer index or a timestamp. A sub window can be accessed by using a slice of integers or timestamps.</p> <p>Note that a numpy ndarray is returned and thus users can use numpys operations directly on a window.</p> <p>The window uses a ring buffer for storage and the first element is aligned to a fixed defined point in time. Since the moving nature of the window, the date of the first and the last element are constantly changing and therefore the point in time that defines the alignment can be outside of the time window. Modulo arithmetic is used to move the <code>align_to</code> timestamp into the latest window.</p> <p>If for example the <code>align_to</code> parameter is set to <code>datetime(1, 1, 1, tzinfo=timezone.utc)</code> and the window size is bigger than one day then the first element will always be aligned to midnight.</p> <p>Resampling might be required to reduce the number of samples to store, and it can be set by specifying the resampler config parameter so that the user can control the granularity of the samples to be stored in the underlying buffer.</p> <p>If resampling is not required, the resampler config parameter can be set to None in which case the MovingWindow will not perform any resampling.</p> <p>Example: Calculate the mean of a time interval</p> <pre><code>```python\nfrom datetime import datetime, timedelta, timezone\n\nasync def send_mock_data(sender: Sender[Sample]) -&gt; None:\n    while True:\n        await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n        await asyncio.sleep(1.0)\n\nasync def run() -&gt; None:\n    resampled_data_channel = Broadcast[Sample](\"sample-data\")\n    resampled_data_receiver = resampled_data_channel.new_receiver()\n    resampled_data_sender = resampled_data_channel.new_sender()\n\n    send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n    async with MovingWindow(\n        size=timedelta(seconds=5),\n        resampled_data_recv=resampled_data_receiver,\n        input_sampling_period=timedelta(seconds=1),\n    ) as window:\n        time_start = datetime.now(tz=timezone.utc)\n        time_end = time_start + timedelta(seconds=5)\n\n        # ... wait for 5 seconds until the buffer is filled\n        await asyncio.sleep(5)\n\n        # return an numpy array from the window\n        array = window[time_start:time_end]\n        # and use it to for example calculate the mean\n        mean = array.mean()\n\nasyncio.run(run())\n```\n</code></pre> <p>Example: Create a polars data frame from a <code>MovingWindow</code></p> <pre><code>```python\nimport polars as pl\nfrom datetime import datetime, timedelta, timezone\n\nasync def send_mock_data(sender: Sender[Sample]) -&gt; None:\n    while True:\n        await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n        await asyncio.sleep(1.0)\n\nasync def run() -&gt; None:\n    resampled_data_channel = Broadcast[Sample](\"sample-data\")\n    resampled_data_receiver = resampled_data_channel.new_receiver()\n    resampled_data_sender = resampled_data_channel.new_sender()\n\n    send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n    # create a window that stores two days of data\n    # starting at 1.1.23 with samplerate=1\n    async with MovingWindow(\n        size=timedelta(days=2),\n        resampled_data_recv=resampled_data_receiver,\n        input_sampling_period=timedelta(seconds=1),\n    ) as window:\n        # wait for one full day until the buffer is filled\n        await asyncio.sleep(60*60*24)\n\n        # create a polars series with one full day of data\n        time_start = datetime(2023, 1, 1, tzinfo=timezone.utc)\n        time_end = datetime(2023, 1, 2, tzinfo=timezone.utc)\n        series = pl.Series(\"Jan_1\", window[time_start:time_end])\n\nasyncio.run(run())\n```\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>class MovingWindow(BackgroundService):\n\"\"\"\n    A data window that moves with the latest datapoints of a data stream.\n    After initialization the `MovingWindow` can be accessed by an integer\n    index or a timestamp. A sub window can be accessed by using a slice of\n    integers or timestamps.\n    Note that a numpy ndarray is returned and thus users can use\n    numpys operations directly on a window.\n    The window uses a ring buffer for storage and the first element is aligned to\n    a fixed defined point in time. Since the moving nature of the window, the\n    date of the first and the last element are constantly changing and therefore\n    the point in time that defines the alignment can be outside of the time window.\n    Modulo arithmetic is used to move the `align_to` timestamp into the latest\n    window.\n    If for example the `align_to` parameter is set to\n    `datetime(1, 1, 1, tzinfo=timezone.utc)` and the window size is bigger than\n    one day then the first element will always be aligned to midnight.\n    Resampling might be required to reduce the number of samples to store, and\n    it can be set by specifying the resampler config parameter so that the user\n    can control the granularity of the samples to be stored in the underlying\n    buffer.\n    If resampling is not required, the resampler config parameter can be\n    set to None in which case the MovingWindow will not perform any resampling.\n    Example: Calculate the mean of a time interval\n        ```python\n        from datetime import datetime, timedelta, timezone\n        async def send_mock_data(sender: Sender[Sample]) -&gt; None:\n            while True:\n                await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n                await asyncio.sleep(1.0)\n        async def run() -&gt; None:\n            resampled_data_channel = Broadcast[Sample](\"sample-data\")\n            resampled_data_receiver = resampled_data_channel.new_receiver()\n            resampled_data_sender = resampled_data_channel.new_sender()\n            send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n            async with MovingWindow(\n                size=timedelta(seconds=5),\n                resampled_data_recv=resampled_data_receiver,\n                input_sampling_period=timedelta(seconds=1),\n            ) as window:\n                time_start = datetime.now(tz=timezone.utc)\n                time_end = time_start + timedelta(seconds=5)\n                # ... wait for 5 seconds until the buffer is filled\n                await asyncio.sleep(5)\n                # return an numpy array from the window\n                array = window[time_start:time_end]\n                # and use it to for example calculate the mean\n                mean = array.mean()\n        asyncio.run(run())\n        ```\n    Example: Create a polars data frame from a `MovingWindow`\n        ```python\n        import polars as pl\n        from datetime import datetime, timedelta, timezone\n        async def send_mock_data(sender: Sender[Sample]) -&gt; None:\n            while True:\n                await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n                await asyncio.sleep(1.0)\n        async def run() -&gt; None:\n            resampled_data_channel = Broadcast[Sample](\"sample-data\")\n            resampled_data_receiver = resampled_data_channel.new_receiver()\n            resampled_data_sender = resampled_data_channel.new_sender()\n            send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n            # create a window that stores two days of data\n            # starting at 1.1.23 with samplerate=1\n            async with MovingWindow(\n                size=timedelta(days=2),\n                resampled_data_recv=resampled_data_receiver,\n                input_sampling_period=timedelta(seconds=1),\n            ) as window:\n                # wait for one full day until the buffer is filled\n                await asyncio.sleep(60*60*24)\n                # create a polars series with one full day of data\n                time_start = datetime(2023, 1, 1, tzinfo=timezone.utc)\n                time_end = datetime(2023, 1, 2, tzinfo=timezone.utc)\n                series = pl.Series(\"Jan_1\", window[time_start:time_end])\n        asyncio.run(run())\n        ```\n    \"\"\"\ndef __init__(  # pylint: disable=too-many-arguments\nself,\nsize: timedelta,\nresampled_data_recv: Receiver[Sample[Quantity]],\ninput_sampling_period: timedelta,\nresampler_config: ResamplerConfig | None = None,\nalign_to: datetime = UNIX_EPOCH,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"\n        Initialize the MovingWindow.\n        This method creates the underlying ring buffer and starts a\n        new task that updates the ring buffer with new incoming samples.\n        The task stops running only if the channel receiver is closed.\n        Args:\n            size: The time span of the moving window over which samples will be stored.\n            resampled_data_recv: A receiver that delivers samples with a\n                given sampling period.\n            input_sampling_period: The time interval between consecutive input samples.\n            resampler_config: The resampler configuration in case resampling is required.\n            align_to: A datetime object that defines a point in time to which\n                the window is aligned to modulo window size. For further\n                information, consult the class level documentation.\n            name: The name of this moving window. If `None`, `str(id(self))` will be\n                used. This is used mostly for debugging purposes.\n        \"\"\"\nassert (\ninput_sampling_period.total_seconds() &gt; 0\n), \"The input sampling period should be greater than zero.\"\nassert (\ninput_sampling_period &lt;= size\n), \"The input sampling period should be equal to or lower than the window size.\"\nsuper().__init__(name=name)\nself._sampling_period = input_sampling_period\nself._resampler: Resampler | None = None\nself._resampler_sender: Sender[Sample[Quantity]] | None = None\nif resampler_config:\nassert (\nresampler_config.resampling_period &lt;= size\n), \"The resampling period should be equal to or lower than the window size.\"\nself._resampler = Resampler(resampler_config)\nself._sampling_period = resampler_config.resampling_period\n# Sampling period might not fit perfectly into the window size.\nnum_samples = math.ceil(\nsize.total_seconds() / self._sampling_period.total_seconds()\n)\nself._resampled_data_recv = resampled_data_recv\nself._buffer = OrderedRingBuffer(\nnp.empty(shape=num_samples, dtype=float),\nsampling_period=self._sampling_period,\nalign_to=align_to,\n)\ndef start(self) -&gt; None:\n\"\"\"Start the MovingWindow.\n        This method starts the MovingWindow tasks.\n        \"\"\"\nif self._resampler:\nself._configure_resampler()\nself._tasks.add(asyncio.create_task(self._run_impl(), name=\"update-window\"))\n@property\ndef sampling_period(self) -&gt; timedelta:\n\"\"\"\n        Return the sampling period of the MovingWindow.\n        Returns:\n            The sampling period of the MovingWindow.\n        \"\"\"\nreturn self._sampling_period\nasync def _run_impl(self) -&gt; None:\n\"\"\"Awaits samples from the receiver and updates the underlying ring buffer.\n        Raises:\n            asyncio.CancelledError: if the MovingWindow task is cancelled.\n        \"\"\"\ntry:\nasync for sample in self._resampled_data_recv:\n_logger.debug(\"Received new sample: %s\", sample)\nif self._resampler and self._resampler_sender:\nawait self._resampler_sender.send(sample)\nelse:\nself._buffer.update(sample)\nexcept asyncio.CancelledError:\n_logger.info(\"MovingWindow task has been cancelled.\")\nraise\n_logger.error(\"Channel has been closed\")\ndef _configure_resampler(self) -&gt; None:\n\"\"\"Configure the components needed to run the resampler.\"\"\"\nassert self._resampler is not None\nasync def sink_buffer(sample: Sample[Quantity]) -&gt; None:\nif sample.value is not None:\nself._buffer.update(sample)\nresampler_channel = Broadcast[Sample[Quantity]](\"average\")\nself._resampler_sender = resampler_channel.new_sender()\nself._resampler.add_timeseries(\n\"avg\", resampler_channel.new_receiver(), sink_buffer\n)\nself._tasks.add(\nasyncio.create_task(self._resampler.resample(), name=\"resample\")\n)\ndef __len__(self) -&gt; int:\n\"\"\"\n        Return the size of the `MovingWindow`s underlying buffer.\n        Returns:\n            The size of the `MovingWindow`.\n        \"\"\"\nreturn len(self._buffer)\n@overload\ndef __getitem__(self, key: SupportsIndex) -&gt; float:\n\"\"\"See the main __getitem__ method.\n        [//]: # (# noqa: DAR101 key)\n        \"\"\"\n@overload\ndef __getitem__(self, key: datetime) -&gt; float:\n\"\"\"See the main __getitem__ method.\n        [//]: # (# noqa: DAR101 key)\n        \"\"\"\n@overload\ndef __getitem__(self, key: slice) -&gt; ArrayLike:\n\"\"\"See the main __getitem__ method.\n        [//]: # (# noqa: DAR101 key)\n        \"\"\"\ndef __getitem__(self, key: SupportsIndex | datetime | slice) -&gt; float | ArrayLike:\n\"\"\"\n        Return a sub window of the `MovingWindow`.\n        The `MovingWindow` is accessed either by timestamp or by index\n        or by a slice of timestamps or integers.\n        * If the key is an integer, the float value of that key\n          at the given position is returned.\n        * If the key is a datetime object, the float value of that key\n          that corresponds to the timestamp is returned.\n        * If the key is a slice of timestamps or integers, an ndarray is returned,\n          where the bounds correspond to the slice bounds.\n          Note that a half open interval, which is open at the end, is returned.\n        Args:\n            key: Either an integer or a timestamp or a slice of timestamps or integers.\n        Raises:\n            IndexError: when requesting an out of range timestamp or index\n            TypeError: when the key is not a datetime or slice object.\n        Returns:\n            A float if the key is a number or a timestamp.\n            an numpy array if the key is a slice.\n        \"\"\"\nif len(self._buffer) == 0:\nraise IndexError(\"The buffer is empty.\")\nif isinstance(key, slice):\nif isinstance(key.start, int) or isinstance(key.stop, int):\nif key.start is None or key.stop is None:\nkey = slice(slice(key.start, key.stop).indices(self.__len__()))\nelif isinstance(key.start, datetime) or isinstance(key.stop, datetime):\nif key.start is None:\nkey = slice(self._buffer.time_bound_oldest, key.stop)\nif key.stop is None:\nkey = slice(key.start, self._buffer.time_bound_newest)\n_logger.debug(\"Returning slice for [%s:%s].\", key.start, key.stop)\n# we are doing runtime typechecks since there is no abstract slice type yet\n# see also (https://peps.python.org/pep-0696)\nif isinstance(key.start, datetime) and isinstance(key.stop, datetime):\nreturn self._buffer.window(key.start, key.stop)\nif isinstance(key.start, int) and isinstance(key.stop, int):\nreturn self._buffer[key]\nelif isinstance(key, datetime):\n_logger.debug(\"Returning value at time %s \", key)\nreturn self._buffer[self._buffer.datetime_to_index(key)]\nelif isinstance(key, SupportsIndex):\n_logger.debug(\"Returning value at index %s \", key)\nreturn self._buffer[key]\nraise TypeError(\n\"Key has to be either a timestamp or an integer \"\n\"or a slice of timestamps or integers\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.sampling_period","title":"<code>sampling_period: timedelta</code>  <code>property</code>","text":"<p>Return the sampling period of the MovingWindow.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The sampling period of the MovingWindow.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Return a sub window of the <code>MovingWindow</code>.</p> <p>The <code>MovingWindow</code> is accessed either by timestamp or by index or by a slice of timestamps or integers.</p> <ul> <li>If the key is an integer, the float value of that key   at the given position is returned.</li> <li>If the key is a datetime object, the float value of that key   that corresponds to the timestamp is returned.</li> <li>If the key is a slice of timestamps or integers, an ndarray is returned,   where the bounds correspond to the slice bounds.   Note that a half open interval, which is open at the end, is returned.</li> </ul> PARAMETER  DESCRIPTION <code>key</code> <p>Either an integer or a timestamp or a slice of timestamps or integers.</p> <p> TYPE: <code>SupportsIndex | datetime | slice</code> </p> RAISES DESCRIPTION <code>IndexError</code> <p>when requesting an out of range timestamp or index</p> <code>TypeError</code> <p>when the key is not a datetime or slice object.</p> RETURNS DESCRIPTION <code>float | ArrayLike</code> <p>A float if the key is a number or a timestamp.</p> <code>float | ArrayLike</code> <p>an numpy array if the key is a slice.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __getitem__(self, key: SupportsIndex | datetime | slice) -&gt; float | ArrayLike:\n\"\"\"\n    Return a sub window of the `MovingWindow`.\n    The `MovingWindow` is accessed either by timestamp or by index\n    or by a slice of timestamps or integers.\n    * If the key is an integer, the float value of that key\n      at the given position is returned.\n    * If the key is a datetime object, the float value of that key\n      that corresponds to the timestamp is returned.\n    * If the key is a slice of timestamps or integers, an ndarray is returned,\n      where the bounds correspond to the slice bounds.\n      Note that a half open interval, which is open at the end, is returned.\n    Args:\n        key: Either an integer or a timestamp or a slice of timestamps or integers.\n    Raises:\n        IndexError: when requesting an out of range timestamp or index\n        TypeError: when the key is not a datetime or slice object.\n    Returns:\n        A float if the key is a number or a timestamp.\n        an numpy array if the key is a slice.\n    \"\"\"\nif len(self._buffer) == 0:\nraise IndexError(\"The buffer is empty.\")\nif isinstance(key, slice):\nif isinstance(key.start, int) or isinstance(key.stop, int):\nif key.start is None or key.stop is None:\nkey = slice(slice(key.start, key.stop).indices(self.__len__()))\nelif isinstance(key.start, datetime) or isinstance(key.stop, datetime):\nif key.start is None:\nkey = slice(self._buffer.time_bound_oldest, key.stop)\nif key.stop is None:\nkey = slice(key.start, self._buffer.time_bound_newest)\n_logger.debug(\"Returning slice for [%s:%s].\", key.start, key.stop)\n# we are doing runtime typechecks since there is no abstract slice type yet\n# see also (https://peps.python.org/pep-0696)\nif isinstance(key.start, datetime) and isinstance(key.stop, datetime):\nreturn self._buffer.window(key.start, key.stop)\nif isinstance(key.start, int) and isinstance(key.stop, int):\nreturn self._buffer[key]\nelif isinstance(key, datetime):\n_logger.debug(\"Returning value at time %s \", key)\nreturn self._buffer[self._buffer.datetime_to_index(key)]\nelif isinstance(key, SupportsIndex):\n_logger.debug(\"Returning value at index %s \", key)\nreturn self._buffer[key]\nraise TypeError(\n\"Key has to be either a timestamp or an integer \"\n\"or a slice of timestamps or integers\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__init__","title":"<code>__init__(size, resampled_data_recv, input_sampling_period, resampler_config=None, align_to=UNIX_EPOCH, *, name=None)</code>","text":"<p>Initialize the MovingWindow.</p> <p>This method creates the underlying ring buffer and starts a new task that updates the ring buffer with new incoming samples. The task stops running only if the channel receiver is closed.</p> PARAMETER  DESCRIPTION <code>size</code> <p>The time span of the moving window over which samples will be stored.</p> <p> TYPE: <code>timedelta</code> </p> <code>resampled_data_recv</code> <p>A receiver that delivers samples with a given sampling period.</p> <p> TYPE: <code>Receiver[Sample[Quantity]]</code> </p> <code>input_sampling_period</code> <p>The time interval between consecutive input samples.</p> <p> TYPE: <code>timedelta</code> </p> <code>resampler_config</code> <p>The resampler configuration in case resampling is required.</p> <p> TYPE: <code>ResamplerConfig | None</code> DEFAULT: <code>None</code> </p> <code>align_to</code> <p>A datetime object that defines a point in time to which the window is aligned to modulo window size. For further information, consult the class level documentation.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>UNIX_EPOCH</code> </p> <code>name</code> <p>The name of this moving window. If <code>None</code>, <code>str(id(self))</code> will be used. This is used mostly for debugging purposes.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\nself,\nsize: timedelta,\nresampled_data_recv: Receiver[Sample[Quantity]],\ninput_sampling_period: timedelta,\nresampler_config: ResamplerConfig | None = None,\nalign_to: datetime = UNIX_EPOCH,\n*,\nname: str | None = None,\n) -&gt; None:\n\"\"\"\n    Initialize the MovingWindow.\n    This method creates the underlying ring buffer and starts a\n    new task that updates the ring buffer with new incoming samples.\n    The task stops running only if the channel receiver is closed.\n    Args:\n        size: The time span of the moving window over which samples will be stored.\n        resampled_data_recv: A receiver that delivers samples with a\n            given sampling period.\n        input_sampling_period: The time interval between consecutive input samples.\n        resampler_config: The resampler configuration in case resampling is required.\n        align_to: A datetime object that defines a point in time to which\n            the window is aligned to modulo window size. For further\n            information, consult the class level documentation.\n        name: The name of this moving window. If `None`, `str(id(self))` will be\n            used. This is used mostly for debugging purposes.\n    \"\"\"\nassert (\ninput_sampling_period.total_seconds() &gt; 0\n), \"The input sampling period should be greater than zero.\"\nassert (\ninput_sampling_period &lt;= size\n), \"The input sampling period should be equal to or lower than the window size.\"\nsuper().__init__(name=name)\nself._sampling_period = input_sampling_period\nself._resampler: Resampler | None = None\nself._resampler_sender: Sender[Sample[Quantity]] | None = None\nif resampler_config:\nassert (\nresampler_config.resampling_period &lt;= size\n), \"The resampling period should be equal to or lower than the window size.\"\nself._resampler = Resampler(resampler_config)\nself._sampling_period = resampler_config.resampling_period\n# Sampling period might not fit perfectly into the window size.\nnum_samples = math.ceil(\nsize.total_seconds() / self._sampling_period.total_seconds()\n)\nself._resampled_data_recv = resampled_data_recv\nself._buffer = OrderedRingBuffer(\nnp.empty(shape=num_samples, dtype=float),\nsampling_period=self._sampling_period,\nalign_to=align_to,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.__len__","title":"<code>__len__()</code>","text":"<p>Return the size of the <code>MovingWindow</code>s underlying buffer.</p> RETURNS DESCRIPTION <code>int</code> <p>The size of the <code>MovingWindow</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    Return the size of the `MovingWindow`s underlying buffer.\n    Returns:\n        The size of the `MovingWindow`.\n    \"\"\"\nreturn len(self._buffer)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow.start","title":"<code>start()</code>","text":"<p>Start the MovingWindow.</p> <p>This method starts the MovingWindow tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start the MovingWindow.\n    This method starts the MovingWindow tasks.\n    \"\"\"\nif self._resampler:\nself._configure_resampler()\nself._tasks.add(asyncio.create_task(self._run_impl(), name=\"update-window\"))\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage","title":"<code>frequenz.sdk.timeseries.Percentage</code>","text":"<p>             Bases: <code>Quantity</code></p> <p>A percentage quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Percentage(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={0: \"%\"},\n):\n\"\"\"A percentage quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_percent(cls, percent: float) -&gt; Self:\n\"\"\"Initialize a new percentage quantity from a percent value.\n        Args:\n            percent: The percent value, normally in the 0.0-100.0 range.\n        Returns:\n            A new percentage quantity.\n        \"\"\"\npercentage = cls.__new__(cls)\npercentage._base_value = percent\nreturn percentage\n@classmethod\ndef from_fraction(cls, fraction: float) -&gt; Self:\n\"\"\"Initialize a new percentage quantity from a fraction.\n        Args:\n            fraction: The fraction, normally in the 0.0-1.0 range.\n        Returns:\n            A new percentage quantity.\n        \"\"\"\npercentage = cls.__new__(cls)\npercentage._base_value = fraction * 100\nreturn percentage\ndef as_percent(self) -&gt; float:\n\"\"\"Return this quantity as a percentage.\n        Returns:\n            This quantity as a percentage.\n        \"\"\"\nreturn self._base_value\ndef as_fraction(self) -&gt; float:\n\"\"\"Return this quantity as a fraction.\n        Returns:\n            This quantity as a fraction.\n        \"\"\"\nreturn self._base_value / 100\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.as_fraction","title":"<code>as_fraction()</code>","text":"<p>Return this quantity as a fraction.</p> RETURNS DESCRIPTION <code>float</code> <p>This quantity as a fraction.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_fraction(self) -&gt; float:\n\"\"\"Return this quantity as a fraction.\n    Returns:\n        This quantity as a fraction.\n    \"\"\"\nreturn self._base_value / 100\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.as_percent","title":"<code>as_percent()</code>","text":"<p>Return this quantity as a percentage.</p> RETURNS DESCRIPTION <code>float</code> <p>This quantity as a percentage.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_percent(self) -&gt; float:\n\"\"\"Return this quantity as a percentage.\n    Returns:\n        This quantity as a percentage.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.from_fraction","title":"<code>from_fraction(fraction)</code>  <code>classmethod</code>","text":"<p>Initialize a new percentage quantity from a fraction.</p> PARAMETER  DESCRIPTION <code>fraction</code> <p>The fraction, normally in the 0.0-1.0 range.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new percentage quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_fraction(cls, fraction: float) -&gt; Self:\n\"\"\"Initialize a new percentage quantity from a fraction.\n    Args:\n        fraction: The fraction, normally in the 0.0-1.0 range.\n    Returns:\n        A new percentage quantity.\n    \"\"\"\npercentage = cls.__new__(cls)\npercentage._base_value = fraction * 100\nreturn percentage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Percentage.from_percent","title":"<code>from_percent(percent)</code>  <code>classmethod</code>","text":"<p>Initialize a new percentage quantity from a percent value.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percent value, normally in the 0.0-100.0 range.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new percentage quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_percent(cls, percent: float) -&gt; Self:\n\"\"\"Initialize a new percentage quantity from a percent value.\n    Args:\n        percent: The percent value, normally in the 0.0-100.0 range.\n    Returns:\n        A new percentage quantity.\n    \"\"\"\npercentage = cls.__new__(cls)\npercentage._base_value = percent\nreturn percentage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor","title":"<code>frequenz.sdk.timeseries.PeriodicFeatureExtractor</code>","text":"<p>A feature extractor for historical timeseries data.</p> <p>This class is creating a profile from periodically occurring windows in a buffer of historical data.</p> <p>The profile is created out of all windows that are fully contained in the underlying buffer with the same start and end time modulo a fixed period.</p> <p>Consider for example a timeseries $T$ of historical data and sub-series $S_i$ of $T$ all having the same size $l$ and the same fixed distance $p$ called period, where period of two sub-windows is defined as the distance of two points at the same position within the sub-windows.</p> <p>This class calculates a statistical profile $S$ over all $S_i$, i.e. the value of $S$ at position $i$ is calculated by performing a certain calculation, e.g. an average, over all values of $S_i$ at position $i$.</p> Note <p>The oldest window or the window that is currently overwritten in the <code>MovingWindow</code> is not considered in the profile.</p> Note <p>When constructing a <code>PeriodicFeatureExtractor</code> object the <code>MovingWindow</code> size has to be a integer multiple of the period.</p> Example <pre><code>from frequenz.sdk import microgrid\nfrom datetime import datetime, timedelta, timezone\nasync with MovingWindow(\nsize=timedelta(days=35),\nresampled_data_recv=microgrid.logical_meter().grid_power.new_receiver(),\ninput_sampling_period=timedelta(seconds=1),\n) as moving_window:\nfeature_extractor = PeriodicFeatureExtractor(\nmoving_window=moving_window,\nperiod=timedelta(days=7),\n)\nnow = datetime.now(timezone.utc)\n# create a daily weighted average for the next 24h\navg_24h = feature_extractor.avg(\nnow,\nnow + timedelta(hours=24),\nweights=[0.1, 0.2, 0.3, 0.4]\n)\n# create a daily average for Thursday March 23 2023\nth_avg_24h = feature_extractor.avg(datetime(2023, 3, 23), datetime(2023, 3, 24))\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>class PeriodicFeatureExtractor:\n\"\"\"\n    A feature extractor for historical timeseries data.\n    This class is creating a profile from periodically occurring windows in a\n    buffer of historical data.\n    The profile is created out of all windows that are fully contained in the\n    underlying buffer with the same start and end time modulo a fixed period.\n    Consider for example a timeseries $T$ of historical data and sub-series\n    $S_i$ of $T$ all having the same size $l$ and the same fixed distance $p$\n    called period, where period of two sub-windows is defined as the distance\n    of two points at the same position within the sub-windows.\n    This class calculates a statistical profile $S$ over all $S_i$, i.e. the\n    value of $S$ at position $i$ is calculated by performing a certain\n    calculation, e.g. an average, over all values of $S_i$ at position $i$.\n    Note:\n        The oldest window or the window that is currently overwritten in the\n        `MovingWindow` is not considered in the profile.\n    Note:\n        When constructing a `PeriodicFeatureExtractor` object the\n        `MovingWindow` size has to be a integer multiple of the period.\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n        from datetime import datetime, timedelta, timezone\n        async with MovingWindow(\n            size=timedelta(days=35),\n            resampled_data_recv=microgrid.logical_meter().grid_power.new_receiver(),\n            input_sampling_period=timedelta(seconds=1),\n        ) as moving_window:\n            feature_extractor = PeriodicFeatureExtractor(\n                moving_window=moving_window,\n                period=timedelta(days=7),\n            )\n            now = datetime.now(timezone.utc)\n            # create a daily weighted average for the next 24h\n            avg_24h = feature_extractor.avg(\n                now,\n                now + timedelta(hours=24),\n                weights=[0.1, 0.2, 0.3, 0.4]\n            )\n            # create a daily average for Thursday March 23 2023\n            th_avg_24h = feature_extractor.avg(datetime(2023, 3, 23), datetime(2023, 3, 24))\n        ```\n    \"\"\"\ndef __init__(\nself,\nmoving_window: MovingWindow,\nperiod: timedelta,\n) -&gt; None:\n\"\"\"\n        Initialize a PeriodicFeatureExtractor object.\n        Args:\n            moving_window: The MovingWindow that is used for the average calculation.\n            period: The distance between two succeeding intervals.\n        Raises:\n            ValueError: If the MovingWindow size is not a integer multiple of the period.\n        \"\"\"\nself._moving_window = moving_window\nself._sampling_period = self._moving_window.sampling_period\n\"\"\"The sampling_period as float to use it for indexing of samples.\"\"\"\nself._period = int(period / self._sampling_period)\n\"\"\"Distance between two succeeding intervals in samples.\"\"\"\n_logger.debug(\"Initializing PeriodicFeatureExtractor!\")\n_logger.debug(\"MovingWindow size: %i\", len(self._moving_window))\n_logger.debug(\n\"Period between two succeeding intervals (in samples): %i\",\nself._period,\n)\nif not len(self._moving_window) % self._period == 0:\nraise ValueError(\n\"The MovingWindow size is not a integer multiple of the period.\"\n)\nif not is_close_to_zero(self._period - period / self._sampling_period):\nraise ValueError(\n\"The period is not a multiple of the sampling period. \"\n\"This might result in unexpected behaviour.\"\n)\n@property\ndef _buffer(self) -&gt; OrderedRingBuffer[NDArray[np.float64]]:\nreturn self._moving_window._buffer  # pylint: disable=protected-access\ndef _timestamp_to_rel_index(self, timestamp: datetime) -&gt; int:\n\"\"\"\n        Get the index of a timestamp relative to the oldest sample in the MovingWindow.\n        In other word consider an integer axis where the zero is defined as the\n        oldest element in the MovingWindow. This function returns the index of\n        the given timestamp an this axis.\n        This method can return negative values.\n        Args:\n            timestamp: A timestamp that we want to shift into the window.\n        Returns:\n            The index of the timestamp shifted into the MovingWindow.\n        \"\"\"\n# align timestamp to the sampling period\ntimestamp = self._buffer.normalize_timestamp(timestamp)\n# distance between the input ts and the ts of oldest known samples (in samples)\ndist_to_oldest = int(\n(timestamp - self._buffer.time_bound_oldest) / self._sampling_period\n)\n_logger.debug(\"Shifting ts: %s\", timestamp)\n_logger.debug(\"Oldest timestamp in buffer: %s\", self._buffer.time_bound_oldest)\n_logger.debug(\"Distance to the oldest sample: %i\", dist_to_oldest)\nreturn dist_to_oldest\ndef _reshape_np_array(\nself, array: NDArray[np.float_], window_size: int\n) -&gt; NDArray[np.float_]:\n\"\"\"\n        Reshape a numpy array to a 2D array where each row represents a window.\n        There are three cases to consider\n        1. The array size is a multiple of window_size + period,\n           i.e. num_windows is integer and we can simply reshape.\n        2. The array size is NOT a multiple of window_size + period and\n           it has length n * period + m, where m &lt; window_size.\n        3. The array size is NOT a multiple of window_size + period and\n           it has length n * period + m, where m &gt;= window_size.\n        Note that in the current implementation of this class we have the restriction\n        that period is a multiple integer of the size of the MovingWindow and hence\n        only case 1 can occur.\n        Args:\n            array: The numpy array to reshape.\n            window_size: The size of the window in samples.\n        Returns:\n            The reshaped 2D array.\n        Raises:\n            ValueError: If the array is smaller or equal to the given period.\n        \"\"\"\n# Not using the num_windows function here because we want to\n# differentiate between the three cases.\nif len(array) &lt; self._period:\nraise ValueError(\nf\"The array (length:{len(array)}) is too small to be reshaped.\"\n)\nnum_windows = len(array) // self._period\n# Case 1:\nif len(array) - num_windows * self._period == 0:\nresized_array = array\n# Case 2\nelif len(array) - num_windows * self._period &lt; window_size:\nresized_array = array[: num_windows * self._period]\n# Case 3\nelse:\nnum_windows += 1\nresized_array = np.resize(array, num_windows * self._period)\nreturn resized_array.reshape(num_windows, self._period)\ndef _get_relative_positions(\nself, start: datetime, window_size: int\n) -&gt; RelativePositions:\n\"\"\"\n        Return relative positions of the MovingWindow.\n        This method calculates the shifted relative positions of the start\n        timestamp, the end timestamps as well as the next position that is\n        overwritten in the ringbuffer.\n        Shifted in that context means that the positions are moved as close\n        assume possible to the oldest sample in the MovingWindow.\n        Args:\n            start: The start timestamp of the window.\n            window_size: The size of the window in samples.\n        Returns:\n            The relative positions of the start, end and next samples.\n        \"\"\"\n# The number of usable windows can change, when the current position of\n# the ringbuffer is inside one of the windows inside the MovingWindow.\n# Since this is possible, we assume that one window is always not used\n# for the average calculation.\n#\n# We are ignoring either the window that is currently overwritten if\n# the current position is inside that window or the window that would\n# be overwritten next.\n#\n# Move the window to its first appearance in the MovingWindow relative\n# to the oldest sample stored in the MovingWindow.\n#\n# In other words the oldest stored sample is considered to have index 0.\n#\n# Note that the returned value is a index not a timestamp\nrel_start_sample = self._timestamp_to_rel_index(start) % self._period\nrel_end_sample = rel_start_sample + window_size\n# check if the newest time bound, i.e. the sample that is currently written,\n# is inside the interval\nrb_current_position = self._buffer.time_bound_newest\nrel_next_position = (\nself._timestamp_to_rel_index(rb_current_position) + 1\n) % self._period\n# fix the rel_next_position if modulo period the next position\n# is smaller then the start sample position\nif rel_next_position &lt; rel_start_sample:\nrel_next_position += self._period\nrel_next_position += self._period * (window_size // self._period)\n_logger.debug(\"current position of the ringbuffer: %s\", rb_current_position)\n_logger.debug(\"relative start_sample: %s\", rel_start_sample)\n_logger.debug(\"relative end_sample: %s\", rel_end_sample)\n_logger.debug(\"relative next_position: %s\", rel_next_position)\nreturn RelativePositions(rel_start_sample, rel_end_sample, rel_next_position)\ndef _get_buffer_bounds(\nself, start: datetime, end: datetime\n) -&gt; Tuple[int, int, int]:\n\"\"\"\n        Get the bounds of the ringbuffer used for further operations.\n        This method uses the given start and end timestamps to calculate the\n        part of the ringbuffer that can be used for further operations, like\n        average or min/max.\n        Here we cut out the oldest window or the window that is currently\n        overwritten in the MovingWindow such that it is not considered in any\n        further operation.\n        Args:\n            start: The start timestamp of the window.\n            end: The end timestamp of the window.\n        Returns:\n            The bounds of the to be used buffer and the window size.\n        Raises:\n            ValueError: If the start timestamp is after the end timestamp.\n        \"\"\"\nwindow_size = self._timestamp_to_rel_index(end) - self._timestamp_to_rel_index(\nstart\n)\nif window_size &lt;= 0:\nraise ValueError(\"Start timestamp must be before end timestamp\")\nif window_size &gt; self._period:\nraise ValueError(\n\"The window size must be smaller or equal than the period.\"\n)\nrel_pos = self._get_relative_positions(start, window_size)\nif window_size &gt; len(self._moving_window):\nraise ValueError(\n\"The window size must be smaller than the size of the `MovingWindow`\"\n)\n# shifted distance between the next incoming sample and the start of the window\ndist_to_start = rel_pos.next - rel_pos.start\n# get the start and end position inside the ringbuffer\nend_pos = (\nself._timestamp_to_rel_index(self._buffer.time_bound_newest) + 1\n) - dist_to_start\n# Note that these check is working since we are using the positions\n# relative to the oldest sample stored in the MovingWindow.\nif rel_pos.start &lt;= rel_pos.next &lt; rel_pos.end:\n# end position is start_position of the window that is currently written\n# that's how end_pos is currently set\n_logger.debug(\"Next sample will be inside the window time interval!\")\nelse:\n_logger.debug(\"Next sample will be outside the window time interval!\")\n# end position is start_position of the window that\n# is overwritten next, hence we adding period.\nend_pos += self._period\n# add the offset to the oldest sample in the ringbuffer and wrap around\n# to get the start and end positions in the ringbuffer\nrb_offset = self._buffer.datetime_to_index(self._buffer.time_bound_oldest)\nstart_pos = self._buffer.wrap(end_pos + self._period + rb_offset)\nend_pos = self._buffer.wrap(end_pos + rb_offset)\n_logger.debug(\"start_pos in ringbuffer: %s\", start_pos)\n_logger.debug(\"end_pos in ringbuffer: %s\", end_pos)\nreturn (start_pos, end_pos, window_size)\ndef _get_reshaped_np_array(\nself, start: datetime, end: datetime\n) -&gt; Tuple[NDArray[np.float_], int]:\n\"\"\"\n        Create a reshaped numpy array from the MovingWindow.\n        The reshaped array is a two dimensional array, where one dimension is\n        the window_size and the other the number of windows returned by the\n        `_get_buffer_bounds` method.\n        Args:\n            start: The start timestamp of the window.\n            end: The end timestamp of the window.\n        Returns:\n            A tuple containing the reshaped numpy array and the window size.\n        \"\"\"\n(start_pos, end_pos, window_size) = self._get_buffer_bounds(start, end)\nif start_pos &gt;= end_pos:\nwindow_start = self._buffer[start_pos : len(self._moving_window)]\nwindow_end = self._buffer[0:end_pos]\n# make the linter happy\nassert isinstance(window_start, np.ndarray)\nassert isinstance(window_end, np.ndarray)\nwindow_array = np.concatenate((window_start, window_end))\nelse:\nwindow_array = self._buffer[start_pos:end_pos]\nreturn (self._reshape_np_array(window_array, window_size), window_size)\ndef avg(\nself, start: datetime, end: datetime, weights: List[float] | None = None\n) -&gt; NDArray[np.float_]:\n\"\"\"\n        Create the average window out of the window defined by `start` and `end`.\n        This method calculates the average of a window by averaging over all\n        windows fully inside the MovingWindow having the period\n        `self.period`.\n        Args:\n            start: The start of the window to average over.\n            end: The end of the window to average over.\n            weights: The weights to use for the average calculation (oldest first).\n        Returns:\n            The averaged timeseries window.\n        \"\"\"\n(reshaped, window_size) = self._get_reshaped_np_array(start, end)\nreturn np.average(  # type: ignore[no-any-return]\nreshaped[:, :window_size], axis=0, weights=weights\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor.__init__","title":"<code>__init__(moving_window, period)</code>","text":"<p>Initialize a PeriodicFeatureExtractor object.</p> PARAMETER  DESCRIPTION <code>moving_window</code> <p>The MovingWindow that is used for the average calculation.</p> <p> TYPE: <code>MovingWindow</code> </p> <code>period</code> <p>The distance between two succeeding intervals.</p> <p> TYPE: <code>timedelta</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the MovingWindow size is not a integer multiple of the period.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>def __init__(\nself,\nmoving_window: MovingWindow,\nperiod: timedelta,\n) -&gt; None:\n\"\"\"\n    Initialize a PeriodicFeatureExtractor object.\n    Args:\n        moving_window: The MovingWindow that is used for the average calculation.\n        period: The distance between two succeeding intervals.\n    Raises:\n        ValueError: If the MovingWindow size is not a integer multiple of the period.\n    \"\"\"\nself._moving_window = moving_window\nself._sampling_period = self._moving_window.sampling_period\n\"\"\"The sampling_period as float to use it for indexing of samples.\"\"\"\nself._period = int(period / self._sampling_period)\n\"\"\"Distance between two succeeding intervals in samples.\"\"\"\n_logger.debug(\"Initializing PeriodicFeatureExtractor!\")\n_logger.debug(\"MovingWindow size: %i\", len(self._moving_window))\n_logger.debug(\n\"Period between two succeeding intervals (in samples): %i\",\nself._period,\n)\nif not len(self._moving_window) % self._period == 0:\nraise ValueError(\n\"The MovingWindow size is not a integer multiple of the period.\"\n)\nif not is_close_to_zero(self._period - period / self._sampling_period):\nraise ValueError(\n\"The period is not a multiple of the sampling period. \"\n\"This might result in unexpected behaviour.\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor.avg","title":"<code>avg(start, end, weights=None)</code>","text":"<p>Create the average window out of the window defined by <code>start</code> and <code>end</code>.</p> <p>This method calculates the average of a window by averaging over all windows fully inside the MovingWindow having the period <code>self.period</code>.</p> PARAMETER  DESCRIPTION <code>start</code> <p>The start of the window to average over.</p> <p> TYPE: <code>datetime</code> </p> <code>end</code> <p>The end of the window to average over.</p> <p> TYPE: <code>datetime</code> </p> <code>weights</code> <p>The weights to use for the average calculation (oldest first).</p> <p> TYPE: <code>List[float] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>NDArray[float_]</code> <p>The averaged timeseries window.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>def avg(\nself, start: datetime, end: datetime, weights: List[float] | None = None\n) -&gt; NDArray[np.float_]:\n\"\"\"\n    Create the average window out of the window defined by `start` and `end`.\n    This method calculates the average of a window by averaging over all\n    windows fully inside the MovingWindow having the period\n    `self.period`.\n    Args:\n        start: The start of the window to average over.\n        end: The end of the window to average over.\n        weights: The weights to use for the average calculation (oldest first).\n    Returns:\n        The averaged timeseries window.\n    \"\"\"\n(reshaped, window_size) = self._get_reshaped_np_array(start, end)\nreturn np.average(  # type: ignore[no-any-return]\nreshaped[:, :window_size], axis=0, weights=weights\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power","title":"<code>frequenz.sdk.timeseries.Power</code>","text":"<p>             Bases: <code>Quantity</code></p> <p>A power quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Power(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={\n-3: \"mW\",\n0: \"W\",\n3: \"kW\",\n6: \"MW\",\n},\n):\n\"\"\"A power quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_watts(cls, watts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n        Args:\n            watts: The power in watts.\n        Returns:\n            A new power quantity.\n        \"\"\"\npower = cls.__new__(cls)\npower._base_value = watts\nreturn power\n@classmethod\ndef from_milliwatts(cls, milliwatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n        Args:\n            milliwatts: The power in milliwatts.\n        Returns:\n            A new power quantity.\n        \"\"\"\npower = cls.__new__(cls)\npower._base_value = milliwatts * 10**-3\nreturn power\n@classmethod\ndef from_kilowatts(cls, kilowatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n        Args:\n            kilowatts: The power in kilowatts.\n        Returns:\n            A new power quantity.\n        \"\"\"\npower = cls.__new__(cls)\npower._base_value = kilowatts * 10**3\nreturn power\n@classmethod\ndef from_megawatts(cls, megawatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n        Args:\n            megawatts: The power in megawatts.\n        Returns:\n            A new power quantity.\n        \"\"\"\npower = cls.__new__(cls)\npower._base_value = megawatts * 10**6\nreturn power\ndef as_watts(self) -&gt; float:\n\"\"\"Return the power in watts.\n        Returns:\n            The power in watts.\n        \"\"\"\nreturn self._base_value\ndef as_kilowatts(self) -&gt; float:\n\"\"\"Return the power in kilowatts.\n        Returns:\n            The power in kilowatts.\n        \"\"\"\nreturn self._base_value / 1e3\ndef as_megawatts(self) -&gt; float:\n\"\"\"Return the power in megawatts.\n        Returns:\n            The power in megawatts.\n        \"\"\"\nreturn self._base_value / 1e6\n@overload  # type: ignore\ndef __mul__(self, other: Percentage) -&gt; Self:\n\"\"\"Scale this power by a percentage.\n        Args:\n            other: The percentage by which to scale this power.\n        Returns:\n            The scaled power.\n        \"\"\"\n@overload\ndef __mul__(self, other: timedelta) -&gt; Energy:\n\"\"\"Return an energy from multiplying this power by the given duration.\n        Args:\n            other: The duration to multiply by.\n        Returns:\n            The calculated energy.\n        \"\"\"\ndef __mul__(self, other: Percentage | timedelta) -&gt; Self | Energy:\n\"\"\"Return a power or energy from multiplying this power by the given value.\n        Args:\n            other: The percentage or duration to multiply by.\n        Returns:\n            A power or energy.\n        \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, timedelta):\nreturn Energy.from_watt_hours(\nself._base_value * other.total_seconds() / 3600.0\n)\nreturn NotImplemented\n@overload\ndef __truediv__(self, other: Current) -&gt; Voltage:\n\"\"\"Return a voltage from dividing this power by the given current.\n        Args:\n            other: The current to divide by.\n        Returns:\n            A voltage from dividing this power by the a current.\n        \"\"\"\n@overload\ndef __truediv__(self, other: Voltage) -&gt; Current:\n\"\"\"Return a current from dividing this power by the given voltage.\n        Args:\n            other: The voltage to divide by.\n        Returns:\n            A current from dividing this power by a voltage.\n        \"\"\"\ndef __truediv__(self, other: Current | Voltage) -&gt; Voltage | Current:\n\"\"\"Return a current or voltage from dividing this power by the given value.\n        Args:\n            other: The current or voltage to divide by.\n        Returns:\n            A current or voltage from dividing this power by the given value.\n        Raises:\n            TypeError: If the given value is not a current or voltage.\n        \"\"\"\nif isinstance(other, Current):\nreturn Voltage.from_volts(self._base_value / other._base_value)\nif isinstance(other, Voltage):\nreturn Current.from_amperes(self._base_value / other._base_value)\nraise TypeError(\nf\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Return a power or energy from multiplying this power by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The percentage or duration to multiply by.</p> <p> TYPE: <code>Percentage | timedelta</code> </p> RETURNS DESCRIPTION <code>Self | Energy</code> <p>A power or energy.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: Percentage | timedelta) -&gt; Self | Energy:\n\"\"\"Return a power or energy from multiplying this power by the given value.\n    Args:\n        other: The percentage or duration to multiply by.\n    Returns:\n        A power or energy.\n    \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, timedelta):\nreturn Energy.from_watt_hours(\nself._base_value * other.total_seconds() / 3600.0\n)\nreturn NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Return a current or voltage from dividing this power by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The current or voltage to divide by.</p> <p> TYPE: <code>Current | Voltage</code> </p> RETURNS DESCRIPTION <code>Voltage | Current</code> <p>A current or voltage from dividing this power by the given value.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given value is not a current or voltage.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __truediv__(self, other: Current | Voltage) -&gt; Voltage | Current:\n\"\"\"Return a current or voltage from dividing this power by the given value.\n    Args:\n        other: The current or voltage to divide by.\n    Returns:\n        A current or voltage from dividing this power by the given value.\n    Raises:\n        TypeError: If the given value is not a current or voltage.\n    \"\"\"\nif isinstance(other, Current):\nreturn Voltage.from_volts(self._base_value / other._base_value)\nif isinstance(other, Voltage):\nreturn Current.from_amperes(self._base_value / other._base_value)\nraise TypeError(\nf\"unsupported operand type(s) for /: '{type(self)}' and '{type(other)}'\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_kilowatts","title":"<code>as_kilowatts()</code>","text":"<p>Return the power in kilowatts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in kilowatts.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilowatts(self) -&gt; float:\n\"\"\"Return the power in kilowatts.\n    Returns:\n        The power in kilowatts.\n    \"\"\"\nreturn self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_megawatts","title":"<code>as_megawatts()</code>","text":"<p>Return the power in megawatts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in megawatts.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_megawatts(self) -&gt; float:\n\"\"\"Return the power in megawatts.\n    Returns:\n        The power in megawatts.\n    \"\"\"\nreturn self._base_value / 1e6\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.as_watts","title":"<code>as_watts()</code>","text":"<p>Return the power in watts.</p> RETURNS DESCRIPTION <code>float</code> <p>The power in watts.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_watts(self) -&gt; float:\n\"\"\"Return the power in watts.\n    Returns:\n        The power in watts.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_kilowatts","title":"<code>from_kilowatts(kilowatts)</code>  <code>classmethod</code>","text":"<p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>kilowatts</code> <p>The power in kilowatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilowatts(cls, kilowatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n    Args:\n        kilowatts: The power in kilowatts.\n    Returns:\n        A new power quantity.\n    \"\"\"\npower = cls.__new__(cls)\npower._base_value = kilowatts * 10**3\nreturn power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_megawatts","title":"<code>from_megawatts(megawatts)</code>  <code>classmethod</code>","text":"<p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>megawatts</code> <p>The power in megawatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_megawatts(cls, megawatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n    Args:\n        megawatts: The power in megawatts.\n    Returns:\n        A new power quantity.\n    \"\"\"\npower = cls.__new__(cls)\npower._base_value = megawatts * 10**6\nreturn power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_milliwatts","title":"<code>from_milliwatts(milliwatts)</code>  <code>classmethod</code>","text":"<p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>milliwatts</code> <p>The power in milliwatts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_milliwatts(cls, milliwatts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n    Args:\n        milliwatts: The power in milliwatts.\n    Returns:\n        A new power quantity.\n    \"\"\"\npower = cls.__new__(cls)\npower._base_value = milliwatts * 10**-3\nreturn power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Power.from_watts","title":"<code>from_watts(watts)</code>  <code>classmethod</code>","text":"<p>Initialize a new power quantity.</p> PARAMETER  DESCRIPTION <code>watts</code> <p>The power in watts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new power quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_watts(cls, watts: float) -&gt; Self:\n\"\"\"Initialize a new power quantity.\n    Args:\n        watts: The power in watts.\n    Returns:\n        A new power quantity.\n    \"\"\"\npower = cls.__new__(cls)\npower._base_value = watts\nreturn power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity","title":"<code>frequenz.sdk.timeseries.Quantity</code>","text":"<p>A quantity with a unit.</p> <p>Quantities try to behave like float and are also immutable.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Quantity:\n\"\"\"A quantity with a unit.\n    Quantities try to behave like float and are also immutable.\n    \"\"\"\n_base_value: float\n\"\"\"The value of this quantity in the base unit.\"\"\"\n_exponent_unit_map: dict[int, str] | None = None\n\"\"\"A mapping from the exponent of the base unit to the unit symbol.\n    If None, this quantity has no unit.  None is possible only when using the base\n    class.  Sub-classes must define this.\n    \"\"\"\ndef __init__(self, value: float, exponent: int = 0) -&gt; None:\n\"\"\"Initialize a new quantity.\n        Args:\n            value: The value of this quantity in a given exponent of the base unit.\n            exponent: The exponent of the base unit the given value is in.\n        \"\"\"\nself._base_value = value * 10**exponent\ndef __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n\"\"\"Initialize a new subclass of Quantity.\n        Args:\n            exponent_unit_map: A mapping from the exponent of the base unit to the unit\n                symbol.\n        Raises:\n            TypeError: If the given exponent_unit_map is not a dict.\n            ValueError: If the given exponent_unit_map does not contain a base unit\n                (exponent 0).\n        \"\"\"\nif 0 not in exponent_unit_map:\nraise ValueError(\"Expected a base unit for the type (for exponent 0)\")\ncls._exponent_unit_map = exponent_unit_map\nsuper().__init_subclass__()\n_zero_cache: dict[type, Quantity] = {}\n\"\"\"Cache for zero singletons.\n    This is a workaround for mypy getting confused when using @functools.cache and\n    @classmethod combined with returning Self. It believes the resulting type of this\n    method is Self and complains that members of the actual class don't exist in Self,\n    so we need to implement the cache ourselves.\n    \"\"\"\n@classmethod\ndef zero(cls) -&gt; Self:\n\"\"\"Return a quantity with value 0.\n        Returns:\n            A quantity with value 0.\n        \"\"\"\n_zero = cls._zero_cache.get(cls, None)\nif _zero is None:\n_zero = cls.__new__(cls)\n_zero._base_value = 0\ncls._zero_cache[cls] = _zero\nassert isinstance(_zero, cls)\nreturn _zero\n@property\ndef base_value(self) -&gt; float:\n\"\"\"Return the value of this quantity in the base unit.\n        Returns:\n            The value of this quantity in the base unit.\n        \"\"\"\nreturn self._base_value\n@property\ndef base_unit(self) -&gt; str | None:\n\"\"\"Return the base unit of this quantity.\n        None if this quantity has no unit.\n        Returns:\n            The base unit of this quantity.\n        \"\"\"\nif not self._exponent_unit_map:\nreturn None\nreturn self._exponent_unit_map[0]\ndef isnan(self) -&gt; bool:\n\"\"\"Return whether this quantity is NaN.\n        Returns:\n            Whether this quantity is NaN.\n        \"\"\"\nreturn math.isnan(self._base_value)\ndef isinf(self) -&gt; bool:\n\"\"\"Return whether this quantity is infinite.\n        Returns:\n            Whether this quantity is infinite.\n        \"\"\"\nreturn math.isinf(self._base_value)\ndef isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n\"\"\"Return whether this quantity is close to another.\n        Args:\n            other: The quantity to compare to.\n            rel_tol: The relative tolerance.\n            abs_tol: The absolute tolerance.\n        Returns:\n            Whether this quantity is close to another.\n        \"\"\"\nreturn math.isclose(\nself._base_value,\nother._base_value,  # pylint: disable=protected-access\nrel_tol=rel_tol,\nabs_tol=abs_tol,\n)\ndef __repr__(self) -&gt; str:\n\"\"\"Return a representation of this quantity.\n        Returns:\n            A representation of this quantity.\n        \"\"\"\nreturn f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\ndef __str__(self) -&gt; str:\n\"\"\"Return a string representation of this quantity.\n        Returns:\n            A string representation of this quantity.\n        \"\"\"\nreturn self.__format__(\"\")\ndef __format__(self, __format_spec: str) -&gt; str:\n\"\"\"Return a formatted string representation of this quantity.\n        If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n        trailing zeros will be omitted.  If no precision is given, the default is 3.\n        The returned string will use the unit that will result in the maximum precision,\n        based on the magnitude of the value.\n        Example:\n            ```python\n            from frequenz.sdk.timeseries import Current\n            c = Current.from_amperes(0.2345)\n            assert f\"{c:.2}\" == \"234.5 mA\"\n            c = Current.from_amperes(1.2345)\n            assert f\"{c:.2}\" == \"1.23 A\"\n            c = Current.from_milliamperes(1.2345)\n            assert f\"{c:.6}\" == \"1.2345 mA\"\n            ```\n        Args:\n            __format_spec: The format specifier.\n        Returns:\n            A string representation of this quantity.\n        Raises:\n            ValueError: If the given format specifier is invalid.\n        \"\"\"\nkeep_trailing_zeros = False\nif __format_spec != \"\":\nfspec_parts = __format_spec.split(\".\")\nif (\nlen(fspec_parts) != 2\nor fspec_parts[0] not in (\"\", \"0\")\nor not fspec_parts[1].isdigit()\n):\nraise ValueError(\n\"Invalid format specifier. Must be empty or `[0].{precision}`\"\n)\nif fspec_parts[0] == \"0\":\nkeep_trailing_zeros = True\nprecision = int(fspec_parts[1])\nelse:\nprecision = 3\nif not self._exponent_unit_map:\nreturn f\"{self._base_value:.{precision}f}\"\nif math.isinf(self._base_value) or math.isnan(self._base_value):\nreturn f\"{self._base_value} {self._exponent_unit_map[0]}\"\nabs_value = abs(self._base_value)\nexponent = math.floor(math.log10(abs_value)) if abs_value else 0\nunit_place = exponent - exponent % 3\nif unit_place &lt; min(self._exponent_unit_map):\nunit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\nunit_place = min(self._exponent_unit_map)\nelif unit_place &gt; max(self._exponent_unit_map):\nunit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\nunit_place = max(self._exponent_unit_map)\nelse:\nunit = self._exponent_unit_map[unit_place]\nvalue_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\nstripped = value_str.rstrip(\"0\").rstrip(\".\")\nif not keep_trailing_zeros:\nvalue_str = stripped\nunit_str = unit if stripped != \"0\" else self._exponent_unit_map[0]\nreturn f\"{value_str} {unit_str}\"\ndef __add__(self, other: Self) -&gt; Self:\n\"\"\"Return the sum of this quantity and another.\n        Args:\n            other: The other quantity.\n        Returns:\n            The sum of this quantity and another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nsumme = type(self).__new__(type(self))\nsumme._base_value = self._base_value + other._base_value\nreturn summe\ndef __sub__(self, other: Self) -&gt; Self:\n\"\"\"Return the difference of this quantity and another.\n        Args:\n            other: The other quantity.\n        Returns:\n            The difference of this quantity and another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\ndifference = type(self).__new__(type(self))\ndifference._base_value = self._base_value - other._base_value\nreturn difference\ndef __mul__(self, percent: Percentage) -&gt; Self:\n\"\"\"Scale this quantity by a percentage.\n        Args:\n            percent: The percentage by which to scale this quantity.\n        Returns:\n            The scaled quantity.\n        \"\"\"\nif not isinstance(percent, Percentage):\nreturn NotImplemented\nproduct = type(self).__new__(type(self))\nproduct._base_value = self._base_value * percent.as_fraction()\nreturn product\ndef __gt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than another.\n        Args:\n            other: The other quantity.\n        Returns:\n            Whether this quantity is greater than another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt; other._base_value\ndef __ge__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than or equal to another.\n        Args:\n            other: The other quantity.\n        Returns:\n            Whether this quantity is greater than or equal to another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt;= other._base_value\ndef __lt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than another.\n        Args:\n            other: The other quantity.\n        Returns:\n            Whether this quantity is less than another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt; other._base_value\ndef __le__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than or equal to another.\n        Args:\n            other: The other quantity.\n        Returns:\n            Whether this quantity is less than or equal to another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt;= other._base_value\ndef __eq__(self, other: object) -&gt; bool:\n\"\"\"Return whether this quantity is equal to another.\n        Args:\n            other: The other quantity.\n        Returns:\n            Whether this quantity is equal to another.\n        \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\n# The above check ensures that both quantities are the exact same type, because\n# `isinstance` returns true for subclasses and superclasses.  But the above check\n# doesn't help mypy identify the type of other,  so the below line is necessary.\nassert isinstance(other, self.__class__)\nreturn self._base_value == other._base_value\ndef __neg__(self) -&gt; Self:\n\"\"\"Return the negation of this quantity.\n        Returns:\n            The negation of this quantity.\n        \"\"\"\nnegation = type(self).__new__(type(self))\nnegation._base_value = -self._base_value\nreturn negation\ndef __abs__(self) -&gt; Self:\n\"\"\"Return the absolute value of this quantity.\n        Returns:\n            The absolute value of this quantity.\n        \"\"\"\nabsolute = type(self).__new__(type(self))\nabsolute._base_value = abs(self._base_value)\nreturn absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.base_unit","title":"<code>base_unit: str | None</code>  <code>property</code>","text":"<p>Return the base unit of this quantity.</p> <p>None if this quantity has no unit.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The base unit of this quantity.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.base_value","title":"<code>base_value: float</code>  <code>property</code>","text":"<p>Return the value of this quantity in the base unit.</p> RETURNS DESCRIPTION <code>float</code> <p>The value of this quantity in the base unit.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__abs__","title":"<code>__abs__()</code>","text":"<p>Return the absolute value of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The absolute value of this quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __abs__(self) -&gt; Self:\n\"\"\"Return the absolute value of this quantity.\n    Returns:\n        The absolute value of this quantity.\n    \"\"\"\nabsolute = type(self).__new__(type(self))\nabsolute._base_value = abs(self._base_value)\nreturn absolute\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__add__","title":"<code>__add__(other)</code>","text":"<p>Return the sum of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The sum of this quantity and another.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __add__(self, other: Self) -&gt; Self:\n\"\"\"Return the sum of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The sum of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nsumme = type(self).__new__(type(self))\nsumme._base_value = self._base_value + other._base_value\nreturn summe\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Return whether this quantity is equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is equal to another.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Return whether this quantity is equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\n# The above check ensures that both quantities are the exact same type, because\n# `isinstance` returns true for subclasses and superclasses.  But the above check\n# doesn't help mypy identify the type of other,  so the below line is necessary.\nassert isinstance(other, self.__class__)\nreturn self._base_value == other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__format__","title":"<code>__format__(__format_spec)</code>","text":"<p>Return a formatted string representation of this quantity.</p> <p>If specified, must be of this form: <code>[0].{precision}</code>.  If a 0 is not given, the trailing zeros will be omitted.  If no precision is given, the default is 3.</p> <p>The returned string will use the unit that will result in the maximum precision, based on the magnitude of the value.</p> Example <pre><code>from frequenz.sdk.timeseries import Current\nc = Current.from_amperes(0.2345)\nassert f\"{c:.2}\" == \"234.5 mA\"\nc = Current.from_amperes(1.2345)\nassert f\"{c:.2}\" == \"1.23 A\"\nc = Current.from_milliamperes(1.2345)\nassert f\"{c:.6}\" == \"1.2345 mA\"\n</code></pre> PARAMETER  DESCRIPTION <code>__format_spec</code> <p>The format specifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given format specifier is invalid.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __format__(self, __format_spec: str) -&gt; str:\n\"\"\"Return a formatted string representation of this quantity.\n    If specified, must be of this form: `[0].{precision}`.  If a 0 is not given, the\n    trailing zeros will be omitted.  If no precision is given, the default is 3.\n    The returned string will use the unit that will result in the maximum precision,\n    based on the magnitude of the value.\n    Example:\n        ```python\n        from frequenz.sdk.timeseries import Current\n        c = Current.from_amperes(0.2345)\n        assert f\"{c:.2}\" == \"234.5 mA\"\n        c = Current.from_amperes(1.2345)\n        assert f\"{c:.2}\" == \"1.23 A\"\n        c = Current.from_milliamperes(1.2345)\n        assert f\"{c:.6}\" == \"1.2345 mA\"\n        ```\n    Args:\n        __format_spec: The format specifier.\n    Returns:\n        A string representation of this quantity.\n    Raises:\n        ValueError: If the given format specifier is invalid.\n    \"\"\"\nkeep_trailing_zeros = False\nif __format_spec != \"\":\nfspec_parts = __format_spec.split(\".\")\nif (\nlen(fspec_parts) != 2\nor fspec_parts[0] not in (\"\", \"0\")\nor not fspec_parts[1].isdigit()\n):\nraise ValueError(\n\"Invalid format specifier. Must be empty or `[0].{precision}`\"\n)\nif fspec_parts[0] == \"0\":\nkeep_trailing_zeros = True\nprecision = int(fspec_parts[1])\nelse:\nprecision = 3\nif not self._exponent_unit_map:\nreturn f\"{self._base_value:.{precision}f}\"\nif math.isinf(self._base_value) or math.isnan(self._base_value):\nreturn f\"{self._base_value} {self._exponent_unit_map[0]}\"\nabs_value = abs(self._base_value)\nexponent = math.floor(math.log10(abs_value)) if abs_value else 0\nunit_place = exponent - exponent % 3\nif unit_place &lt; min(self._exponent_unit_map):\nunit = self._exponent_unit_map[min(self._exponent_unit_map.keys())]\nunit_place = min(self._exponent_unit_map)\nelif unit_place &gt; max(self._exponent_unit_map):\nunit = self._exponent_unit_map[max(self._exponent_unit_map.keys())]\nunit_place = max(self._exponent_unit_map)\nelse:\nunit = self._exponent_unit_map[unit_place]\nvalue_str = f\"{self._base_value / 10 ** unit_place:.{precision}f}\"\nstripped = value_str.rstrip(\"0\").rstrip(\".\")\nif not keep_trailing_zeros:\nvalue_str = stripped\nunit_str = unit if stripped != \"0\" else self._exponent_unit_map[0]\nreturn f\"{value_str} {unit_str}\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Return whether this quantity is greater than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than or equal to another.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __ge__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Return whether this quantity is greater than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is greater than another.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __gt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is greater than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is greater than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &gt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__init__","title":"<code>__init__(value, exponent=0)</code>","text":"<p>Initialize a new quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value of this quantity in a given exponent of the base unit.</p> <p> TYPE: <code>float</code> </p> <code>exponent</code> <p>The exponent of the base unit the given value is in.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init__(self, value: float, exponent: int = 0) -&gt; None:\n\"\"\"Initialize a new quantity.\n    Args:\n        value: The value of this quantity in a given exponent of the base unit.\n        exponent: The exponent of the base unit the given value is in.\n    \"\"\"\nself._base_value = value * 10**exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__init_subclass__","title":"<code>__init_subclass__(exponent_unit_map)</code>","text":"<p>Initialize a new subclass of Quantity.</p> PARAMETER  DESCRIPTION <code>exponent_unit_map</code> <p>A mapping from the exponent of the base unit to the unit symbol.</p> <p> TYPE: <code>dict[int, str]</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If the given exponent_unit_map is not a dict.</p> <code>ValueError</code> <p>If the given exponent_unit_map does not contain a base unit (exponent 0).</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __init_subclass__(cls, exponent_unit_map: dict[int, str]) -&gt; None:\n\"\"\"Initialize a new subclass of Quantity.\n    Args:\n        exponent_unit_map: A mapping from the exponent of the base unit to the unit\n            symbol.\n    Raises:\n        TypeError: If the given exponent_unit_map is not a dict.\n        ValueError: If the given exponent_unit_map does not contain a base unit\n            (exponent 0).\n    \"\"\"\nif 0 not in exponent_unit_map:\nraise ValueError(\"Expected a base unit for the type (for exponent 0)\")\ncls._exponent_unit_map = exponent_unit_map\nsuper().__init_subclass__()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__le__","title":"<code>__le__(other)</code>","text":"<p>Return whether this quantity is less than or equal to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than or equal to another.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __le__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than or equal to another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than or equal to another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt;= other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Return whether this quantity is less than another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is less than another.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __lt__(self, other: Self) -&gt; bool:\n\"\"\"Return whether this quantity is less than another.\n    Args:\n        other: The other quantity.\n    Returns:\n        Whether this quantity is less than another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\nreturn self._base_value &lt; other._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__mul__","title":"<code>__mul__(percent)</code>","text":"<p>Scale this quantity by a percentage.</p> PARAMETER  DESCRIPTION <code>percent</code> <p>The percentage by which to scale this quantity.</p> <p> TYPE: <code>Percentage</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The scaled quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, percent: Percentage) -&gt; Self:\n\"\"\"Scale this quantity by a percentage.\n    Args:\n        percent: The percentage by which to scale this quantity.\n    Returns:\n        The scaled quantity.\n    \"\"\"\nif not isinstance(percent, Percentage):\nreturn NotImplemented\nproduct = type(self).__new__(type(self))\nproduct._base_value = self._base_value * percent.as_fraction()\nreturn product\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__neg__","title":"<code>__neg__()</code>","text":"<p>Return the negation of this quantity.</p> RETURNS DESCRIPTION <code>Self</code> <p>The negation of this quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __neg__(self) -&gt; Self:\n\"\"\"Return the negation of this quantity.\n    Returns:\n        The negation of this quantity.\n    \"\"\"\nnegation = type(self).__new__(type(self))\nnegation._base_value = -self._base_value\nreturn negation\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A representation of this quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a representation of this quantity.\n    Returns:\n        A representation of this quantity.\n    \"\"\"\nreturn f\"{type(self).__name__}(value={self._base_value}, exponent=0)\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this quantity.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return a string representation of this quantity.\n    Returns:\n        A string representation of this quantity.\n    \"\"\"\nreturn self.__format__(\"\")\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Return the difference of this quantity and another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other quantity.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The difference of this quantity and another.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __sub__(self, other: Self) -&gt; Self:\n\"\"\"Return the difference of this quantity and another.\n    Args:\n        other: The other quantity.\n    Returns:\n        The difference of this quantity and another.\n    \"\"\"\nif not type(other) is type(self):\nreturn NotImplemented\ndifference = type(self).__new__(type(self))\ndifference._base_value = self._base_value - other._base_value\nreturn difference\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isclose","title":"<code>isclose(other, rel_tol=1e-09, abs_tol=0.0)</code>","text":"<p>Return whether this quantity is close to another.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The quantity to compare to.</p> <p> TYPE: <code>Self</code> </p> <code>rel_tol</code> <p>The relative tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> <code>abs_tol</code> <p>The absolute tolerance.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is close to another.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isclose(self, other: Self, rel_tol: float = 1e-9, abs_tol: float = 0.0) -&gt; bool:\n\"\"\"Return whether this quantity is close to another.\n    Args:\n        other: The quantity to compare to.\n        rel_tol: The relative tolerance.\n        abs_tol: The absolute tolerance.\n    Returns:\n        Whether this quantity is close to another.\n    \"\"\"\nreturn math.isclose(\nself._base_value,\nother._base_value,  # pylint: disable=protected-access\nrel_tol=rel_tol,\nabs_tol=abs_tol,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isinf","title":"<code>isinf()</code>","text":"<p>Return whether this quantity is infinite.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is infinite.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isinf(self) -&gt; bool:\n\"\"\"Return whether this quantity is infinite.\n    Returns:\n        Whether this quantity is infinite.\n    \"\"\"\nreturn math.isinf(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.isnan","title":"<code>isnan()</code>","text":"<p>Return whether this quantity is NaN.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this quantity is NaN.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def isnan(self) -&gt; bool:\n\"\"\"Return whether this quantity is NaN.\n    Returns:\n        Whether this quantity is NaN.\n    \"\"\"\nreturn math.isnan(self._base_value)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Quantity.zero","title":"<code>zero()</code>  <code>classmethod</code>","text":"<p>Return a quantity with value 0.</p> RETURNS DESCRIPTION <code>Self</code> <p>A quantity with value 0.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef zero(cls) -&gt; Self:\n\"\"\"Return a quantity with value 0.\n    Returns:\n        A quantity with value 0.\n    \"\"\"\n_zero = cls._zero_cache.get(cls, None)\nif _zero is None:\n_zero = cls.__new__(cls)\n_zero._base_value = 0\ncls._zero_cache[cls] = _zero\nassert isinstance(_zero, cls)\nreturn _zero\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig","title":"<code>frequenz.sdk.timeseries.ResamplerConfig</code>  <code>dataclass</code>","text":"<p>Resampler configuration.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_resampling.py</code> <pre><code>@dataclass(frozen=True)\nclass ResamplerConfig:\n\"\"\"Resampler configuration.\"\"\"\nresampling_period: timedelta\n\"\"\"The resampling period.\n    This is the time it passes between resampled data should be calculated.\n    It must be a positive time span.\n    \"\"\"\nmax_data_age_in_periods: float = 3.0\n\"\"\"The maximum age a sample can have to be considered *relevant* for resampling.\n    Expressed in number of periods, where period is the `resampling_period`\n    if we are downsampling (resampling period bigger than the input period) or\n    the input sampling period if we are upsampling (input period bigger than\n    the resampling period).\n    It must be bigger than 1.0.\n    Example:\n        If `resampling_period` is 3 seconds, the input sampling period is\n        1 and `max_data_age_in_periods` is 2, then data older than 3*2\n        = 6 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n        If `resampling_period` is 3 seconds, the input sampling period is\n        5 and `max_data_age_in_periods` is 2, then data older than 5*2\n        = 10 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n    \"\"\"\nresampling_function: ResamplingFunction = average\n\"\"\"The resampling function.\n    This function will be applied to the sequence of relevant samples at\n    a given time. The result of the function is what is sent as the resampled\n    value.\n    \"\"\"\ninitial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n\"\"\"The initial length of the resampling buffer.\n    The buffer could grow or shrink depending on the source properties,\n    like sampling rate, to make sure all the requested past sampling periods\n    can be stored.\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\nwarn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n\"\"\"The minimum length of the resampling buffer that will emit a warning.\n    If a buffer grows bigger than this value, it will emit a warning in the\n    logs, so buffers don't grow too big inadvertently.\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\nmax_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n\"\"\"The maximum length of the resampling buffer.\n    Buffers won't be allowed to grow beyond this point even if it would be\n    needed to keep all the requested past sampling periods. An error will be\n    emitted in the logs if the buffer length needs to be truncated to this\n    value.\n    It must be at bigger than `warn_buffer_len`.\n    \"\"\"\nalign_to: datetime | None = UNIX_EPOCH\n\"\"\"The time to align the resampling period to.\n    The resampling period will be aligned to this time, so the first resampled\n    sample will be at the first multiple of `resampling_period` starting from\n    `align_to`. It must be an aware datetime and can be in the future too.\n    If `align_to` is `None`, the resampling period will be aligned to the\n    time the resampler is created.\n    \"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n        Raises:\n            ValueError: If any value is out of range.\n        \"\"\"\nif self.resampling_period.total_seconds() &lt; 0.0:\nraise ValueError(\nf\"resampling_period ({self.resampling_period}) must be positive\"\n)\nif self.max_data_age_in_periods &lt; 1.0:\nraise ValueError(\nf\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n)\nif self.warn_buffer_len &lt; 1:\nraise ValueError(\nf\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n)\nif self.max_buffer_len &lt;= self.warn_buffer_len:\nraise ValueError(\nf\"max_buffer_len ({self.max_buffer_len}) should \"\nf\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n)\nif self.initial_buffer_len &lt; 1:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n)\nif self.initial_buffer_len &gt; self.max_buffer_len:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\nf\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n\"initial_buffer_len or a bigger max_buffer_len\"\n)\nif self.initial_buffer_len &gt; self.warn_buffer_len:\n_logger.warning(\n\"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\nself.initial_buffer_len,\nself.warn_buffer_len,\n)\nif self.align_to is not None and self.align_to.tzinfo is None:\nraise ValueError(\nf\"align_to ({self.align_to}) should be a timezone aware datetime\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.align_to","title":"<code>align_to: datetime | None = UNIX_EPOCH</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The time to align the resampling period to.</p> <p>The resampling period will be aligned to this time, so the first resampled sample will be at the first multiple of <code>resampling_period</code> starting from <code>align_to</code>. It must be an aware datetime and can be in the future too.</p> <p>If <code>align_to</code> is <code>None</code>, the resampling period will be aligned to the time the resampler is created.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.initial_buffer_len","title":"<code>initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The initial length of the resampling buffer.</p> <p>The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.max_buffer_len","title":"<code>max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The maximum length of the resampling buffer.</p> <p>Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value.</p> <p>It must be at bigger than <code>warn_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.max_data_age_in_periods","title":"<code>max_data_age_in_periods: float = 3.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The maximum age a sample can have to be considered relevant for resampling.</p> <p>Expressed in number of periods, where period is the <code>resampling_period</code> if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period).</p> <p>It must be bigger than 1.0.</p> Example <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 1 and <code>max_data_age_in_periods</code> is 2, then data older than 3*2 = 6 seconds will be discarded when creating a new sample and never passed to the resampling function.</p> <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 5 and <code>max_data_age_in_periods</code> is 2, then data older than 5*2 = 10 seconds will be discarded when creating a new sample and never passed to the resampling function.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.resampling_function","title":"<code>resampling_function: ResamplingFunction = average</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The resampling function.</p> <p>This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.resampling_period","title":"<code>resampling_period: timedelta</code>  <code>instance-attribute</code>","text":"<p>The resampling period.</p> <p>This is the time it passes between resampled data should be calculated.</p> <p>It must be a positive time span.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.warn_buffer_len","title":"<code>warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The minimum length of the resampling buffer that will emit a warning.</p> <p>If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertently.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check that config values are valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any value is out of range.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_resampling.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n    Raises:\n        ValueError: If any value is out of range.\n    \"\"\"\nif self.resampling_period.total_seconds() &lt; 0.0:\nraise ValueError(\nf\"resampling_period ({self.resampling_period}) must be positive\"\n)\nif self.max_data_age_in_periods &lt; 1.0:\nraise ValueError(\nf\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n)\nif self.warn_buffer_len &lt; 1:\nraise ValueError(\nf\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n)\nif self.max_buffer_len &lt;= self.warn_buffer_len:\nraise ValueError(\nf\"max_buffer_len ({self.max_buffer_len}) should \"\nf\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n)\nif self.initial_buffer_len &lt; 1:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n)\nif self.initial_buffer_len &gt; self.max_buffer_len:\nraise ValueError(\nf\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\nf\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n\"initial_buffer_len or a bigger max_buffer_len\"\n)\nif self.initial_buffer_len &gt; self.warn_buffer_len:\n_logger.warning(\n\"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\nself.initial_buffer_len,\nself.warn_buffer_len,\n)\nif self.align_to is not None and self.align_to.tzinfo is None:\nraise ValueError(\nf\"align_to ({self.align_to}) should be a timezone aware datetime\"\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample","title":"<code>frequenz.sdk.timeseries.Sample</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[QuantityT]</code></p> <p>A measurement taken at a particular point in time.</p> <p>The <code>value</code> could be <code>None</code> if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True, order=True)\nclass Sample(Generic[QuantityT]):\n\"\"\"A measurement taken at a particular point in time.\n    The `value` could be `None` if a component is malfunctioning or data is\n    lacking for another reason, but a sample still needs to be sent to have a\n    coherent view on a group of component metrics for a particular timestamp.\n    \"\"\"\ntimestamp: datetime\n\"\"\"The time when this sample was generated.\"\"\"\nvalue: QuantityT | None = None\n\"\"\"The value of this sample.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample.timestamp","title":"<code>timestamp: datetime</code>  <code>instance-attribute</code>","text":"<p>The time when this sample was generated.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample.value","title":"<code>value: QuantityT | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The value of this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase","title":"<code>frequenz.sdk.timeseries.Sample3Phase</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[QuantityT]</code></p> <p>A 3-phase measurement made at a particular point in time.</p> <p>Each of the <code>value</code> fields could be <code>None</code> if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Sample3Phase(Generic[QuantityT]):\n\"\"\"A 3-phase measurement made at a particular point in time.\n    Each of the `value` fields could be `None` if a component is malfunctioning\n    or data is lacking for another reason, but a sample still needs to be sent\n    to have a coherent view on a group of component metrics for a particular\n    timestamp.\n    \"\"\"\ntimestamp: datetime\n\"\"\"The time when this sample was generated.\"\"\"\nvalue_p1: QuantityT | None\n\"\"\"The value of the 1st phase in this sample.\"\"\"\nvalue_p2: QuantityT | None\n\"\"\"The value of the 2nd phase in this sample.\"\"\"\nvalue_p3: QuantityT | None\n\"\"\"The value of the 3rd phase in this sample.\"\"\"\ndef __iter__(self) -&gt; Iterator[QuantityT | None]:\n\"\"\"Return an iterator that yields values from each of the phases.\n        Yields:\n            Per-phase measurements one-by-one.\n        \"\"\"\nyield self.value_p1\nyield self.value_p2\nyield self.value_p3\n@overload\ndef max(self, default: QuantityT) -&gt; QuantityT:\n...\n@overload\ndef max(self, default: None = None) -&gt; QuantityT | None:\n...\ndef max(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n\"\"\"Return the max value among all phases, or default if they are all `None`.\n        Args:\n            default: value to return if all phases are `None`.\n        Returns:\n            Max value among all phases, if available, default value otherwise.\n        \"\"\"\nif not any(self):\nreturn default\nvalue: QuantityT = functools.reduce(\nlambda x, y: x if x &gt; y else y,\nfilter(None, self),\n)\nreturn value\n@overload\ndef min(self, default: QuantityT) -&gt; QuantityT:\n...\n@overload\ndef min(self, default: None = None) -&gt; QuantityT | None:\n...\ndef min(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n\"\"\"Return the min value among all phases, or default if they are all `None`.\n        Args:\n            default: value to return if all phases are `None`.\n        Returns:\n            Min value among all phases, if available, default value otherwise.\n        \"\"\"\nif not any(self):\nreturn default\nvalue: QuantityT = functools.reduce(\nlambda x, y: x if x &lt; y else y,\nfilter(None, self),\n)\nreturn value\ndef map(\nself,\nfunction: Callable[[QuantityT], QuantityT],\ndefault: QuantityT | None = None,\n) -&gt; Self:\n\"\"\"Apply the given function on each of the phase values and return the result.\n        If a phase value is `None`, replace it with `default` instead.\n        Args:\n            function: The function to apply on each of the phase values.\n            default: The value to apply if a phase value is `None`.\n        Returns:\n            A new instance, with the given function applied on values for each of the\n                phases.\n        \"\"\"\nreturn self.__class__(\ntimestamp=self.timestamp,\nvalue_p1=default if self.value_p1 is None else function(self.value_p1),\nvalue_p2=default if self.value_p2 is None else function(self.value_p2),\nvalue_p3=default if self.value_p3 is None else function(self.value_p3),\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.timestamp","title":"<code>timestamp: datetime</code>  <code>instance-attribute</code>","text":"<p>The time when this sample was generated.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p1","title":"<code>value_p1: QuantityT | None</code>  <code>instance-attribute</code>","text":"<p>The value of the 1st phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p2","title":"<code>value_p2: QuantityT | None</code>  <code>instance-attribute</code>","text":"<p>The value of the 2nd phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.value_p3","title":"<code>value_p3: QuantityT | None</code>  <code>instance-attribute</code>","text":"<p>The value of the 3rd phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator that yields values from each of the phases.</p> YIELDS DESCRIPTION <code>QuantityT | None</code> <p>Per-phase measurements one-by-one.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def __iter__(self) -&gt; Iterator[QuantityT | None]:\n\"\"\"Return an iterator that yields values from each of the phases.\n    Yields:\n        Per-phase measurements one-by-one.\n    \"\"\"\nyield self.value_p1\nyield self.value_p2\nyield self.value_p3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.map","title":"<code>map(function, default=None)</code>","text":"<p>Apply the given function on each of the phase values and return the result.</p> <p>If a phase value is <code>None</code>, replace it with <code>default</code> instead.</p> PARAMETER  DESCRIPTION <code>function</code> <p>The function to apply on each of the phase values.</p> <p> TYPE: <code>Callable[[QuantityT], QuantityT]</code> </p> <code>default</code> <p>The value to apply if a phase value is <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new instance, with the given function applied on values for each of the phases.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def map(\nself,\nfunction: Callable[[QuantityT], QuantityT],\ndefault: QuantityT | None = None,\n) -&gt; Self:\n\"\"\"Apply the given function on each of the phase values and return the result.\n    If a phase value is `None`, replace it with `default` instead.\n    Args:\n        function: The function to apply on each of the phase values.\n        default: The value to apply if a phase value is `None`.\n    Returns:\n        A new instance, with the given function applied on values for each of the\n            phases.\n    \"\"\"\nreturn self.__class__(\ntimestamp=self.timestamp,\nvalue_p1=default if self.value_p1 is None else function(self.value_p1),\nvalue_p2=default if self.value_p2 is None else function(self.value_p2),\nvalue_p3=default if self.value_p3 is None else function(self.value_p3),\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.max","title":"<code>max(default=None)</code>","text":"<p>Return the max value among all phases, or default if they are all <code>None</code>.</p> PARAMETER  DESCRIPTION <code>default</code> <p>value to return if all phases are <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>QuantityT | None</code> <p>Max value among all phases, if available, default value otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def max(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n\"\"\"Return the max value among all phases, or default if they are all `None`.\n    Args:\n        default: value to return if all phases are `None`.\n    Returns:\n        Max value among all phases, if available, default value otherwise.\n    \"\"\"\nif not any(self):\nreturn default\nvalue: QuantityT = functools.reduce(\nlambda x, y: x if x &gt; y else y,\nfilter(None, self),\n)\nreturn value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase.min","title":"<code>min(default=None)</code>","text":"<p>Return the min value among all phases, or default if they are all <code>None</code>.</p> PARAMETER  DESCRIPTION <code>default</code> <p>value to return if all phases are <code>None</code>.</p> <p> TYPE: <code>QuantityT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>QuantityT | None</code> <p>Min value among all phases, if available, default value otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def min(self, default: QuantityT | None = None) -&gt; QuantityT | None:\n\"\"\"Return the min value among all phases, or default if they are all `None`.\n    Args:\n        default: value to return if all phases are `None`.\n    Returns:\n        Min value among all phases, if available, default value otherwise.\n    \"\"\"\nif not any(self):\nreturn default\nvalue: QuantityT = functools.reduce(\nlambda x, y: x if x &lt; y else y,\nfilter(None, self),\n)\nreturn value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature","title":"<code>frequenz.sdk.timeseries.Temperature</code>","text":"<p>             Bases: <code>Quantity</code></p> <p>A temperature quantity (in degrees Celsius).</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Temperature(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={\n0: \"\u00b0C\",\n},\n):\n\"\"\"A temperature quantity (in degrees Celsius).\"\"\"\n@classmethod\ndef from_celsius(cls, value: float) -&gt; Self:\n\"\"\"Initialize a new temperature quantity.\n        Args:\n            value: The temperature in degrees Celsius.\n        Returns:\n            A new temperature quantity.\n        \"\"\"\npower = cls.__new__(cls)\npower._base_value = value\nreturn power\ndef as_celsius(self) -&gt; float:\n\"\"\"Return the temperature in degrees Celsius.\n        Returns:\n            The temperature in degrees Celsius.\n        \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.as_celsius","title":"<code>as_celsius()</code>","text":"<p>Return the temperature in degrees Celsius.</p> RETURNS DESCRIPTION <code>float</code> <p>The temperature in degrees Celsius.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_celsius(self) -&gt; float:\n\"\"\"Return the temperature in degrees Celsius.\n    Returns:\n        The temperature in degrees Celsius.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Temperature.from_celsius","title":"<code>from_celsius(value)</code>  <code>classmethod</code>","text":"<p>Initialize a new temperature quantity.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The temperature in degrees Celsius.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new temperature quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_celsius(cls, value: float) -&gt; Self:\n\"\"\"Initialize a new temperature quantity.\n    Args:\n        value: The temperature in degrees Celsius.\n    Returns:\n        A new temperature quantity.\n    \"\"\"\npower = cls.__new__(cls)\npower._base_value = value\nreturn power\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage","title":"<code>frequenz.sdk.timeseries.Voltage</code>","text":"<p>             Bases: <code>Quantity</code></p> <p>A voltage quantity.</p> <p>Objects of this type are wrappers around <code>float</code> values and are immutable.</p> <p>The constructors accept a single <code>float</code> value, the <code>as_*()</code> methods return a <code>float</code> value, and each of the arithmetic operators supported by this type are actually implemented using floating-point arithmetic.</p> <p>So all considerations about floating-point arithmetic apply to this type as well.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>class Voltage(\nQuantity,\nmetaclass=_NoDefaultConstructible,\nexponent_unit_map={0: \"V\", -3: \"mV\", 3: \"kV\"},\n):\n\"\"\"A voltage quantity.\n    Objects of this type are wrappers around `float` values and are immutable.\n    The constructors accept a single `float` value, the `as_*()` methods return a\n    `float` value, and each of the arithmetic operators supported by this type are\n    actually implemented using floating-point arithmetic.\n    So all considerations about floating-point arithmetic apply to this type as well.\n    \"\"\"\n@classmethod\ndef from_volts(cls, volts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n        Args:\n            volts: The voltage in volts.\n        Returns:\n            A new voltage quantity.\n        \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = volts\nreturn voltage\n@classmethod\ndef from_millivolts(cls, millivolts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n        Args:\n            millivolts: The voltage in millivolts.\n        Returns:\n            A new voltage quantity.\n        \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = millivolts * 10**-3\nreturn voltage\n@classmethod\ndef from_kilovolts(cls, kilovolts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n        Args:\n            kilovolts: The voltage in kilovolts.\n        Returns:\n            A new voltage quantity.\n        \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = kilovolts * 10**3\nreturn voltage\ndef as_volts(self) -&gt; float:\n\"\"\"Return the voltage in volts.\n        Returns:\n            The voltage in volts.\n        \"\"\"\nreturn self._base_value\ndef as_millivolts(self) -&gt; float:\n\"\"\"Return the voltage in millivolts.\n        Returns:\n            The voltage in millivolts.\n        \"\"\"\nreturn self._base_value * 1e3\ndef as_kilovolts(self) -&gt; float:\n\"\"\"Return the voltage in kilovolts.\n        Returns:\n            The voltage in kilovolts.\n        \"\"\"\nreturn self._base_value / 1e3\n@overload  # type: ignore\ndef __mul__(self, other: Percentage) -&gt; Self:\n\"\"\"Scale this voltage by a percentage.\n        Args:\n            other: The percentage by which to scale this voltage.\n        Returns:\n            The scaled voltage.\n        \"\"\"\n@overload\ndef __mul__(self, other: Current) -&gt; Power:\n\"\"\"Multiply the voltage by the current to get the power.\n        Args:\n            other: The current to multiply the voltage with.\n        Returns:\n            The calculated power.\n        \"\"\"\ndef __mul__(self, other: Percentage | Current) -&gt; Self | Power:\n\"\"\"Return a voltage or power from multiplying this voltage by the given value.\n        Args:\n            other: The percentage or current to multiply by.\n        Returns:\n            The calculated voltage or power.\n        \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, Current):\nreturn Power.from_watts(self._base_value * other._base_value)\nreturn NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Return a voltage or power from multiplying this voltage by the given value.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The percentage or current to multiply by.</p> <p> TYPE: <code>Percentage | Current</code> </p> RETURNS DESCRIPTION <code>Self | Power</code> <p>The calculated voltage or power.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def __mul__(self, other: Percentage | Current) -&gt; Self | Power:\n\"\"\"Return a voltage or power from multiplying this voltage by the given value.\n    Args:\n        other: The percentage or current to multiply by.\n    Returns:\n        The calculated voltage or power.\n    \"\"\"\nif isinstance(other, Percentage):\nreturn super().__mul__(other)\nif isinstance(other, Current):\nreturn Power.from_watts(self._base_value * other._base_value)\nreturn NotImplemented\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_kilovolts","title":"<code>as_kilovolts()</code>","text":"<p>Return the voltage in kilovolts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in kilovolts.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_kilovolts(self) -&gt; float:\n\"\"\"Return the voltage in kilovolts.\n    Returns:\n        The voltage in kilovolts.\n    \"\"\"\nreturn self._base_value / 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_millivolts","title":"<code>as_millivolts()</code>","text":"<p>Return the voltage in millivolts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in millivolts.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_millivolts(self) -&gt; float:\n\"\"\"Return the voltage in millivolts.\n    Returns:\n        The voltage in millivolts.\n    \"\"\"\nreturn self._base_value * 1e3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.as_volts","title":"<code>as_volts()</code>","text":"<p>Return the voltage in volts.</p> RETURNS DESCRIPTION <code>float</code> <p>The voltage in volts.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>def as_volts(self) -&gt; float:\n\"\"\"Return the voltage in volts.\n    Returns:\n        The voltage in volts.\n    \"\"\"\nreturn self._base_value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_kilovolts","title":"<code>from_kilovolts(kilovolts)</code>  <code>classmethod</code>","text":"<p>Initialize a new voltage quantity.</p> PARAMETER  DESCRIPTION <code>kilovolts</code> <p>The voltage in kilovolts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_kilovolts(cls, kilovolts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n    Args:\n        kilovolts: The voltage in kilovolts.\n    Returns:\n        A new voltage quantity.\n    \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = kilovolts * 10**3\nreturn voltage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_millivolts","title":"<code>from_millivolts(millivolts)</code>  <code>classmethod</code>","text":"<p>Initialize a new voltage quantity.</p> PARAMETER  DESCRIPTION <code>millivolts</code> <p>The voltage in millivolts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_millivolts(cls, millivolts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n    Args:\n        millivolts: The voltage in millivolts.\n    Returns:\n        A new voltage quantity.\n    \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = millivolts * 10**-3\nreturn voltage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Voltage.from_volts","title":"<code>from_volts(volts)</code>  <code>classmethod</code>","text":"<p>Initialize a new voltage quantity.</p> PARAMETER  DESCRIPTION <code>volts</code> <p>The voltage in volts.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new voltage quantity.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_quantities.py</code> <pre><code>@classmethod\ndef from_volts(cls, volts: float) -&gt; Self:\n\"\"\"Initialize a new voltage quantity.\n    Args:\n        volts: The voltage in volts.\n    Returns:\n        A new voltage quantity.\n    \"\"\"\nvoltage = cls.__new__(cls)\nvoltage._base_value = volts\nreturn voltage\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/","title":"battery_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool","title":"<code>frequenz.sdk.timeseries.battery_pool</code>","text":"<p>Manage a pool of batteries.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool","title":"<code>frequenz.sdk.timeseries.battery_pool.BatteryPool</code>","text":"<p>Calculate high level metrics for a pool of the batteries.</p> <p>BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>class BatteryPool:\n\"\"\"Calculate high level metrics for a pool of the batteries.\n    BatterPool accepts subset of the battery ids and provides methods methods for\n    fetching high level metrics for this subset.\n    \"\"\"\ndef __init__(  # pylint: disable=too-many-arguments\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\nbatteries_status_receiver: Receiver[BatteryStatus],\npower_distributing_sender: Sender[Request],\nmin_update_interval: timedelta,\nbatteries_id: Set[int] | None = None,\n) -&gt; None:\n\"\"\"Create the class instance.\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n            batteries_status_receiver: Receiver to receive status of the batteries.\n                Receivers should has maxsize = 1 to fetch only the latest status.\n                Battery status channel should has resend_latest = True.\n                It should send information when any battery changed status.\n                Battery status should include status of the inverter adjacent to this\n                battery.\n            power_distributing_sender: A Channel sender for sending power requests to\n                the power distributing actor.\n            min_update_interval: Some metrics in BatteryPool are send only when they\n                change. For these metrics min_update_interval is the minimum time\n                interval between the following messages.\n                Note that this argument is similar to the resampling period\n                argument in the ComponentMetricsResamplingActor. But as opposed to\n                ResamplingActor, timestamp returned in the resulting message will be\n                the timestamp of the last received component data.\n                It is currently impossible to use resampling actor for these metrics,\n                because we can't specify resampling function for them.\n            batteries_id: Subset of the batteries that should be included in the\n                battery pool. If None or empty, then all batteries from the microgrid\n                will be used.\n        \"\"\"\nif batteries_id:\nself._batteries: Set[int] = batteries_id\nelse:\nself._batteries = self._get_all_batteries()\nself._working_batteries: set[int] = set()\nself._update_battery_status_task: asyncio.Task[None] | None = None\nif self._batteries:\nself._update_battery_status_task = asyncio.create_task(\nself._update_battery_status(batteries_status_receiver)\n)\nself._min_update_interval = min_update_interval\nself._power_distributing_sender = power_distributing_sender\nself._active_methods: dict[str, MetricAggregator[Any]] = {}\nself._namespace: str = f\"battery-pool-{self._batteries}-{uuid.uuid4()}\"\nself._power_distributing_namespace: str = f\"power-distributor-{self._namespace}\"\nself._channel_registry: ChannelRegistry = channel_registry\nself._formula_pool: FormulaEnginePool = FormulaEnginePool(\nself._namespace,\nchannel_registry,\nresampler_subscription_sender,\n)\nasync def set_power(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given power for the batteries in the pool.\n        Power values need to follow the Passive Sign Convention (PSC). That is, positive\n        values indicate charge power and negative values indicate discharge power.\n        When not using the Passive Sign Convention, the `charge` and `discharge` methods\n        might be more convenient.\n        The result of the request can be accessed using the receiver returned from\n        the `power_distribution_results` method.\n        Args:\n            power: The power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n        \"\"\"\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\nasync def charge(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given charge power for the batteries in the pool.\n        Power values need to be positive values, indicating charge power.\n        When using the Passive Sign Convention, the `set_power` method might be more\n        convenient.\n        The result of the request can be accessed using the receiver returned from\n        the `power_distribution_results` method.\n        Args:\n            power: Unsigned charge power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\nif power &lt; Power.zero():\nraise ValueError(\"Charge power must be positive.\")\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\nasync def discharge(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given discharge power for the batteries in the pool.\n        Power values need to be positive values, indicating discharge power.\n        When using the Passive Sign Convention, the `set_power` method might be more\n        convenient.\n        The result of the request can be accessed using the receiver returned from\n        the `power_distribution_results` method.\n        Args:\n            power: Unsigned discharge power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\nif power &lt; Power.zero():\nraise ValueError(\"Discharge power must be positive.\")\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=-power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\ndef power_distribution_results(self) -&gt; Receiver[Result]:\n\"\"\"Return a receiver for the power distribution results.\n        Returns:\n            A receiver for the power distribution results.\n        \"\"\"\nreturn self._channel_registry.new_receiver(self._power_distributing_namespace)\n@property\ndef battery_ids(self) -&gt; Set[int]:\n\"\"\"Return ids of the batteries in the pool.\n        Returns:\n            Ids of the batteries in the pool\n        \"\"\"\nreturn self._batteries\n@property\ndef power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the total power of the batteries in the pool.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all\n                batteries in the pool.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"battery_pool_power\",\nBatteryPowerFormula,\nFormulaGeneratorConfig(\ncomponent_ids=self._batteries,\nformula_type=FormulaType.PASSIVE_SIGN_CONVENTION,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef production_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the total production power of the batteries in the pool.\n        This formula produces positive values when producing power and 0 otherwise.\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the total production power of\n                all batteries in the pool.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"battery_pool_production_power\",\nBatteryPowerFormula,\nFormulaGeneratorConfig(\ncomponent_ids=self._batteries,\nformula_type=FormulaType.PRODUCTION,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef consumption_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the total consumption power of the batteries in the pool.\n        This formula produces positive values when consuming power and 0 otherwise.\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the total consumption\n                power of all batteries in the pool.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"battery_pool_consumption_power\",\nBatteryPowerFormula,\nFormulaGeneratorConfig(\ncomponent_ids=self._batteries,\nformula_type=FormulaType.CONSUMPTION,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef soc(self) -&gt; MetricAggregator[Sample[Percentage]]:\n\"\"\"Fetch the normalized average weighted-by-capacity SoC values for the pool.\n        The SoC values are normalized to the 0-100% range and clamped if they are out\n        of bounds. Only values from working batteries with operational inverters are\n        considered in the calculation.\n        Average SoC is calculated using the formula:\n        ```\n        working_batteries: Set[BatteryData] # working batteries from the battery pool\n        soc_scaled = min(max(\n            0,\n            (soc - soc_lower_bound) / (soc_upper_bound - soc_lower_bound) * 100,\n        ), 100)\n        used_capacity = sum(\n            battery.usable_capacity * battery.soc_scaled\n            for battery in working_batteries\n        )\n        total_capacity = sum(battery.usable_capacity for battery in working_batteries)\n        average_soc = used_capacity/total_capacity\n        ```\n        `None` values will be sent if there are no working batteries with operational\n        inverters to calculate the metric with.\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n        Returns:\n            A MetricAggregator that will calculate and stream the aggregate SoC of all\n                batteries in the pool, considering only working batteries with\n                operational inverters.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + SoCCalculator.name()\nif method_name not in self._active_methods:\ncalculator = SoCCalculator(self._batteries)\nself._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._working_batteries,\nmin_update_interval=self._min_update_interval,\n)\nreturn self._active_methods[method_name]\n@property\ndef temperature(self) -&gt; MetricAggregator[Sample[Temperature]]:\n\"\"\"Fetch the average temperature of the batteries in the pool.\n        Returns:\n            A MetricAggregator that will calculate and stream the average temperature\n                of all batteries in the pool.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + TemperatureCalculator.name()\nif method_name not in self._active_methods:\ncalculator = TemperatureCalculator(self._batteries)\nself._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._working_batteries,\nmin_update_interval=self._min_update_interval,\n)\nreturn self._active_methods[method_name]\n@property\ndef capacity(self) -&gt; MetricAggregator[Sample[Energy]]:\n\"\"\"Get a receiver to receive new capacity metrics when they change.\n        The reported capacity values consider only working batteries with operational\n        inverters.\n        Calculated with the formula:\n        ```\n        working_batteries: Set[BatteryData] # working batteries from the battery pool\n        total_capacity = sum(\n            battery.capacity * (soc_upper_bound - soc_lower_bound) / 100\n            for battery in working_batteries\n        )\n        ```\n        `None` will be sent if there are no working batteries with operational\n        inverters to calculate metrics.\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n        Returns:\n            A MetricAggregator that will calculate and stream the capacity of all\n                batteries in the pool, considering only working batteries with\n                operational inverters.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + CapacityCalculator.name()\nif method_name not in self._active_methods:\ncalculator = CapacityCalculator(self._batteries)\nself._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._working_batteries,\nmin_update_interval=self._min_update_interval,\n)\nreturn self._active_methods[method_name]\n@property\ndef power_bounds(self) -&gt; MetricAggregator[PowerMetrics]:\n\"\"\"Get receiver to receive new power bounds when they change.\n        Power bounds refer to the min and max power that a battery can\n        discharge or charge at and is also denoted as SoP.\n        Power bounds formulas are described in the receiver return type.\n        None will be send if there is no component to calculate metrics.\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n        Returns:\n            A MetricAggregator that will calculate and stream the power bounds\n                of all batteries in the pool.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + PowerBoundsCalculator.name()\nif method_name not in self._active_methods:\ncalculator = PowerBoundsCalculator(self._batteries)\nself._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._working_batteries,\nmin_update_interval=self._min_update_interval,\n)\nreturn self._active_methods[method_name]\nasync def stop(self) -&gt; None:\n\"\"\"Stop all pending async tasks.\"\"\"\ntasks_to_stop: list[Awaitable[Any]] = [\nmethod.stop() for method in self._active_methods.values()\n]\ntasks_to_stop.append(self._formula_pool.stop())\nif self._update_battery_status_task:\ntasks_to_stop.append(cancel_and_await(self._update_battery_status_task))\nawait asyncio.gather(*tasks_to_stop)\ndef _get_all_batteries(self) -&gt; Set[int]:\n\"\"\"Get all batteries from the microgrid.\n        Returns:\n            All batteries in the microgrid.\n        \"\"\"\ngraph = connection_manager.get().component_graph\nreturn {\nbattery.component_id\nfor battery in graph.components(\ncomponent_category={ComponentCategory.BATTERY}\n)\n}\nasync def _update_battery_status(self, receiver: Receiver[BatteryStatus]) -&gt; None:\nasync for status in receiver:\nself._working_batteries = status.get_working_batteries(self._batteries)\nfor item in self._active_methods.values():\nitem.update_working_batteries(self._working_batteries)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.battery_ids","title":"<code>battery_ids: Set[int]</code>  <code>property</code>","text":"<p>Return ids of the batteries in the pool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Ids of the batteries in the pool</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.capacity","title":"<code>capacity: MetricAggregator[Sample[Energy]]</code>  <code>property</code>","text":"<p>Get a receiver to receive new capacity metrics when they change.</p> <p>The reported capacity values consider only working batteries with operational inverters.</p> <p>Calculated with the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\ntotal_capacity = sum(\n    battery.capacity * (soc_upper_bound - soc_lower_bound) / 100\n    for battery in working_batteries\n)\n</code></pre></p> <p><code>None</code> will be sent if there are no working batteries with operational inverters to calculate metrics.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[Sample[Energy]]</code> <p>A MetricAggregator that will calculate and stream the capacity of all batteries in the pool, considering only working batteries with operational inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.consumption_power","title":"<code>consumption_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the total consumption power of the batteries in the pool.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total consumption power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.power","title":"<code>power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the total power of the batteries in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.power_bounds","title":"<code>power_bounds: MetricAggregator[PowerMetrics]</code>  <code>property</code>","text":"<p>Get receiver to receive new power bounds when they change.</p> <p>Power bounds refer to the min and max power that a battery can discharge or charge at and is also denoted as SoP.</p> <p>Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[PowerMetrics]</code> <p>A MetricAggregator that will calculate and stream the power bounds of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.production_power","title":"<code>production_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the total production power of the batteries in the pool.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total production power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.soc","title":"<code>soc: MetricAggregator[Sample[Percentage]]</code>  <code>property</code>","text":"<p>Fetch the normalized average weighted-by-capacity SoC values for the pool.</p> <p>The SoC values are normalized to the 0-100% range and clamped if they are out of bounds. Only values from working batteries with operational inverters are considered in the calculation.</p> <p>Average SoC is calculated using the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\n\nsoc_scaled = min(max(\n    0,\n    (soc - soc_lower_bound) / (soc_upper_bound - soc_lower_bound) * 100,\n), 100)\nused_capacity = sum(\n    battery.usable_capacity * battery.soc_scaled\n    for battery in working_batteries\n)\ntotal_capacity = sum(battery.usable_capacity for battery in working_batteries)\naverage_soc = used_capacity/total_capacity\n</code></pre></p> <p><code>None</code> values will be sent if there are no working batteries with operational inverters to calculate the metric with.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[Sample[Percentage]]</code> <p>A MetricAggregator that will calculate and stream the aggregate SoC of all batteries in the pool, considering only working batteries with operational inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.temperature","title":"<code>temperature: MetricAggregator[Sample[Temperature]]</code>  <code>property</code>","text":"<p>Fetch the average temperature of the batteries in the pool.</p> RETURNS DESCRIPTION <code>MetricAggregator[Sample[Temperature]]</code> <p>A MetricAggregator that will calculate and stream the average temperature of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.__init__","title":"<code>__init__(channel_registry, resampler_subscription_sender, batteries_status_receiver, power_distributing_sender, min_update_interval, batteries_id=None)</code>","text":"<p>Create the class instance.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>batteries_status_receiver</code> <p>Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery.</p> <p> TYPE: <code>Receiver[BatteryStatus]</code> </p> <code>power_distributing_sender</code> <p>A Channel sender for sending power requests to the power distributing actor.</p> <p> TYPE: <code>Sender[Request]</code> </p> <code>min_update_interval</code> <p>Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them.</p> <p> TYPE: <code>timedelta</code> </p> <code>batteries_id</code> <p>Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used.</p> <p> TYPE: <code>Set[int] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\nbatteries_status_receiver: Receiver[BatteryStatus],\npower_distributing_sender: Sender[Request],\nmin_update_interval: timedelta,\nbatteries_id: Set[int] | None = None,\n) -&gt; None:\n\"\"\"Create the class instance.\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n        batteries_status_receiver: Receiver to receive status of the batteries.\n            Receivers should has maxsize = 1 to fetch only the latest status.\n            Battery status channel should has resend_latest = True.\n            It should send information when any battery changed status.\n            Battery status should include status of the inverter adjacent to this\n            battery.\n        power_distributing_sender: A Channel sender for sending power requests to\n            the power distributing actor.\n        min_update_interval: Some metrics in BatteryPool are send only when they\n            change. For these metrics min_update_interval is the minimum time\n            interval between the following messages.\n            Note that this argument is similar to the resampling period\n            argument in the ComponentMetricsResamplingActor. But as opposed to\n            ResamplingActor, timestamp returned in the resulting message will be\n            the timestamp of the last received component data.\n            It is currently impossible to use resampling actor for these metrics,\n            because we can't specify resampling function for them.\n        batteries_id: Subset of the batteries that should be included in the\n            battery pool. If None or empty, then all batteries from the microgrid\n            will be used.\n    \"\"\"\nif batteries_id:\nself._batteries: Set[int] = batteries_id\nelse:\nself._batteries = self._get_all_batteries()\nself._working_batteries: set[int] = set()\nself._update_battery_status_task: asyncio.Task[None] | None = None\nif self._batteries:\nself._update_battery_status_task = asyncio.create_task(\nself._update_battery_status(batteries_status_receiver)\n)\nself._min_update_interval = min_update_interval\nself._power_distributing_sender = power_distributing_sender\nself._active_methods: dict[str, MetricAggregator[Any]] = {}\nself._namespace: str = f\"battery-pool-{self._batteries}-{uuid.uuid4()}\"\nself._power_distributing_namespace: str = f\"power-distributor-{self._namespace}\"\nself._channel_registry: ChannelRegistry = channel_registry\nself._formula_pool: FormulaEnginePool = FormulaEnginePool(\nself._namespace,\nchannel_registry,\nresampler_subscription_sender,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.charge","title":"<code>charge(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given charge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating charge power.</p> <p>When using the Passive Sign Convention, the <code>set_power</code> method might be more convenient.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_distribution_results</code> method.</p> PARAMETER  DESCRIPTION <code>power</code> <p>Unsigned charge power to set for the batteries in the pool.</p> <p> TYPE: <code>Power</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def charge(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given charge power for the batteries in the pool.\n    Power values need to be positive values, indicating charge power.\n    When using the Passive Sign Convention, the `set_power` method might be more\n    convenient.\n    The result of the request can be accessed using the receiver returned from\n    the `power_distribution_results` method.\n    Args:\n        power: Unsigned charge power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\nif power &lt; Power.zero():\nraise ValueError(\"Charge power must be positive.\")\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.discharge","title":"<code>discharge(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given discharge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating discharge power.</p> <p>When using the Passive Sign Convention, the <code>set_power</code> method might be more convenient.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_distribution_results</code> method.</p> PARAMETER  DESCRIPTION <code>power</code> <p>Unsigned discharge power to set for the batteries in the pool.</p> <p> TYPE: <code>Power</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def discharge(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given discharge power for the batteries in the pool.\n    Power values need to be positive values, indicating discharge power.\n    When using the Passive Sign Convention, the `set_power` method might be more\n    convenient.\n    The result of the request can be accessed using the receiver returned from\n    the `power_distribution_results` method.\n    Args:\n        power: Unsigned discharge power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\nif power &lt; Power.zero():\nraise ValueError(\"Discharge power must be positive.\")\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=-power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.power_distribution_results","title":"<code>power_distribution_results()</code>","text":"<p>Return a receiver for the power distribution results.</p> RETURNS DESCRIPTION <code>Receiver[Result]</code> <p>A receiver for the power distribution results.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>def power_distribution_results(self) -&gt; Receiver[Result]:\n\"\"\"Return a receiver for the power distribution results.\n    Returns:\n        A receiver for the power distribution results.\n    \"\"\"\nreturn self._channel_registry.new_receiver(self._power_distributing_namespace)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.set_power","title":"<code>set_power(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given power for the batteries in the pool.</p> <p>Power values need to follow the Passive Sign Convention (PSC). That is, positive values indicate charge power and negative values indicate discharge power.</p> <p>When not using the Passive Sign Convention, the <code>charge</code> and <code>discharge</code> methods might be more convenient.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_distribution_results</code> method.</p> PARAMETER  DESCRIPTION <code>power</code> <p>The power to set for the batteries in the pool.</p> <p> TYPE: <code>Power</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def set_power(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given power for the batteries in the pool.\n    Power values need to follow the Passive Sign Convention (PSC). That is, positive\n    values indicate charge power and negative values indicate discharge power.\n    When not using the Passive Sign Convention, the `charge` and `discharge` methods\n    might be more convenient.\n    The result of the request can be accessed using the receiver returned from\n    the `power_distribution_results` method.\n    Args:\n        power: The power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n    \"\"\"\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop all pending async tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop all pending async tasks.\"\"\"\ntasks_to_stop: list[Awaitable[Any]] = [\nmethod.stop() for method in self._active_methods.values()\n]\ntasks_to_stop.append(self._formula_pool.stop())\nif self._update_battery_status_task:\ntasks_to_stop.append(cancel_and_await(self._update_battery_status_task))\nawait asyncio.gather(*tasks_to_stop)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Bounds","title":"<code>frequenz.sdk.timeseries.battery_pool.Bounds</code>  <code>dataclass</code>","text":"<p>Lower and upper bound values.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/_result_types.py</code> <pre><code>@dataclass\nclass Bounds:\n\"\"\"Lower and upper bound values.\"\"\"\nlower: Power\n\"\"\"Lower bound.\"\"\"\nupper: Power\n\"\"\"Upper bound.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Bounds-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Bounds.lower","title":"<code>lower: Power</code>  <code>instance-attribute</code>","text":"<p>Lower bound.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Bounds.upper","title":"<code>upper: Power</code>  <code>instance-attribute</code>","text":"<p>Upper bound.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics","title":"<code>frequenz.sdk.timeseries.battery_pool.PowerMetrics</code>  <code>dataclass</code>","text":"<p>Power bounds metrics.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/_result_types.py</code> <pre><code>@dataclass\nclass PowerMetrics:\n\"\"\"Power bounds metrics.\"\"\"\n# compare = False tells the dataclass to not use name for comparison methods\ntimestamp: datetime = field(compare=False)\n\"\"\"Timestamp of the metrics.\"\"\"\n# pylint: disable=line-too-long\ninclusion_bounds: Bounds | None\n\"\"\"Inclusion power bounds for all batteries in the battery pool instance.\n    This is the range within which power requests are allowed by the battery pool.\n    When exclusion bounds are present, they will exclude a subset of the inclusion\n    bounds.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\nexclusion_bounds: Bounds | None\n\"\"\"Exclusion power bounds for all batteries in the battery pool instance.\n    This is the range within which power requests are NOT allowed by the battery pool.\n    If present, they will be a subset of the inclusion bounds.\n    See [`frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds`][] and\n    [`frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds`][] for more\n    details.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics.exclusion_bounds","title":"<code>exclusion_bounds: Bounds | None</code>  <code>instance-attribute</code>","text":"<p>Exclusion power bounds for all batteries in the battery pool instance.</p> <p>This is the range within which power requests are NOT allowed by the battery pool. If present, they will be a subset of the inclusion bounds.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics.inclusion_bounds","title":"<code>inclusion_bounds: Bounds | None</code>  <code>instance-attribute</code>","text":"<p>Inclusion power bounds for all batteries in the battery pool instance.</p> <p>This is the range within which power requests are allowed by the battery pool.</p> <p>When exclusion bounds are present, they will exclude a subset of the inclusion bounds.</p> <p>See <code>frequenz.api.common.metrics_pb2.Metric.system_inclusion_bounds</code> and <code>frequenz.api.common.metrics_pb2.Metric.system_exclusion_bounds</code> for more details.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics.timestamp","title":"<code>timestamp: datetime = field(compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Timestamp of the metrics.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/","title":"battery_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool","title":"<code>frequenz.sdk.timeseries.battery_pool.battery_pool</code>","text":"<p>User interface for requesting aggregated battery-inverter data.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool","title":"<code>frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool</code>","text":"<p>Calculate high level metrics for a pool of the batteries.</p> <p>BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>class BatteryPool:\n\"\"\"Calculate high level metrics for a pool of the batteries.\n    BatterPool accepts subset of the battery ids and provides methods methods for\n    fetching high level metrics for this subset.\n    \"\"\"\ndef __init__(  # pylint: disable=too-many-arguments\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\nbatteries_status_receiver: Receiver[BatteryStatus],\npower_distributing_sender: Sender[Request],\nmin_update_interval: timedelta,\nbatteries_id: Set[int] | None = None,\n) -&gt; None:\n\"\"\"Create the class instance.\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n            batteries_status_receiver: Receiver to receive status of the batteries.\n                Receivers should has maxsize = 1 to fetch only the latest status.\n                Battery status channel should has resend_latest = True.\n                It should send information when any battery changed status.\n                Battery status should include status of the inverter adjacent to this\n                battery.\n            power_distributing_sender: A Channel sender for sending power requests to\n                the power distributing actor.\n            min_update_interval: Some metrics in BatteryPool are send only when they\n                change. For these metrics min_update_interval is the minimum time\n                interval between the following messages.\n                Note that this argument is similar to the resampling period\n                argument in the ComponentMetricsResamplingActor. But as opposed to\n                ResamplingActor, timestamp returned in the resulting message will be\n                the timestamp of the last received component data.\n                It is currently impossible to use resampling actor for these metrics,\n                because we can't specify resampling function for them.\n            batteries_id: Subset of the batteries that should be included in the\n                battery pool. If None or empty, then all batteries from the microgrid\n                will be used.\n        \"\"\"\nif batteries_id:\nself._batteries: Set[int] = batteries_id\nelse:\nself._batteries = self._get_all_batteries()\nself._working_batteries: set[int] = set()\nself._update_battery_status_task: asyncio.Task[None] | None = None\nif self._batteries:\nself._update_battery_status_task = asyncio.create_task(\nself._update_battery_status(batteries_status_receiver)\n)\nself._min_update_interval = min_update_interval\nself._power_distributing_sender = power_distributing_sender\nself._active_methods: dict[str, MetricAggregator[Any]] = {}\nself._namespace: str = f\"battery-pool-{self._batteries}-{uuid.uuid4()}\"\nself._power_distributing_namespace: str = f\"power-distributor-{self._namespace}\"\nself._channel_registry: ChannelRegistry = channel_registry\nself._formula_pool: FormulaEnginePool = FormulaEnginePool(\nself._namespace,\nchannel_registry,\nresampler_subscription_sender,\n)\nasync def set_power(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given power for the batteries in the pool.\n        Power values need to follow the Passive Sign Convention (PSC). That is, positive\n        values indicate charge power and negative values indicate discharge power.\n        When not using the Passive Sign Convention, the `charge` and `discharge` methods\n        might be more convenient.\n        The result of the request can be accessed using the receiver returned from\n        the `power_distribution_results` method.\n        Args:\n            power: The power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n        \"\"\"\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\nasync def charge(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given charge power for the batteries in the pool.\n        Power values need to be positive values, indicating charge power.\n        When using the Passive Sign Convention, the `set_power` method might be more\n        convenient.\n        The result of the request can be accessed using the receiver returned from\n        the `power_distribution_results` method.\n        Args:\n            power: Unsigned charge power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\nif power &lt; Power.zero():\nraise ValueError(\"Charge power must be positive.\")\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\nasync def discharge(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given discharge power for the batteries in the pool.\n        Power values need to be positive values, indicating discharge power.\n        When using the Passive Sign Convention, the `set_power` method might be more\n        convenient.\n        The result of the request can be accessed using the receiver returned from\n        the `power_distribution_results` method.\n        Args:\n            power: Unsigned discharge power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\nif power &lt; Power.zero():\nraise ValueError(\"Discharge power must be positive.\")\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=-power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\ndef power_distribution_results(self) -&gt; Receiver[Result]:\n\"\"\"Return a receiver for the power distribution results.\n        Returns:\n            A receiver for the power distribution results.\n        \"\"\"\nreturn self._channel_registry.new_receiver(self._power_distributing_namespace)\n@property\ndef battery_ids(self) -&gt; Set[int]:\n\"\"\"Return ids of the batteries in the pool.\n        Returns:\n            Ids of the batteries in the pool\n        \"\"\"\nreturn self._batteries\n@property\ndef power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the total power of the batteries in the pool.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all\n                batteries in the pool.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"battery_pool_power\",\nBatteryPowerFormula,\nFormulaGeneratorConfig(\ncomponent_ids=self._batteries,\nformula_type=FormulaType.PASSIVE_SIGN_CONVENTION,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef production_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the total production power of the batteries in the pool.\n        This formula produces positive values when producing power and 0 otherwise.\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the total production power of\n                all batteries in the pool.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"battery_pool_production_power\",\nBatteryPowerFormula,\nFormulaGeneratorConfig(\ncomponent_ids=self._batteries,\nformula_type=FormulaType.PRODUCTION,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef consumption_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the total consumption power of the batteries in the pool.\n        This formula produces positive values when consuming power and 0 otherwise.\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the total consumption\n                power of all batteries in the pool.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"battery_pool_consumption_power\",\nBatteryPowerFormula,\nFormulaGeneratorConfig(\ncomponent_ids=self._batteries,\nformula_type=FormulaType.CONSUMPTION,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef soc(self) -&gt; MetricAggregator[Sample[Percentage]]:\n\"\"\"Fetch the normalized average weighted-by-capacity SoC values for the pool.\n        The SoC values are normalized to the 0-100% range and clamped if they are out\n        of bounds. Only values from working batteries with operational inverters are\n        considered in the calculation.\n        Average SoC is calculated using the formula:\n        ```\n        working_batteries: Set[BatteryData] # working batteries from the battery pool\n        soc_scaled = min(max(\n            0,\n            (soc - soc_lower_bound) / (soc_upper_bound - soc_lower_bound) * 100,\n        ), 100)\n        used_capacity = sum(\n            battery.usable_capacity * battery.soc_scaled\n            for battery in working_batteries\n        )\n        total_capacity = sum(battery.usable_capacity for battery in working_batteries)\n        average_soc = used_capacity/total_capacity\n        ```\n        `None` values will be sent if there are no working batteries with operational\n        inverters to calculate the metric with.\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n        Returns:\n            A MetricAggregator that will calculate and stream the aggregate SoC of all\n                batteries in the pool, considering only working batteries with\n                operational inverters.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + SoCCalculator.name()\nif method_name not in self._active_methods:\ncalculator = SoCCalculator(self._batteries)\nself._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._working_batteries,\nmin_update_interval=self._min_update_interval,\n)\nreturn self._active_methods[method_name]\n@property\ndef temperature(self) -&gt; MetricAggregator[Sample[Temperature]]:\n\"\"\"Fetch the average temperature of the batteries in the pool.\n        Returns:\n            A MetricAggregator that will calculate and stream the average temperature\n                of all batteries in the pool.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + TemperatureCalculator.name()\nif method_name not in self._active_methods:\ncalculator = TemperatureCalculator(self._batteries)\nself._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._working_batteries,\nmin_update_interval=self._min_update_interval,\n)\nreturn self._active_methods[method_name]\n@property\ndef capacity(self) -&gt; MetricAggregator[Sample[Energy]]:\n\"\"\"Get a receiver to receive new capacity metrics when they change.\n        The reported capacity values consider only working batteries with operational\n        inverters.\n        Calculated with the formula:\n        ```\n        working_batteries: Set[BatteryData] # working batteries from the battery pool\n        total_capacity = sum(\n            battery.capacity * (soc_upper_bound - soc_lower_bound) / 100\n            for battery in working_batteries\n        )\n        ```\n        `None` will be sent if there are no working batteries with operational\n        inverters to calculate metrics.\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n        Returns:\n            A MetricAggregator that will calculate and stream the capacity of all\n                batteries in the pool, considering only working batteries with\n                operational inverters.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + CapacityCalculator.name()\nif method_name not in self._active_methods:\ncalculator = CapacityCalculator(self._batteries)\nself._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._working_batteries,\nmin_update_interval=self._min_update_interval,\n)\nreturn self._active_methods[method_name]\n@property\ndef power_bounds(self) -&gt; MetricAggregator[PowerMetrics]:\n\"\"\"Get receiver to receive new power bounds when they change.\n        Power bounds refer to the min and max power that a battery can\n        discharge or charge at and is also denoted as SoP.\n        Power bounds formulas are described in the receiver return type.\n        None will be send if there is no component to calculate metrics.\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n        Returns:\n            A MetricAggregator that will calculate and stream the power bounds\n                of all batteries in the pool.\n        \"\"\"\nmethod_name = SendOnUpdate.name() + \"_\" + PowerBoundsCalculator.name()\nif method_name not in self._active_methods:\ncalculator = PowerBoundsCalculator(self._batteries)\nself._active_methods[method_name] = SendOnUpdate(\nmetric_calculator=calculator,\nworking_batteries=self._working_batteries,\nmin_update_interval=self._min_update_interval,\n)\nreturn self._active_methods[method_name]\nasync def stop(self) -&gt; None:\n\"\"\"Stop all pending async tasks.\"\"\"\ntasks_to_stop: list[Awaitable[Any]] = [\nmethod.stop() for method in self._active_methods.values()\n]\ntasks_to_stop.append(self._formula_pool.stop())\nif self._update_battery_status_task:\ntasks_to_stop.append(cancel_and_await(self._update_battery_status_task))\nawait asyncio.gather(*tasks_to_stop)\ndef _get_all_batteries(self) -&gt; Set[int]:\n\"\"\"Get all batteries from the microgrid.\n        Returns:\n            All batteries in the microgrid.\n        \"\"\"\ngraph = connection_manager.get().component_graph\nreturn {\nbattery.component_id\nfor battery in graph.components(\ncomponent_category={ComponentCategory.BATTERY}\n)\n}\nasync def _update_battery_status(self, receiver: Receiver[BatteryStatus]) -&gt; None:\nasync for status in receiver:\nself._working_batteries = status.get_working_batteries(self._batteries)\nfor item in self._active_methods.values():\nitem.update_working_batteries(self._working_batteries)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.battery_ids","title":"<code>battery_ids: Set[int]</code>  <code>property</code>","text":"<p>Return ids of the batteries in the pool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Ids of the batteries in the pool</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.capacity","title":"<code>capacity: MetricAggregator[Sample[Energy]]</code>  <code>property</code>","text":"<p>Get a receiver to receive new capacity metrics when they change.</p> <p>The reported capacity values consider only working batteries with operational inverters.</p> <p>Calculated with the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\ntotal_capacity = sum(\n    battery.capacity * (soc_upper_bound - soc_lower_bound) / 100\n    for battery in working_batteries\n)\n</code></pre></p> <p><code>None</code> will be sent if there are no working batteries with operational inverters to calculate metrics.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[Sample[Energy]]</code> <p>A MetricAggregator that will calculate and stream the capacity of all batteries in the pool, considering only working batteries with operational inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.consumption_power","title":"<code>consumption_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the total consumption power of the batteries in the pool.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total consumption power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.power","title":"<code>power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the total power of the batteries in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.power_bounds","title":"<code>power_bounds: MetricAggregator[PowerMetrics]</code>  <code>property</code>","text":"<p>Get receiver to receive new power bounds when they change.</p> <p>Power bounds refer to the min and max power that a battery can discharge or charge at and is also denoted as SoP.</p> <p>Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[PowerMetrics]</code> <p>A MetricAggregator that will calculate and stream the power bounds of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.production_power","title":"<code>production_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the total production power of the batteries in the pool.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total production power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.soc","title":"<code>soc: MetricAggregator[Sample[Percentage]]</code>  <code>property</code>","text":"<p>Fetch the normalized average weighted-by-capacity SoC values for the pool.</p> <p>The SoC values are normalized to the 0-100% range and clamped if they are out of bounds. Only values from working batteries with operational inverters are considered in the calculation.</p> <p>Average SoC is calculated using the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\n\nsoc_scaled = min(max(\n    0,\n    (soc - soc_lower_bound) / (soc_upper_bound - soc_lower_bound) * 100,\n), 100)\nused_capacity = sum(\n    battery.usable_capacity * battery.soc_scaled\n    for battery in working_batteries\n)\ntotal_capacity = sum(battery.usable_capacity for battery in working_batteries)\naverage_soc = used_capacity/total_capacity\n</code></pre></p> <p><code>None</code> values will be sent if there are no working batteries with operational inverters to calculate the metric with.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[Sample[Percentage]]</code> <p>A MetricAggregator that will calculate and stream the aggregate SoC of all batteries in the pool, considering only working batteries with operational inverters.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.temperature","title":"<code>temperature: MetricAggregator[Sample[Temperature]]</code>  <code>property</code>","text":"<p>Fetch the average temperature of the batteries in the pool.</p> RETURNS DESCRIPTION <code>MetricAggregator[Sample[Temperature]]</code> <p>A MetricAggregator that will calculate and stream the average temperature of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.__init__","title":"<code>__init__(channel_registry, resampler_subscription_sender, batteries_status_receiver, power_distributing_sender, min_update_interval, batteries_id=None)</code>","text":"<p>Create the class instance.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>batteries_status_receiver</code> <p>Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery.</p> <p> TYPE: <code>Receiver[BatteryStatus]</code> </p> <code>power_distributing_sender</code> <p>A Channel sender for sending power requests to the power distributing actor.</p> <p> TYPE: <code>Sender[Request]</code> </p> <code>min_update_interval</code> <p>Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them.</p> <p> TYPE: <code>timedelta</code> </p> <code>batteries_id</code> <p>Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used.</p> <p> TYPE: <code>Set[int] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\nbatteries_status_receiver: Receiver[BatteryStatus],\npower_distributing_sender: Sender[Request],\nmin_update_interval: timedelta,\nbatteries_id: Set[int] | None = None,\n) -&gt; None:\n\"\"\"Create the class instance.\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n        batteries_status_receiver: Receiver to receive status of the batteries.\n            Receivers should has maxsize = 1 to fetch only the latest status.\n            Battery status channel should has resend_latest = True.\n            It should send information when any battery changed status.\n            Battery status should include status of the inverter adjacent to this\n            battery.\n        power_distributing_sender: A Channel sender for sending power requests to\n            the power distributing actor.\n        min_update_interval: Some metrics in BatteryPool are send only when they\n            change. For these metrics min_update_interval is the minimum time\n            interval between the following messages.\n            Note that this argument is similar to the resampling period\n            argument in the ComponentMetricsResamplingActor. But as opposed to\n            ResamplingActor, timestamp returned in the resulting message will be\n            the timestamp of the last received component data.\n            It is currently impossible to use resampling actor for these metrics,\n            because we can't specify resampling function for them.\n        batteries_id: Subset of the batteries that should be included in the\n            battery pool. If None or empty, then all batteries from the microgrid\n            will be used.\n    \"\"\"\nif batteries_id:\nself._batteries: Set[int] = batteries_id\nelse:\nself._batteries = self._get_all_batteries()\nself._working_batteries: set[int] = set()\nself._update_battery_status_task: asyncio.Task[None] | None = None\nif self._batteries:\nself._update_battery_status_task = asyncio.create_task(\nself._update_battery_status(batteries_status_receiver)\n)\nself._min_update_interval = min_update_interval\nself._power_distributing_sender = power_distributing_sender\nself._active_methods: dict[str, MetricAggregator[Any]] = {}\nself._namespace: str = f\"battery-pool-{self._batteries}-{uuid.uuid4()}\"\nself._power_distributing_namespace: str = f\"power-distributor-{self._namespace}\"\nself._channel_registry: ChannelRegistry = channel_registry\nself._formula_pool: FormulaEnginePool = FormulaEnginePool(\nself._namespace,\nchannel_registry,\nresampler_subscription_sender,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.charge","title":"<code>charge(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given charge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating charge power.</p> <p>When using the Passive Sign Convention, the <code>set_power</code> method might be more convenient.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_distribution_results</code> method.</p> PARAMETER  DESCRIPTION <code>power</code> <p>Unsigned charge power to set for the batteries in the pool.</p> <p> TYPE: <code>Power</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def charge(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given charge power for the batteries in the pool.\n    Power values need to be positive values, indicating charge power.\n    When using the Passive Sign Convention, the `set_power` method might be more\n    convenient.\n    The result of the request can be accessed using the receiver returned from\n    the `power_distribution_results` method.\n    Args:\n        power: Unsigned charge power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\nif power &lt; Power.zero():\nraise ValueError(\"Charge power must be positive.\")\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.discharge","title":"<code>discharge(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given discharge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating discharge power.</p> <p>When using the Passive Sign Convention, the <code>set_power</code> method might be more convenient.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_distribution_results</code> method.</p> PARAMETER  DESCRIPTION <code>power</code> <p>Unsigned discharge power to set for the batteries in the pool.</p> <p> TYPE: <code>Power</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def discharge(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given discharge power for the batteries in the pool.\n    Power values need to be positive values, indicating discharge power.\n    When using the Passive Sign Convention, the `set_power` method might be more\n    convenient.\n    The result of the request can be accessed using the receiver returned from\n    the `power_distribution_results` method.\n    Args:\n        power: Unsigned discharge power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\nif power &lt; Power.zero():\nraise ValueError(\"Discharge power must be positive.\")\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=-power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.power_distribution_results","title":"<code>power_distribution_results()</code>","text":"<p>Return a receiver for the power distribution results.</p> RETURNS DESCRIPTION <code>Receiver[Result]</code> <p>A receiver for the power distribution results.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>def power_distribution_results(self) -&gt; Receiver[Result]:\n\"\"\"Return a receiver for the power distribution results.\n    Returns:\n        A receiver for the power distribution results.\n    \"\"\"\nreturn self._channel_registry.new_receiver(self._power_distributing_namespace)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.set_power","title":"<code>set_power(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given power for the batteries in the pool.</p> <p>Power values need to follow the Passive Sign Convention (PSC). That is, positive values indicate charge power and negative values indicate discharge power.</p> <p>When not using the Passive Sign Convention, the <code>charge</code> and <code>discharge</code> methods might be more convenient.</p> <p>The result of the request can be accessed using the receiver returned from the <code>power_distribution_results</code> method.</p> PARAMETER  DESCRIPTION <code>power</code> <p>The power to set for the batteries in the pool.</p> <p> TYPE: <code>Power</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def set_power(\nself,\npower: Power,\n*,\nadjust_power: bool = True,\nrequest_timeout: timedelta = timedelta(seconds=5.0),\ninclude_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given power for the batteries in the pool.\n    Power values need to follow the Passive Sign Convention (PSC). That is, positive\n    values indicate charge power and negative values indicate discharge power.\n    When not using the Passive Sign Convention, the `charge` and `discharge` methods\n    might be more convenient.\n    The result of the request can be accessed using the receiver returned from\n    the `power_distribution_results` method.\n    Args:\n        power: The power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n    \"\"\"\nawait self._power_distributing_sender.send(\nRequest(\nnamespace=self._power_distributing_namespace,\npower=power,\nbatteries=self._batteries,\nadjust_power=adjust_power,\nrequest_timeout=request_timeout,\ninclude_broken_batteries=include_broken_batteries,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop all pending async tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop all pending async tasks.\"\"\"\ntasks_to_stop: list[Awaitable[Any]] = [\nmethod.stop() for method in self._active_methods.values()\n]\ntasks_to_stop.append(self._formula_pool.stop())\nif self._update_battery_status_task:\ntasks_to_stop.append(cancel_and_await(self._update_battery_status_task))\nawait asyncio.gather(*tasks_to_stop)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/","title":"ev_charger_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool","title":"<code>frequenz.sdk.timeseries.ev_charger_pool</code>","text":"<p>Interactions with EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit","title":"<code>frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit</code>  <code>dataclass</code>","text":"<p>A current limit, to be sent to the EV Charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_set_current_bounds.py</code> <pre><code>@dataclass\nclass ComponentCurrentLimit:\n\"\"\"A current limit, to be sent to the EV Charger.\"\"\"\ncomponent_id: int\n\"\"\"The component ID of the EV Charger.\"\"\"\nmax_amps: float\n\"\"\"The maximum current in amps, that an EV can draw from this EV Charger.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit.component_id","title":"<code>component_id: int</code>  <code>instance-attribute</code>","text":"<p>The component ID of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit.max_amps","title":"<code>max_amps: float</code>  <code>instance-attribute</code>","text":"<p>The maximum current in amps, that an EV can draw from this EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData","title":"<code>frequenz.sdk.timeseries.ev_charger_pool.EVChargerData</code>  <code>dataclass</code>","text":"<p>Data for an EV Charger, including the 3-phase current and the component state.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>@dataclass(frozen=True)\nclass EVChargerData:\n\"\"\"Data for an EV Charger, including the 3-phase current and the component state.\"\"\"\ncomponent_id: int\n\"\"\"The component ID of the EV Charger.\"\"\"\ncurrent: Sample3Phase[Current]\n\"\"\"The 3-phase current of the EV Charger.\"\"\"\nstate: EVChargerState\n\"\"\"The state of the EV Charger.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData.component_id","title":"<code>component_id: int</code>  <code>instance-attribute</code>","text":"<p>The component ID of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData.current","title":"<code>current: Sample3Phase[Current]</code>  <code>instance-attribute</code>","text":"<p>The 3-phase current of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData.state","title":"<code>state: EVChargerState</code>  <code>instance-attribute</code>","text":"<p>The state of the EV Charger.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool","title":"<code>frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool</code>","text":"<p>Interactions with EV Chargers.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>class EVChargerPool:\n\"\"\"Interactions with EV Chargers.\"\"\"\ndef __init__(\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\ncomponent_ids: set[int] | None = None,\nrepeat_interval: timedelta = timedelta(seconds=3.0),\n) -&gt; None:\n\"\"\"Create an `EVChargerPool` instance.\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n            component_ids: An optional list of component_ids belonging to this pool.  If\n                not specified, IDs of all EV Chargers in the microgrid will be fetched\n                from the component graph.\n            repeat_interval: Interval after which to repeat the last set bounds to the\n                microgrid API, if no new calls to `set_bounds` have been made.\n        \"\"\"\nself._channel_registry: ChannelRegistry = channel_registry\nself._repeat_interval = repeat_interval\nself._resampler_subscription_sender: Sender[\nComponentMetricRequest\n] = resampler_subscription_sender\nself._component_ids: set[int] = set()\nif component_ids is not None:\nself._component_ids = component_ids\nelse:\ngraph = connection_manager.get().component_graph\nself._component_ids = {\nevc.component_id\nfor evc in graph.components(\ncomponent_category={ComponentCategory.EV_CHARGER}\n)\n}\nself._state_tracker: StateTracker | None = None\nself._status_streams: dict[\nint, tuple[Task[None], Broadcast[EVChargerData]]\n] = {}\nself._namespace: str = f\"ev-charger-pool-{uuid.uuid4()}\"\nself._formula_pool: FormulaEnginePool = FormulaEnginePool(\nself._namespace,\nself._channel_registry,\nself._resampler_subscription_sender,\n)\nself._bounds_setter: BoundsSetter | None = None\n@property\ndef component_ids(self) -&gt; abc.Set[int]:\n\"\"\"Return component IDs of all EV Chargers managed by this EVChargerPool.\n        Returns:\n            Set of managed component IDs.\n        \"\"\"\nreturn self._component_ids\n@property\ndef current(self) -&gt; FormulaEngine3Phase[Current]:\n\"\"\"Fetch the total current for the EV Chargers in the pool.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate EV Charger current is not already running, it\n        will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the total current of all EV\n                Chargers.\n        \"\"\"\nengine = self._formula_pool.from_3_phase_current_formula_generator(\n\"ev_charger_total_current\",\nEVChargerCurrentFormula,\nFormulaGeneratorConfig(component_ids=self._component_ids),\n)\nassert isinstance(engine, FormulaEngine3Phase)\nreturn engine\n@property\ndef power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the total power for the EV Chargers in the pool.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate EV Charger power is not already running, it\n        will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all EV\n                Chargers.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"ev_charger_power\",\nEVChargerPowerFormula,\nFormulaGeneratorConfig(\ncomponent_ids=self._component_ids,\nformula_type=FormulaType.PASSIVE_SIGN_CONVENTION,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef production_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the total power produced by the EV Chargers in the pool.\n        This formula produces positive values when producing power and 0 otherwise.\n        If a formula engine to calculate EV Charger power is not already running, it\n        will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the production power of all\n                EV Chargers.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"ev_charger_production_power\",\nEVChargerPowerFormula,\nFormulaGeneratorConfig(\ncomponent_ids=self._component_ids,\nformula_type=FormulaType.PRODUCTION,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef consumption_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the total power consumed by the EV Chargers in the pool.\n        This formula produces positive values when consuming power and 0 otherwise.\n        If a formula engine to calculate EV Charger power is not already running, it\n        will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream the consumption power of all\n                EV Chargers.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"ev_charger_consumption_power\",\nEVChargerPowerFormula,\nFormulaGeneratorConfig(\ncomponent_ids=self._component_ids,\nformula_type=FormulaType.CONSUMPTION,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\ndef component_data(self, component_id: int) -&gt; Receiver[EVChargerData]:\n\"\"\"Stream 3-phase current values and state of an EV Charger.\n        Args:\n            component_id: id of the EV Charger for which data is requested.\n        Returns:\n            A receiver that streams objects containing 3-phase current and state of\n                an EV Charger.\n        \"\"\"\nif recv := self._status_streams.get(component_id, None):\ntask, output_chan = recv\nif not task.done():\nreturn output_chan.new_receiver()\n_logger.warning(\"Restarting component_status for id: %s\", component_id)\nelse:\noutput_chan = Broadcast[EVChargerData](\nf\"evpool-component_status-{component_id}\"\n)\ntask = asyncio.create_task(\nself._stream_component_data(component_id, output_chan.new_sender())\n)\nself._status_streams[component_id] = (task, output_chan)\nreturn output_chan.new_receiver()\nasync def set_bounds(self, component_id: int, max_current: Current) -&gt; None:\n\"\"\"Send given max current bound for the given EV Charger to the microgrid API.\n        Bounds are used to limit the max current drawn by an EV, although the exact\n        value will be determined by the EV.\n        Args:\n            component_id: ID of EV Charger to set the current bounds to.\n            max_current: maximum current that an EV can draw from this EV Charger.\n        \"\"\"\nif not self._bounds_setter:\nself._bounds_setter = BoundsSetter(self._repeat_interval)\nawait self._bounds_setter.set(component_id, max_current.as_amperes())\ndef new_bounds_sender(self) -&gt; Sender[ComponentCurrentLimit]:\n\"\"\"Return a `Sender` for setting EV Charger current bounds with.\n        Bounds are used to limit the max current drawn by an EV, although the exact\n        value will be determined by the EV.\n        Returns:\n            A new `Sender`.\n        \"\"\"\nif not self._bounds_setter:\nself._bounds_setter = BoundsSetter(self._repeat_interval)\nreturn self._bounds_setter.new_bounds_sender()\nasync def stop(self) -&gt; None:\n\"\"\"Stop all tasks and channels owned by the EVChargerPool.\"\"\"\nif self._bounds_setter:\nawait self._bounds_setter.stop()\nif self._state_tracker:\nawait self._state_tracker.stop()\nawait self._formula_pool.stop()\nfor stream in self._status_streams.values():\ntask, chan = stream\nawait chan.close()\nawait cancel_and_await(task)\nasync def _get_current_streams(\nself, component_id: int\n) -&gt; tuple[\nReceiver[Sample[Quantity]],\nReceiver[Sample[Quantity]],\nReceiver[Sample[Quantity]],\n]:\n\"\"\"Fetch current streams from the resampler for each phase.\n        Args:\n            component_id: id of EV Charger for which current streams are being fetched.\n        Returns:\n            A tuple of 3 receivers stream resampled current values for the given\n                component id, one for each phase.\n        \"\"\"\nasync def resampler_subscribe(\nmetric_id: ComponentMetricId,\n) -&gt; Receiver[Sample[Quantity]]:\nrequest = ComponentMetricRequest(\nnamespace=\"ev-pool\",\ncomponent_id=component_id,\nmetric_id=metric_id,\nstart_time=None,\n)\nawait self._resampler_subscription_sender.send(request)\nreturn self._channel_registry.new_receiver(request.get_channel_name())\nreturn (\nawait resampler_subscribe(ComponentMetricId.CURRENT_PHASE_1),\nawait resampler_subscribe(ComponentMetricId.CURRENT_PHASE_2),\nawait resampler_subscribe(ComponentMetricId.CURRENT_PHASE_3),\n)\nasync def _stream_component_data(\nself,\ncomponent_id: int,\nsender: Sender[EVChargerData],\n) -&gt; None:\n\"\"\"Stream 3-phase current values and state of an EV Charger.\n        Args:\n            component_id: id of the EV Charger for which data is requested.\n            sender: A sender to stream EV Charger data to.\n        Raises:\n            ChannelClosedError: If the channels from the resampler are closed.\n        \"\"\"\nif not self._state_tracker:\nself._state_tracker = StateTracker(self._component_ids)\n(phase_1_rx, phase_2_rx, phase_3_rx) = await self._get_current_streams(\ncomponent_id\n)\nwhile True:\ntry:\n(phase_1, phase_2, phase_3) = (\nawait phase_1_rx.receive(),\nawait phase_2_rx.receive(),\nawait phase_3_rx.receive(),\n)\nexcept ChannelClosedError:\n_logger.exception(\"Streams closed for component_id=%s.\", component_id)\nraise\nsample = Sample3Phase(\ntimestamp=phase_1.timestamp,\nvalue_p1=None\nif phase_1.value is None\nelse Current.from_amperes(phase_1.value.base_value),\nvalue_p2=None\nif phase_2.value is None\nelse Current.from_amperes(phase_2.value.base_value),\nvalue_p3=None\nif phase_3.value is None\nelse Current.from_amperes(phase_3.value.base_value),\n)\nif (\nphase_1.value is None\nand phase_2.value is None\nand phase_3.value is None\n):\nstate = EVChargerState.MISSING\nelse:\nstate = self._state_tracker.get(component_id)\nawait sender.send(\nEVChargerData(\ncomponent_id=component_id,\ncurrent=sample,\nstate=state,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.component_ids","title":"<code>component_ids: abc.Set[int]</code>  <code>property</code>","text":"<p>Return component IDs of all EV Chargers managed by this EVChargerPool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Set of managed component IDs.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.consumption_power","title":"<code>consumption_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the total power consumed by the EV Chargers in the pool.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate EV Charger power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the consumption power of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.current","title":"<code>current: FormulaEngine3Phase[Current]</code>  <code>property</code>","text":"<p>Fetch the total current for the EV Chargers in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate EV Charger current is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine3Phase[Current]</code> <p>A FormulaEngine that will calculate and stream the total current of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.power","title":"<code>power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the total power for the EV Chargers in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate EV Charger power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the total power of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.production_power","title":"<code>production_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the total power produced by the EV Chargers in the pool.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate EV Charger power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream the production power of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.__init__","title":"<code>__init__(channel_registry, resampler_subscription_sender, component_ids=None, repeat_interval=timedelta(seconds=3.0))</code>","text":"<p>Create an <code>EVChargerPool</code> instance.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>component_ids</code> <p>An optional list of component_ids belonging to this pool.  If not specified, IDs of all EV Chargers in the microgrid will be fetched from the component graph.</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>repeat_interval</code> <p>Interval after which to repeat the last set bounds to the microgrid API, if no new calls to <code>set_bounds</code> have been made.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=3.0)</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def __init__(\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\ncomponent_ids: set[int] | None = None,\nrepeat_interval: timedelta = timedelta(seconds=3.0),\n) -&gt; None:\n\"\"\"Create an `EVChargerPool` instance.\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n        component_ids: An optional list of component_ids belonging to this pool.  If\n            not specified, IDs of all EV Chargers in the microgrid will be fetched\n            from the component graph.\n        repeat_interval: Interval after which to repeat the last set bounds to the\n            microgrid API, if no new calls to `set_bounds` have been made.\n    \"\"\"\nself._channel_registry: ChannelRegistry = channel_registry\nself._repeat_interval = repeat_interval\nself._resampler_subscription_sender: Sender[\nComponentMetricRequest\n] = resampler_subscription_sender\nself._component_ids: set[int] = set()\nif component_ids is not None:\nself._component_ids = component_ids\nelse:\ngraph = connection_manager.get().component_graph\nself._component_ids = {\nevc.component_id\nfor evc in graph.components(\ncomponent_category={ComponentCategory.EV_CHARGER}\n)\n}\nself._state_tracker: StateTracker | None = None\nself._status_streams: dict[\nint, tuple[Task[None], Broadcast[EVChargerData]]\n] = {}\nself._namespace: str = f\"ev-charger-pool-{uuid.uuid4()}\"\nself._formula_pool: FormulaEnginePool = FormulaEnginePool(\nself._namespace,\nself._channel_registry,\nself._resampler_subscription_sender,\n)\nself._bounds_setter: BoundsSetter | None = None\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.component_data","title":"<code>component_data(component_id)</code>","text":"<p>Stream 3-phase current values and state of an EV Charger.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>id of the EV Charger for which data is requested.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A receiver that streams objects containing 3-phase current and state of an EV Charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def component_data(self, component_id: int) -&gt; Receiver[EVChargerData]:\n\"\"\"Stream 3-phase current values and state of an EV Charger.\n    Args:\n        component_id: id of the EV Charger for which data is requested.\n    Returns:\n        A receiver that streams objects containing 3-phase current and state of\n            an EV Charger.\n    \"\"\"\nif recv := self._status_streams.get(component_id, None):\ntask, output_chan = recv\nif not task.done():\nreturn output_chan.new_receiver()\n_logger.warning(\"Restarting component_status for id: %s\", component_id)\nelse:\noutput_chan = Broadcast[EVChargerData](\nf\"evpool-component_status-{component_id}\"\n)\ntask = asyncio.create_task(\nself._stream_component_data(component_id, output_chan.new_sender())\n)\nself._status_streams[component_id] = (task, output_chan)\nreturn output_chan.new_receiver()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.new_bounds_sender","title":"<code>new_bounds_sender()</code>","text":"<p>Return a <code>Sender</code> for setting EV Charger current bounds with.</p> <p>Bounds are used to limit the max current drawn by an EV, although the exact value will be determined by the EV.</p> RETURNS DESCRIPTION <code>Sender[ComponentCurrentLimit]</code> <p>A new <code>Sender</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def new_bounds_sender(self) -&gt; Sender[ComponentCurrentLimit]:\n\"\"\"Return a `Sender` for setting EV Charger current bounds with.\n    Bounds are used to limit the max current drawn by an EV, although the exact\n    value will be determined by the EV.\n    Returns:\n        A new `Sender`.\n    \"\"\"\nif not self._bounds_setter:\nself._bounds_setter = BoundsSetter(self._repeat_interval)\nreturn self._bounds_setter.new_bounds_sender()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.set_bounds","title":"<code>set_bounds(component_id, max_current)</code>  <code>async</code>","text":"<p>Send given max current bound for the given EV Charger to the microgrid API.</p> <p>Bounds are used to limit the max current drawn by an EV, although the exact value will be determined by the EV.</p> PARAMETER  DESCRIPTION <code>component_id</code> <p>ID of EV Charger to set the current bounds to.</p> <p> TYPE: <code>int</code> </p> <code>max_current</code> <p>maximum current that an EV can draw from this EV Charger.</p> <p> TYPE: <code>Current</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>async def set_bounds(self, component_id: int, max_current: Current) -&gt; None:\n\"\"\"Send given max current bound for the given EV Charger to the microgrid API.\n    Bounds are used to limit the max current drawn by an EV, although the exact\n    value will be determined by the EV.\n    Args:\n        component_id: ID of EV Charger to set the current bounds to.\n        max_current: maximum current that an EV can draw from this EV Charger.\n    \"\"\"\nif not self._bounds_setter:\nself._bounds_setter = BoundsSetter(self._repeat_interval)\nawait self._bounds_setter.set(component_id, max_current.as_amperes())\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop all tasks and channels owned by the EVChargerPool.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop all tasks and channels owned by the EVChargerPool.\"\"\"\nif self._bounds_setter:\nawait self._bounds_setter.stop()\nif self._state_tracker:\nawait self._state_tracker.stop()\nawait self._formula_pool.stop()\nfor stream in self._status_streams.values():\ntask, chan = stream\nawait chan.close()\nawait cancel_and_await(task)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolError","title":"<code>frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>An error that occurred in any of the EVChargerPool methods.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>class EVChargerPoolError(Exception):\n\"\"\"An error that occurred in any of the EVChargerPool methods.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState","title":"<code>frequenz.sdk.timeseries.ev_charger_pool.EVChargerState</code>","text":"<p>             Bases: <code>Enum</code></p> <p>State of individual EV charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>class EVChargerState(Enum):\n\"\"\"State of individual EV charger.\"\"\"\nUNSPECIFIED = \"UNSPECIFIED\"\n\"\"\"The state is unspecified.\"\"\"\nMISSING = \"MISSING\"\n\"\"\"The EV Charger is missing.\"\"\"\nIDLE = \"IDLE\"\n\"\"\"The EV Charger is idle.\"\"\"\nEV_PLUGGED = \"EV_PLUGGED\"\n\"\"\"The EV Charger has an EV plugged in.\"\"\"\nEV_LOCKED = \"EV_LOCKED\"\n\"\"\"The EV Charger has an EV plugged in and locked.\"\"\"\nERROR = \"ERROR\"\n\"\"\"The EV Charger is in an error state.\"\"\"\n@classmethod\ndef from_ev_charger_data(cls, data: EVChargerData) -&gt; EVChargerState:\n\"\"\"Create an `EVChargerState` instance from component data.\n        Args:\n            data: ev charger data coming from microgrid.\n        Returns:\n            An `EVChargerState` instance.\n        \"\"\"\nif data.component_state == EVChargerComponentState.UNSPECIFIED:\nreturn EVChargerState.UNSPECIFIED\nif data.component_state in (\nEVChargerComponentState.AUTHORIZATION_REJECTED,\nEVChargerComponentState.ERROR,\n):\nreturn EVChargerState.ERROR\nif data.cable_state == EVChargerCableState.UNSPECIFIED:\nreturn EVChargerState.UNSPECIFIED\nif data.cable_state == EVChargerCableState.EV_LOCKED:\nreturn EVChargerState.EV_LOCKED\nif data.cable_state == EVChargerCableState.EV_PLUGGED:\nreturn EVChargerState.EV_PLUGGED\nreturn EVChargerState.IDLE\ndef is_ev_connected(self) -&gt; bool:\n\"\"\"Check whether an EV is connected to the charger.\n        Returns:\n            Whether an EV is connected to the charger.\n        \"\"\"\nreturn self in (EVChargerState.EV_PLUGGED, EVChargerState.EV_LOCKED)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.ERROR","title":"<code>ERROR = 'ERROR'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The EV Charger is in an error state.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.EV_LOCKED","title":"<code>EV_LOCKED = 'EV_LOCKED'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The EV Charger has an EV plugged in and locked.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.EV_PLUGGED","title":"<code>EV_PLUGGED = 'EV_PLUGGED'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The EV Charger has an EV plugged in.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.IDLE","title":"<code>IDLE = 'IDLE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The EV Charger is idle.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.MISSING","title":"<code>MISSING = 'MISSING'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The EV Charger is missing.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.UNSPECIFIED","title":"<code>UNSPECIFIED = 'UNSPECIFIED'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The state is unspecified.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.from_ev_charger_data","title":"<code>from_ev_charger_data(data)</code>  <code>classmethod</code>","text":"<p>Create an <code>EVChargerState</code> instance from component data.</p> PARAMETER  DESCRIPTION <code>data</code> <p>ev charger data coming from microgrid.</p> <p> TYPE: <code>EVChargerData</code> </p> RETURNS DESCRIPTION <code>EVChargerState</code> <p>An <code>EVChargerState</code> instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>@classmethod\ndef from_ev_charger_data(cls, data: EVChargerData) -&gt; EVChargerState:\n\"\"\"Create an `EVChargerState` instance from component data.\n    Args:\n        data: ev charger data coming from microgrid.\n    Returns:\n        An `EVChargerState` instance.\n    \"\"\"\nif data.component_state == EVChargerComponentState.UNSPECIFIED:\nreturn EVChargerState.UNSPECIFIED\nif data.component_state in (\nEVChargerComponentState.AUTHORIZATION_REJECTED,\nEVChargerComponentState.ERROR,\n):\nreturn EVChargerState.ERROR\nif data.cable_state == EVChargerCableState.UNSPECIFIED:\nreturn EVChargerState.UNSPECIFIED\nif data.cable_state == EVChargerCableState.EV_LOCKED:\nreturn EVChargerState.EV_LOCKED\nif data.cable_state == EVChargerCableState.EV_PLUGGED:\nreturn EVChargerState.EV_PLUGGED\nreturn EVChargerState.IDLE\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState.is_ev_connected","title":"<code>is_ev_connected()</code>","text":"<p>Check whether an EV is connected to the charger.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether an EV is connected to the charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>def is_ev_connected(self) -&gt; bool:\n\"\"\"Check whether an EV is connected to the charger.\n    Returns:\n        Whether an EV is connected to the charger.\n    \"\"\"\nreturn self in (EVChargerState.EV_PLUGGED, EVChargerState.EV_LOCKED)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/","title":"logical_meter","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter","title":"<code>frequenz.sdk.timeseries.logical_meter</code>","text":"<p>A logical meter for calculating high level metrics for a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter","title":"<code>frequenz.sdk.timeseries.logical_meter.LogicalMeter</code>","text":"<p>A logical meter for calculating high level metrics in a microgrid.</p> <p>LogicalMeter provides methods for fetching power values from different points in the microgrid.  These methods return <code>FormulaReceiver</code> objects, which can be used like normal <code>Receiver</code>s, but can also be composed to form higher-order formula streams.</p> Example <pre><code>from frequenz.channels import Sender, Broadcast\nfrom frequenz.sdk.actor import DataSourcingActor, ComponentMetricsResamplingActor\nfrom frequenz.sdk.timeseries import ResamplerConfig\nfrom frequenz.sdk.microgrid import initialize\nfrom datetime import timedelta\nchannel_registry = ChannelRegistry(name=\"data-registry\")\n# Create a channels for sending/receiving subscription requests\ndata_source_request_channel = Broadcast[ComponentMetricRequest](\"data-source\")\ndata_source_request_sender = data_source_request_channel.new_sender()\ndata_source_request_receiver = data_source_request_channel.new_receiver()\nresampling_request_channel = Broadcast[ComponentMetricRequest](\"resample\")\nresampling_request_sender = resampling_request_channel.new_sender()\nresampling_request_receiver = resampling_request_channel.new_receiver()\n# Instantiate a data sourcing actor\n_data_sourcing_actor = DataSourcingActor(\nrequest_receiver=data_source_request_receiver, registry=channel_registry\n)\n# Instantiate a resampling actor\nasync with ComponentMetricsResamplingActor(\nchannel_registry=channel_registry,\ndata_sourcing_request_sender=data_source_request_sender,\nresampling_request_receiver=resampling_request_receiver,\nconfig=ResamplerConfig(resampling_period=timedelta(seconds=1)),\n):\nawait initialize(\n\"127.0.0.1\",\n50051,\nResamplerConfig(resampling_period=timedelta(seconds=1))\n)\n# Create a logical meter instance\nlogical_meter = LogicalMeter(\nchannel_registry,\nresampling_request_sender,\n)\n# Get a receiver for a builtin formula\ngrid_power_recv = logical_meter.grid_power.new_receiver()\nfor grid_power_sample in grid_power_recv:\nprint(grid_power_sample)\n# or compose formula receivers to create a new formula\nnet_power_recv = (\n(\nlogical_meter.grid_power\n- logical_meter.pv_power\n)\n.build(\"net_power\")\n.new_receiver()\n)\nfor net_power_sample in net_power_recv:\nprint(net_power_sample)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>class LogicalMeter:\n\"\"\"A logical meter for calculating high level metrics in a microgrid.\n    LogicalMeter provides methods for fetching power values from different points in the\n    microgrid.  These methods return `FormulaReceiver` objects, which can be used like\n    normal `Receiver`s, but can also be composed to form higher-order formula streams.\n    Example:\n        ```python\n        from frequenz.channels import Sender, Broadcast\n        from frequenz.sdk.actor import DataSourcingActor, ComponentMetricsResamplingActor\n        from frequenz.sdk.timeseries import ResamplerConfig\n        from frequenz.sdk.microgrid import initialize\n        from datetime import timedelta\n        channel_registry = ChannelRegistry(name=\"data-registry\")\n        # Create a channels for sending/receiving subscription requests\n        data_source_request_channel = Broadcast[ComponentMetricRequest](\"data-source\")\n        data_source_request_sender = data_source_request_channel.new_sender()\n        data_source_request_receiver = data_source_request_channel.new_receiver()\n        resampling_request_channel = Broadcast[ComponentMetricRequest](\"resample\")\n        resampling_request_sender = resampling_request_channel.new_sender()\n        resampling_request_receiver = resampling_request_channel.new_receiver()\n        # Instantiate a data sourcing actor\n        _data_sourcing_actor = DataSourcingActor(\n            request_receiver=data_source_request_receiver, registry=channel_registry\n        )\n        # Instantiate a resampling actor\n        async with ComponentMetricsResamplingActor(\n            channel_registry=channel_registry,\n            data_sourcing_request_sender=data_source_request_sender,\n            resampling_request_receiver=resampling_request_receiver,\n            config=ResamplerConfig(resampling_period=timedelta(seconds=1)),\n        ):\n            await initialize(\n                \"127.0.0.1\",\n                50051,\n                ResamplerConfig(resampling_period=timedelta(seconds=1))\n            )\n            # Create a logical meter instance\n            logical_meter = LogicalMeter(\n                channel_registry,\n                resampling_request_sender,\n            )\n            # Get a receiver for a builtin formula\n            grid_power_recv = logical_meter.grid_power.new_receiver()\n            for grid_power_sample in grid_power_recv:\n                print(grid_power_sample)\n            # or compose formula receivers to create a new formula\n            net_power_recv = (\n                (\n                    logical_meter.grid_power\n                    - logical_meter.pv_power\n                )\n                .build(\"net_power\")\n                .new_receiver()\n            )\n            for net_power_sample in net_power_recv:\n                print(net_power_sample)\n        ```\n    \"\"\"\ndef __init__(\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n\"\"\"Create a `LogicalMeter instance`.\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n        \"\"\"\nself._channel_registry = channel_registry\nself._resampler_subscription_sender = resampler_subscription_sender\n# Use a randomly generated uuid to create a unique namespace name for the local\n# meter to use when communicating with the resampling actor.\nself._namespace = f\"logical-meter-{uuid.uuid4()}\"\nself._formula_pool = FormulaEnginePool(\nself._namespace,\nself._channel_registry,\nself._resampler_subscription_sender,\n)\ndef start_formula(\nself,\nformula: str,\ncomponent_metric_id: ComponentMetricId,\n*,\nnones_are_zeros: bool = False,\n) -&gt; FormulaEngine[Quantity]:\n\"\"\"Start execution of the given formula.\n        Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and\n        these operators: +, -, *, /, (, ).\n        For example, the input string: \"#20 + #5\" is a formula for adding metrics from\n        two components with ids 20 and 5.\n        Args:\n            formula: formula to execute.\n            component_metric_id: The metric ID to use when fetching receivers from the\n                resampling actor.\n            nones_are_zeros: Whether to treat None values from the stream as 0s.  If\n                False, the returned value will be a None.\n        Returns:\n            A FormulaEngine that applies the formula and streams values.\n        \"\"\"\nreturn self._formula_pool.from_string(\nformula, component_metric_id, nones_are_zeros=nones_are_zeros\n)\n@property\ndef grid_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the grid power for the microgrid.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate grid power is not already running, it will be\n        started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream grid power.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"grid_power\",\nGridPowerFormula,\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef grid_consumption_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the grid consumption power for the microgrid.\n        This formula produces positive values when consuming power and 0 otherwise.\n        If a formula engine to calculate grid consumption power is not already running,\n        it will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream grid consumption power.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"grid_consumption_power\",\nGridPowerFormula,\nFormulaGeneratorConfig(formula_type=FormulaType.CONSUMPTION),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef grid_production_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the grid production power for the microgrid.\n        This formula produces positive values when producing power and 0 otherwise.\n        If a formula engine to calculate grid production power is not already running,\n        it will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream grid production power.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"grid_production_power\",\nGridPowerFormula,\nFormulaGeneratorConfig(formula_type=FormulaType.PRODUCTION),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef grid_current(self) -&gt; FormulaEngine3Phase[Current]:\n\"\"\"Fetch the grid power for the microgrid.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate grid current is not already running, it will be\n        started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream grid current.\n        \"\"\"\nengine = self._formula_pool.from_3_phase_current_formula_generator(\n\"grid_current\",\nGridCurrentFormula,\n)\nassert isinstance(engine, FormulaEngine3Phase)\nreturn engine\n@property\ndef consumer_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the consumer power for the microgrid.\n        Under normal circumstances this is expected to correspond to the gross\n        consumption of the site excluding active parts and battery.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate consumer power is not already running, it will\n        be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream consumer power.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"consumer_power\",\nConsumerPowerFormula,\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef producer_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the producer power for the microgrid.\n        Under normal circumstances this is expected to correspond to the production\n        of the sites active parts excluding ev chargers and batteries.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate producer power is not already running, it will\n        be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream producer power.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"producer_power\",\nProducerPowerFormula,\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef pv_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the PV power in the microgrid.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate PV power is not already running, it will be\n        started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream PV total power.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"pv_power\",\nPVPowerFormula,\nFormulaGeneratorConfig(formula_type=FormulaType.PASSIVE_SIGN_CONVENTION),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef pv_production_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the PV power production in the microgrid.\n        This formula produces positive values when producing power and 0 otherwise.\n        If a formula engine to calculate PV power production is not already running, it\n        will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream PV power production.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"pv_production_power\",\nPVPowerFormula,\nFormulaGeneratorConfig(formula_type=FormulaType.PRODUCTION),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef pv_consumption_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the PV power consumption in the microgrid.\n        This formula produces positive values when consuming power and 0 otherwise.\n        If a formula engine to calculate PV power consumption is not already running, it\n        will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream PV power consumption.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"pv_consumption_power\",\nPVPowerFormula,\nFormulaGeneratorConfig(formula_type=FormulaType.CONSUMPTION),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef chp_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the CHP power production in the microgrid.\n        This formula produces values that are in the Passive Sign Convention (PSC).\n        If a formula engine to calculate CHP power production is not already running, it\n        will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream CHP power production.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"chp_power\",\nCHPPowerFormula,\nFormulaGeneratorConfig(formula_type=FormulaType.PASSIVE_SIGN_CONVENTION),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef chp_production_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the CHP power production in the microgrid.\n        This formula produces positive values when producing power and 0 otherwise.\n        If a formula engine to calculate CHP power production is not already running, it\n        will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream CHP power production.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"chp_production_power\",\nCHPPowerFormula,\nFormulaGeneratorConfig(\nformula_type=FormulaType.PRODUCTION,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\n@property\ndef chp_consumption_power(self) -&gt; FormulaEngine[Power]:\n\"\"\"Fetch the CHP power consumption in the microgrid.\n        This formula produces positive values when consuming power and 0 otherwise.\n        If a formula engine to calculate CHP power consumption is not already running,\n        it will be started.\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n        Returns:\n            A FormulaEngine that will calculate and stream CHP power consumption.\n        \"\"\"\nengine = self._formula_pool.from_power_formula_generator(\n\"chp_consumption_power\",\nCHPPowerFormula,\nFormulaGeneratorConfig(\nformula_type=FormulaType.CONSUMPTION,\n),\n)\nassert isinstance(engine, FormulaEngine)\nreturn engine\nasync def stop(self) -&gt; None:\n\"\"\"Stop all formula engines.\"\"\"\nawait self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.chp_consumption_power","title":"<code>chp_consumption_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the CHP power consumption in the microgrid.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate CHP power consumption is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream CHP power consumption.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.chp_power","title":"<code>chp_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the CHP power production in the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate CHP power production is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream CHP power production.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.chp_production_power","title":"<code>chp_production_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the CHP power production in the microgrid.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate CHP power production is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream CHP power production.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.consumer_power","title":"<code>consumer_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the consumer power for the microgrid.</p> <p>Under normal circumstances this is expected to correspond to the gross consumption of the site excluding active parts and battery.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate consumer power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream consumer power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.grid_consumption_power","title":"<code>grid_consumption_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the grid consumption power for the microgrid.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate grid consumption power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream grid consumption power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.grid_current","title":"<code>grid_current: FormulaEngine3Phase[Current]</code>  <code>property</code>","text":"<p>Fetch the grid power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate grid current is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine3Phase[Current]</code> <p>A FormulaEngine that will calculate and stream grid current.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.grid_power","title":"<code>grid_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the grid power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate grid power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream grid power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.grid_production_power","title":"<code>grid_production_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the grid production power for the microgrid.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate grid production power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream grid production power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.producer_power","title":"<code>producer_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the producer power for the microgrid.</p> <p>Under normal circumstances this is expected to correspond to the production of the sites active parts excluding ev chargers and batteries.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate producer power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream producer power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.pv_consumption_power","title":"<code>pv_consumption_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the PV power consumption in the microgrid.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate PV power consumption is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream PV power consumption.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.pv_power","title":"<code>pv_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the PV power in the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate PV power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream PV total power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.pv_production_power","title":"<code>pv_production_power: FormulaEngine[Power]</code>  <code>property</code>","text":"<p>Fetch the PV power production in the microgrid.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate PV power production is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine[Power]</code> <p>A FormulaEngine that will calculate and stream PV power production.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.__init__","title":"<code>__init__(channel_registry, resampler_subscription_sender)</code>","text":"<p>Create a <code>LogicalMeter instance</code>.</p> PARAMETER  DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>def __init__(\nself,\nchannel_registry: ChannelRegistry,\nresampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n\"\"\"Create a `LogicalMeter instance`.\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n    \"\"\"\nself._channel_registry = channel_registry\nself._resampler_subscription_sender = resampler_subscription_sender\n# Use a randomly generated uuid to create a unique namespace name for the local\n# meter to use when communicating with the resampling actor.\nself._namespace = f\"logical-meter-{uuid.uuid4()}\"\nself._formula_pool = FormulaEnginePool(\nself._namespace,\nself._channel_registry,\nself._resampler_subscription_sender,\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.start_formula","title":"<code>start_formula(formula, component_metric_id, *, nones_are_zeros=False)</code>","text":"<p>Start execution of the given formula.</p> <p>Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and these operators: +, -, *, /, (, ).</p> <p>For example, the input string: \"#20 + #5\" is a formula for adding metrics from two components with ids 20 and 5.</p> PARAMETER  DESCRIPTION <code>formula</code> <p>formula to execute.</p> <p> TYPE: <code>str</code> </p> <code>component_metric_id</code> <p>The metric ID to use when fetching receivers from the resampling actor.</p> <p> TYPE: <code>ComponentMetricId</code> </p> <code>nones_are_zeros</code> <p>Whether to treat None values from the stream as 0s.  If False, the returned value will be a None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>FormulaEngine[Quantity]</code> <p>A FormulaEngine that applies the formula and streams values.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>def start_formula(\nself,\nformula: str,\ncomponent_metric_id: ComponentMetricId,\n*,\nnones_are_zeros: bool = False,\n) -&gt; FormulaEngine[Quantity]:\n\"\"\"Start execution of the given formula.\n    Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and\n    these operators: +, -, *, /, (, ).\n    For example, the input string: \"#20 + #5\" is a formula for adding metrics from\n    two components with ids 20 and 5.\n    Args:\n        formula: formula to execute.\n        component_metric_id: The metric ID to use when fetching receivers from the\n            resampling actor.\n        nones_are_zeros: Whether to treat None values from the stream as 0s.  If\n            False, the returned value will be a None.\n    Returns:\n        A FormulaEngine that applies the formula and streams values.\n    \"\"\"\nreturn self._formula_pool.from_string(\nformula, component_metric_id, nones_are_zeros=nones_are_zeros\n)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop all formula engines.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop all formula engines.\"\"\"\nawait self._formula_pool.stop()\n</code></pre>"}]}