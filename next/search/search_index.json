{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Frequenz Python SDK \u00a4 A development kit to interact with the Frequenz development platform. Supported Python versions \u00a4 For x86_64 Python 3.8 - 3.11 are supported (tested). For arm64 only Python 3.8 is supported (due to some dependencies that only support 3.8). Contributing \u00a4 If you want to know how to build this project and contribute to it, please check out the Contributing Guide .","title":"Home"},{"location":"#frequenz-python-sdk","text":"A development kit to interact with the Frequenz development platform.","title":"Frequenz Python SDK"},{"location":"#supported-python-versions","text":"For x86_64 Python 3.8 - 3.11 are supported (tested). For arm64 only Python 3.8 is supported (due to some dependencies that only support 3.8).","title":"Supported Python versions"},{"location":"#contributing","text":"If you want to know how to build this project and contribute to it, please check out the Contributing Guide .","title":"Contributing"},{"location":"CONTRIBUTING/","text":"Contributing to frequenz-sdk \u00a4 Build \u00a4 You can use build to simply build the source and binary distribution: python -m pip install build python -m build Local development \u00a4 You can use editable installs to develop the project locally (it will install all the dependencies too): python -m pip install -e . Or you can install all development dependencies ( mypy , pylint , pytest , etc.) in one go too: python -m pip install -e . [ dev ] If you don't want to install all the dependencies, you can also use nox to run the tests and other checks creating its own virtual environments: python -m pip install nox toml nox You can also use nox -R to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment. Running tests / checks individually \u00a4 For a better development test cycle you can install the runtime and test dependencies and run pytest manually. python -m pip install . [ pytest ] # included in .[dev] too # And for example pytest tests/test_sdk.py Or you can use nox : nox -R -s pytest -- test/test_sdk.py The same appliest to pylint or mypy for example: nox -R -s pylint -- test/test_sdk.py nox -R -s mypy -- test/test_sdk.py Building the documentation \u00a4 To build the documentation, first install the dependencies (if you didn't install all dev dependencies): python -m pip install -e . [ docs-gen ] Then you can build the documentation (it will be written in the site/ directory): mkdocs build Or you can just serve the documentation without building it using: mkdocs serve Your site will be updated live when you change your files (provided that you used pip install -e . , beware of a common pitfall of using pip install without -e , in that case the API reference won't change unless you do a new pip install ). To build multi-version documentation, we use mike . If you want to see how the multi-version sites looks like locally, you can use: mike deploy my-version mike set-default my-version mike serve mike works in mysterious ways. Some basic information: mike deploy will do a mike build and write the results to your local gh-pages branch. my-version is an arbitrary name for the local version you want to preview. mike set-default is needed so when you serve the documentation, it goes to your newly produced documentation by default. mike serve will serve the contents of your local gh-pages branch. Be aware that, unlike mkdocs serve , changes to the sources won't be shown live, as the mike deploy step is needed to refresh them. Be careful not to use --push with mike deploy , otherwise it will push your local gh-pages branch to the origin remote. That said, if you want to test the actual website in your fork , you can always use mike deploy --push --remote your-fork-remote , and then access the GitHub pages produced for your fork. Releasing \u00a4 These are the steps to create a new release: Get the latest head you want to create a release from. Update the RELEASE_NOTES.md file if it is not complete, up to date, and clean from template comments ( <!-- ... -> ) and empty sections. Submit a pull request if an update is needed, wait until it is merged, and update the latest head you want to create a release from to get the new merged pull request. Create a new signed tag using the release notes and a semver compatible version number with a v prefix, for example: git tag -s -F RELEASE_NOTES.md v0.0.1 Push the new tag. A GitHub action will test the tag and if all goes well it will create a GitHub Release , create a new announcement about the release, and upload a new package to PyPI automatically. Once this is done, reset the RELEASE_NOTES.md with the template: cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md Commit the new release notes and create a PR (this step should be automated eventually too). Celebrate!","title":"Development"},{"location":"CONTRIBUTING/#contributing-to-frequenz-sdk","text":"","title":"Contributing to frequenz-sdk"},{"location":"CONTRIBUTING/#build","text":"You can use build to simply build the source and binary distribution: python -m pip install build python -m build","title":"Build"},{"location":"CONTRIBUTING/#local-development","text":"You can use editable installs to develop the project locally (it will install all the dependencies too): python -m pip install -e . Or you can install all development dependencies ( mypy , pylint , pytest , etc.) in one go too: python -m pip install -e . [ dev ] If you don't want to install all the dependencies, you can also use nox to run the tests and other checks creating its own virtual environments: python -m pip install nox toml nox You can also use nox -R to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.","title":"Local development"},{"location":"CONTRIBUTING/#running-tests-checks-individually","text":"For a better development test cycle you can install the runtime and test dependencies and run pytest manually. python -m pip install . [ pytest ] # included in .[dev] too # And for example pytest tests/test_sdk.py Or you can use nox : nox -R -s pytest -- test/test_sdk.py The same appliest to pylint or mypy for example: nox -R -s pylint -- test/test_sdk.py nox -R -s mypy -- test/test_sdk.py","title":"Running tests / checks individually"},{"location":"CONTRIBUTING/#building-the-documentation","text":"To build the documentation, first install the dependencies (if you didn't install all dev dependencies): python -m pip install -e . [ docs-gen ] Then you can build the documentation (it will be written in the site/ directory): mkdocs build Or you can just serve the documentation without building it using: mkdocs serve Your site will be updated live when you change your files (provided that you used pip install -e . , beware of a common pitfall of using pip install without -e , in that case the API reference won't change unless you do a new pip install ). To build multi-version documentation, we use mike . If you want to see how the multi-version sites looks like locally, you can use: mike deploy my-version mike set-default my-version mike serve mike works in mysterious ways. Some basic information: mike deploy will do a mike build and write the results to your local gh-pages branch. my-version is an arbitrary name for the local version you want to preview. mike set-default is needed so when you serve the documentation, it goes to your newly produced documentation by default. mike serve will serve the contents of your local gh-pages branch. Be aware that, unlike mkdocs serve , changes to the sources won't be shown live, as the mike deploy step is needed to refresh them. Be careful not to use --push with mike deploy , otherwise it will push your local gh-pages branch to the origin remote. That said, if you want to test the actual website in your fork , you can always use mike deploy --push --remote your-fork-remote , and then access the GitHub pages produced for your fork.","title":"Building the documentation"},{"location":"CONTRIBUTING/#releasing","text":"These are the steps to create a new release: Get the latest head you want to create a release from. Update the RELEASE_NOTES.md file if it is not complete, up to date, and clean from template comments ( <!-- ... -> ) and empty sections. Submit a pull request if an update is needed, wait until it is merged, and update the latest head you want to create a release from to get the new merged pull request. Create a new signed tag using the release notes and a semver compatible version number with a v prefix, for example: git tag -s -F RELEASE_NOTES.md v0.0.1 Push the new tag. A GitHub action will test the tag and if all goes well it will create a GitHub Release , create a new announcement about the release, and upload a new package to PyPI automatically. Once this is done, reset the RELEASE_NOTES.md with the template: cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md Commit the new release notes and create a PR (this step should be automated eventually too). Celebrate!","title":"Releasing"},{"location":"SUMMARY/","text":"Home API Reference Development","title":"SUMMARY"},{"location":"reference/SUMMARY/","text":"frequenz sdk actor power_distributing power_distributing request result config microgrid client component power timeseries battery_pool battery_pool ev_charger_pool logical_meter","title":"SUMMARY"},{"location":"reference/frequenz/sdk/","text":"frequenz.sdk \u00a4 Frequenz Python SDK.","title":"sdk"},{"location":"reference/frequenz/sdk/#frequenz.sdk","text":"Frequenz Python SDK.","title":"sdk"},{"location":"reference/frequenz/sdk/actor/","text":"frequenz.sdk.actor \u00a4 A base class for creating simple composable actors. Classes \u00a4 frequenz.sdk.actor.ChannelRegistry \u00a4 Dynamically creates, own and provide access to channels. It can be used by actors to dynamically establish a communication channel between each other. Channels are identified by string names. Source code in frequenz/sdk/actor/_channel_registry.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class ChannelRegistry : \"\"\"Dynamically creates, own and provide access to channels. It can be used by actors to dynamically establish a communication channel between each other. Channels are identified by string names. \"\"\" def __init__ ( self , * , name : str ) -> None : \"\"\"Create a `ChannelRegistry` instance. Args: name: A unique name for the registry. \"\"\" self . _name = name self . _channels : Dict [ str , Broadcast [ Any ]] = {} def new_sender ( self , key : str ) -> Sender [ Any ]: \"\"\"Get a sender to a dynamically created channel with the given key. Args: key: A key to identify the channel. Returns: A sender to a dynamically created channel with the given key. \"\"\" if key not in self . _channels : self . _channels [ key ] = Broadcast ( f \" { self . _name } - { key } \" ) return self . _channels [ key ] . new_sender () def new_receiver ( self , key : str ) -> Receiver [ Any ]: \"\"\"Get a receiver to a dynamically created channel with the given key. Args: key: A key to identify the channel. Returns: A receiver for a dynamically created channel with the given key. \"\"\" if key not in self . _channels : self . _channels [ key ] = Broadcast ( f \" { self . _name } - { key } \" ) return self . _channels [ key ] . new_receiver () async def _close_channel ( self , key : str ) -> None : \"\"\"Close a channel with the given key. This method is private and should only be used in special cases. Args: key: A key to identify the channel. \"\"\" if key in self . _channels : if channel := self . _channels . pop ( key , None ): await channel . close () Functions \u00a4 __init__ ( * , name ) \u00a4 Create a ChannelRegistry instance. PARAMETER DESCRIPTION name A unique name for the registry. TYPE: str Source code in frequenz/sdk/actor/_channel_registry.py 18 19 20 21 22 23 24 25 def __init__ ( self , * , name : str ) -> None : \"\"\"Create a `ChannelRegistry` instance. Args: name: A unique name for the registry. \"\"\" self . _name = name self . _channels : Dict [ str , Broadcast [ Any ]] = {} new_receiver ( key ) \u00a4 Get a receiver to a dynamically created channel with the given key. PARAMETER DESCRIPTION key A key to identify the channel. TYPE: str RETURNS DESCRIPTION Receiver [ Any ] A receiver for a dynamically created channel with the given key. Source code in frequenz/sdk/actor/_channel_registry.py 40 41 42 43 44 45 46 47 48 49 50 51 def new_receiver ( self , key : str ) -> Receiver [ Any ]: \"\"\"Get a receiver to a dynamically created channel with the given key. Args: key: A key to identify the channel. Returns: A receiver for a dynamically created channel with the given key. \"\"\" if key not in self . _channels : self . _channels [ key ] = Broadcast ( f \" { self . _name } - { key } \" ) return self . _channels [ key ] . new_receiver () new_sender ( key ) \u00a4 Get a sender to a dynamically created channel with the given key. PARAMETER DESCRIPTION key A key to identify the channel. TYPE: str RETURNS DESCRIPTION Sender [ Any ] A sender to a dynamically created channel with the given key. Source code in frequenz/sdk/actor/_channel_registry.py 27 28 29 30 31 32 33 34 35 36 37 38 def new_sender ( self , key : str ) -> Sender [ Any ]: \"\"\"Get a sender to a dynamically created channel with the given key. Args: key: A key to identify the channel. Returns: A sender to a dynamically created channel with the given key. \"\"\" if key not in self . _channels : self . _channels [ key ] = Broadcast ( f \" { self . _name } - { key } \" ) return self . _channels [ key ] . new_sender () frequenz.sdk.actor.ComponentMetricRequest dataclass \u00a4 A request object to start streaming a metric for a component. Source code in frequenz/sdk/actor/_data_sourcing/microgrid_api_source.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @dataclass class ComponentMetricRequest : \"\"\"A request object to start streaming a metric for a component.\"\"\" namespace : str \"\"\"The namespace that this request belongs to. Metric requests with a shared namespace enable the reuse of channels within that namespace. If for example, an actor making a multiple requests, uses the name of the actor as the namespace, then requests from the actor will get reused when possible. \"\"\" component_id : int \"\"\"The ID of the requested component.\"\"\" metric_id : ComponentMetricId \"\"\"The ID of the requested component's metric.\"\"\" start_time : Optional [ datetime ] \"\"\"The start time from which data is required. When None, we will stream only live data. \"\"\" def get_channel_name ( self ) -> str : \"\"\"Return a channel name constructed from Self. This channel name can be used by the sending side and receiving sides to identify the right channel from the ChannelRegistry. Returns: A string denoting a channel name. \"\"\" return f \" { self . component_id } :: { self . metric_id . name } :: { self . start_time } :: { self . namespace } \" Attributes \u00a4 component_id : int class-attribute \u00a4 The ID of the requested component. metric_id : ComponentMetricId class-attribute \u00a4 The ID of the requested component's metric. namespace : str class-attribute \u00a4 The namespace that this request belongs to. Metric requests with a shared namespace enable the reuse of channels within that namespace. If for example, an actor making a multiple requests, uses the name of the actor as the namespace, then requests from the actor will get reused when possible. start_time : Optional [ datetime ] class-attribute \u00a4 The start time from which data is required. When None, we will stream only live data. Functions \u00a4 get_channel_name () \u00a4 Return a channel name constructed from Self. This channel name can be used by the sending side and receiving sides to identify the right channel from the ChannelRegistry. RETURNS DESCRIPTION str A string denoting a channel name. Source code in frequenz/sdk/actor/_data_sourcing/microgrid_api_source.py 54 55 56 57 58 59 60 61 62 63 def get_channel_name ( self ) -> str : \"\"\"Return a channel name constructed from Self. This channel name can be used by the sending side and receiving sides to identify the right channel from the ChannelRegistry. Returns: A string denoting a channel name. \"\"\" return f \" { self . component_id } :: { self . metric_id . name } :: { self . start_time } :: { self . namespace } \" frequenz.sdk.actor.ComponentMetricsResamplingActor \u00a4 An actor to resample microgrid component metrics. Source code in frequenz/sdk/actor/_resampling.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 @actor class ComponentMetricsResamplingActor : \"\"\"An actor to resample microgrid component metrics.\"\"\" def __init__ ( # pylint: disable=too-many-arguments self , * , channel_registry : ChannelRegistry , data_sourcing_request_sender : Sender [ ComponentMetricRequest ], resampling_request_receiver : Receiver [ ComponentMetricRequest ], config : ResamplerConfig , ) -> None : \"\"\"Initialize an instance. Args: channel_registry: The channel registry used to get senders and receivers for data sourcing subscriptions. data_sourcing_request_sender: The sender used to send requests to the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor] to subscribe to component metrics. resampling_request_receiver: The receiver to use to receive new resampmling subscription requests. config: The configuration for the resampler. \"\"\" self . _channel_registry : ChannelRegistry = channel_registry self . _data_sourcing_request_sender : Sender [ ComponentMetricRequest ] = data_sourcing_request_sender self . _resampling_request_receiver : Receiver [ ComponentMetricRequest ] = resampling_request_receiver self . _resampler : Resampler = Resampler ( config ) self . _active_req_channels : set [ str ] = set () async def _subscribe ( self , request : ComponentMetricRequest ) -> None : \"\"\"Request data for a component metric. Args: request: The request for component metric data. \"\"\" request_channel_name = request . get_channel_name () # If we are already handling this request, there is nothing to do. if request_channel_name in self . _active_req_channels : return self . _active_req_channels . add ( request_channel_name ) data_source_request = dataclasses . replace ( request , namespace = request . namespace + \":Source\" ) data_source_channel_name = data_source_request . get_channel_name () await self . _data_sourcing_request_sender . send ( data_source_request ) receiver = self . _channel_registry . new_receiver ( data_source_channel_name ) # This is a temporary hack until the Sender implementation uses # exceptions to report errors. sender = self . _channel_registry . new_sender ( request . get_channel_name ()) async def sink_adapter ( sample : Sample ) -> None : if not await sender . send ( sample ): raise RuntimeError ( f \"Error while sending with sender { sender } \" , sender ) self . _resampler . add_timeseries ( request_channel_name , receiver , sink_adapter ) async def _process_resampling_requests ( self ) -> None : \"\"\"Process resampling data requests.\"\"\" async for request in self . _resampling_request_receiver : await self . _subscribe ( request ) async def run ( self ) -> None : \"\"\"Resample known component metrics and process resampling requests. If there is a resampling error while resampling some component metric, then that metric will be discarded and not resampled any more. Any other error will be propagated (most likely ending in the actor being restarted). Raises: RuntimeError: If there is some unexpected error while resampling or handling requests. # noqa: DAR401 error \"\"\" tasks_to_cancel : set [ asyncio . Task [ None ]] = set () try : subscriptions_task = asyncio . create_task ( self . _process_resampling_requests () ) tasks_to_cancel . add ( subscriptions_task ) while True : resampling_task = asyncio . create_task ( self . _resampler . resample ()) tasks_to_cancel . add ( resampling_task ) done , _ = await asyncio . wait ( [ resampling_task , subscriptions_task ], return_when = asyncio . FIRST_COMPLETED , ) if subscriptions_task in done : tasks_to_cancel . remove ( subscriptions_task ) raise RuntimeError ( \"There was a problem with the subscriptions channel.\" ) if resampling_task in done : tasks_to_cancel . remove ( resampling_task ) # The resampler shouldn't end without an exception error = resampling_task . exception () assert ( error is not None ), \"The resample() function shouldn't exit normally.\" # We don't know what to do with something other than # ResamplingError, so propagate the exception if that is the # case. if not isinstance ( error , ResamplingError ): raise error for source , source_error in error . exceptions . items (): logger . error ( \"Error resampling source %s , removing source...\" , source ) removed = self . _resampler . remove_timeseries ( source ) if not removed : logger . warning ( \"Got an exception from an unknown source: \" \"source= %r , exception= %r \" , source , source_error , ) # The resampling_task will be re-created if we reached this point finally : await asyncio . gather ( * [ cancel_and_await ( t ) for t in tasks_to_cancel ]) Functions \u00a4 __init__ ( * , channel_registry , data_sourcing_request_sender , resampling_request_receiver , config ) \u00a4 Initialize an instance. PARAMETER DESCRIPTION channel_registry The channel registry used to get senders and receivers for data sourcing subscriptions. TYPE: ChannelRegistry data_sourcing_request_sender The sender used to send requests to the DataSourcingActor to subscribe to component metrics. TYPE: Sender [ ComponentMetricRequest ] resampling_request_receiver The receiver to use to receive new resampmling subscription requests. TYPE: Receiver [ ComponentMetricRequest ] config The configuration for the resampler. TYPE: ResamplerConfig Source code in frequenz/sdk/actor/_resampling.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( # pylint: disable=too-many-arguments self , * , channel_registry : ChannelRegistry , data_sourcing_request_sender : Sender [ ComponentMetricRequest ], resampling_request_receiver : Receiver [ ComponentMetricRequest ], config : ResamplerConfig , ) -> None : \"\"\"Initialize an instance. Args: channel_registry: The channel registry used to get senders and receivers for data sourcing subscriptions. data_sourcing_request_sender: The sender used to send requests to the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor] to subscribe to component metrics. resampling_request_receiver: The receiver to use to receive new resampmling subscription requests. config: The configuration for the resampler. \"\"\" self . _channel_registry : ChannelRegistry = channel_registry self . _data_sourcing_request_sender : Sender [ ComponentMetricRequest ] = data_sourcing_request_sender self . _resampling_request_receiver : Receiver [ ComponentMetricRequest ] = resampling_request_receiver self . _resampler : Resampler = Resampler ( config ) self . _active_req_channels : set [ str ] = set () run () async \u00a4 Resample known component metrics and process resampling requests. If there is a resampling error while resampling some component metric, then that metric will be discarded and not resampled any more. Any other error will be propagated (most likely ending in the actor being restarted). RAISES DESCRIPTION RuntimeError If there is some unexpected error while resampling or handling requests. noqa: DAR401 error \u00a4 Source code in frequenz/sdk/actor/_resampling.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 async def run ( self ) -> None : \"\"\"Resample known component metrics and process resampling requests. If there is a resampling error while resampling some component metric, then that metric will be discarded and not resampled any more. Any other error will be propagated (most likely ending in the actor being restarted). Raises: RuntimeError: If there is some unexpected error while resampling or handling requests. # noqa: DAR401 error \"\"\" tasks_to_cancel : set [ asyncio . Task [ None ]] = set () try : subscriptions_task = asyncio . create_task ( self . _process_resampling_requests () ) tasks_to_cancel . add ( subscriptions_task ) while True : resampling_task = asyncio . create_task ( self . _resampler . resample ()) tasks_to_cancel . add ( resampling_task ) done , _ = await asyncio . wait ( [ resampling_task , subscriptions_task ], return_when = asyncio . FIRST_COMPLETED , ) if subscriptions_task in done : tasks_to_cancel . remove ( subscriptions_task ) raise RuntimeError ( \"There was a problem with the subscriptions channel.\" ) if resampling_task in done : tasks_to_cancel . remove ( resampling_task ) # The resampler shouldn't end without an exception error = resampling_task . exception () assert ( error is not None ), \"The resample() function shouldn't exit normally.\" # We don't know what to do with something other than # ResamplingError, so propagate the exception if that is the # case. if not isinstance ( error , ResamplingError ): raise error for source , source_error in error . exceptions . items (): logger . error ( \"Error resampling source %s , removing source...\" , source ) removed = self . _resampler . remove_timeseries ( source ) if not removed : logger . warning ( \"Got an exception from an unknown source: \" \"source= %r , exception= %r \" , source , source_error , ) # The resampling_task will be re-created if we reached this point finally : await asyncio . gather ( * [ cancel_and_await ( t ) for t in tasks_to_cancel ]) frequenz.sdk.actor.ConfigManagingActor \u00a4 Manages config variables. Config variables are read from file. Only single file can be read. If new file is read, then previous configs will be forgotten. Source code in frequenz/sdk/actor/_config_managing.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @actor class ConfigManagingActor : \"\"\" Manages config variables. Config variables are read from file. Only single file can be read. If new file is read, then previous configs will be forgotten. \"\"\" def __init__ ( self , conf_file : str , output : Sender [ Config ], event_types : Optional [ Set [ FileWatcher . EventType ]] = None , ) -> None : \"\"\"Read config variables from the file. Args: conf_file: Path to file with config variables. output: Channel to publish updates to. event_types: Which types of events should update the config and trigger a notification. \"\"\" self . _conf_file : str = conf_file self . _conf_dir : str = os . path . dirname ( conf_file ) self . _file_watcher = FileWatcher ( paths = [ self . _conf_dir ], event_types = event_types ) self . _output = output def _read_config ( self ) -> Dict [ str , Any ]: \"\"\"Read the contents of the config file. Raises: ValueError: if config file cannot be read. Returns: A dictionary containing configuration variables. \"\"\" try : return toml . load ( self . _conf_file ) except ValueError as err : logging . error ( \"Can't read config file, err: %s \" , err ) raise async def send_config ( self ) -> None : \"\"\"Send config file using a broadcast channel.\"\"\" conf_vars = self . _read_config () config = Config ( conf_vars ) await self . _output . send ( config ) async def run ( self ) -> None : \"\"\"Watch config file and update when modified. At startup, the Config Manager sends the current config so that it can be cache in the Broadcast channel and served to receivers even if there hasn't been any change to the config file itself. \"\"\" await self . send_config () async for path in self . _file_watcher : if str ( path ) == self . _conf_file : logger . info ( \"Update configs, because file %s was modified.\" , self . _conf_file , ) await self . send_config () logger . debug ( \"ConfigManager stopped.\" ) Functions \u00a4 __init__ ( conf_file , output , event_types = None ) \u00a4 Read config variables from the file. PARAMETER DESCRIPTION conf_file Path to file with config variables. TYPE: str output Channel to publish updates to. TYPE: Sender [ Config ] event_types Which types of events should update the config and trigger a notification. TYPE: Optional [ Set [ FileWatcher . EventType ]] DEFAULT: None Source code in frequenz/sdk/actor/_config_managing.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , conf_file : str , output : Sender [ Config ], event_types : Optional [ Set [ FileWatcher . EventType ]] = None , ) -> None : \"\"\"Read config variables from the file. Args: conf_file: Path to file with config variables. output: Channel to publish updates to. event_types: Which types of events should update the config and trigger a notification. \"\"\" self . _conf_file : str = conf_file self . _conf_dir : str = os . path . dirname ( conf_file ) self . _file_watcher = FileWatcher ( paths = [ self . _conf_dir ], event_types = event_types ) self . _output = output run () async \u00a4 Watch config file and update when modified. At startup, the Config Manager sends the current config so that it can be cache in the Broadcast channel and served to receivers even if there hasn't been any change to the config file itself. Source code in frequenz/sdk/actor/_config_managing.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 async def run ( self ) -> None : \"\"\"Watch config file and update when modified. At startup, the Config Manager sends the current config so that it can be cache in the Broadcast channel and served to receivers even if there hasn't been any change to the config file itself. \"\"\" await self . send_config () async for path in self . _file_watcher : if str ( path ) == self . _conf_file : logger . info ( \"Update configs, because file %s was modified.\" , self . _conf_file , ) await self . send_config () logger . debug ( \"ConfigManager stopped.\" ) send_config () async \u00a4 Send config file using a broadcast channel. Source code in frequenz/sdk/actor/_config_managing.py 66 67 68 69 70 async def send_config ( self ) -> None : \"\"\"Send config file using a broadcast channel.\"\"\" conf_vars = self . _read_config () config = Config ( conf_vars ) await self . _output . send ( config ) frequenz.sdk.actor.DataSourcingActor \u00a4 An actor that provides data streams of metrics as time series. Source code in frequenz/sdk/actor/_data_sourcing/data_sourcing.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @actor class DataSourcingActor : \"\"\"An actor that provides data streams of metrics as time series.\"\"\" def __init__ ( self , request_receiver : Receiver [ ComponentMetricRequest ], registry : ChannelRegistry , ) -> None : \"\"\"Create a `DataSourcingActor` instance. Args: request_receiver: A channel receiver to accept metric requests from. registry: A channel registry. To be replaced by a singleton instance. \"\"\" self . _request_receiver = request_receiver self . _microgrid_api_source = MicrogridApiSource ( registry ) async def run ( self ) -> None : \"\"\"Run the actor.\"\"\" async for request in self . _request_receiver : await self . _microgrid_api_source . add_metric ( request ) Functions \u00a4 __init__ ( request_receiver , registry ) \u00a4 Create a DataSourcingActor instance. PARAMETER DESCRIPTION request_receiver A channel receiver to accept metric requests from. TYPE: Receiver [ ComponentMetricRequest ] registry A channel registry. To be replaced by a singleton instance. TYPE: ChannelRegistry Source code in frequenz/sdk/actor/_data_sourcing/data_sourcing.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , request_receiver : Receiver [ ComponentMetricRequest ], registry : ChannelRegistry , ) -> None : \"\"\"Create a `DataSourcingActor` instance. Args: request_receiver: A channel receiver to accept metric requests from. registry: A channel registry. To be replaced by a singleton instance. \"\"\" self . _request_receiver = request_receiver self . _microgrid_api_source = MicrogridApiSource ( registry ) run () async \u00a4 Run the actor. Source code in frequenz/sdk/actor/_data_sourcing/data_sourcing.py 32 33 34 35 async def run ( self ) -> None : \"\"\"Run the actor.\"\"\" async for request in self . _request_receiver : await self . _microgrid_api_source . add_metric ( request ) frequenz.sdk.actor.ResamplerConfig dataclass \u00a4 Resampler configuration. Source code in frequenz/sdk/timeseries/_resampling.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 @dataclass ( frozen = True ) class ResamplerConfig : \"\"\"Resampler configuration.\"\"\" resampling_period_s : float \"\"\"The resampling period in seconds. This is the time it passes between resampled data should be calculated. It must be a positive number. \"\"\" max_data_age_in_periods : float = 3.0 \"\"\"The maximum age a sample can have to be considered *relevant* for resampling. Expressed in number of periods, where period is the `resampling_period_s` if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period). It must be bigger than 1.0. Example: If `resampling_period_s` is 3, the input sampling period is 1 and `max_data_age_in_periods` is 2, then data older than 3*2 = 6 secods will be discarded when creating a new sample and never passed to the resampling function. If `resampling_period_s` is 3, the input sampling period is 5 and `max_data_age_in_periods` is 2, then data older than 5*2 = 10 secods will be discarded when creating a new sample and never passed to the resampling function. \"\"\" resampling_function : ResamplingFunction = average \"\"\"The resampling function. This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value. \"\"\" initial_buffer_len : int = DEFAULT_BUFFER_LEN_INIT \"\"\"The initial length of the resampling buffer. The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored. It must be at least 1 and at most `max_buffer_len`. \"\"\" warn_buffer_len : int = DEFAULT_BUFFER_LEN_WARN \"\"\"The minimum length of the resampling buffer that will emit a warning. If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertly. It must be at least 1 and at most `max_buffer_len`. \"\"\" max_buffer_len : int = DEFAULT_BUFFER_LEN_MAX \"\"\"The maximum length of the resampling buffer. Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value. It must be at bigger than `warn_buffer_len`. \"\"\" def __post_init__ ( self ) -> None : \"\"\"Check that config values are valid. Raises: ValueError: If any value is out of range. \"\"\" if self . resampling_period_s < 0.0 : raise ValueError ( f \"resampling_period_s ( { self . resampling_period_s } ) must be positive\" ) if self . max_data_age_in_periods < 1.0 : raise ValueError ( f \"max_data_age_in_periods ( { self . max_data_age_in_periods } ) should be at least 1.0\" ) if self . warn_buffer_len < 1 : raise ValueError ( f \"warn_buffer_len ( { self . warn_buffer_len } ) should be at least 1\" ) if self . max_buffer_len <= self . warn_buffer_len : raise ValueError ( f \"max_buffer_len ( { self . max_buffer_len } ) should \" f \"be bigger than warn_buffer_len ( { self . warn_buffer_len } )\" ) if self . initial_buffer_len < 1 : raise ValueError ( f \"initial_buffer_len ( { self . initial_buffer_len } ) should at least 1\" ) if self . initial_buffer_len > self . max_buffer_len : raise ValueError ( f \"initial_buffer_len ( { self . initial_buffer_len } ) is bigger \" f \"than max_buffer_len ( { self . max_buffer_len } ), use a smaller \" \"initial_buffer_len or a bigger max_buffer_len\" ) if self . initial_buffer_len > self . warn_buffer_len : _logger . warning ( \"initial_buffer_len ( %s ) is bigger than warn_buffer_len ( %s )\" , self . initial_buffer_len , self . warn_buffer_len , ) Attributes \u00a4 initial_buffer_len : int = DEFAULT_BUFFER_LEN_INIT class-attribute \u00a4 The initial length of the resampling buffer. The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored. It must be at least 1 and at most max_buffer_len . max_buffer_len : int = DEFAULT_BUFFER_LEN_MAX class-attribute \u00a4 The maximum length of the resampling buffer. Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value. It must be at bigger than warn_buffer_len . max_data_age_in_periods : float = 3.0 class-attribute \u00a4 The maximum age a sample can have to be considered relevant for resampling. Expressed in number of periods, where period is the resampling_period_s if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period). It must be bigger than 1.0. Example If resampling_period_s is 3, the input sampling period is 1 and max_data_age_in_periods is 2, then data older than 3*2 = 6 secods will be discarded when creating a new sample and never passed to the resampling function. If resampling_period_s is 3, the input sampling period is 5 and max_data_age_in_periods is 2, then data older than 5*2 = 10 secods will be discarded when creating a new sample and never passed to the resampling function. resampling_function : ResamplingFunction = average class-attribute \u00a4 The resampling function. This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value. resampling_period_s : float class-attribute \u00a4 The resampling period in seconds. This is the time it passes between resampled data should be calculated. It must be a positive number. warn_buffer_len : int = DEFAULT_BUFFER_LEN_WARN class-attribute \u00a4 The minimum length of the resampling buffer that will emit a warning. If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertly. It must be at least 1 and at most max_buffer_len . Functions \u00a4 __post_init__ () \u00a4 Check that config values are valid. RAISES DESCRIPTION ValueError If any value is out of range. Source code in frequenz/sdk/timeseries/_resampling.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def __post_init__ ( self ) -> None : \"\"\"Check that config values are valid. Raises: ValueError: If any value is out of range. \"\"\" if self . resampling_period_s < 0.0 : raise ValueError ( f \"resampling_period_s ( { self . resampling_period_s } ) must be positive\" ) if self . max_data_age_in_periods < 1.0 : raise ValueError ( f \"max_data_age_in_periods ( { self . max_data_age_in_periods } ) should be at least 1.0\" ) if self . warn_buffer_len < 1 : raise ValueError ( f \"warn_buffer_len ( { self . warn_buffer_len } ) should be at least 1\" ) if self . max_buffer_len <= self . warn_buffer_len : raise ValueError ( f \"max_buffer_len ( { self . max_buffer_len } ) should \" f \"be bigger than warn_buffer_len ( { self . warn_buffer_len } )\" ) if self . initial_buffer_len < 1 : raise ValueError ( f \"initial_buffer_len ( { self . initial_buffer_len } ) should at least 1\" ) if self . initial_buffer_len > self . max_buffer_len : raise ValueError ( f \"initial_buffer_len ( { self . initial_buffer_len } ) is bigger \" f \"than max_buffer_len ( { self . max_buffer_len } ), use a smaller \" \"initial_buffer_len or a bigger max_buffer_len\" ) if self . initial_buffer_len > self . warn_buffer_len : _logger . warning ( \"initial_buffer_len ( %s ) is bigger than warn_buffer_len ( %s )\" , self . initial_buffer_len , self . warn_buffer_len , ) Functions \u00a4 frequenz . sdk . actor . actor ( cls ) \u00a4 Decorate a class into a simple composable actor. A actor using the actor decorator should define an async def run(self) method, that loops over incoming data, and sends results out. Channels can be used to implement communication between actors, as shown in the examples below. PARAMETER DESCRIPTION cls the class to decorate. TYPE: Type [ Any ] RETURNS DESCRIPTION Type [ Any ] The decorated class. RAISES DESCRIPTION TypeError when the class doesn't have a run method as per spec. Example (one actor receiving from two receivers): @actor class EchoActor : def __init__ ( self , name : str , recv1 : Receiver [ bool ], recv2 : Receiver [ bool ], output : Sender [ bool ], ) -> None : self . name = name self . _recv1 = recv1 self . _recv2 = recv2 self . _output = output async def run ( self ) -> None : select = Select ( channel_1 = self . _recv1 , channel_2 = self . _recv2 ) while await select . ready (): if msg := select . channel_1 : await self . _output . send ( msg . inner ) elif msg := select . channel_2 : await self . _output . send ( msg . inner ) input_chan_1 : Broadcast [ bool ] = Broadcast ( \"input_chan_1\" ) input_chan_2 : Broadcast [ bool ] = Broadcast ( \"input_chan_2\" ) echo_chan : Broadcast [ bool ] = Broadcast ( \"EchoChannel\" ) echo_actor = EchoActor ( \"EchoActor\" , recv1 = input_chan_1 . new_receiver (), recv2 = input_chan_2 . new_receiver (), output = echo_chan . new_sender (), ) echo_rx = echo_chan . new_receiver () await input_chan_2 . new_sender () . send ( True ) msg = await echo_rx . receive () Example (two Actors composed): @actor class Actor1 : def __init__ ( self , name : str , recv : Receiver [ bool ], output : Sender [ bool ], ) -> None : self . name = name self . _recv = recv self . _output = output async def run ( self ) -> None : async for msg in self . _recv : await self . _output . send ( msg ) @actor class Actor2 : def __init__ ( self , name : str , recv : Receiver [ bool ], output : Sender [ bool ], ) -> None : self . name = name self . _recv = recv self . _output = output async def run ( self ) -> None : async for msg in self . _recv : await self . _output . send ( msg ) input_chan : Broadcast [ bool ] = Broadcast ( \"Input to A1\" ) a1_chan : Broadcast [ bool ] = Broadcast [ \"A1 stream\" ] a2_chan : Broadcast [ bool ] = Broadcast [ \"A2 stream\" ] a1 = Actor1 ( name = \"ActorOne\" , recv = input_chan . new_receiver (), output = a1_chan . new_sender (), ) a2 = Actor2 ( name = \"ActorTwo\" , recv = a1_chan . new_receiver (), output = a2_chan . new_sender (), ) a2_rx = a2_chan . new_receiver () await input_chan . new_sender () . send ( True ) msg = await a2_rx . receive () Source code in frequenz/sdk/actor/_decorator.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def actor ( cls : Type [ Any ]) -> Type [ Any ]: \"\"\"Decorate a class into a simple composable actor. A actor using the `actor` decorator should define an `async def run(self)` method, that loops over incoming data, and sends results out. Channels can be used to implement communication between actors, as shown in the examples below. Args: cls: the class to decorate. Returns: The decorated class. Raises: TypeError: when the class doesn't have a `run` method as per spec. Example (one actor receiving from two receivers): ``` python @actor class EchoActor: def __init__( self, name: str, recv1: Receiver[bool], recv2: Receiver[bool], output: Sender[bool], ) -> None: self.name = name self._recv1 = recv1 self._recv2 = recv2 self._output = output async def run(self) -> None: select = Select(channel_1=self._recv1, channel_2=self._recv2) while await select.ready(): if msg := select.channel_1: await self._output.send(msg.inner) elif msg := select.channel_2: await self._output.send(msg.inner) input_chan_1: Broadcast[bool] = Broadcast(\"input_chan_1\") input_chan_2: Broadcast[bool] = Broadcast(\"input_chan_2\") echo_chan: Broadcast[bool] = Broadcast(\"EchoChannel\") echo_actor = EchoActor( \"EchoActor\", recv1=input_chan_1.new_receiver(), recv2=input_chan_2.new_receiver(), output=echo_chan.new_sender(), ) echo_rx = echo_chan.new_receiver() await input_chan_2.new_sender().send(True) msg = await echo_rx.receive() ``` Example (two Actors composed): ``` python @actor class Actor1: def __init__( self, name: str, recv: Receiver[bool], output: Sender[bool], ) -> None: self.name = name self._recv = recv self._output = output async def run(self) -> None: async for msg in self._recv: await self._output.send(msg) @actor class Actor2: def __init__( self, name: str, recv: Receiver[bool], output: Sender[bool], ) -> None: self.name = name self._recv = recv self._output = output async def run(self) -> None: async for msg in self._recv: await self._output.send(msg) input_chan: Broadcast[bool] = Broadcast(\"Input to A1\") a1_chan: Broadcast[bool] = Broadcast[\"A1 stream\"] a2_chan: Broadcast[bool] = Broadcast[\"A2 stream\"] a1 = Actor1( name=\"ActorOne\", recv=input_chan.new_receiver(), output=a1_chan.new_sender(), ) a2 = Actor2( name=\"ActorTwo\", recv=a1_chan.new_receiver(), output=a2_chan.new_sender(), ) a2_rx = a2_chan.new_receiver() await input_chan.new_sender().send(True) msg = await a2_rx.receive() ``` \"\"\" if not inspect . isclass ( cls ): raise TypeError ( \"The `@actor` decorator can only be applied for classes.\" ) _check_run_method_exists ( cls ) class ActorClass ( cls , BaseActor , Generic [ OT ]): # type: ignore \"\"\"A wrapper class to make an actor.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\"Create an `ActorClass` instance. Also call __init__ on `cls`. Args: *args: Any positional arguments to `cls.__init__`. **kwargs: Any keyword arguments to `cls.__init__`. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _actor_task = asyncio . create_task ( self . _start_actor ()) async def _start_actor ( self ) -> None : \"\"\"Run the main logic of the actor as a coroutine. Raises: asyncio.CancelledError: when the actor's task gets cancelled. \"\"\" logger . debug ( \"Starting actor: %s \" , cls . __name__ ) number_of_restarts = 0 while ( self . restart_limit is None or number_of_restarts <= self . restart_limit ): if number_of_restarts > 0 : logger . info ( \"Restarting actor: %s \" , cls . __name__ ) try : await super () . run () except asyncio . CancelledError : logger . debug ( \"Cancelling actor: %s \" , cls . __name__ ) raise except Exception : # pylint: disable=broad-except logger . exception ( \"Actor ( %s ) crashed\" , cls . __name__ ) finally : number_of_restarts += 1 logger . info ( \"Shutting down actor: %s \" , cls . __name__ ) async def _stop ( self ) -> None : \"\"\"Stop an running actor.\"\"\" self . _actor_task . cancel () try : await self . _actor_task except asyncio . CancelledError : pass async def join ( self ) -> None : \"\"\"Await the actor's task, and return when the task completes.\"\"\" await self . _actor_task return ActorClass frequenz . sdk . actor . run ( * actors ) async \u00a4 Await the completion of all actors. PARAMETER DESCRIPTION actors the actors to be awaited. TYPE: Any DEFAULT: () RAISES DESCRIPTION AssertionError if any of the actors is not an instance of BaseActor. Source code in frequenz/sdk/actor/_run_utils.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 async def run ( * actors : Any ) -> None : \"\"\"Await the completion of all actors. Args: actors: the actors to be awaited. Raises: AssertionError: if any of the actors is not an instance of BaseActor. \"\"\" # Check that each actor is an instance of BaseActor at runtime, # due to the indirection created by the actor decorator. for actor in actors : assert isinstance ( actor , BaseActor ), f \" { actor } is not an instance of BaseActor\" pending_tasks = set () for actor in actors : pending_tasks . add ( asyncio . create_task ( actor . join (), name = str ( actor ))) # Currently the actor decorator manages the life-cycle of the actor tasks while pending_tasks : done_tasks , pending_tasks = await asyncio . wait ( pending_tasks , return_when = asyncio . FIRST_COMPLETED ) # This should always be only one task, but we handle many for extra safety for task in done_tasks : # Cancellation needs to be checked first, otherwise the other methods # could raise a CancelledError if task . cancelled (): _logger . info ( \"The actor %s was cancelled\" , task . get_name ()) elif exception := task . exception (): _logger . error ( \"The actor %s was finished due to an uncaught exception\" , task . get_name (), exc_info = exception , ) else : _logger . info ( \"The actor %s finished normally\" , task . get_name ())","title":"actor"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor","text":"A base class for creating simple composable actors.","title":"actor"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry","text":"Dynamically creates, own and provide access to channels. It can be used by actors to dynamically establish a communication channel between each other. Channels are identified by string names. Source code in frequenz/sdk/actor/_channel_registry.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class ChannelRegistry : \"\"\"Dynamically creates, own and provide access to channels. It can be used by actors to dynamically establish a communication channel between each other. Channels are identified by string names. \"\"\" def __init__ ( self , * , name : str ) -> None : \"\"\"Create a `ChannelRegistry` instance. Args: name: A unique name for the registry. \"\"\" self . _name = name self . _channels : Dict [ str , Broadcast [ Any ]] = {} def new_sender ( self , key : str ) -> Sender [ Any ]: \"\"\"Get a sender to a dynamically created channel with the given key. Args: key: A key to identify the channel. Returns: A sender to a dynamically created channel with the given key. \"\"\" if key not in self . _channels : self . _channels [ key ] = Broadcast ( f \" { self . _name } - { key } \" ) return self . _channels [ key ] . new_sender () def new_receiver ( self , key : str ) -> Receiver [ Any ]: \"\"\"Get a receiver to a dynamically created channel with the given key. Args: key: A key to identify the channel. Returns: A receiver for a dynamically created channel with the given key. \"\"\" if key not in self . _channels : self . _channels [ key ] = Broadcast ( f \" { self . _name } - { key } \" ) return self . _channels [ key ] . new_receiver () async def _close_channel ( self , key : str ) -> None : \"\"\"Close a channel with the given key. This method is private and should only be used in special cases. Args: key: A key to identify the channel. \"\"\" if key in self . _channels : if channel := self . _channels . pop ( key , None ): await channel . close ()","title":"ChannelRegistry"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._channel_registry.ChannelRegistry.__init__","text":"Create a ChannelRegistry instance. PARAMETER DESCRIPTION name A unique name for the registry. TYPE: str Source code in frequenz/sdk/actor/_channel_registry.py 18 19 20 21 22 23 24 25 def __init__ ( self , * , name : str ) -> None : \"\"\"Create a `ChannelRegistry` instance. Args: name: A unique name for the registry. \"\"\" self . _name = name self . _channels : Dict [ str , Broadcast [ Any ]] = {}","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._channel_registry.ChannelRegistry.new_receiver","text":"Get a receiver to a dynamically created channel with the given key. PARAMETER DESCRIPTION key A key to identify the channel. TYPE: str RETURNS DESCRIPTION Receiver [ Any ] A receiver for a dynamically created channel with the given key. Source code in frequenz/sdk/actor/_channel_registry.py 40 41 42 43 44 45 46 47 48 49 50 51 def new_receiver ( self , key : str ) -> Receiver [ Any ]: \"\"\"Get a receiver to a dynamically created channel with the given key. Args: key: A key to identify the channel. Returns: A receiver for a dynamically created channel with the given key. \"\"\" if key not in self . _channels : self . _channels [ key ] = Broadcast ( f \" { self . _name } - { key } \" ) return self . _channels [ key ] . new_receiver ()","title":"new_receiver()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._channel_registry.ChannelRegistry.new_sender","text":"Get a sender to a dynamically created channel with the given key. PARAMETER DESCRIPTION key A key to identify the channel. TYPE: str RETURNS DESCRIPTION Sender [ Any ] A sender to a dynamically created channel with the given key. Source code in frequenz/sdk/actor/_channel_registry.py 27 28 29 30 31 32 33 34 35 36 37 38 def new_sender ( self , key : str ) -> Sender [ Any ]: \"\"\"Get a sender to a dynamically created channel with the given key. Args: key: A key to identify the channel. Returns: A sender to a dynamically created channel with the given key. \"\"\" if key not in self . _channels : self . _channels [ key ] = Broadcast ( f \" { self . _name } - { key } \" ) return self . _channels [ key ] . new_sender ()","title":"new_sender()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest","text":"A request object to start streaming a metric for a component. Source code in frequenz/sdk/actor/_data_sourcing/microgrid_api_source.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @dataclass class ComponentMetricRequest : \"\"\"A request object to start streaming a metric for a component.\"\"\" namespace : str \"\"\"The namespace that this request belongs to. Metric requests with a shared namespace enable the reuse of channels within that namespace. If for example, an actor making a multiple requests, uses the name of the actor as the namespace, then requests from the actor will get reused when possible. \"\"\" component_id : int \"\"\"The ID of the requested component.\"\"\" metric_id : ComponentMetricId \"\"\"The ID of the requested component's metric.\"\"\" start_time : Optional [ datetime ] \"\"\"The start time from which data is required. When None, we will stream only live data. \"\"\" def get_channel_name ( self ) -> str : \"\"\"Return a channel name constructed from Self. This channel name can be used by the sending side and receiving sides to identify the right channel from the ChannelRegistry. Returns: A string denoting a channel name. \"\"\" return f \" { self . component_id } :: { self . metric_id . name } :: { self . start_time } :: { self . namespace } \"","title":"ComponentMetricRequest"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.microgrid_api_source.ComponentMetricRequest.component_id","text":"The ID of the requested component.","title":"component_id"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.microgrid_api_source.ComponentMetricRequest.metric_id","text":"The ID of the requested component's metric.","title":"metric_id"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.microgrid_api_source.ComponentMetricRequest.namespace","text":"The namespace that this request belongs to. Metric requests with a shared namespace enable the reuse of channels within that namespace. If for example, an actor making a multiple requests, uses the name of the actor as the namespace, then requests from the actor will get reused when possible.","title":"namespace"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.microgrid_api_source.ComponentMetricRequest.start_time","text":"The start time from which data is required. When None, we will stream only live data.","title":"start_time"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.microgrid_api_source.ComponentMetricRequest.get_channel_name","text":"Return a channel name constructed from Self. This channel name can be used by the sending side and receiving sides to identify the right channel from the ChannelRegistry. RETURNS DESCRIPTION str A string denoting a channel name. Source code in frequenz/sdk/actor/_data_sourcing/microgrid_api_source.py 54 55 56 57 58 59 60 61 62 63 def get_channel_name ( self ) -> str : \"\"\"Return a channel name constructed from Self. This channel name can be used by the sending side and receiving sides to identify the right channel from the ChannelRegistry. Returns: A string denoting a channel name. \"\"\" return f \" { self . component_id } :: { self . metric_id . name } :: { self . start_time } :: { self . namespace } \"","title":"get_channel_name()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor","text":"An actor to resample microgrid component metrics. Source code in frequenz/sdk/actor/_resampling.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 @actor class ComponentMetricsResamplingActor : \"\"\"An actor to resample microgrid component metrics.\"\"\" def __init__ ( # pylint: disable=too-many-arguments self , * , channel_registry : ChannelRegistry , data_sourcing_request_sender : Sender [ ComponentMetricRequest ], resampling_request_receiver : Receiver [ ComponentMetricRequest ], config : ResamplerConfig , ) -> None : \"\"\"Initialize an instance. Args: channel_registry: The channel registry used to get senders and receivers for data sourcing subscriptions. data_sourcing_request_sender: The sender used to send requests to the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor] to subscribe to component metrics. resampling_request_receiver: The receiver to use to receive new resampmling subscription requests. config: The configuration for the resampler. \"\"\" self . _channel_registry : ChannelRegistry = channel_registry self . _data_sourcing_request_sender : Sender [ ComponentMetricRequest ] = data_sourcing_request_sender self . _resampling_request_receiver : Receiver [ ComponentMetricRequest ] = resampling_request_receiver self . _resampler : Resampler = Resampler ( config ) self . _active_req_channels : set [ str ] = set () async def _subscribe ( self , request : ComponentMetricRequest ) -> None : \"\"\"Request data for a component metric. Args: request: The request for component metric data. \"\"\" request_channel_name = request . get_channel_name () # If we are already handling this request, there is nothing to do. if request_channel_name in self . _active_req_channels : return self . _active_req_channels . add ( request_channel_name ) data_source_request = dataclasses . replace ( request , namespace = request . namespace + \":Source\" ) data_source_channel_name = data_source_request . get_channel_name () await self . _data_sourcing_request_sender . send ( data_source_request ) receiver = self . _channel_registry . new_receiver ( data_source_channel_name ) # This is a temporary hack until the Sender implementation uses # exceptions to report errors. sender = self . _channel_registry . new_sender ( request . get_channel_name ()) async def sink_adapter ( sample : Sample ) -> None : if not await sender . send ( sample ): raise RuntimeError ( f \"Error while sending with sender { sender } \" , sender ) self . _resampler . add_timeseries ( request_channel_name , receiver , sink_adapter ) async def _process_resampling_requests ( self ) -> None : \"\"\"Process resampling data requests.\"\"\" async for request in self . _resampling_request_receiver : await self . _subscribe ( request ) async def run ( self ) -> None : \"\"\"Resample known component metrics and process resampling requests. If there is a resampling error while resampling some component metric, then that metric will be discarded and not resampled any more. Any other error will be propagated (most likely ending in the actor being restarted). Raises: RuntimeError: If there is some unexpected error while resampling or handling requests. # noqa: DAR401 error \"\"\" tasks_to_cancel : set [ asyncio . Task [ None ]] = set () try : subscriptions_task = asyncio . create_task ( self . _process_resampling_requests () ) tasks_to_cancel . add ( subscriptions_task ) while True : resampling_task = asyncio . create_task ( self . _resampler . resample ()) tasks_to_cancel . add ( resampling_task ) done , _ = await asyncio . wait ( [ resampling_task , subscriptions_task ], return_when = asyncio . FIRST_COMPLETED , ) if subscriptions_task in done : tasks_to_cancel . remove ( subscriptions_task ) raise RuntimeError ( \"There was a problem with the subscriptions channel.\" ) if resampling_task in done : tasks_to_cancel . remove ( resampling_task ) # The resampler shouldn't end without an exception error = resampling_task . exception () assert ( error is not None ), \"The resample() function shouldn't exit normally.\" # We don't know what to do with something other than # ResamplingError, so propagate the exception if that is the # case. if not isinstance ( error , ResamplingError ): raise error for source , source_error in error . exceptions . items (): logger . error ( \"Error resampling source %s , removing source...\" , source ) removed = self . _resampler . remove_timeseries ( source ) if not removed : logger . warning ( \"Got an exception from an unknown source: \" \"source= %r , exception= %r \" , source , source_error , ) # The resampling_task will be re-created if we reached this point finally : await asyncio . gather ( * [ cancel_and_await ( t ) for t in tasks_to_cancel ])","title":"ComponentMetricsResamplingActor"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._resampling.ComponentMetricsResamplingActor.__init__","text":"Initialize an instance. PARAMETER DESCRIPTION channel_registry The channel registry used to get senders and receivers for data sourcing subscriptions. TYPE: ChannelRegistry data_sourcing_request_sender The sender used to send requests to the DataSourcingActor to subscribe to component metrics. TYPE: Sender [ ComponentMetricRequest ] resampling_request_receiver The receiver to use to receive new resampmling subscription requests. TYPE: Receiver [ ComponentMetricRequest ] config The configuration for the resampler. TYPE: ResamplerConfig Source code in frequenz/sdk/actor/_resampling.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( # pylint: disable=too-many-arguments self , * , channel_registry : ChannelRegistry , data_sourcing_request_sender : Sender [ ComponentMetricRequest ], resampling_request_receiver : Receiver [ ComponentMetricRequest ], config : ResamplerConfig , ) -> None : \"\"\"Initialize an instance. Args: channel_registry: The channel registry used to get senders and receivers for data sourcing subscriptions. data_sourcing_request_sender: The sender used to send requests to the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor] to subscribe to component metrics. resampling_request_receiver: The receiver to use to receive new resampmling subscription requests. config: The configuration for the resampler. \"\"\" self . _channel_registry : ChannelRegistry = channel_registry self . _data_sourcing_request_sender : Sender [ ComponentMetricRequest ] = data_sourcing_request_sender self . _resampling_request_receiver : Receiver [ ComponentMetricRequest ] = resampling_request_receiver self . _resampler : Resampler = Resampler ( config ) self . _active_req_channels : set [ str ] = set ()","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._resampling.ComponentMetricsResamplingActor.run","text":"Resample known component metrics and process resampling requests. If there is a resampling error while resampling some component metric, then that metric will be discarded and not resampled any more. Any other error will be propagated (most likely ending in the actor being restarted). RAISES DESCRIPTION RuntimeError If there is some unexpected error while resampling or handling requests.","title":"run()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._resampling.ComponentMetricsResamplingActor.run--noqa-dar401-error","text":"Source code in frequenz/sdk/actor/_resampling.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 async def run ( self ) -> None : \"\"\"Resample known component metrics and process resampling requests. If there is a resampling error while resampling some component metric, then that metric will be discarded and not resampled any more. Any other error will be propagated (most likely ending in the actor being restarted). Raises: RuntimeError: If there is some unexpected error while resampling or handling requests. # noqa: DAR401 error \"\"\" tasks_to_cancel : set [ asyncio . Task [ None ]] = set () try : subscriptions_task = asyncio . create_task ( self . _process_resampling_requests () ) tasks_to_cancel . add ( subscriptions_task ) while True : resampling_task = asyncio . create_task ( self . _resampler . resample ()) tasks_to_cancel . add ( resampling_task ) done , _ = await asyncio . wait ( [ resampling_task , subscriptions_task ], return_when = asyncio . FIRST_COMPLETED , ) if subscriptions_task in done : tasks_to_cancel . remove ( subscriptions_task ) raise RuntimeError ( \"There was a problem with the subscriptions channel.\" ) if resampling_task in done : tasks_to_cancel . remove ( resampling_task ) # The resampler shouldn't end without an exception error = resampling_task . exception () assert ( error is not None ), \"The resample() function shouldn't exit normally.\" # We don't know what to do with something other than # ResamplingError, so propagate the exception if that is the # case. if not isinstance ( error , ResamplingError ): raise error for source , source_error in error . exceptions . items (): logger . error ( \"Error resampling source %s , removing source...\" , source ) removed = self . _resampler . remove_timeseries ( source ) if not removed : logger . warning ( \"Got an exception from an unknown source: \" \"source= %r , exception= %r \" , source , source_error , ) # The resampling_task will be re-created if we reached this point finally : await asyncio . gather ( * [ cancel_and_await ( t ) for t in tasks_to_cancel ])","title":"noqa: DAR401 error"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor","text":"Manages config variables. Config variables are read from file. Only single file can be read. If new file is read, then previous configs will be forgotten. Source code in frequenz/sdk/actor/_config_managing.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @actor class ConfigManagingActor : \"\"\" Manages config variables. Config variables are read from file. Only single file can be read. If new file is read, then previous configs will be forgotten. \"\"\" def __init__ ( self , conf_file : str , output : Sender [ Config ], event_types : Optional [ Set [ FileWatcher . EventType ]] = None , ) -> None : \"\"\"Read config variables from the file. Args: conf_file: Path to file with config variables. output: Channel to publish updates to. event_types: Which types of events should update the config and trigger a notification. \"\"\" self . _conf_file : str = conf_file self . _conf_dir : str = os . path . dirname ( conf_file ) self . _file_watcher = FileWatcher ( paths = [ self . _conf_dir ], event_types = event_types ) self . _output = output def _read_config ( self ) -> Dict [ str , Any ]: \"\"\"Read the contents of the config file. Raises: ValueError: if config file cannot be read. Returns: A dictionary containing configuration variables. \"\"\" try : return toml . load ( self . _conf_file ) except ValueError as err : logging . error ( \"Can't read config file, err: %s \" , err ) raise async def send_config ( self ) -> None : \"\"\"Send config file using a broadcast channel.\"\"\" conf_vars = self . _read_config () config = Config ( conf_vars ) await self . _output . send ( config ) async def run ( self ) -> None : \"\"\"Watch config file and update when modified. At startup, the Config Manager sends the current config so that it can be cache in the Broadcast channel and served to receivers even if there hasn't been any change to the config file itself. \"\"\" await self . send_config () async for path in self . _file_watcher : if str ( path ) == self . _conf_file : logger . info ( \"Update configs, because file %s was modified.\" , self . _conf_file , ) await self . send_config () logger . debug ( \"ConfigManager stopped.\" )","title":"ConfigManagingActor"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._config_managing.ConfigManagingActor.__init__","text":"Read config variables from the file. PARAMETER DESCRIPTION conf_file Path to file with config variables. TYPE: str output Channel to publish updates to. TYPE: Sender [ Config ] event_types Which types of events should update the config and trigger a notification. TYPE: Optional [ Set [ FileWatcher . EventType ]] DEFAULT: None Source code in frequenz/sdk/actor/_config_managing.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , conf_file : str , output : Sender [ Config ], event_types : Optional [ Set [ FileWatcher . EventType ]] = None , ) -> None : \"\"\"Read config variables from the file. Args: conf_file: Path to file with config variables. output: Channel to publish updates to. event_types: Which types of events should update the config and trigger a notification. \"\"\" self . _conf_file : str = conf_file self . _conf_dir : str = os . path . dirname ( conf_file ) self . _file_watcher = FileWatcher ( paths = [ self . _conf_dir ], event_types = event_types ) self . _output = output","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._config_managing.ConfigManagingActor.run","text":"Watch config file and update when modified. At startup, the Config Manager sends the current config so that it can be cache in the Broadcast channel and served to receivers even if there hasn't been any change to the config file itself. Source code in frequenz/sdk/actor/_config_managing.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 async def run ( self ) -> None : \"\"\"Watch config file and update when modified. At startup, the Config Manager sends the current config so that it can be cache in the Broadcast channel and served to receivers even if there hasn't been any change to the config file itself. \"\"\" await self . send_config () async for path in self . _file_watcher : if str ( path ) == self . _conf_file : logger . info ( \"Update configs, because file %s was modified.\" , self . _conf_file , ) await self . send_config () logger . debug ( \"ConfigManager stopped.\" )","title":"run()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._config_managing.ConfigManagingActor.send_config","text":"Send config file using a broadcast channel. Source code in frequenz/sdk/actor/_config_managing.py 66 67 68 69 70 async def send_config ( self ) -> None : \"\"\"Send config file using a broadcast channel.\"\"\" conf_vars = self . _read_config () config = Config ( conf_vars ) await self . _output . send ( config )","title":"send_config()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor","text":"An actor that provides data streams of metrics as time series. Source code in frequenz/sdk/actor/_data_sourcing/data_sourcing.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @actor class DataSourcingActor : \"\"\"An actor that provides data streams of metrics as time series.\"\"\" def __init__ ( self , request_receiver : Receiver [ ComponentMetricRequest ], registry : ChannelRegistry , ) -> None : \"\"\"Create a `DataSourcingActor` instance. Args: request_receiver: A channel receiver to accept metric requests from. registry: A channel registry. To be replaced by a singleton instance. \"\"\" self . _request_receiver = request_receiver self . _microgrid_api_source = MicrogridApiSource ( registry ) async def run ( self ) -> None : \"\"\"Run the actor.\"\"\" async for request in self . _request_receiver : await self . _microgrid_api_source . add_metric ( request )","title":"DataSourcingActor"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.data_sourcing.DataSourcingActor.__init__","text":"Create a DataSourcingActor instance. PARAMETER DESCRIPTION request_receiver A channel receiver to accept metric requests from. TYPE: Receiver [ ComponentMetricRequest ] registry A channel registry. To be replaced by a singleton instance. TYPE: ChannelRegistry Source code in frequenz/sdk/actor/_data_sourcing/data_sourcing.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , request_receiver : Receiver [ ComponentMetricRequest ], registry : ChannelRegistry , ) -> None : \"\"\"Create a `DataSourcingActor` instance. Args: request_receiver: A channel receiver to accept metric requests from. registry: A channel registry. To be replaced by a singleton instance. \"\"\" self . _request_receiver = request_receiver self . _microgrid_api_source = MicrogridApiSource ( registry )","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.data_sourcing.DataSourcingActor.run","text":"Run the actor. Source code in frequenz/sdk/actor/_data_sourcing/data_sourcing.py 32 33 34 35 async def run ( self ) -> None : \"\"\"Run the actor.\"\"\" async for request in self . _request_receiver : await self . _microgrid_api_source . add_metric ( request )","title":"run()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig","text":"Resampler configuration. Source code in frequenz/sdk/timeseries/_resampling.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 @dataclass ( frozen = True ) class ResamplerConfig : \"\"\"Resampler configuration.\"\"\" resampling_period_s : float \"\"\"The resampling period in seconds. This is the time it passes between resampled data should be calculated. It must be a positive number. \"\"\" max_data_age_in_periods : float = 3.0 \"\"\"The maximum age a sample can have to be considered *relevant* for resampling. Expressed in number of periods, where period is the `resampling_period_s` if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period). It must be bigger than 1.0. Example: If `resampling_period_s` is 3, the input sampling period is 1 and `max_data_age_in_periods` is 2, then data older than 3*2 = 6 secods will be discarded when creating a new sample and never passed to the resampling function. If `resampling_period_s` is 3, the input sampling period is 5 and `max_data_age_in_periods` is 2, then data older than 5*2 = 10 secods will be discarded when creating a new sample and never passed to the resampling function. \"\"\" resampling_function : ResamplingFunction = average \"\"\"The resampling function. This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value. \"\"\" initial_buffer_len : int = DEFAULT_BUFFER_LEN_INIT \"\"\"The initial length of the resampling buffer. The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored. It must be at least 1 and at most `max_buffer_len`. \"\"\" warn_buffer_len : int = DEFAULT_BUFFER_LEN_WARN \"\"\"The minimum length of the resampling buffer that will emit a warning. If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertly. It must be at least 1 and at most `max_buffer_len`. \"\"\" max_buffer_len : int = DEFAULT_BUFFER_LEN_MAX \"\"\"The maximum length of the resampling buffer. Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value. It must be at bigger than `warn_buffer_len`. \"\"\" def __post_init__ ( self ) -> None : \"\"\"Check that config values are valid. Raises: ValueError: If any value is out of range. \"\"\" if self . resampling_period_s < 0.0 : raise ValueError ( f \"resampling_period_s ( { self . resampling_period_s } ) must be positive\" ) if self . max_data_age_in_periods < 1.0 : raise ValueError ( f \"max_data_age_in_periods ( { self . max_data_age_in_periods } ) should be at least 1.0\" ) if self . warn_buffer_len < 1 : raise ValueError ( f \"warn_buffer_len ( { self . warn_buffer_len } ) should be at least 1\" ) if self . max_buffer_len <= self . warn_buffer_len : raise ValueError ( f \"max_buffer_len ( { self . max_buffer_len } ) should \" f \"be bigger than warn_buffer_len ( { self . warn_buffer_len } )\" ) if self . initial_buffer_len < 1 : raise ValueError ( f \"initial_buffer_len ( { self . initial_buffer_len } ) should at least 1\" ) if self . initial_buffer_len > self . max_buffer_len : raise ValueError ( f \"initial_buffer_len ( { self . initial_buffer_len } ) is bigger \" f \"than max_buffer_len ( { self . max_buffer_len } ), use a smaller \" \"initial_buffer_len or a bigger max_buffer_len\" ) if self . initial_buffer_len > self . warn_buffer_len : _logger . warning ( \"initial_buffer_len ( %s ) is bigger than warn_buffer_len ( %s )\" , self . initial_buffer_len , self . warn_buffer_len , )","title":"ResamplerConfig"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.initial_buffer_len","text":"The initial length of the resampling buffer. The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored. It must be at least 1 and at most max_buffer_len .","title":"initial_buffer_len"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.max_buffer_len","text":"The maximum length of the resampling buffer. Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value. It must be at bigger than warn_buffer_len .","title":"max_buffer_len"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.max_data_age_in_periods","text":"The maximum age a sample can have to be considered relevant for resampling. Expressed in number of periods, where period is the resampling_period_s if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period). It must be bigger than 1.0. Example If resampling_period_s is 3, the input sampling period is 1 and max_data_age_in_periods is 2, then data older than 3*2 = 6 secods will be discarded when creating a new sample and never passed to the resampling function. If resampling_period_s is 3, the input sampling period is 5 and max_data_age_in_periods is 2, then data older than 5*2 = 10 secods will be discarded when creating a new sample and never passed to the resampling function.","title":"max_data_age_in_periods"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.resampling_function","text":"The resampling function. This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value.","title":"resampling_function"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.resampling_period_s","text":"The resampling period in seconds. This is the time it passes between resampled data should be calculated. It must be a positive number.","title":"resampling_period_s"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.warn_buffer_len","text":"The minimum length of the resampling buffer that will emit a warning. If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertly. It must be at least 1 and at most max_buffer_len .","title":"warn_buffer_len"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.__post_init__","text":"Check that config values are valid. RAISES DESCRIPTION ValueError If any value is out of range. Source code in frequenz/sdk/timeseries/_resampling.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def __post_init__ ( self ) -> None : \"\"\"Check that config values are valid. Raises: ValueError: If any value is out of range. \"\"\" if self . resampling_period_s < 0.0 : raise ValueError ( f \"resampling_period_s ( { self . resampling_period_s } ) must be positive\" ) if self . max_data_age_in_periods < 1.0 : raise ValueError ( f \"max_data_age_in_periods ( { self . max_data_age_in_periods } ) should be at least 1.0\" ) if self . warn_buffer_len < 1 : raise ValueError ( f \"warn_buffer_len ( { self . warn_buffer_len } ) should be at least 1\" ) if self . max_buffer_len <= self . warn_buffer_len : raise ValueError ( f \"max_buffer_len ( { self . max_buffer_len } ) should \" f \"be bigger than warn_buffer_len ( { self . warn_buffer_len } )\" ) if self . initial_buffer_len < 1 : raise ValueError ( f \"initial_buffer_len ( { self . initial_buffer_len } ) should at least 1\" ) if self . initial_buffer_len > self . max_buffer_len : raise ValueError ( f \"initial_buffer_len ( { self . initial_buffer_len } ) is bigger \" f \"than max_buffer_len ( { self . max_buffer_len } ), use a smaller \" \"initial_buffer_len or a bigger max_buffer_len\" ) if self . initial_buffer_len > self . warn_buffer_len : _logger . warning ( \"initial_buffer_len ( %s ) is bigger than warn_buffer_len ( %s )\" , self . initial_buffer_len , self . warn_buffer_len , )","title":"__post_init__()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.actor","text":"Decorate a class into a simple composable actor. A actor using the actor decorator should define an async def run(self) method, that loops over incoming data, and sends results out. Channels can be used to implement communication between actors, as shown in the examples below. PARAMETER DESCRIPTION cls the class to decorate. TYPE: Type [ Any ] RETURNS DESCRIPTION Type [ Any ] The decorated class. RAISES DESCRIPTION TypeError when the class doesn't have a run method as per spec. Example (one actor receiving from two receivers): @actor class EchoActor : def __init__ ( self , name : str , recv1 : Receiver [ bool ], recv2 : Receiver [ bool ], output : Sender [ bool ], ) -> None : self . name = name self . _recv1 = recv1 self . _recv2 = recv2 self . _output = output async def run ( self ) -> None : select = Select ( channel_1 = self . _recv1 , channel_2 = self . _recv2 ) while await select . ready (): if msg := select . channel_1 : await self . _output . send ( msg . inner ) elif msg := select . channel_2 : await self . _output . send ( msg . inner ) input_chan_1 : Broadcast [ bool ] = Broadcast ( \"input_chan_1\" ) input_chan_2 : Broadcast [ bool ] = Broadcast ( \"input_chan_2\" ) echo_chan : Broadcast [ bool ] = Broadcast ( \"EchoChannel\" ) echo_actor = EchoActor ( \"EchoActor\" , recv1 = input_chan_1 . new_receiver (), recv2 = input_chan_2 . new_receiver (), output = echo_chan . new_sender (), ) echo_rx = echo_chan . new_receiver () await input_chan_2 . new_sender () . send ( True ) msg = await echo_rx . receive () Example (two Actors composed): @actor class Actor1 : def __init__ ( self , name : str , recv : Receiver [ bool ], output : Sender [ bool ], ) -> None : self . name = name self . _recv = recv self . _output = output async def run ( self ) -> None : async for msg in self . _recv : await self . _output . send ( msg ) @actor class Actor2 : def __init__ ( self , name : str , recv : Receiver [ bool ], output : Sender [ bool ], ) -> None : self . name = name self . _recv = recv self . _output = output async def run ( self ) -> None : async for msg in self . _recv : await self . _output . send ( msg ) input_chan : Broadcast [ bool ] = Broadcast ( \"Input to A1\" ) a1_chan : Broadcast [ bool ] = Broadcast [ \"A1 stream\" ] a2_chan : Broadcast [ bool ] = Broadcast [ \"A2 stream\" ] a1 = Actor1 ( name = \"ActorOne\" , recv = input_chan . new_receiver (), output = a1_chan . new_sender (), ) a2 = Actor2 ( name = \"ActorTwo\" , recv = a1_chan . new_receiver (), output = a2_chan . new_sender (), ) a2_rx = a2_chan . new_receiver () await input_chan . new_sender () . send ( True ) msg = await a2_rx . receive () Source code in frequenz/sdk/actor/_decorator.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def actor ( cls : Type [ Any ]) -> Type [ Any ]: \"\"\"Decorate a class into a simple composable actor. A actor using the `actor` decorator should define an `async def run(self)` method, that loops over incoming data, and sends results out. Channels can be used to implement communication between actors, as shown in the examples below. Args: cls: the class to decorate. Returns: The decorated class. Raises: TypeError: when the class doesn't have a `run` method as per spec. Example (one actor receiving from two receivers): ``` python @actor class EchoActor: def __init__( self, name: str, recv1: Receiver[bool], recv2: Receiver[bool], output: Sender[bool], ) -> None: self.name = name self._recv1 = recv1 self._recv2 = recv2 self._output = output async def run(self) -> None: select = Select(channel_1=self._recv1, channel_2=self._recv2) while await select.ready(): if msg := select.channel_1: await self._output.send(msg.inner) elif msg := select.channel_2: await self._output.send(msg.inner) input_chan_1: Broadcast[bool] = Broadcast(\"input_chan_1\") input_chan_2: Broadcast[bool] = Broadcast(\"input_chan_2\") echo_chan: Broadcast[bool] = Broadcast(\"EchoChannel\") echo_actor = EchoActor( \"EchoActor\", recv1=input_chan_1.new_receiver(), recv2=input_chan_2.new_receiver(), output=echo_chan.new_sender(), ) echo_rx = echo_chan.new_receiver() await input_chan_2.new_sender().send(True) msg = await echo_rx.receive() ``` Example (two Actors composed): ``` python @actor class Actor1: def __init__( self, name: str, recv: Receiver[bool], output: Sender[bool], ) -> None: self.name = name self._recv = recv self._output = output async def run(self) -> None: async for msg in self._recv: await self._output.send(msg) @actor class Actor2: def __init__( self, name: str, recv: Receiver[bool], output: Sender[bool], ) -> None: self.name = name self._recv = recv self._output = output async def run(self) -> None: async for msg in self._recv: await self._output.send(msg) input_chan: Broadcast[bool] = Broadcast(\"Input to A1\") a1_chan: Broadcast[bool] = Broadcast[\"A1 stream\"] a2_chan: Broadcast[bool] = Broadcast[\"A2 stream\"] a1 = Actor1( name=\"ActorOne\", recv=input_chan.new_receiver(), output=a1_chan.new_sender(), ) a2 = Actor2( name=\"ActorTwo\", recv=a1_chan.new_receiver(), output=a2_chan.new_sender(), ) a2_rx = a2_chan.new_receiver() await input_chan.new_sender().send(True) msg = await a2_rx.receive() ``` \"\"\" if not inspect . isclass ( cls ): raise TypeError ( \"The `@actor` decorator can only be applied for classes.\" ) _check_run_method_exists ( cls ) class ActorClass ( cls , BaseActor , Generic [ OT ]): # type: ignore \"\"\"A wrapper class to make an actor.\"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\"Create an `ActorClass` instance. Also call __init__ on `cls`. Args: *args: Any positional arguments to `cls.__init__`. **kwargs: Any keyword arguments to `cls.__init__`. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _actor_task = asyncio . create_task ( self . _start_actor ()) async def _start_actor ( self ) -> None : \"\"\"Run the main logic of the actor as a coroutine. Raises: asyncio.CancelledError: when the actor's task gets cancelled. \"\"\" logger . debug ( \"Starting actor: %s \" , cls . __name__ ) number_of_restarts = 0 while ( self . restart_limit is None or number_of_restarts <= self . restart_limit ): if number_of_restarts > 0 : logger . info ( \"Restarting actor: %s \" , cls . __name__ ) try : await super () . run () except asyncio . CancelledError : logger . debug ( \"Cancelling actor: %s \" , cls . __name__ ) raise except Exception : # pylint: disable=broad-except logger . exception ( \"Actor ( %s ) crashed\" , cls . __name__ ) finally : number_of_restarts += 1 logger . info ( \"Shutting down actor: %s \" , cls . __name__ ) async def _stop ( self ) -> None : \"\"\"Stop an running actor.\"\"\" self . _actor_task . cancel () try : await self . _actor_task except asyncio . CancelledError : pass async def join ( self ) -> None : \"\"\"Await the actor's task, and return when the task completes.\"\"\" await self . _actor_task return ActorClass","title":"actor()"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.run","text":"Await the completion of all actors. PARAMETER DESCRIPTION actors the actors to be awaited. TYPE: Any DEFAULT: () RAISES DESCRIPTION AssertionError if any of the actors is not an instance of BaseActor. Source code in frequenz/sdk/actor/_run_utils.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 async def run ( * actors : Any ) -> None : \"\"\"Await the completion of all actors. Args: actors: the actors to be awaited. Raises: AssertionError: if any of the actors is not an instance of BaseActor. \"\"\" # Check that each actor is an instance of BaseActor at runtime, # due to the indirection created by the actor decorator. for actor in actors : assert isinstance ( actor , BaseActor ), f \" { actor } is not an instance of BaseActor\" pending_tasks = set () for actor in actors : pending_tasks . add ( asyncio . create_task ( actor . join (), name = str ( actor ))) # Currently the actor decorator manages the life-cycle of the actor tasks while pending_tasks : done_tasks , pending_tasks = await asyncio . wait ( pending_tasks , return_when = asyncio . FIRST_COMPLETED ) # This should always be only one task, but we handle many for extra safety for task in done_tasks : # Cancellation needs to be checked first, otherwise the other methods # could raise a CancelledError if task . cancelled (): _logger . info ( \"The actor %s was cancelled\" , task . get_name ()) elif exception := task . exception (): _logger . error ( \"The actor %s was finished due to an uncaught exception\" , task . get_name (), exc_info = exception , ) else : _logger . info ( \"The actor %s finished normally\" , task . get_name ())","title":"run()"},{"location":"reference/frequenz/sdk/actor/power_distributing/","text":"frequenz.sdk.actor.power_distributing \u00a4 This module provides feature to set power between many batteries. Distributing power is very important to keep the microgrid ready for the power requirements. This module provides PowerDistributingActor that knows how to distribute power. It also provides all the secondary features that should be used to communicate with PowerDistributingActor and send requests for charging or discharging power. Classes \u00a4 frequenz.sdk.actor.power_distributing.BatteryStatus dataclass \u00a4 Status of the batteries. Source code in frequenz/sdk/actor/power_distributing/_battery_pool_status.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @dataclass class BatteryStatus : \"\"\"Status of the batteries.\"\"\" working : Set [ int ] \"\"\"Set of working battery ids.\"\"\" uncertain : Set [ int ] \"\"\"Set of batteries that should be used only if there are no working batteries.\"\"\" def get_working_batteries ( self , batteries : Set [ int ]) -> Set [ int ]: \"\"\"From the given set of batteries return working batteries. Args: batteries: Set of batteries Returns: Subset with working batteries. \"\"\" working = self . working . intersection ( batteries ) if len ( working ) > 0 : return working return self . uncertain . intersection ( batteries ) Attributes \u00a4 uncertain : Set [ int ] class-attribute \u00a4 Set of batteries that should be used only if there are no working batteries. working : Set [ int ] class-attribute \u00a4 Set of working battery ids. Functions \u00a4 get_working_batteries ( batteries ) \u00a4 From the given set of batteries return working batteries. PARAMETER DESCRIPTION batteries Set of batteries TYPE: Set [ int ] RETURNS DESCRIPTION Set [ int ] Subset with working batteries. Source code in frequenz/sdk/actor/power_distributing/_battery_pool_status.py 31 32 33 34 35 36 37 38 39 40 41 42 43 def get_working_batteries ( self , batteries : Set [ int ]) -> Set [ int ]: \"\"\"From the given set of batteries return working batteries. Args: batteries: Set of batteries Returns: Subset with working batteries. \"\"\" working = self . working . intersection ( batteries ) if len ( working ) > 0 : return working return self . uncertain . intersection ( batteries ) frequenz.sdk.actor.power_distributing.Error \u00a4 Bases: Result Error occurred and power was not set. Source code in frequenz/sdk/actor/power_distributing/result.py 86 87 88 89 90 91 92 93 94 95 96 97 class Error ( Result ): \"\"\"Error occurred and power was not set.\"\"\" def __init__ ( self , request : Request , msg : str ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. msg: Error message explaining why error happened. \"\"\" super () . __init__ ( request ) self . msg : str = msg Functions \u00a4 __init__ ( request , msg ) \u00a4 Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request msg Error message explaining why error happened. TYPE: str Source code in frequenz/sdk/actor/power_distributing/result.py 89 90 91 92 93 94 95 96 97 def __init__ ( self , request : Request , msg : str ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. msg: Error message explaining why error happened. \"\"\" super () . __init__ ( request ) self . msg : str = msg frequenz.sdk.actor.power_distributing.Ignored \u00a4 Bases: Result Send if request was ignored. Request was ignored because new request for the same subset of batteries was received. Source code in frequenz/sdk/actor/power_distributing/result.py 119 120 121 122 123 124 class Ignored ( Result ): \"\"\"Send if request was ignored. Request was ignored because new request for the same subset of batteries was received. \"\"\" frequenz.sdk.actor.power_distributing.OutOfBound \u00a4 Bases: Result Send if power was not set because requested power was not within bounds. This message is send only if Request.adjust_power = False. Source code in frequenz/sdk/actor/power_distributing/result.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class OutOfBound ( Result ): \"\"\"Send if power was not set because requested power was not within bounds. This message is send only if Request.adjust_power = False. \"\"\" def __init__ ( self , request : Request , bound : int ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. bound: Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. \"\"\" super () . __init__ ( request ) self . bound : int = bound Functions \u00a4 __init__ ( request , bound ) \u00a4 Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request bound Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , request : Request , bound : int ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. bound: Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. \"\"\" super () . __init__ ( request ) self . bound : int = bound frequenz.sdk.actor.power_distributing.PartialFailure \u00a4 Bases: Result Send if any battery failed and didn't perform the request. Source code in frequenz/sdk/actor/power_distributing/result.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class PartialFailure ( Result ): \"\"\"Send if any battery failed and didn't perform the request.\"\"\" # It is very simple class with only data so it should be ok to disable pylint. # All these results should be dataclass but in python < 3.10 it is risky # to derive after dataclass. def __init__ ( # pylint: disable=too-many-arguments self , request : Request , succeed_power : int , succeed_batteries : Set [ int ], failed_power : int , failed_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. succeed_batteries: Subset of the requested batteries for which the request succeed. failed_power: Part of the requested power that failed. failed_batteries: Subset of the requested batteries for which the request failed. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . succeed_batteries : Set [ int ] = succeed_batteries self . failed_power : int = failed_power self . failed_batteries : Set [ int ] = failed_batteries self . excess_power : int = excess_power Functions \u00a4 __init__ ( request , succeed_power , succeed_batteries , failed_power , failed_batteries , excess_power ) \u00a4 Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request succeed_power Part of the requested power that was successfully set. TYPE: int succeed_batteries Subset of the requested batteries for which the request succeed. TYPE: Set [ int ] failed_power Part of the requested power that failed. TYPE: int failed_batteries Subset of the requested batteries for which the request failed. TYPE: Set [ int ] excess_power Part of the requested power that could not be fulfilled, because it was outside available power bounds. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( # pylint: disable=too-many-arguments self , request : Request , succeed_power : int , succeed_batteries : Set [ int ], failed_power : int , failed_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. succeed_batteries: Subset of the requested batteries for which the request succeed. failed_power: Part of the requested power that failed. failed_batteries: Subset of the requested batteries for which the request failed. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . succeed_batteries : Set [ int ] = succeed_batteries self . failed_power : int = failed_power self . failed_batteries : Set [ int ] = failed_batteries self . excess_power : int = excess_power frequenz.sdk.actor.power_distributing.PowerDistributingActor \u00a4 Actor to distribute the power between batteries in a microgrid. The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time. For each user a bidirectional channel needs to be created through which they can send and receive requests and responses. It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout_sec + time for processing the request. Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED. If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed. Example import grpc.aio as grpcaio from frequenz.sdk.microgrid.graph import _MicrogridComponentGraph from frequenz.sdk.microgrid.component import ComponentCategory from frequenz.sdk.actor.power_distributing import ( PowerDistributingActor , Request , Result , Success , Error , PartialFailure , Ignored , ) target = f \" { host } : { port } \" grpc_channel = grpcaio . insecure_channel ( target ) api = MicrogridGrpcClient ( grpc_channel , target ) graph = _MicrogridComponentGraph () await graph . refresh_from_api ( api ) batteries = graph . components ( component_category = { ComponentCategory . BATTERY }) batteries_ids = { c . component_id for c in batteries } channel = Bidirectional [ Request , Result ]( \"user1\" , \"power_distributor\" ) power_distributor = PowerDistributingActor ( mock_api , component_graph , { \"user1\" : channel . service_handle } ) client_handle = channel . client_handle # Set power 1200W to given batteries. request = Request ( power = 1200 , batteries = batteries_ids , request_timeout_sec = 10.0 ) await client_handle . send ( request ) # It is recommended to use timeout when waiting for the response! result : Result = await asyncio . wait_for ( client_handle . receive (), timeout = 10 ) if isinstance ( result , Success ): print ( \"Command succeed\" ) elif isinstance ( result , PartialFailure ): print ( f \"Batteries { result . failed_batteries } failed, total failed power\" f \" { result . failed_power } \" ) elif isinstance ( result , Ignored ): print ( f \"Request was ignored, because of newer request\" ) elif isinstance ( result , Error ): print ( f \"Request failed with error: { result . msg } \" ) Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 @actor class PowerDistributingActor : # pylint: disable=too-many-instance-attributes \"\"\"Actor to distribute the power between batteries in a microgrid. The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time. For each user a bidirectional channel needs to be created through which they can send and receive requests and responses. It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout_sec + time for processing the request. Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED. * If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed. Example: ``` python import grpc.aio as grpcaio from frequenz.sdk.microgrid.graph import _MicrogridComponentGraph from frequenz.sdk.microgrid.component import ComponentCategory from frequenz.sdk.actor.power_distributing import ( PowerDistributingActor, Request, Result, Success, Error, PartialFailure, Ignored, ) target = f\"{host}:{port}\" grpc_channel = grpcaio.insecure_channel(target) api = MicrogridGrpcClient(grpc_channel, target) graph = _MicrogridComponentGraph() await graph.refresh_from_api(api) batteries = graph.components(component_category={ComponentCategory.BATTERY}) batteries_ids = {c.component_id for c in batteries} channel = Bidirectional[Request, Result](\"user1\", \"power_distributor\") power_distributor = PowerDistributingActor( mock_api, component_graph, {\"user1\": channel.service_handle} ) client_handle = channel.client_handle # Set power 1200W to given batteries. request = Request(power=1200, batteries=batteries_ids, request_timeout_sec=10.0) await client_handle.send(request) # It is recommended to use timeout when waiting for the response! result: Result = await asyncio.wait_for(client_handle.receive(), timeout=10) if isinstance(result, Success): print(\"Command succeed\") elif isinstance(result, PartialFailure): print( f\"Batteries {result.failed_batteries} failed, total failed power\" \\ f\"{result.failed_power}\") elif isinstance(result, Ignored): print(f\"Request was ignored, because of newer request\") elif isinstance(result, Error): print(f\"Request failed with error: {result.msg}\") ``` \"\"\" def __init__ ( self , users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ]], battery_status_sender : Sender [ BatteryStatus ], wait_for_data_sec : float = 2 , ) -> None : \"\"\"Create class instance. Args: users_channels: BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. battery_status_sender: Channel for sending information which batteries are working. wait_for_data_sec: How long actor should wait before processing first request. It is a time needed to collect first components data. \"\"\" self . _wait_for_data_sec = wait_for_data_sec # NOTE: power_distributor_exponent should be received from ConfigManager self . power_distributor_exponent : float = 1.0 self . distribution_algorithm = DistributionAlgorithm ( self . power_distributor_exponent ) self . _bat_inv_map , self . _inv_bat_map = self . _get_components_pairs ( microgrid . get () . component_graph ) self . _battery_receivers : Dict [ int , Peekable [ BatteryData ]] = {} self . _inverter_receivers : Dict [ int , Peekable [ InverterData ]] = {} # The components in different requests be for the same components, or for # completely different components. They should not overlap. # Otherwise the PowerDistributingActor has no way to decide what request is more # important. It will execute both. And later request will override the previous # one. # That is why the queue of maxsize = total number of batteries should be enough. self . _request_queue : asyncio . Queue [ Tuple [ Request , _User ]] = asyncio . Queue ( maxsize = len ( self . _bat_inv_map ) ) self . _users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ] ] = users_channels self . _users_tasks = self . _create_users_tasks () self . _started = asyncio . Event () self . _all_battery_status = BatteryPoolStatus ( battery_ids = set ( self . _bat_inv_map . keys ()), battery_status_sender = battery_status_sender , max_blocking_duration_sec = 30.0 , max_data_age_sec = 10.0 , ) def _create_users_tasks ( self ) -> List [ asyncio . Task [ None ]]: \"\"\"For each user create a task to wait for request. Returns: List with users tasks. \"\"\" tasks = [] for user , handler in self . _users_channels . items (): tasks . append ( asyncio . create_task ( self . _wait_for_request ( _User ( user , handler ))) ) return tasks def _get_upper_bound ( self , batteries : Set [ int ]) -> int : \"\"\"Get total upper bound of power to be set for given batteries. Note, output of that function doesn't guarantee that this bound will be the same when the request is processed. Args: batteries: List of batteries Returns: Upper bound for `set_power` operation. \"\"\" pairs_data : List [ InvBatPair ] = self . _get_components_data ( batteries ) bound = sum ( min ( battery . power_upper_bound , inverter . active_power_upper_bound ) for battery , inverter in pairs_data ) return floor ( bound ) def _get_lower_bound ( self , batteries : Set [ int ]) -> int : \"\"\"Get total lower bound of power to be set for given batteries. Note, output of that function doesn't guarantee that this bound will be the same when the request is processed. Args: batteries: List of batteries Returns: Lower bound for `set_power` operation. \"\"\" pairs_data : List [ InvBatPair ] = self . _get_components_data ( batteries ) bound = sum ( max ( battery . power_lower_bound , inverter . active_power_lower_bound ) for battery , inverter in pairs_data ) return ceil ( bound ) async def run ( self ) -> None : \"\"\"Run actor main function. It waits for new requests in task_queue and process it, and send `set_power` request with distributed power. The output of the `set_power` method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. \"\"\" await self . _create_channels () api = microgrid . get () . api_client # Wait few seconds to get data from the channels created above. await asyncio . sleep ( self . _wait_for_data_sec ) self . _started . set () while True : request , user = await self . _request_queue . get () try : pairs_data : List [ InvBatPair ] = self . _get_components_data ( request . batteries ) except KeyError as err : await user . channel . send ( Error ( request , str ( err ))) continue if len ( pairs_data ) == 0 : error_msg = f \"No data for the given batteries { str ( request . batteries ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue try : distribution = self . distribution_algorithm . distribute_power ( request . power , pairs_data ) except ValueError as err : error_msg = f \"Couldn't distribute power, error: { str ( err ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue distributed_power_value = request . power - distribution . remaining_power battery_distribution = { self . _inv_bat_map [ bat_id ]: dist for bat_id , dist in distribution . distribution . items () } _logger . debug ( \" %s : Distributing power %d between the batteries %s \" , user . user_id , distributed_power_value , str ( battery_distribution ), ) failed_power , failed_batteries = await self . _set_distributed_power ( api , distribution , request . request_timeout_sec ) response : Success | PartialFailure if len ( failed_batteries ) > 0 : succeed_batteries = set ( battery_distribution . keys ()) - failed_batteries response = PartialFailure ( request = request , succeed_power = distributed_power_value , succeed_batteries = succeed_batteries , failed_power = failed_power , failed_batteries = failed_batteries , excess_power = distribution . remaining_power , ) else : succeed_batteries = set ( battery_distribution . keys ()) response = Success ( request = request , succeed_power = distributed_power_value , used_batteries = succeed_batteries , excess_power = distribution . remaining_power , ) asyncio . gather ( * [ self . _all_battery_status . update_status ( succeed_batteries , failed_batteries ), user . channel . send ( response ), ] ) async def _set_distributed_power ( self , api : MicrogridApiClient , distribution : DistributionResult , timeout_sec : float , ) -> Tuple [ int , Set [ int ]]: \"\"\"Send distributed power to the inverters. Args: api: Microgrid api client distribution: Distribution result timeout_sec: How long wait for the response Returns: Tuple where first element is total failed power, and the second element set of batteries that failed. \"\"\" tasks = { inverter_id : asyncio . create_task ( api . set_power ( inverter_id , power )) for inverter_id , power in distribution . distribution . items () } _ , pending = await asyncio . wait ( tasks . values (), timeout = timeout_sec , return_when = ALL_COMPLETED , ) await self . _cancel_tasks ( pending ) return self . _parse_result ( tasks , distribution . distribution , timeout_sec ) def _check_request ( self , request : Request ) -> Optional [ Result ]: \"\"\"Check whether the given request if correct. Args: request: request to check Returns: Result for the user if the request is wrong, None otherwise. \"\"\" for battery in request . batteries : if battery not in self . _battery_receivers : msg = ( f \"No battery { battery } , available batteries: \" f \" { list ( self . _battery_receivers . keys ()) } \" ) return Error ( request , msg ) if not request . adjust_power : if request . power < 0 : bound = self . _get_lower_bound ( request . batteries ) if request . power < bound : return OutOfBound ( request , bound ) else : bound = self . _get_upper_bound ( request . batteries ) if request . power > bound : return OutOfBound ( request , bound ) return None def _remove_duplicated_requests ( self , request : Request , user : _User ) -> List [ asyncio . Task [ bool ]]: \"\"\"Remove duplicated requests from the queue. Remove old requests in which set of batteries are the same as in new request. If batteries in new request overlap with batteries in old request but are not equal, then log error and process both messages. Args: request: request to check user: User who sent the request. Returns: Tasks with result sent to the users which requests were duplicated. \"\"\" batteries = request . batteries good_requests : List [ Tuple [ Request , _User ]] = [] to_ignore : List [ asyncio . Task [ bool ]] = [] while not self . _request_queue . empty (): prev_request , prev_user = self . _request_queue . get_nowait () # Generators seems to be the fastest if prev_request . batteries == batteries : task = asyncio . create_task ( prev_user . channel . send ( Ignored ( prev_request )) ) to_ignore . append ( task ) # Use generators as generators seems to be the fastest. elif any ( battery_id in prev_request . batteries for battery_id in batteries ): # If that happen PowerDistributingActor has no way to distinguish what # request is more important. This should not happen _logger . error ( \"Batteries in two requests overlap! Actor: %s requested %s \" \"and Actor: %s requested %s \" , user . user_id , str ( request ), prev_user . user_id , str ( prev_request ), ) good_requests . append (( prev_request , prev_user )) else : good_requests . append (( prev_request , prev_user )) for good_request in good_requests : self . _request_queue . put_nowait ( good_request ) return to_ignore async def _wait_for_request ( self , user : _User ) -> None : \"\"\"Wait for the request from user. Check if request is correct. If request is not correct send ERROR response to the user. If request is correct, then add it to the main queue to be process. Already existing requests for the same subset of batteries will be removed and their users will be notified with a Result.Status.IGNORED response. Only new request will re processed. If the sets of batteries are not the same but they have common elements, then both batteries will be processed. Args: user: User that sends the requests. \"\"\" while True : request : Optional [ Request ] = await user . channel . receive () if request is None : _logger . info ( \"Send channel for user %s was closed. User will be unregistered.\" , user . user_id , ) self . _users_channels . pop ( user . user_id ) if len ( self . _users_channels ) == 0 : _logger . error ( \"No users in PowerDistributingActor!\" ) return # Wait for PowerDistributingActor to start. if not self . _started . is_set (): await self . _started . wait () # We should discover as fast as possible that request is wrong. error = self . _check_request ( request ) if error is not None : await user . channel . send ( error ) continue tasks = self . _remove_duplicated_requests ( request , user ) if self . _request_queue . full (): q_size = ( self . _request_queue . qsize (),) msg = ( f \"Request queue is full { q_size } , can't process this request. \" \"Consider increasing size of the queue.\" ) _logger . error ( msg ) await user . channel . send ( Error ( request , str ( msg ))) else : self . _request_queue . put_nowait (( request , user )) await asyncio . gather ( * tasks ) def _get_components_pairs ( self , component_graph : ComponentGraph ) -> Tuple [ Dict [ int , int ], Dict [ int , int ]]: \"\"\"Create maps between battery and adjacent inverter. Args: component_graph: component graph Returns: Tuple where first element is map between battery and adjacent inverter, second element of the tuple is map between inverter and adjacent battery. \"\"\" bat_inv_map : Dict [ int , int ] = {} inv_bat_map : Dict [ int , int ] = {} batteries : Iterable [ Component ] = component_graph . components ( component_category = { ComponentCategory . BATTERY } ) for battery in batteries : inverters : List [ Component ] = [ component for component in component_graph . predecessors ( battery . component_id ) if component . category == ComponentCategory . INVERTER ] if len ( inverters ) == 0 : _logger . error ( \"No inverters for battery %d \" , battery . component_id ) continue if len ( inverters ) > 1 : _logger . error ( \"Battery %d has more then one inverter. It is not supported now.\" , battery . component_id , ) bat_inv_map [ battery . component_id ] = inverters [ 0 ] . component_id inv_bat_map [ inverters [ 0 ] . component_id ] = battery . component_id return bat_inv_map , inv_bat_map def _get_working_batteries ( self , batteries : Set [ int ]) -> Set [ int ]: \"\"\"Get subset with working batteries. If none of the given batteries are working, then treat all of them as working. Args: batteries: requested batteries Returns: Subset with working batteries or input set if none of the given batteries are working. \"\"\" working_batteries = self . _all_battery_status . get_working_batteries ( batteries ) if len ( working_batteries ) == 0 : return batteries return working_batteries def _get_components_data ( self , batteries : Set [ int ]) -> List [ InvBatPair ]: \"\"\"Get data for the given batteries and adjacent inverters. Args: batteries: Batteries that needs data. Raises: KeyError: If any battery in the given list doesn't exists in microgrid. Returns: Pairs of battery and adjacent inverter data. \"\"\" pairs_data : List [ InvBatPair ] = [] working_batteries = self . _get_working_batteries ( batteries ) for battery_id in working_batteries : if battery_id not in self . _battery_receivers : raise KeyError ( f \"No battery { battery_id } , \" f \"available batteries: { list ( self . _battery_receivers . keys ()) } \" ) inverter_id : int = self . _bat_inv_map [ battery_id ] data = self . _get_battery_inverter_data ( battery_id , inverter_id ) if data is None : _logger . warning ( \"Skipping battery %d because its message isn't correct.\" , battery_id , ) continue pairs_data . append ( data ) return pairs_data def _get_battery_inverter_data ( self , battery_id : int , inverter_id : int ) -> Optional [ InvBatPair ]: \"\"\"Get battery and inverter data if they are correct. Each float data from the microgrid can be \"NaN\". We can't do math operations on \"NaN\". So check all the metrics and: * if power bounds are NaN, then try to replace it with the corresponding power bounds from the adjacent component. If metric in the adjacent component is also NaN, then return None. * if other metrics are NaN then return None. We can't assume anything for other metrics. Args: battery_id: battery id inverter_id: inverter id Returns: Data for the battery and adjacent inverter without NaN values. Return None if we could not replace NaN values. \"\"\" battery_data = self . _battery_receivers [ battery_id ] . peek () inverter_data = self . _inverter_receivers [ inverter_id ] . peek () # It means that nothing has been send on this channels, yet. # This should be handled by BatteryStatus. BatteryStatus should not return # this batteries as working. if battery_data is None or inverter_data is None : _logger . error ( \"Battery %d or inverter %d send no data, yet. They should be not used.\" , battery_id , inverter_id , ) return None not_replaceable_metrics = [ battery_data . soc , battery_data . soc_lower_bound , battery_data . soc_upper_bound , # We could replace capacity with 0, but it won't change distribution. # This battery will be ignored in distribution anyway. battery_data . capacity , ] if any ( map ( isnan , not_replaceable_metrics )): _logger . debug ( \"Some metrics for battery %d are NaN\" , battery_id ) return None replaceable_metrics = [ battery_data . power_lower_bound , battery_data . power_upper_bound , inverter_data . active_power_lower_bound , inverter_data . active_power_upper_bound , ] # If all values are ok then return them. if not any ( map ( isnan , replaceable_metrics )): return InvBatPair ( battery_data , inverter_data ) # Replace NaN with the corresponding value in the adjacent component. # If both metrics are None, return None to ignore this battery. replaceable_pairs = [ ( \"power_lower_bound\" , \"active_power_lower_bound\" ), ( \"power_upper_bound\" , \"active_power_upper_bound\" ), ] battery_new_metrics = {} inverter_new_metrics = {} for bat_attr , inv_attr in replaceable_pairs : bat_bound = getattr ( battery_data , bat_attr ) inv_bound = getattr ( inverter_data , inv_attr ) if isnan ( bat_bound ) and isnan ( inv_bound ): _logger . debug ( \"Some metrics for battery %d are NaN\" , battery_id ) return None if isnan ( bat_bound ): battery_new_metrics [ bat_attr ] = inv_bound elif isnan ( inv_bound ): inverter_new_metrics [ inv_attr ] = bat_bound return InvBatPair ( replace ( battery_data , ** battery_new_metrics ), replace ( inverter_data , ** inverter_new_metrics ), ) async def _create_channels ( self ) -> None : \"\"\"Create channels to get data of components in microgrid.\"\"\" api = microgrid . get () . api_client for battery_id , inverter_id in self . _bat_inv_map . items (): bat_recv : Receiver [ BatteryData ] = await api . battery_data ( battery_id ) self . _battery_receivers [ battery_id ] = bat_recv . into_peekable () inv_recv : Receiver [ InverterData ] = await api . inverter_data ( inverter_id ) self . _inverter_receivers [ inverter_id ] = inv_recv . into_peekable () def _parse_result ( self , # type comment to quiet pylint and mypy `unused-import` error tasks , # type: Dict[int, asyncio.Task[Empty]] distribution : Dict [ int , int ], request_timeout_sec : float , ) -> Tuple [ int , Set [ int ]]: \"\"\"Parse result of `set_power` requests. Check if any task failed and why. If any task didn't success, then corresponding battery is marked as broken. Args: tasks: Dictionary where key is inverter id and value is task that set power for this inverter. Each tasks should be finished or cancelled. distribution: Dictionary where key is inverter id and value is how much power was set to the corresponding inverter. request_timeout_sec: timeout which has been used for request. Returns: Tuple where first element is total failed power, and the second element set of batteries that failed. \"\"\" failed_power : int = 0 failed_batteries : Set [ int ] = set () for inverter_id , aws in tasks . items (): battery_id = self . _inv_bat_map [ inverter_id ] try : aws . result () except grpc . aio . AioRpcError as err : failed_power += distribution [ inverter_id ] failed_batteries . add ( battery_id ) if err . code () == grpc . StatusCode . OUT_OF_RANGE : _logger . debug ( \"Set power for battery %d failed, error %s \" , battery_id , str ( err ), ) else : _logger . warning ( \"Set power for battery %d failed, error %s . Mark it as broken.\" , battery_id , str ( err ), ) except asyncio . exceptions . CancelledError : failed_power += distribution [ inverter_id ] failed_batteries . add ( battery_id ) _logger . warning ( \"Battery %d didn't respond in %f sec. Mark it as broken.\" , battery_id , request_timeout_sec , ) return failed_power , failed_batteries async def _cancel_tasks ( self , tasks : Iterable [ asyncio . Task [ Any ]]) -> None : \"\"\"Cancel given asyncio tasks and wait for them. Args: tasks: tasks to cancel. \"\"\" for aws in tasks : aws . cancel () await asyncio . gather ( * tasks , return_exceptions = True ) async def _stop_actor ( self ) -> None : \"\"\"Stop all running async tasks.\"\"\" await asyncio . gather ( * [ cancel_and_await ( t ) for t in self . _users_tasks ]) await self . _all_battery_status . stop () await self . _stop () # type: ignore # pylint: disable=no-member Functions \u00a4 __init__ ( users_channels , battery_status_sender , wait_for_data_sec = 2 ) \u00a4 Create class instance. PARAMETER DESCRIPTION users_channels BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. TYPE: Dict [ str , Bidirectional . Handle [ Result , Request ]] battery_status_sender Channel for sending information which batteries are working. TYPE: Sender [ BatteryStatus ] wait_for_data_sec How long actor should wait before processing first request. It is a time needed to collect first components data. TYPE: float DEFAULT: 2 Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __init__ ( self , users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ]], battery_status_sender : Sender [ BatteryStatus ], wait_for_data_sec : float = 2 , ) -> None : \"\"\"Create class instance. Args: users_channels: BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. battery_status_sender: Channel for sending information which batteries are working. wait_for_data_sec: How long actor should wait before processing first request. It is a time needed to collect first components data. \"\"\" self . _wait_for_data_sec = wait_for_data_sec # NOTE: power_distributor_exponent should be received from ConfigManager self . power_distributor_exponent : float = 1.0 self . distribution_algorithm = DistributionAlgorithm ( self . power_distributor_exponent ) self . _bat_inv_map , self . _inv_bat_map = self . _get_components_pairs ( microgrid . get () . component_graph ) self . _battery_receivers : Dict [ int , Peekable [ BatteryData ]] = {} self . _inverter_receivers : Dict [ int , Peekable [ InverterData ]] = {} # The components in different requests be for the same components, or for # completely different components. They should not overlap. # Otherwise the PowerDistributingActor has no way to decide what request is more # important. It will execute both. And later request will override the previous # one. # That is why the queue of maxsize = total number of batteries should be enough. self . _request_queue : asyncio . Queue [ Tuple [ Request , _User ]] = asyncio . Queue ( maxsize = len ( self . _bat_inv_map ) ) self . _users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ] ] = users_channels self . _users_tasks = self . _create_users_tasks () self . _started = asyncio . Event () self . _all_battery_status = BatteryPoolStatus ( battery_ids = set ( self . _bat_inv_map . keys ()), battery_status_sender = battery_status_sender , max_blocking_duration_sec = 30.0 , max_data_age_sec = 10.0 , ) run () async \u00a4 Run actor main function. It waits for new requests in task_queue and process it, and send set_power request with distributed power. The output of the set_power method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 async def run ( self ) -> None : \"\"\"Run actor main function. It waits for new requests in task_queue and process it, and send `set_power` request with distributed power. The output of the `set_power` method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. \"\"\" await self . _create_channels () api = microgrid . get () . api_client # Wait few seconds to get data from the channels created above. await asyncio . sleep ( self . _wait_for_data_sec ) self . _started . set () while True : request , user = await self . _request_queue . get () try : pairs_data : List [ InvBatPair ] = self . _get_components_data ( request . batteries ) except KeyError as err : await user . channel . send ( Error ( request , str ( err ))) continue if len ( pairs_data ) == 0 : error_msg = f \"No data for the given batteries { str ( request . batteries ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue try : distribution = self . distribution_algorithm . distribute_power ( request . power , pairs_data ) except ValueError as err : error_msg = f \"Couldn't distribute power, error: { str ( err ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue distributed_power_value = request . power - distribution . remaining_power battery_distribution = { self . _inv_bat_map [ bat_id ]: dist for bat_id , dist in distribution . distribution . items () } _logger . debug ( \" %s : Distributing power %d between the batteries %s \" , user . user_id , distributed_power_value , str ( battery_distribution ), ) failed_power , failed_batteries = await self . _set_distributed_power ( api , distribution , request . request_timeout_sec ) response : Success | PartialFailure if len ( failed_batteries ) > 0 : succeed_batteries = set ( battery_distribution . keys ()) - failed_batteries response = PartialFailure ( request = request , succeed_power = distributed_power_value , succeed_batteries = succeed_batteries , failed_power = failed_power , failed_batteries = failed_batteries , excess_power = distribution . remaining_power , ) else : succeed_batteries = set ( battery_distribution . keys ()) response = Success ( request = request , succeed_power = distributed_power_value , used_batteries = succeed_batteries , excess_power = distribution . remaining_power , ) asyncio . gather ( * [ self . _all_battery_status . update_status ( succeed_batteries , failed_batteries ), user . channel . send ( response ), ] ) frequenz.sdk.actor.power_distributing.Request dataclass \u00a4 Request from the user. Source code in frequenz/sdk/actor/power_distributing/request.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @dataclass class Request : \"\"\"Request from the user.\"\"\" # How much power to set power : int # In which batteries the power should be set batteries : Set [ int ] # Timeout for the server to respond on the requests. request_timeout_sec : float = 5.0 # If True and requested power value is above upper bound, then the power will be # decreased to match the bounds. Only the decreased power will be set. # If False and the requested power is above upper bound, then request won't # be processed. result.OutOfBound message will be send back to the user. adjust_power : bool = True frequenz.sdk.actor.power_distributing.Result \u00a4 Bases: ABC Base class for the power distributor result. Source code in frequenz/sdk/actor/power_distributing/result.py 12 13 14 15 16 17 18 19 20 21 class Result ( ABC ): \"\"\"Base class for the power distributor result.\"\"\" def __init__ ( self , request : Request ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. \"\"\" self . request : Request = request Functions \u00a4 __init__ ( request ) \u00a4 Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request Source code in frequenz/sdk/actor/power_distributing/result.py 15 16 17 18 19 20 21 def __init__ ( self , request : Request ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. \"\"\" self . request : Request = request frequenz.sdk.actor.power_distributing.Success \u00a4 Bases: Result Send if setting power for all batteries succeed. Source code in frequenz/sdk/actor/power_distributing/result.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Success ( Result ): \"\"\"Send if setting power for all batteries succeed.\"\"\" def __init__ ( self , request : Request , succeed_power : int , used_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. used_batteries: Subset of the requested batteries, that were used to realize the request. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . used_batteries : Set [ int ] = used_batteries self . excess_power : int = excess_power Functions \u00a4 __init__ ( request , succeed_power , used_batteries , excess_power ) \u00a4 Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request succeed_power Part of the requested power that was successfully set. TYPE: int used_batteries Subset of the requested batteries, that were used to realize the request. TYPE: Set [ int ] excess_power Part of the requested power that could not be fulfilled, because it was outside available power bounds. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , request : Request , succeed_power : int , used_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. used_batteries: Subset of the requested batteries, that were used to realize the request. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . used_batteries : Set [ int ] = used_batteries self . excess_power : int = excess_power","title":"power_distributing"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing","text":"This module provides feature to set power between many batteries. Distributing power is very important to keep the microgrid ready for the power requirements. This module provides PowerDistributingActor that knows how to distribute power. It also provides all the secondary features that should be used to communicate with PowerDistributingActor and send requests for charging or discharging power.","title":"power_distributing"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus","text":"Status of the batteries. Source code in frequenz/sdk/actor/power_distributing/_battery_pool_status.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @dataclass class BatteryStatus : \"\"\"Status of the batteries.\"\"\" working : Set [ int ] \"\"\"Set of working battery ids.\"\"\" uncertain : Set [ int ] \"\"\"Set of batteries that should be used only if there are no working batteries.\"\"\" def get_working_batteries ( self , batteries : Set [ int ]) -> Set [ int ]: \"\"\"From the given set of batteries return working batteries. Args: batteries: Set of batteries Returns: Subset with working batteries. \"\"\" working = self . working . intersection ( batteries ) if len ( working ) > 0 : return working return self . uncertain . intersection ( batteries )","title":"BatteryStatus"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing._battery_pool_status.BatteryStatus.uncertain","text":"Set of batteries that should be used only if there are no working batteries.","title":"uncertain"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing._battery_pool_status.BatteryStatus.working","text":"Set of working battery ids.","title":"working"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing._battery_pool_status.BatteryStatus.get_working_batteries","text":"From the given set of batteries return working batteries. PARAMETER DESCRIPTION batteries Set of batteries TYPE: Set [ int ] RETURNS DESCRIPTION Set [ int ] Subset with working batteries. Source code in frequenz/sdk/actor/power_distributing/_battery_pool_status.py 31 32 33 34 35 36 37 38 39 40 41 42 43 def get_working_batteries ( self , batteries : Set [ int ]) -> Set [ int ]: \"\"\"From the given set of batteries return working batteries. Args: batteries: Set of batteries Returns: Subset with working batteries. \"\"\" working = self . working . intersection ( batteries ) if len ( working ) > 0 : return working return self . uncertain . intersection ( batteries )","title":"get_working_batteries()"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error","text":"Bases: Result Error occurred and power was not set. Source code in frequenz/sdk/actor/power_distributing/result.py 86 87 88 89 90 91 92 93 94 95 96 97 class Error ( Result ): \"\"\"Error occurred and power was not set.\"\"\" def __init__ ( self , request : Request , msg : str ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. msg: Error message explaining why error happened. \"\"\" super () . __init__ ( request ) self . msg : str = msg","title":"Error"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.result.Error.__init__","text":"Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request msg Error message explaining why error happened. TYPE: str Source code in frequenz/sdk/actor/power_distributing/result.py 89 90 91 92 93 94 95 96 97 def __init__ ( self , request : Request , msg : str ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. msg: Error message explaining why error happened. \"\"\" super () . __init__ ( request ) self . msg : str = msg","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Ignored","text":"Bases: Result Send if request was ignored. Request was ignored because new request for the same subset of batteries was received. Source code in frequenz/sdk/actor/power_distributing/result.py 119 120 121 122 123 124 class Ignored ( Result ): \"\"\"Send if request was ignored. Request was ignored because new request for the same subset of batteries was received. \"\"\"","title":"Ignored"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBound","text":"Bases: Result Send if power was not set because requested power was not within bounds. This message is send only if Request.adjust_power = False. Source code in frequenz/sdk/actor/power_distributing/result.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class OutOfBound ( Result ): \"\"\"Send if power was not set because requested power was not within bounds. This message is send only if Request.adjust_power = False. \"\"\" def __init__ ( self , request : Request , bound : int ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. bound: Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. \"\"\" super () . __init__ ( request ) self . bound : int = bound","title":"OutOfBound"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBound-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.result.OutOfBound.__init__","text":"Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request bound Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , request : Request , bound : int ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. bound: Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. \"\"\" super () . __init__ ( request ) self . bound : int = bound","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure","text":"Bases: Result Send if any battery failed and didn't perform the request. Source code in frequenz/sdk/actor/power_distributing/result.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class PartialFailure ( Result ): \"\"\"Send if any battery failed and didn't perform the request.\"\"\" # It is very simple class with only data so it should be ok to disable pylint. # All these results should be dataclass but in python < 3.10 it is risky # to derive after dataclass. def __init__ ( # pylint: disable=too-many-arguments self , request : Request , succeed_power : int , succeed_batteries : Set [ int ], failed_power : int , failed_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. succeed_batteries: Subset of the requested batteries for which the request succeed. failed_power: Part of the requested power that failed. failed_batteries: Subset of the requested batteries for which the request failed. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . succeed_batteries : Set [ int ] = succeed_batteries self . failed_power : int = failed_power self . failed_batteries : Set [ int ] = failed_batteries self . excess_power : int = excess_power","title":"PartialFailure"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.result.PartialFailure.__init__","text":"Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request succeed_power Part of the requested power that was successfully set. TYPE: int succeed_batteries Subset of the requested batteries for which the request succeed. TYPE: Set [ int ] failed_power Part of the requested power that failed. TYPE: int failed_batteries Subset of the requested batteries for which the request failed. TYPE: Set [ int ] excess_power Part of the requested power that could not be fulfilled, because it was outside available power bounds. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( # pylint: disable=too-many-arguments self , request : Request , succeed_power : int , succeed_batteries : Set [ int ], failed_power : int , failed_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. succeed_batteries: Subset of the requested batteries for which the request succeed. failed_power: Part of the requested power that failed. failed_batteries: Subset of the requested batteries for which the request failed. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . succeed_batteries : Set [ int ] = succeed_batteries self . failed_power : int = failed_power self . failed_batteries : Set [ int ] = failed_batteries self . excess_power : int = excess_power","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor","text":"Actor to distribute the power between batteries in a microgrid. The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time. For each user a bidirectional channel needs to be created through which they can send and receive requests and responses. It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout_sec + time for processing the request. Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED. If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed. Example import grpc.aio as grpcaio from frequenz.sdk.microgrid.graph import _MicrogridComponentGraph from frequenz.sdk.microgrid.component import ComponentCategory from frequenz.sdk.actor.power_distributing import ( PowerDistributingActor , Request , Result , Success , Error , PartialFailure , Ignored , ) target = f \" { host } : { port } \" grpc_channel = grpcaio . insecure_channel ( target ) api = MicrogridGrpcClient ( grpc_channel , target ) graph = _MicrogridComponentGraph () await graph . refresh_from_api ( api ) batteries = graph . components ( component_category = { ComponentCategory . BATTERY }) batteries_ids = { c . component_id for c in batteries } channel = Bidirectional [ Request , Result ]( \"user1\" , \"power_distributor\" ) power_distributor = PowerDistributingActor ( mock_api , component_graph , { \"user1\" : channel . service_handle } ) client_handle = channel . client_handle # Set power 1200W to given batteries. request = Request ( power = 1200 , batteries = batteries_ids , request_timeout_sec = 10.0 ) await client_handle . send ( request ) # It is recommended to use timeout when waiting for the response! result : Result = await asyncio . wait_for ( client_handle . receive (), timeout = 10 ) if isinstance ( result , Success ): print ( \"Command succeed\" ) elif isinstance ( result , PartialFailure ): print ( f \"Batteries { result . failed_batteries } failed, total failed power\" f \" { result . failed_power } \" ) elif isinstance ( result , Ignored ): print ( f \"Request was ignored, because of newer request\" ) elif isinstance ( result , Error ): print ( f \"Request failed with error: { result . msg } \" ) Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 @actor class PowerDistributingActor : # pylint: disable=too-many-instance-attributes \"\"\"Actor to distribute the power between batteries in a microgrid. The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time. For each user a bidirectional channel needs to be created through which they can send and receive requests and responses. It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout_sec + time for processing the request. Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED. * If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed. Example: ``` python import grpc.aio as grpcaio from frequenz.sdk.microgrid.graph import _MicrogridComponentGraph from frequenz.sdk.microgrid.component import ComponentCategory from frequenz.sdk.actor.power_distributing import ( PowerDistributingActor, Request, Result, Success, Error, PartialFailure, Ignored, ) target = f\"{host}:{port}\" grpc_channel = grpcaio.insecure_channel(target) api = MicrogridGrpcClient(grpc_channel, target) graph = _MicrogridComponentGraph() await graph.refresh_from_api(api) batteries = graph.components(component_category={ComponentCategory.BATTERY}) batteries_ids = {c.component_id for c in batteries} channel = Bidirectional[Request, Result](\"user1\", \"power_distributor\") power_distributor = PowerDistributingActor( mock_api, component_graph, {\"user1\": channel.service_handle} ) client_handle = channel.client_handle # Set power 1200W to given batteries. request = Request(power=1200, batteries=batteries_ids, request_timeout_sec=10.0) await client_handle.send(request) # It is recommended to use timeout when waiting for the response! result: Result = await asyncio.wait_for(client_handle.receive(), timeout=10) if isinstance(result, Success): print(\"Command succeed\") elif isinstance(result, PartialFailure): print( f\"Batteries {result.failed_batteries} failed, total failed power\" \\ f\"{result.failed_power}\") elif isinstance(result, Ignored): print(f\"Request was ignored, because of newer request\") elif isinstance(result, Error): print(f\"Request failed with error: {result.msg}\") ``` \"\"\" def __init__ ( self , users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ]], battery_status_sender : Sender [ BatteryStatus ], wait_for_data_sec : float = 2 , ) -> None : \"\"\"Create class instance. Args: users_channels: BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. battery_status_sender: Channel for sending information which batteries are working. wait_for_data_sec: How long actor should wait before processing first request. It is a time needed to collect first components data. \"\"\" self . _wait_for_data_sec = wait_for_data_sec # NOTE: power_distributor_exponent should be received from ConfigManager self . power_distributor_exponent : float = 1.0 self . distribution_algorithm = DistributionAlgorithm ( self . power_distributor_exponent ) self . _bat_inv_map , self . _inv_bat_map = self . _get_components_pairs ( microgrid . get () . component_graph ) self . _battery_receivers : Dict [ int , Peekable [ BatteryData ]] = {} self . _inverter_receivers : Dict [ int , Peekable [ InverterData ]] = {} # The components in different requests be for the same components, or for # completely different components. They should not overlap. # Otherwise the PowerDistributingActor has no way to decide what request is more # important. It will execute both. And later request will override the previous # one. # That is why the queue of maxsize = total number of batteries should be enough. self . _request_queue : asyncio . Queue [ Tuple [ Request , _User ]] = asyncio . Queue ( maxsize = len ( self . _bat_inv_map ) ) self . _users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ] ] = users_channels self . _users_tasks = self . _create_users_tasks () self . _started = asyncio . Event () self . _all_battery_status = BatteryPoolStatus ( battery_ids = set ( self . _bat_inv_map . keys ()), battery_status_sender = battery_status_sender , max_blocking_duration_sec = 30.0 , max_data_age_sec = 10.0 , ) def _create_users_tasks ( self ) -> List [ asyncio . Task [ None ]]: \"\"\"For each user create a task to wait for request. Returns: List with users tasks. \"\"\" tasks = [] for user , handler in self . _users_channels . items (): tasks . append ( asyncio . create_task ( self . _wait_for_request ( _User ( user , handler ))) ) return tasks def _get_upper_bound ( self , batteries : Set [ int ]) -> int : \"\"\"Get total upper bound of power to be set for given batteries. Note, output of that function doesn't guarantee that this bound will be the same when the request is processed. Args: batteries: List of batteries Returns: Upper bound for `set_power` operation. \"\"\" pairs_data : List [ InvBatPair ] = self . _get_components_data ( batteries ) bound = sum ( min ( battery . power_upper_bound , inverter . active_power_upper_bound ) for battery , inverter in pairs_data ) return floor ( bound ) def _get_lower_bound ( self , batteries : Set [ int ]) -> int : \"\"\"Get total lower bound of power to be set for given batteries. Note, output of that function doesn't guarantee that this bound will be the same when the request is processed. Args: batteries: List of batteries Returns: Lower bound for `set_power` operation. \"\"\" pairs_data : List [ InvBatPair ] = self . _get_components_data ( batteries ) bound = sum ( max ( battery . power_lower_bound , inverter . active_power_lower_bound ) for battery , inverter in pairs_data ) return ceil ( bound ) async def run ( self ) -> None : \"\"\"Run actor main function. It waits for new requests in task_queue and process it, and send `set_power` request with distributed power. The output of the `set_power` method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. \"\"\" await self . _create_channels () api = microgrid . get () . api_client # Wait few seconds to get data from the channels created above. await asyncio . sleep ( self . _wait_for_data_sec ) self . _started . set () while True : request , user = await self . _request_queue . get () try : pairs_data : List [ InvBatPair ] = self . _get_components_data ( request . batteries ) except KeyError as err : await user . channel . send ( Error ( request , str ( err ))) continue if len ( pairs_data ) == 0 : error_msg = f \"No data for the given batteries { str ( request . batteries ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue try : distribution = self . distribution_algorithm . distribute_power ( request . power , pairs_data ) except ValueError as err : error_msg = f \"Couldn't distribute power, error: { str ( err ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue distributed_power_value = request . power - distribution . remaining_power battery_distribution = { self . _inv_bat_map [ bat_id ]: dist for bat_id , dist in distribution . distribution . items () } _logger . debug ( \" %s : Distributing power %d between the batteries %s \" , user . user_id , distributed_power_value , str ( battery_distribution ), ) failed_power , failed_batteries = await self . _set_distributed_power ( api , distribution , request . request_timeout_sec ) response : Success | PartialFailure if len ( failed_batteries ) > 0 : succeed_batteries = set ( battery_distribution . keys ()) - failed_batteries response = PartialFailure ( request = request , succeed_power = distributed_power_value , succeed_batteries = succeed_batteries , failed_power = failed_power , failed_batteries = failed_batteries , excess_power = distribution . remaining_power , ) else : succeed_batteries = set ( battery_distribution . keys ()) response = Success ( request = request , succeed_power = distributed_power_value , used_batteries = succeed_batteries , excess_power = distribution . remaining_power , ) asyncio . gather ( * [ self . _all_battery_status . update_status ( succeed_batteries , failed_batteries ), user . channel . send ( response ), ] ) async def _set_distributed_power ( self , api : MicrogridApiClient , distribution : DistributionResult , timeout_sec : float , ) -> Tuple [ int , Set [ int ]]: \"\"\"Send distributed power to the inverters. Args: api: Microgrid api client distribution: Distribution result timeout_sec: How long wait for the response Returns: Tuple where first element is total failed power, and the second element set of batteries that failed. \"\"\" tasks = { inverter_id : asyncio . create_task ( api . set_power ( inverter_id , power )) for inverter_id , power in distribution . distribution . items () } _ , pending = await asyncio . wait ( tasks . values (), timeout = timeout_sec , return_when = ALL_COMPLETED , ) await self . _cancel_tasks ( pending ) return self . _parse_result ( tasks , distribution . distribution , timeout_sec ) def _check_request ( self , request : Request ) -> Optional [ Result ]: \"\"\"Check whether the given request if correct. Args: request: request to check Returns: Result for the user if the request is wrong, None otherwise. \"\"\" for battery in request . batteries : if battery not in self . _battery_receivers : msg = ( f \"No battery { battery } , available batteries: \" f \" { list ( self . _battery_receivers . keys ()) } \" ) return Error ( request , msg ) if not request . adjust_power : if request . power < 0 : bound = self . _get_lower_bound ( request . batteries ) if request . power < bound : return OutOfBound ( request , bound ) else : bound = self . _get_upper_bound ( request . batteries ) if request . power > bound : return OutOfBound ( request , bound ) return None def _remove_duplicated_requests ( self , request : Request , user : _User ) -> List [ asyncio . Task [ bool ]]: \"\"\"Remove duplicated requests from the queue. Remove old requests in which set of batteries are the same as in new request. If batteries in new request overlap with batteries in old request but are not equal, then log error and process both messages. Args: request: request to check user: User who sent the request. Returns: Tasks with result sent to the users which requests were duplicated. \"\"\" batteries = request . batteries good_requests : List [ Tuple [ Request , _User ]] = [] to_ignore : List [ asyncio . Task [ bool ]] = [] while not self . _request_queue . empty (): prev_request , prev_user = self . _request_queue . get_nowait () # Generators seems to be the fastest if prev_request . batteries == batteries : task = asyncio . create_task ( prev_user . channel . send ( Ignored ( prev_request )) ) to_ignore . append ( task ) # Use generators as generators seems to be the fastest. elif any ( battery_id in prev_request . batteries for battery_id in batteries ): # If that happen PowerDistributingActor has no way to distinguish what # request is more important. This should not happen _logger . error ( \"Batteries in two requests overlap! Actor: %s requested %s \" \"and Actor: %s requested %s \" , user . user_id , str ( request ), prev_user . user_id , str ( prev_request ), ) good_requests . append (( prev_request , prev_user )) else : good_requests . append (( prev_request , prev_user )) for good_request in good_requests : self . _request_queue . put_nowait ( good_request ) return to_ignore async def _wait_for_request ( self , user : _User ) -> None : \"\"\"Wait for the request from user. Check if request is correct. If request is not correct send ERROR response to the user. If request is correct, then add it to the main queue to be process. Already existing requests for the same subset of batteries will be removed and their users will be notified with a Result.Status.IGNORED response. Only new request will re processed. If the sets of batteries are not the same but they have common elements, then both batteries will be processed. Args: user: User that sends the requests. \"\"\" while True : request : Optional [ Request ] = await user . channel . receive () if request is None : _logger . info ( \"Send channel for user %s was closed. User will be unregistered.\" , user . user_id , ) self . _users_channels . pop ( user . user_id ) if len ( self . _users_channels ) == 0 : _logger . error ( \"No users in PowerDistributingActor!\" ) return # Wait for PowerDistributingActor to start. if not self . _started . is_set (): await self . _started . wait () # We should discover as fast as possible that request is wrong. error = self . _check_request ( request ) if error is not None : await user . channel . send ( error ) continue tasks = self . _remove_duplicated_requests ( request , user ) if self . _request_queue . full (): q_size = ( self . _request_queue . qsize (),) msg = ( f \"Request queue is full { q_size } , can't process this request. \" \"Consider increasing size of the queue.\" ) _logger . error ( msg ) await user . channel . send ( Error ( request , str ( msg ))) else : self . _request_queue . put_nowait (( request , user )) await asyncio . gather ( * tasks ) def _get_components_pairs ( self , component_graph : ComponentGraph ) -> Tuple [ Dict [ int , int ], Dict [ int , int ]]: \"\"\"Create maps between battery and adjacent inverter. Args: component_graph: component graph Returns: Tuple where first element is map between battery and adjacent inverter, second element of the tuple is map between inverter and adjacent battery. \"\"\" bat_inv_map : Dict [ int , int ] = {} inv_bat_map : Dict [ int , int ] = {} batteries : Iterable [ Component ] = component_graph . components ( component_category = { ComponentCategory . BATTERY } ) for battery in batteries : inverters : List [ Component ] = [ component for component in component_graph . predecessors ( battery . component_id ) if component . category == ComponentCategory . INVERTER ] if len ( inverters ) == 0 : _logger . error ( \"No inverters for battery %d \" , battery . component_id ) continue if len ( inverters ) > 1 : _logger . error ( \"Battery %d has more then one inverter. It is not supported now.\" , battery . component_id , ) bat_inv_map [ battery . component_id ] = inverters [ 0 ] . component_id inv_bat_map [ inverters [ 0 ] . component_id ] = battery . component_id return bat_inv_map , inv_bat_map def _get_working_batteries ( self , batteries : Set [ int ]) -> Set [ int ]: \"\"\"Get subset with working batteries. If none of the given batteries are working, then treat all of them as working. Args: batteries: requested batteries Returns: Subset with working batteries or input set if none of the given batteries are working. \"\"\" working_batteries = self . _all_battery_status . get_working_batteries ( batteries ) if len ( working_batteries ) == 0 : return batteries return working_batteries def _get_components_data ( self , batteries : Set [ int ]) -> List [ InvBatPair ]: \"\"\"Get data for the given batteries and adjacent inverters. Args: batteries: Batteries that needs data. Raises: KeyError: If any battery in the given list doesn't exists in microgrid. Returns: Pairs of battery and adjacent inverter data. \"\"\" pairs_data : List [ InvBatPair ] = [] working_batteries = self . _get_working_batteries ( batteries ) for battery_id in working_batteries : if battery_id not in self . _battery_receivers : raise KeyError ( f \"No battery { battery_id } , \" f \"available batteries: { list ( self . _battery_receivers . keys ()) } \" ) inverter_id : int = self . _bat_inv_map [ battery_id ] data = self . _get_battery_inverter_data ( battery_id , inverter_id ) if data is None : _logger . warning ( \"Skipping battery %d because its message isn't correct.\" , battery_id , ) continue pairs_data . append ( data ) return pairs_data def _get_battery_inverter_data ( self , battery_id : int , inverter_id : int ) -> Optional [ InvBatPair ]: \"\"\"Get battery and inverter data if they are correct. Each float data from the microgrid can be \"NaN\". We can't do math operations on \"NaN\". So check all the metrics and: * if power bounds are NaN, then try to replace it with the corresponding power bounds from the adjacent component. If metric in the adjacent component is also NaN, then return None. * if other metrics are NaN then return None. We can't assume anything for other metrics. Args: battery_id: battery id inverter_id: inverter id Returns: Data for the battery and adjacent inverter without NaN values. Return None if we could not replace NaN values. \"\"\" battery_data = self . _battery_receivers [ battery_id ] . peek () inverter_data = self . _inverter_receivers [ inverter_id ] . peek () # It means that nothing has been send on this channels, yet. # This should be handled by BatteryStatus. BatteryStatus should not return # this batteries as working. if battery_data is None or inverter_data is None : _logger . error ( \"Battery %d or inverter %d send no data, yet. They should be not used.\" , battery_id , inverter_id , ) return None not_replaceable_metrics = [ battery_data . soc , battery_data . soc_lower_bound , battery_data . soc_upper_bound , # We could replace capacity with 0, but it won't change distribution. # This battery will be ignored in distribution anyway. battery_data . capacity , ] if any ( map ( isnan , not_replaceable_metrics )): _logger . debug ( \"Some metrics for battery %d are NaN\" , battery_id ) return None replaceable_metrics = [ battery_data . power_lower_bound , battery_data . power_upper_bound , inverter_data . active_power_lower_bound , inverter_data . active_power_upper_bound , ] # If all values are ok then return them. if not any ( map ( isnan , replaceable_metrics )): return InvBatPair ( battery_data , inverter_data ) # Replace NaN with the corresponding value in the adjacent component. # If both metrics are None, return None to ignore this battery. replaceable_pairs = [ ( \"power_lower_bound\" , \"active_power_lower_bound\" ), ( \"power_upper_bound\" , \"active_power_upper_bound\" ), ] battery_new_metrics = {} inverter_new_metrics = {} for bat_attr , inv_attr in replaceable_pairs : bat_bound = getattr ( battery_data , bat_attr ) inv_bound = getattr ( inverter_data , inv_attr ) if isnan ( bat_bound ) and isnan ( inv_bound ): _logger . debug ( \"Some metrics for battery %d are NaN\" , battery_id ) return None if isnan ( bat_bound ): battery_new_metrics [ bat_attr ] = inv_bound elif isnan ( inv_bound ): inverter_new_metrics [ inv_attr ] = bat_bound return InvBatPair ( replace ( battery_data , ** battery_new_metrics ), replace ( inverter_data , ** inverter_new_metrics ), ) async def _create_channels ( self ) -> None : \"\"\"Create channels to get data of components in microgrid.\"\"\" api = microgrid . get () . api_client for battery_id , inverter_id in self . _bat_inv_map . items (): bat_recv : Receiver [ BatteryData ] = await api . battery_data ( battery_id ) self . _battery_receivers [ battery_id ] = bat_recv . into_peekable () inv_recv : Receiver [ InverterData ] = await api . inverter_data ( inverter_id ) self . _inverter_receivers [ inverter_id ] = inv_recv . into_peekable () def _parse_result ( self , # type comment to quiet pylint and mypy `unused-import` error tasks , # type: Dict[int, asyncio.Task[Empty]] distribution : Dict [ int , int ], request_timeout_sec : float , ) -> Tuple [ int , Set [ int ]]: \"\"\"Parse result of `set_power` requests. Check if any task failed and why. If any task didn't success, then corresponding battery is marked as broken. Args: tasks: Dictionary where key is inverter id and value is task that set power for this inverter. Each tasks should be finished or cancelled. distribution: Dictionary where key is inverter id and value is how much power was set to the corresponding inverter. request_timeout_sec: timeout which has been used for request. Returns: Tuple where first element is total failed power, and the second element set of batteries that failed. \"\"\" failed_power : int = 0 failed_batteries : Set [ int ] = set () for inverter_id , aws in tasks . items (): battery_id = self . _inv_bat_map [ inverter_id ] try : aws . result () except grpc . aio . AioRpcError as err : failed_power += distribution [ inverter_id ] failed_batteries . add ( battery_id ) if err . code () == grpc . StatusCode . OUT_OF_RANGE : _logger . debug ( \"Set power for battery %d failed, error %s \" , battery_id , str ( err ), ) else : _logger . warning ( \"Set power for battery %d failed, error %s . Mark it as broken.\" , battery_id , str ( err ), ) except asyncio . exceptions . CancelledError : failed_power += distribution [ inverter_id ] failed_batteries . add ( battery_id ) _logger . warning ( \"Battery %d didn't respond in %f sec. Mark it as broken.\" , battery_id , request_timeout_sec , ) return failed_power , failed_batteries async def _cancel_tasks ( self , tasks : Iterable [ asyncio . Task [ Any ]]) -> None : \"\"\"Cancel given asyncio tasks and wait for them. Args: tasks: tasks to cancel. \"\"\" for aws in tasks : aws . cancel () await asyncio . gather ( * tasks , return_exceptions = True ) async def _stop_actor ( self ) -> None : \"\"\"Stop all running async tasks.\"\"\" await asyncio . gather ( * [ cancel_and_await ( t ) for t in self . _users_tasks ]) await self . _all_battery_status . stop () await self . _stop () # type: ignore # pylint: disable=no-member","title":"PowerDistributingActor"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__init__","text":"Create class instance. PARAMETER DESCRIPTION users_channels BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. TYPE: Dict [ str , Bidirectional . Handle [ Result , Request ]] battery_status_sender Channel for sending information which batteries are working. TYPE: Sender [ BatteryStatus ] wait_for_data_sec How long actor should wait before processing first request. It is a time needed to collect first components data. TYPE: float DEFAULT: 2 Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __init__ ( self , users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ]], battery_status_sender : Sender [ BatteryStatus ], wait_for_data_sec : float = 2 , ) -> None : \"\"\"Create class instance. Args: users_channels: BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. battery_status_sender: Channel for sending information which batteries are working. wait_for_data_sec: How long actor should wait before processing first request. It is a time needed to collect first components data. \"\"\" self . _wait_for_data_sec = wait_for_data_sec # NOTE: power_distributor_exponent should be received from ConfigManager self . power_distributor_exponent : float = 1.0 self . distribution_algorithm = DistributionAlgorithm ( self . power_distributor_exponent ) self . _bat_inv_map , self . _inv_bat_map = self . _get_components_pairs ( microgrid . get () . component_graph ) self . _battery_receivers : Dict [ int , Peekable [ BatteryData ]] = {} self . _inverter_receivers : Dict [ int , Peekable [ InverterData ]] = {} # The components in different requests be for the same components, or for # completely different components. They should not overlap. # Otherwise the PowerDistributingActor has no way to decide what request is more # important. It will execute both. And later request will override the previous # one. # That is why the queue of maxsize = total number of batteries should be enough. self . _request_queue : asyncio . Queue [ Tuple [ Request , _User ]] = asyncio . Queue ( maxsize = len ( self . _bat_inv_map ) ) self . _users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ] ] = users_channels self . _users_tasks = self . _create_users_tasks () self . _started = asyncio . Event () self . _all_battery_status = BatteryPoolStatus ( battery_ids = set ( self . _bat_inv_map . keys ()), battery_status_sender = battery_status_sender , max_blocking_duration_sec = 30.0 , max_data_age_sec = 10.0 , )","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.run","text":"Run actor main function. It waits for new requests in task_queue and process it, and send set_power request with distributed power. The output of the set_power method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 async def run ( self ) -> None : \"\"\"Run actor main function. It waits for new requests in task_queue and process it, and send `set_power` request with distributed power. The output of the `set_power` method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. \"\"\" await self . _create_channels () api = microgrid . get () . api_client # Wait few seconds to get data from the channels created above. await asyncio . sleep ( self . _wait_for_data_sec ) self . _started . set () while True : request , user = await self . _request_queue . get () try : pairs_data : List [ InvBatPair ] = self . _get_components_data ( request . batteries ) except KeyError as err : await user . channel . send ( Error ( request , str ( err ))) continue if len ( pairs_data ) == 0 : error_msg = f \"No data for the given batteries { str ( request . batteries ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue try : distribution = self . distribution_algorithm . distribute_power ( request . power , pairs_data ) except ValueError as err : error_msg = f \"Couldn't distribute power, error: { str ( err ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue distributed_power_value = request . power - distribution . remaining_power battery_distribution = { self . _inv_bat_map [ bat_id ]: dist for bat_id , dist in distribution . distribution . items () } _logger . debug ( \" %s : Distributing power %d between the batteries %s \" , user . user_id , distributed_power_value , str ( battery_distribution ), ) failed_power , failed_batteries = await self . _set_distributed_power ( api , distribution , request . request_timeout_sec ) response : Success | PartialFailure if len ( failed_batteries ) > 0 : succeed_batteries = set ( battery_distribution . keys ()) - failed_batteries response = PartialFailure ( request = request , succeed_power = distributed_power_value , succeed_batteries = succeed_batteries , failed_power = failed_power , failed_batteries = failed_batteries , excess_power = distribution . remaining_power , ) else : succeed_batteries = set ( battery_distribution . keys ()) response = Success ( request = request , succeed_power = distributed_power_value , used_batteries = succeed_batteries , excess_power = distribution . remaining_power , ) asyncio . gather ( * [ self . _all_battery_status . update_status ( succeed_batteries , failed_batteries ), user . channel . send ( response ), ] )","title":"run()"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request","text":"Request from the user. Source code in frequenz/sdk/actor/power_distributing/request.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @dataclass class Request : \"\"\"Request from the user.\"\"\" # How much power to set power : int # In which batteries the power should be set batteries : Set [ int ] # Timeout for the server to respond on the requests. request_timeout_sec : float = 5.0 # If True and requested power value is above upper bound, then the power will be # decreased to match the bounds. Only the decreased power will be set. # If False and the requested power is above upper bound, then request won't # be processed. result.OutOfBound message will be send back to the user. adjust_power : bool = True","title":"Request"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Result","text":"Bases: ABC Base class for the power distributor result. Source code in frequenz/sdk/actor/power_distributing/result.py 12 13 14 15 16 17 18 19 20 21 class Result ( ABC ): \"\"\"Base class for the power distributor result.\"\"\" def __init__ ( self , request : Request ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. \"\"\" self . request : Request = request","title":"Result"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Result-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.result.Result.__init__","text":"Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request Source code in frequenz/sdk/actor/power_distributing/result.py 15 16 17 18 19 20 21 def __init__ ( self , request : Request ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. \"\"\" self . request : Request = request","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success","text":"Bases: Result Send if setting power for all batteries succeed. Source code in frequenz/sdk/actor/power_distributing/result.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Success ( Result ): \"\"\"Send if setting power for all batteries succeed.\"\"\" def __init__ ( self , request : Request , succeed_power : int , used_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. used_batteries: Subset of the requested batteries, that were used to realize the request. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . used_batteries : Set [ int ] = used_batteries self . excess_power : int = excess_power","title":"Success"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.result.Success.__init__","text":"Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request succeed_power Part of the requested power that was successfully set. TYPE: int used_batteries Subset of the requested batteries, that were used to realize the request. TYPE: Set [ int ] excess_power Part of the requested power that could not be fulfilled, because it was outside available power bounds. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , request : Request , succeed_power : int , used_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. used_batteries: Subset of the requested batteries, that were used to realize the request. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . used_batteries : Set [ int ] = used_batteries self . excess_power : int = excess_power","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/","text":"frequenz.sdk.actor.power_distributing.power_distributing \u00a4 Actor to distribute power between batteries. When charge/discharge method is called the power should be distributed so that the SoC in batteries stays at the same level. That way of distribution prevents using only one battery, increasing temperature, and maximize the total amount power to charge/discharge. Purpose of this actor is to keep SoC level of each component at the equal level. Classes \u00a4 frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor \u00a4 Actor to distribute the power between batteries in a microgrid. The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time. For each user a bidirectional channel needs to be created through which they can send and receive requests and responses. It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout_sec + time for processing the request. Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED. If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed. Example import grpc.aio as grpcaio from frequenz.sdk.microgrid.graph import _MicrogridComponentGraph from frequenz.sdk.microgrid.component import ComponentCategory from frequenz.sdk.actor.power_distributing import ( PowerDistributingActor , Request , Result , Success , Error , PartialFailure , Ignored , ) target = f \" { host } : { port } \" grpc_channel = grpcaio . insecure_channel ( target ) api = MicrogridGrpcClient ( grpc_channel , target ) graph = _MicrogridComponentGraph () await graph . refresh_from_api ( api ) batteries = graph . components ( component_category = { ComponentCategory . BATTERY }) batteries_ids = { c . component_id for c in batteries } channel = Bidirectional [ Request , Result ]( \"user1\" , \"power_distributor\" ) power_distributor = PowerDistributingActor ( mock_api , component_graph , { \"user1\" : channel . service_handle } ) client_handle = channel . client_handle # Set power 1200W to given batteries. request = Request ( power = 1200 , batteries = batteries_ids , request_timeout_sec = 10.0 ) await client_handle . send ( request ) # It is recommended to use timeout when waiting for the response! result : Result = await asyncio . wait_for ( client_handle . receive (), timeout = 10 ) if isinstance ( result , Success ): print ( \"Command succeed\" ) elif isinstance ( result , PartialFailure ): print ( f \"Batteries { result . failed_batteries } failed, total failed power\" f \" { result . failed_power } \" ) elif isinstance ( result , Ignored ): print ( f \"Request was ignored, because of newer request\" ) elif isinstance ( result , Error ): print ( f \"Request failed with error: { result . msg } \" ) Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 @actor class PowerDistributingActor : # pylint: disable=too-many-instance-attributes \"\"\"Actor to distribute the power between batteries in a microgrid. The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time. For each user a bidirectional channel needs to be created through which they can send and receive requests and responses. It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout_sec + time for processing the request. Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED. * If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed. Example: ``` python import grpc.aio as grpcaio from frequenz.sdk.microgrid.graph import _MicrogridComponentGraph from frequenz.sdk.microgrid.component import ComponentCategory from frequenz.sdk.actor.power_distributing import ( PowerDistributingActor, Request, Result, Success, Error, PartialFailure, Ignored, ) target = f\"{host}:{port}\" grpc_channel = grpcaio.insecure_channel(target) api = MicrogridGrpcClient(grpc_channel, target) graph = _MicrogridComponentGraph() await graph.refresh_from_api(api) batteries = graph.components(component_category={ComponentCategory.BATTERY}) batteries_ids = {c.component_id for c in batteries} channel = Bidirectional[Request, Result](\"user1\", \"power_distributor\") power_distributor = PowerDistributingActor( mock_api, component_graph, {\"user1\": channel.service_handle} ) client_handle = channel.client_handle # Set power 1200W to given batteries. request = Request(power=1200, batteries=batteries_ids, request_timeout_sec=10.0) await client_handle.send(request) # It is recommended to use timeout when waiting for the response! result: Result = await asyncio.wait_for(client_handle.receive(), timeout=10) if isinstance(result, Success): print(\"Command succeed\") elif isinstance(result, PartialFailure): print( f\"Batteries {result.failed_batteries} failed, total failed power\" \\ f\"{result.failed_power}\") elif isinstance(result, Ignored): print(f\"Request was ignored, because of newer request\") elif isinstance(result, Error): print(f\"Request failed with error: {result.msg}\") ``` \"\"\" def __init__ ( self , users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ]], battery_status_sender : Sender [ BatteryStatus ], wait_for_data_sec : float = 2 , ) -> None : \"\"\"Create class instance. Args: users_channels: BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. battery_status_sender: Channel for sending information which batteries are working. wait_for_data_sec: How long actor should wait before processing first request. It is a time needed to collect first components data. \"\"\" self . _wait_for_data_sec = wait_for_data_sec # NOTE: power_distributor_exponent should be received from ConfigManager self . power_distributor_exponent : float = 1.0 self . distribution_algorithm = DistributionAlgorithm ( self . power_distributor_exponent ) self . _bat_inv_map , self . _inv_bat_map = self . _get_components_pairs ( microgrid . get () . component_graph ) self . _battery_receivers : Dict [ int , Peekable [ BatteryData ]] = {} self . _inverter_receivers : Dict [ int , Peekable [ InverterData ]] = {} # The components in different requests be for the same components, or for # completely different components. They should not overlap. # Otherwise the PowerDistributingActor has no way to decide what request is more # important. It will execute both. And later request will override the previous # one. # That is why the queue of maxsize = total number of batteries should be enough. self . _request_queue : asyncio . Queue [ Tuple [ Request , _User ]] = asyncio . Queue ( maxsize = len ( self . _bat_inv_map ) ) self . _users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ] ] = users_channels self . _users_tasks = self . _create_users_tasks () self . _started = asyncio . Event () self . _all_battery_status = BatteryPoolStatus ( battery_ids = set ( self . _bat_inv_map . keys ()), battery_status_sender = battery_status_sender , max_blocking_duration_sec = 30.0 , max_data_age_sec = 10.0 , ) def _create_users_tasks ( self ) -> List [ asyncio . Task [ None ]]: \"\"\"For each user create a task to wait for request. Returns: List with users tasks. \"\"\" tasks = [] for user , handler in self . _users_channels . items (): tasks . append ( asyncio . create_task ( self . _wait_for_request ( _User ( user , handler ))) ) return tasks def _get_upper_bound ( self , batteries : Set [ int ]) -> int : \"\"\"Get total upper bound of power to be set for given batteries. Note, output of that function doesn't guarantee that this bound will be the same when the request is processed. Args: batteries: List of batteries Returns: Upper bound for `set_power` operation. \"\"\" pairs_data : List [ InvBatPair ] = self . _get_components_data ( batteries ) bound = sum ( min ( battery . power_upper_bound , inverter . active_power_upper_bound ) for battery , inverter in pairs_data ) return floor ( bound ) def _get_lower_bound ( self , batteries : Set [ int ]) -> int : \"\"\"Get total lower bound of power to be set for given batteries. Note, output of that function doesn't guarantee that this bound will be the same when the request is processed. Args: batteries: List of batteries Returns: Lower bound for `set_power` operation. \"\"\" pairs_data : List [ InvBatPair ] = self . _get_components_data ( batteries ) bound = sum ( max ( battery . power_lower_bound , inverter . active_power_lower_bound ) for battery , inverter in pairs_data ) return ceil ( bound ) async def run ( self ) -> None : \"\"\"Run actor main function. It waits for new requests in task_queue and process it, and send `set_power` request with distributed power. The output of the `set_power` method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. \"\"\" await self . _create_channels () api = microgrid . get () . api_client # Wait few seconds to get data from the channels created above. await asyncio . sleep ( self . _wait_for_data_sec ) self . _started . set () while True : request , user = await self . _request_queue . get () try : pairs_data : List [ InvBatPair ] = self . _get_components_data ( request . batteries ) except KeyError as err : await user . channel . send ( Error ( request , str ( err ))) continue if len ( pairs_data ) == 0 : error_msg = f \"No data for the given batteries { str ( request . batteries ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue try : distribution = self . distribution_algorithm . distribute_power ( request . power , pairs_data ) except ValueError as err : error_msg = f \"Couldn't distribute power, error: { str ( err ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue distributed_power_value = request . power - distribution . remaining_power battery_distribution = { self . _inv_bat_map [ bat_id ]: dist for bat_id , dist in distribution . distribution . items () } _logger . debug ( \" %s : Distributing power %d between the batteries %s \" , user . user_id , distributed_power_value , str ( battery_distribution ), ) failed_power , failed_batteries = await self . _set_distributed_power ( api , distribution , request . request_timeout_sec ) response : Success | PartialFailure if len ( failed_batteries ) > 0 : succeed_batteries = set ( battery_distribution . keys ()) - failed_batteries response = PartialFailure ( request = request , succeed_power = distributed_power_value , succeed_batteries = succeed_batteries , failed_power = failed_power , failed_batteries = failed_batteries , excess_power = distribution . remaining_power , ) else : succeed_batteries = set ( battery_distribution . keys ()) response = Success ( request = request , succeed_power = distributed_power_value , used_batteries = succeed_batteries , excess_power = distribution . remaining_power , ) asyncio . gather ( * [ self . _all_battery_status . update_status ( succeed_batteries , failed_batteries ), user . channel . send ( response ), ] ) async def _set_distributed_power ( self , api : MicrogridApiClient , distribution : DistributionResult , timeout_sec : float , ) -> Tuple [ int , Set [ int ]]: \"\"\"Send distributed power to the inverters. Args: api: Microgrid api client distribution: Distribution result timeout_sec: How long wait for the response Returns: Tuple where first element is total failed power, and the second element set of batteries that failed. \"\"\" tasks = { inverter_id : asyncio . create_task ( api . set_power ( inverter_id , power )) for inverter_id , power in distribution . distribution . items () } _ , pending = await asyncio . wait ( tasks . values (), timeout = timeout_sec , return_when = ALL_COMPLETED , ) await self . _cancel_tasks ( pending ) return self . _parse_result ( tasks , distribution . distribution , timeout_sec ) def _check_request ( self , request : Request ) -> Optional [ Result ]: \"\"\"Check whether the given request if correct. Args: request: request to check Returns: Result for the user if the request is wrong, None otherwise. \"\"\" for battery in request . batteries : if battery not in self . _battery_receivers : msg = ( f \"No battery { battery } , available batteries: \" f \" { list ( self . _battery_receivers . keys ()) } \" ) return Error ( request , msg ) if not request . adjust_power : if request . power < 0 : bound = self . _get_lower_bound ( request . batteries ) if request . power < bound : return OutOfBound ( request , bound ) else : bound = self . _get_upper_bound ( request . batteries ) if request . power > bound : return OutOfBound ( request , bound ) return None def _remove_duplicated_requests ( self , request : Request , user : _User ) -> List [ asyncio . Task [ bool ]]: \"\"\"Remove duplicated requests from the queue. Remove old requests in which set of batteries are the same as in new request. If batteries in new request overlap with batteries in old request but are not equal, then log error and process both messages. Args: request: request to check user: User who sent the request. Returns: Tasks with result sent to the users which requests were duplicated. \"\"\" batteries = request . batteries good_requests : List [ Tuple [ Request , _User ]] = [] to_ignore : List [ asyncio . Task [ bool ]] = [] while not self . _request_queue . empty (): prev_request , prev_user = self . _request_queue . get_nowait () # Generators seems to be the fastest if prev_request . batteries == batteries : task = asyncio . create_task ( prev_user . channel . send ( Ignored ( prev_request )) ) to_ignore . append ( task ) # Use generators as generators seems to be the fastest. elif any ( battery_id in prev_request . batteries for battery_id in batteries ): # If that happen PowerDistributingActor has no way to distinguish what # request is more important. This should not happen _logger . error ( \"Batteries in two requests overlap! Actor: %s requested %s \" \"and Actor: %s requested %s \" , user . user_id , str ( request ), prev_user . user_id , str ( prev_request ), ) good_requests . append (( prev_request , prev_user )) else : good_requests . append (( prev_request , prev_user )) for good_request in good_requests : self . _request_queue . put_nowait ( good_request ) return to_ignore async def _wait_for_request ( self , user : _User ) -> None : \"\"\"Wait for the request from user. Check if request is correct. If request is not correct send ERROR response to the user. If request is correct, then add it to the main queue to be process. Already existing requests for the same subset of batteries will be removed and their users will be notified with a Result.Status.IGNORED response. Only new request will re processed. If the sets of batteries are not the same but they have common elements, then both batteries will be processed. Args: user: User that sends the requests. \"\"\" while True : request : Optional [ Request ] = await user . channel . receive () if request is None : _logger . info ( \"Send channel for user %s was closed. User will be unregistered.\" , user . user_id , ) self . _users_channels . pop ( user . user_id ) if len ( self . _users_channels ) == 0 : _logger . error ( \"No users in PowerDistributingActor!\" ) return # Wait for PowerDistributingActor to start. if not self . _started . is_set (): await self . _started . wait () # We should discover as fast as possible that request is wrong. error = self . _check_request ( request ) if error is not None : await user . channel . send ( error ) continue tasks = self . _remove_duplicated_requests ( request , user ) if self . _request_queue . full (): q_size = ( self . _request_queue . qsize (),) msg = ( f \"Request queue is full { q_size } , can't process this request. \" \"Consider increasing size of the queue.\" ) _logger . error ( msg ) await user . channel . send ( Error ( request , str ( msg ))) else : self . _request_queue . put_nowait (( request , user )) await asyncio . gather ( * tasks ) def _get_components_pairs ( self , component_graph : ComponentGraph ) -> Tuple [ Dict [ int , int ], Dict [ int , int ]]: \"\"\"Create maps between battery and adjacent inverter. Args: component_graph: component graph Returns: Tuple where first element is map between battery and adjacent inverter, second element of the tuple is map between inverter and adjacent battery. \"\"\" bat_inv_map : Dict [ int , int ] = {} inv_bat_map : Dict [ int , int ] = {} batteries : Iterable [ Component ] = component_graph . components ( component_category = { ComponentCategory . BATTERY } ) for battery in batteries : inverters : List [ Component ] = [ component for component in component_graph . predecessors ( battery . component_id ) if component . category == ComponentCategory . INVERTER ] if len ( inverters ) == 0 : _logger . error ( \"No inverters for battery %d \" , battery . component_id ) continue if len ( inverters ) > 1 : _logger . error ( \"Battery %d has more then one inverter. It is not supported now.\" , battery . component_id , ) bat_inv_map [ battery . component_id ] = inverters [ 0 ] . component_id inv_bat_map [ inverters [ 0 ] . component_id ] = battery . component_id return bat_inv_map , inv_bat_map def _get_working_batteries ( self , batteries : Set [ int ]) -> Set [ int ]: \"\"\"Get subset with working batteries. If none of the given batteries are working, then treat all of them as working. Args: batteries: requested batteries Returns: Subset with working batteries or input set if none of the given batteries are working. \"\"\" working_batteries = self . _all_battery_status . get_working_batteries ( batteries ) if len ( working_batteries ) == 0 : return batteries return working_batteries def _get_components_data ( self , batteries : Set [ int ]) -> List [ InvBatPair ]: \"\"\"Get data for the given batteries and adjacent inverters. Args: batteries: Batteries that needs data. Raises: KeyError: If any battery in the given list doesn't exists in microgrid. Returns: Pairs of battery and adjacent inverter data. \"\"\" pairs_data : List [ InvBatPair ] = [] working_batteries = self . _get_working_batteries ( batteries ) for battery_id in working_batteries : if battery_id not in self . _battery_receivers : raise KeyError ( f \"No battery { battery_id } , \" f \"available batteries: { list ( self . _battery_receivers . keys ()) } \" ) inverter_id : int = self . _bat_inv_map [ battery_id ] data = self . _get_battery_inverter_data ( battery_id , inverter_id ) if data is None : _logger . warning ( \"Skipping battery %d because its message isn't correct.\" , battery_id , ) continue pairs_data . append ( data ) return pairs_data def _get_battery_inverter_data ( self , battery_id : int , inverter_id : int ) -> Optional [ InvBatPair ]: \"\"\"Get battery and inverter data if they are correct. Each float data from the microgrid can be \"NaN\". We can't do math operations on \"NaN\". So check all the metrics and: * if power bounds are NaN, then try to replace it with the corresponding power bounds from the adjacent component. If metric in the adjacent component is also NaN, then return None. * if other metrics are NaN then return None. We can't assume anything for other metrics. Args: battery_id: battery id inverter_id: inverter id Returns: Data for the battery and adjacent inverter without NaN values. Return None if we could not replace NaN values. \"\"\" battery_data = self . _battery_receivers [ battery_id ] . peek () inverter_data = self . _inverter_receivers [ inverter_id ] . peek () # It means that nothing has been send on this channels, yet. # This should be handled by BatteryStatus. BatteryStatus should not return # this batteries as working. if battery_data is None or inverter_data is None : _logger . error ( \"Battery %d or inverter %d send no data, yet. They should be not used.\" , battery_id , inverter_id , ) return None not_replaceable_metrics = [ battery_data . soc , battery_data . soc_lower_bound , battery_data . soc_upper_bound , # We could replace capacity with 0, but it won't change distribution. # This battery will be ignored in distribution anyway. battery_data . capacity , ] if any ( map ( isnan , not_replaceable_metrics )): _logger . debug ( \"Some metrics for battery %d are NaN\" , battery_id ) return None replaceable_metrics = [ battery_data . power_lower_bound , battery_data . power_upper_bound , inverter_data . active_power_lower_bound , inverter_data . active_power_upper_bound , ] # If all values are ok then return them. if not any ( map ( isnan , replaceable_metrics )): return InvBatPair ( battery_data , inverter_data ) # Replace NaN with the corresponding value in the adjacent component. # If both metrics are None, return None to ignore this battery. replaceable_pairs = [ ( \"power_lower_bound\" , \"active_power_lower_bound\" ), ( \"power_upper_bound\" , \"active_power_upper_bound\" ), ] battery_new_metrics = {} inverter_new_metrics = {} for bat_attr , inv_attr in replaceable_pairs : bat_bound = getattr ( battery_data , bat_attr ) inv_bound = getattr ( inverter_data , inv_attr ) if isnan ( bat_bound ) and isnan ( inv_bound ): _logger . debug ( \"Some metrics for battery %d are NaN\" , battery_id ) return None if isnan ( bat_bound ): battery_new_metrics [ bat_attr ] = inv_bound elif isnan ( inv_bound ): inverter_new_metrics [ inv_attr ] = bat_bound return InvBatPair ( replace ( battery_data , ** battery_new_metrics ), replace ( inverter_data , ** inverter_new_metrics ), ) async def _create_channels ( self ) -> None : \"\"\"Create channels to get data of components in microgrid.\"\"\" api = microgrid . get () . api_client for battery_id , inverter_id in self . _bat_inv_map . items (): bat_recv : Receiver [ BatteryData ] = await api . battery_data ( battery_id ) self . _battery_receivers [ battery_id ] = bat_recv . into_peekable () inv_recv : Receiver [ InverterData ] = await api . inverter_data ( inverter_id ) self . _inverter_receivers [ inverter_id ] = inv_recv . into_peekable () def _parse_result ( self , # type comment to quiet pylint and mypy `unused-import` error tasks , # type: Dict[int, asyncio.Task[Empty]] distribution : Dict [ int , int ], request_timeout_sec : float , ) -> Tuple [ int , Set [ int ]]: \"\"\"Parse result of `set_power` requests. Check if any task failed and why. If any task didn't success, then corresponding battery is marked as broken. Args: tasks: Dictionary where key is inverter id and value is task that set power for this inverter. Each tasks should be finished or cancelled. distribution: Dictionary where key is inverter id and value is how much power was set to the corresponding inverter. request_timeout_sec: timeout which has been used for request. Returns: Tuple where first element is total failed power, and the second element set of batteries that failed. \"\"\" failed_power : int = 0 failed_batteries : Set [ int ] = set () for inverter_id , aws in tasks . items (): battery_id = self . _inv_bat_map [ inverter_id ] try : aws . result () except grpc . aio . AioRpcError as err : failed_power += distribution [ inverter_id ] failed_batteries . add ( battery_id ) if err . code () == grpc . StatusCode . OUT_OF_RANGE : _logger . debug ( \"Set power for battery %d failed, error %s \" , battery_id , str ( err ), ) else : _logger . warning ( \"Set power for battery %d failed, error %s . Mark it as broken.\" , battery_id , str ( err ), ) except asyncio . exceptions . CancelledError : failed_power += distribution [ inverter_id ] failed_batteries . add ( battery_id ) _logger . warning ( \"Battery %d didn't respond in %f sec. Mark it as broken.\" , battery_id , request_timeout_sec , ) return failed_power , failed_batteries async def _cancel_tasks ( self , tasks : Iterable [ asyncio . Task [ Any ]]) -> None : \"\"\"Cancel given asyncio tasks and wait for them. Args: tasks: tasks to cancel. \"\"\" for aws in tasks : aws . cancel () await asyncio . gather ( * tasks , return_exceptions = True ) async def _stop_actor ( self ) -> None : \"\"\"Stop all running async tasks.\"\"\" await asyncio . gather ( * [ cancel_and_await ( t ) for t in self . _users_tasks ]) await self . _all_battery_status . stop () await self . _stop () # type: ignore # pylint: disable=no-member Functions \u00a4 __init__ ( users_channels , battery_status_sender , wait_for_data_sec = 2 ) \u00a4 Create class instance. PARAMETER DESCRIPTION users_channels BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. TYPE: Dict [ str , Bidirectional . Handle [ Result , Request ]] battery_status_sender Channel for sending information which batteries are working. TYPE: Sender [ BatteryStatus ] wait_for_data_sec How long actor should wait before processing first request. It is a time needed to collect first components data. TYPE: float DEFAULT: 2 Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __init__ ( self , users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ]], battery_status_sender : Sender [ BatteryStatus ], wait_for_data_sec : float = 2 , ) -> None : \"\"\"Create class instance. Args: users_channels: BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. battery_status_sender: Channel for sending information which batteries are working. wait_for_data_sec: How long actor should wait before processing first request. It is a time needed to collect first components data. \"\"\" self . _wait_for_data_sec = wait_for_data_sec # NOTE: power_distributor_exponent should be received from ConfigManager self . power_distributor_exponent : float = 1.0 self . distribution_algorithm = DistributionAlgorithm ( self . power_distributor_exponent ) self . _bat_inv_map , self . _inv_bat_map = self . _get_components_pairs ( microgrid . get () . component_graph ) self . _battery_receivers : Dict [ int , Peekable [ BatteryData ]] = {} self . _inverter_receivers : Dict [ int , Peekable [ InverterData ]] = {} # The components in different requests be for the same components, or for # completely different components. They should not overlap. # Otherwise the PowerDistributingActor has no way to decide what request is more # important. It will execute both. And later request will override the previous # one. # That is why the queue of maxsize = total number of batteries should be enough. self . _request_queue : asyncio . Queue [ Tuple [ Request , _User ]] = asyncio . Queue ( maxsize = len ( self . _bat_inv_map ) ) self . _users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ] ] = users_channels self . _users_tasks = self . _create_users_tasks () self . _started = asyncio . Event () self . _all_battery_status = BatteryPoolStatus ( battery_ids = set ( self . _bat_inv_map . keys ()), battery_status_sender = battery_status_sender , max_blocking_duration_sec = 30.0 , max_data_age_sec = 10.0 , ) run () async \u00a4 Run actor main function. It waits for new requests in task_queue and process it, and send set_power request with distributed power. The output of the set_power method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 async def run ( self ) -> None : \"\"\"Run actor main function. It waits for new requests in task_queue and process it, and send `set_power` request with distributed power. The output of the `set_power` method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. \"\"\" await self . _create_channels () api = microgrid . get () . api_client # Wait few seconds to get data from the channels created above. await asyncio . sleep ( self . _wait_for_data_sec ) self . _started . set () while True : request , user = await self . _request_queue . get () try : pairs_data : List [ InvBatPair ] = self . _get_components_data ( request . batteries ) except KeyError as err : await user . channel . send ( Error ( request , str ( err ))) continue if len ( pairs_data ) == 0 : error_msg = f \"No data for the given batteries { str ( request . batteries ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue try : distribution = self . distribution_algorithm . distribute_power ( request . power , pairs_data ) except ValueError as err : error_msg = f \"Couldn't distribute power, error: { str ( err ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue distributed_power_value = request . power - distribution . remaining_power battery_distribution = { self . _inv_bat_map [ bat_id ]: dist for bat_id , dist in distribution . distribution . items () } _logger . debug ( \" %s : Distributing power %d between the batteries %s \" , user . user_id , distributed_power_value , str ( battery_distribution ), ) failed_power , failed_batteries = await self . _set_distributed_power ( api , distribution , request . request_timeout_sec ) response : Success | PartialFailure if len ( failed_batteries ) > 0 : succeed_batteries = set ( battery_distribution . keys ()) - failed_batteries response = PartialFailure ( request = request , succeed_power = distributed_power_value , succeed_batteries = succeed_batteries , failed_power = failed_power , failed_batteries = failed_batteries , excess_power = distribution . remaining_power , ) else : succeed_batteries = set ( battery_distribution . keys ()) response = Success ( request = request , succeed_power = distributed_power_value , used_batteries = succeed_batteries , excess_power = distribution . remaining_power , ) asyncio . gather ( * [ self . _all_battery_status . update_status ( succeed_batteries , failed_batteries ), user . channel . send ( response ), ] ) Functions \u00a4","title":"power_distributing"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing","text":"Actor to distribute power between batteries. When charge/discharge method is called the power should be distributed so that the SoC in batteries stays at the same level. That way of distribution prevents using only one battery, increasing temperature, and maximize the total amount power to charge/discharge. Purpose of this actor is to keep SoC level of each component at the equal level.","title":"power_distributing"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor","text":"Actor to distribute the power between batteries in a microgrid. The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time. For each user a bidirectional channel needs to be created through which they can send and receive requests and responses. It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout_sec + time for processing the request. Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED. If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed. Example import grpc.aio as grpcaio from frequenz.sdk.microgrid.graph import _MicrogridComponentGraph from frequenz.sdk.microgrid.component import ComponentCategory from frequenz.sdk.actor.power_distributing import ( PowerDistributingActor , Request , Result , Success , Error , PartialFailure , Ignored , ) target = f \" { host } : { port } \" grpc_channel = grpcaio . insecure_channel ( target ) api = MicrogridGrpcClient ( grpc_channel , target ) graph = _MicrogridComponentGraph () await graph . refresh_from_api ( api ) batteries = graph . components ( component_category = { ComponentCategory . BATTERY }) batteries_ids = { c . component_id for c in batteries } channel = Bidirectional [ Request , Result ]( \"user1\" , \"power_distributor\" ) power_distributor = PowerDistributingActor ( mock_api , component_graph , { \"user1\" : channel . service_handle } ) client_handle = channel . client_handle # Set power 1200W to given batteries. request = Request ( power = 1200 , batteries = batteries_ids , request_timeout_sec = 10.0 ) await client_handle . send ( request ) # It is recommended to use timeout when waiting for the response! result : Result = await asyncio . wait_for ( client_handle . receive (), timeout = 10 ) if isinstance ( result , Success ): print ( \"Command succeed\" ) elif isinstance ( result , PartialFailure ): print ( f \"Batteries { result . failed_batteries } failed, total failed power\" f \" { result . failed_power } \" ) elif isinstance ( result , Ignored ): print ( f \"Request was ignored, because of newer request\" ) elif isinstance ( result , Error ): print ( f \"Request failed with error: { result . msg } \" ) Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 @actor class PowerDistributingActor : # pylint: disable=too-many-instance-attributes \"\"\"Actor to distribute the power between batteries in a microgrid. The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time. For each user a bidirectional channel needs to be created through which they can send and receive requests and responses. It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout_sec + time for processing the request. Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED. * If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed. Example: ``` python import grpc.aio as grpcaio from frequenz.sdk.microgrid.graph import _MicrogridComponentGraph from frequenz.sdk.microgrid.component import ComponentCategory from frequenz.sdk.actor.power_distributing import ( PowerDistributingActor, Request, Result, Success, Error, PartialFailure, Ignored, ) target = f\"{host}:{port}\" grpc_channel = grpcaio.insecure_channel(target) api = MicrogridGrpcClient(grpc_channel, target) graph = _MicrogridComponentGraph() await graph.refresh_from_api(api) batteries = graph.components(component_category={ComponentCategory.BATTERY}) batteries_ids = {c.component_id for c in batteries} channel = Bidirectional[Request, Result](\"user1\", \"power_distributor\") power_distributor = PowerDistributingActor( mock_api, component_graph, {\"user1\": channel.service_handle} ) client_handle = channel.client_handle # Set power 1200W to given batteries. request = Request(power=1200, batteries=batteries_ids, request_timeout_sec=10.0) await client_handle.send(request) # It is recommended to use timeout when waiting for the response! result: Result = await asyncio.wait_for(client_handle.receive(), timeout=10) if isinstance(result, Success): print(\"Command succeed\") elif isinstance(result, PartialFailure): print( f\"Batteries {result.failed_batteries} failed, total failed power\" \\ f\"{result.failed_power}\") elif isinstance(result, Ignored): print(f\"Request was ignored, because of newer request\") elif isinstance(result, Error): print(f\"Request failed with error: {result.msg}\") ``` \"\"\" def __init__ ( self , users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ]], battery_status_sender : Sender [ BatteryStatus ], wait_for_data_sec : float = 2 , ) -> None : \"\"\"Create class instance. Args: users_channels: BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. battery_status_sender: Channel for sending information which batteries are working. wait_for_data_sec: How long actor should wait before processing first request. It is a time needed to collect first components data. \"\"\" self . _wait_for_data_sec = wait_for_data_sec # NOTE: power_distributor_exponent should be received from ConfigManager self . power_distributor_exponent : float = 1.0 self . distribution_algorithm = DistributionAlgorithm ( self . power_distributor_exponent ) self . _bat_inv_map , self . _inv_bat_map = self . _get_components_pairs ( microgrid . get () . component_graph ) self . _battery_receivers : Dict [ int , Peekable [ BatteryData ]] = {} self . _inverter_receivers : Dict [ int , Peekable [ InverterData ]] = {} # The components in different requests be for the same components, or for # completely different components. They should not overlap. # Otherwise the PowerDistributingActor has no way to decide what request is more # important. It will execute both. And later request will override the previous # one. # That is why the queue of maxsize = total number of batteries should be enough. self . _request_queue : asyncio . Queue [ Tuple [ Request , _User ]] = asyncio . Queue ( maxsize = len ( self . _bat_inv_map ) ) self . _users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ] ] = users_channels self . _users_tasks = self . _create_users_tasks () self . _started = asyncio . Event () self . _all_battery_status = BatteryPoolStatus ( battery_ids = set ( self . _bat_inv_map . keys ()), battery_status_sender = battery_status_sender , max_blocking_duration_sec = 30.0 , max_data_age_sec = 10.0 , ) def _create_users_tasks ( self ) -> List [ asyncio . Task [ None ]]: \"\"\"For each user create a task to wait for request. Returns: List with users tasks. \"\"\" tasks = [] for user , handler in self . _users_channels . items (): tasks . append ( asyncio . create_task ( self . _wait_for_request ( _User ( user , handler ))) ) return tasks def _get_upper_bound ( self , batteries : Set [ int ]) -> int : \"\"\"Get total upper bound of power to be set for given batteries. Note, output of that function doesn't guarantee that this bound will be the same when the request is processed. Args: batteries: List of batteries Returns: Upper bound for `set_power` operation. \"\"\" pairs_data : List [ InvBatPair ] = self . _get_components_data ( batteries ) bound = sum ( min ( battery . power_upper_bound , inverter . active_power_upper_bound ) for battery , inverter in pairs_data ) return floor ( bound ) def _get_lower_bound ( self , batteries : Set [ int ]) -> int : \"\"\"Get total lower bound of power to be set for given batteries. Note, output of that function doesn't guarantee that this bound will be the same when the request is processed. Args: batteries: List of batteries Returns: Lower bound for `set_power` operation. \"\"\" pairs_data : List [ InvBatPair ] = self . _get_components_data ( batteries ) bound = sum ( max ( battery . power_lower_bound , inverter . active_power_lower_bound ) for battery , inverter in pairs_data ) return ceil ( bound ) async def run ( self ) -> None : \"\"\"Run actor main function. It waits for new requests in task_queue and process it, and send `set_power` request with distributed power. The output of the `set_power` method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. \"\"\" await self . _create_channels () api = microgrid . get () . api_client # Wait few seconds to get data from the channels created above. await asyncio . sleep ( self . _wait_for_data_sec ) self . _started . set () while True : request , user = await self . _request_queue . get () try : pairs_data : List [ InvBatPair ] = self . _get_components_data ( request . batteries ) except KeyError as err : await user . channel . send ( Error ( request , str ( err ))) continue if len ( pairs_data ) == 0 : error_msg = f \"No data for the given batteries { str ( request . batteries ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue try : distribution = self . distribution_algorithm . distribute_power ( request . power , pairs_data ) except ValueError as err : error_msg = f \"Couldn't distribute power, error: { str ( err ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue distributed_power_value = request . power - distribution . remaining_power battery_distribution = { self . _inv_bat_map [ bat_id ]: dist for bat_id , dist in distribution . distribution . items () } _logger . debug ( \" %s : Distributing power %d between the batteries %s \" , user . user_id , distributed_power_value , str ( battery_distribution ), ) failed_power , failed_batteries = await self . _set_distributed_power ( api , distribution , request . request_timeout_sec ) response : Success | PartialFailure if len ( failed_batteries ) > 0 : succeed_batteries = set ( battery_distribution . keys ()) - failed_batteries response = PartialFailure ( request = request , succeed_power = distributed_power_value , succeed_batteries = succeed_batteries , failed_power = failed_power , failed_batteries = failed_batteries , excess_power = distribution . remaining_power , ) else : succeed_batteries = set ( battery_distribution . keys ()) response = Success ( request = request , succeed_power = distributed_power_value , used_batteries = succeed_batteries , excess_power = distribution . remaining_power , ) asyncio . gather ( * [ self . _all_battery_status . update_status ( succeed_batteries , failed_batteries ), user . channel . send ( response ), ] ) async def _set_distributed_power ( self , api : MicrogridApiClient , distribution : DistributionResult , timeout_sec : float , ) -> Tuple [ int , Set [ int ]]: \"\"\"Send distributed power to the inverters. Args: api: Microgrid api client distribution: Distribution result timeout_sec: How long wait for the response Returns: Tuple where first element is total failed power, and the second element set of batteries that failed. \"\"\" tasks = { inverter_id : asyncio . create_task ( api . set_power ( inverter_id , power )) for inverter_id , power in distribution . distribution . items () } _ , pending = await asyncio . wait ( tasks . values (), timeout = timeout_sec , return_when = ALL_COMPLETED , ) await self . _cancel_tasks ( pending ) return self . _parse_result ( tasks , distribution . distribution , timeout_sec ) def _check_request ( self , request : Request ) -> Optional [ Result ]: \"\"\"Check whether the given request if correct. Args: request: request to check Returns: Result for the user if the request is wrong, None otherwise. \"\"\" for battery in request . batteries : if battery not in self . _battery_receivers : msg = ( f \"No battery { battery } , available batteries: \" f \" { list ( self . _battery_receivers . keys ()) } \" ) return Error ( request , msg ) if not request . adjust_power : if request . power < 0 : bound = self . _get_lower_bound ( request . batteries ) if request . power < bound : return OutOfBound ( request , bound ) else : bound = self . _get_upper_bound ( request . batteries ) if request . power > bound : return OutOfBound ( request , bound ) return None def _remove_duplicated_requests ( self , request : Request , user : _User ) -> List [ asyncio . Task [ bool ]]: \"\"\"Remove duplicated requests from the queue. Remove old requests in which set of batteries are the same as in new request. If batteries in new request overlap with batteries in old request but are not equal, then log error and process both messages. Args: request: request to check user: User who sent the request. Returns: Tasks with result sent to the users which requests were duplicated. \"\"\" batteries = request . batteries good_requests : List [ Tuple [ Request , _User ]] = [] to_ignore : List [ asyncio . Task [ bool ]] = [] while not self . _request_queue . empty (): prev_request , prev_user = self . _request_queue . get_nowait () # Generators seems to be the fastest if prev_request . batteries == batteries : task = asyncio . create_task ( prev_user . channel . send ( Ignored ( prev_request )) ) to_ignore . append ( task ) # Use generators as generators seems to be the fastest. elif any ( battery_id in prev_request . batteries for battery_id in batteries ): # If that happen PowerDistributingActor has no way to distinguish what # request is more important. This should not happen _logger . error ( \"Batteries in two requests overlap! Actor: %s requested %s \" \"and Actor: %s requested %s \" , user . user_id , str ( request ), prev_user . user_id , str ( prev_request ), ) good_requests . append (( prev_request , prev_user )) else : good_requests . append (( prev_request , prev_user )) for good_request in good_requests : self . _request_queue . put_nowait ( good_request ) return to_ignore async def _wait_for_request ( self , user : _User ) -> None : \"\"\"Wait for the request from user. Check if request is correct. If request is not correct send ERROR response to the user. If request is correct, then add it to the main queue to be process. Already existing requests for the same subset of batteries will be removed and their users will be notified with a Result.Status.IGNORED response. Only new request will re processed. If the sets of batteries are not the same but they have common elements, then both batteries will be processed. Args: user: User that sends the requests. \"\"\" while True : request : Optional [ Request ] = await user . channel . receive () if request is None : _logger . info ( \"Send channel for user %s was closed. User will be unregistered.\" , user . user_id , ) self . _users_channels . pop ( user . user_id ) if len ( self . _users_channels ) == 0 : _logger . error ( \"No users in PowerDistributingActor!\" ) return # Wait for PowerDistributingActor to start. if not self . _started . is_set (): await self . _started . wait () # We should discover as fast as possible that request is wrong. error = self . _check_request ( request ) if error is not None : await user . channel . send ( error ) continue tasks = self . _remove_duplicated_requests ( request , user ) if self . _request_queue . full (): q_size = ( self . _request_queue . qsize (),) msg = ( f \"Request queue is full { q_size } , can't process this request. \" \"Consider increasing size of the queue.\" ) _logger . error ( msg ) await user . channel . send ( Error ( request , str ( msg ))) else : self . _request_queue . put_nowait (( request , user )) await asyncio . gather ( * tasks ) def _get_components_pairs ( self , component_graph : ComponentGraph ) -> Tuple [ Dict [ int , int ], Dict [ int , int ]]: \"\"\"Create maps between battery and adjacent inverter. Args: component_graph: component graph Returns: Tuple where first element is map between battery and adjacent inverter, second element of the tuple is map between inverter and adjacent battery. \"\"\" bat_inv_map : Dict [ int , int ] = {} inv_bat_map : Dict [ int , int ] = {} batteries : Iterable [ Component ] = component_graph . components ( component_category = { ComponentCategory . BATTERY } ) for battery in batteries : inverters : List [ Component ] = [ component for component in component_graph . predecessors ( battery . component_id ) if component . category == ComponentCategory . INVERTER ] if len ( inverters ) == 0 : _logger . error ( \"No inverters for battery %d \" , battery . component_id ) continue if len ( inverters ) > 1 : _logger . error ( \"Battery %d has more then one inverter. It is not supported now.\" , battery . component_id , ) bat_inv_map [ battery . component_id ] = inverters [ 0 ] . component_id inv_bat_map [ inverters [ 0 ] . component_id ] = battery . component_id return bat_inv_map , inv_bat_map def _get_working_batteries ( self , batteries : Set [ int ]) -> Set [ int ]: \"\"\"Get subset with working batteries. If none of the given batteries are working, then treat all of them as working. Args: batteries: requested batteries Returns: Subset with working batteries or input set if none of the given batteries are working. \"\"\" working_batteries = self . _all_battery_status . get_working_batteries ( batteries ) if len ( working_batteries ) == 0 : return batteries return working_batteries def _get_components_data ( self , batteries : Set [ int ]) -> List [ InvBatPair ]: \"\"\"Get data for the given batteries and adjacent inverters. Args: batteries: Batteries that needs data. Raises: KeyError: If any battery in the given list doesn't exists in microgrid. Returns: Pairs of battery and adjacent inverter data. \"\"\" pairs_data : List [ InvBatPair ] = [] working_batteries = self . _get_working_batteries ( batteries ) for battery_id in working_batteries : if battery_id not in self . _battery_receivers : raise KeyError ( f \"No battery { battery_id } , \" f \"available batteries: { list ( self . _battery_receivers . keys ()) } \" ) inverter_id : int = self . _bat_inv_map [ battery_id ] data = self . _get_battery_inverter_data ( battery_id , inverter_id ) if data is None : _logger . warning ( \"Skipping battery %d because its message isn't correct.\" , battery_id , ) continue pairs_data . append ( data ) return pairs_data def _get_battery_inverter_data ( self , battery_id : int , inverter_id : int ) -> Optional [ InvBatPair ]: \"\"\"Get battery and inverter data if they are correct. Each float data from the microgrid can be \"NaN\". We can't do math operations on \"NaN\". So check all the metrics and: * if power bounds are NaN, then try to replace it with the corresponding power bounds from the adjacent component. If metric in the adjacent component is also NaN, then return None. * if other metrics are NaN then return None. We can't assume anything for other metrics. Args: battery_id: battery id inverter_id: inverter id Returns: Data for the battery and adjacent inverter without NaN values. Return None if we could not replace NaN values. \"\"\" battery_data = self . _battery_receivers [ battery_id ] . peek () inverter_data = self . _inverter_receivers [ inverter_id ] . peek () # It means that nothing has been send on this channels, yet. # This should be handled by BatteryStatus. BatteryStatus should not return # this batteries as working. if battery_data is None or inverter_data is None : _logger . error ( \"Battery %d or inverter %d send no data, yet. They should be not used.\" , battery_id , inverter_id , ) return None not_replaceable_metrics = [ battery_data . soc , battery_data . soc_lower_bound , battery_data . soc_upper_bound , # We could replace capacity with 0, but it won't change distribution. # This battery will be ignored in distribution anyway. battery_data . capacity , ] if any ( map ( isnan , not_replaceable_metrics )): _logger . debug ( \"Some metrics for battery %d are NaN\" , battery_id ) return None replaceable_metrics = [ battery_data . power_lower_bound , battery_data . power_upper_bound , inverter_data . active_power_lower_bound , inverter_data . active_power_upper_bound , ] # If all values are ok then return them. if not any ( map ( isnan , replaceable_metrics )): return InvBatPair ( battery_data , inverter_data ) # Replace NaN with the corresponding value in the adjacent component. # If both metrics are None, return None to ignore this battery. replaceable_pairs = [ ( \"power_lower_bound\" , \"active_power_lower_bound\" ), ( \"power_upper_bound\" , \"active_power_upper_bound\" ), ] battery_new_metrics = {} inverter_new_metrics = {} for bat_attr , inv_attr in replaceable_pairs : bat_bound = getattr ( battery_data , bat_attr ) inv_bound = getattr ( inverter_data , inv_attr ) if isnan ( bat_bound ) and isnan ( inv_bound ): _logger . debug ( \"Some metrics for battery %d are NaN\" , battery_id ) return None if isnan ( bat_bound ): battery_new_metrics [ bat_attr ] = inv_bound elif isnan ( inv_bound ): inverter_new_metrics [ inv_attr ] = bat_bound return InvBatPair ( replace ( battery_data , ** battery_new_metrics ), replace ( inverter_data , ** inverter_new_metrics ), ) async def _create_channels ( self ) -> None : \"\"\"Create channels to get data of components in microgrid.\"\"\" api = microgrid . get () . api_client for battery_id , inverter_id in self . _bat_inv_map . items (): bat_recv : Receiver [ BatteryData ] = await api . battery_data ( battery_id ) self . _battery_receivers [ battery_id ] = bat_recv . into_peekable () inv_recv : Receiver [ InverterData ] = await api . inverter_data ( inverter_id ) self . _inverter_receivers [ inverter_id ] = inv_recv . into_peekable () def _parse_result ( self , # type comment to quiet pylint and mypy `unused-import` error tasks , # type: Dict[int, asyncio.Task[Empty]] distribution : Dict [ int , int ], request_timeout_sec : float , ) -> Tuple [ int , Set [ int ]]: \"\"\"Parse result of `set_power` requests. Check if any task failed and why. If any task didn't success, then corresponding battery is marked as broken. Args: tasks: Dictionary where key is inverter id and value is task that set power for this inverter. Each tasks should be finished or cancelled. distribution: Dictionary where key is inverter id and value is how much power was set to the corresponding inverter. request_timeout_sec: timeout which has been used for request. Returns: Tuple where first element is total failed power, and the second element set of batteries that failed. \"\"\" failed_power : int = 0 failed_batteries : Set [ int ] = set () for inverter_id , aws in tasks . items (): battery_id = self . _inv_bat_map [ inverter_id ] try : aws . result () except grpc . aio . AioRpcError as err : failed_power += distribution [ inverter_id ] failed_batteries . add ( battery_id ) if err . code () == grpc . StatusCode . OUT_OF_RANGE : _logger . debug ( \"Set power for battery %d failed, error %s \" , battery_id , str ( err ), ) else : _logger . warning ( \"Set power for battery %d failed, error %s . Mark it as broken.\" , battery_id , str ( err ), ) except asyncio . exceptions . CancelledError : failed_power += distribution [ inverter_id ] failed_batteries . add ( battery_id ) _logger . warning ( \"Battery %d didn't respond in %f sec. Mark it as broken.\" , battery_id , request_timeout_sec , ) return failed_power , failed_batteries async def _cancel_tasks ( self , tasks : Iterable [ asyncio . Task [ Any ]]) -> None : \"\"\"Cancel given asyncio tasks and wait for them. Args: tasks: tasks to cancel. \"\"\" for aws in tasks : aws . cancel () await asyncio . gather ( * tasks , return_exceptions = True ) async def _stop_actor ( self ) -> None : \"\"\"Stop all running async tasks.\"\"\" await asyncio . gather ( * [ cancel_and_await ( t ) for t in self . _users_tasks ]) await self . _all_battery_status . stop () await self . _stop () # type: ignore # pylint: disable=no-member","title":"PowerDistributingActor"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__init__","text":"Create class instance. PARAMETER DESCRIPTION users_channels BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. TYPE: Dict [ str , Bidirectional . Handle [ Result , Request ]] battery_status_sender Channel for sending information which batteries are working. TYPE: Sender [ BatteryStatus ] wait_for_data_sec How long actor should wait before processing first request. It is a time needed to collect first components data. TYPE: float DEFAULT: 2 Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __init__ ( self , users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ]], battery_status_sender : Sender [ BatteryStatus ], wait_for_data_sec : float = 2 , ) -> None : \"\"\"Create class instance. Args: users_channels: BidirectionalHandle for each user. Key should be user id and value should be BidirectionalHandle. battery_status_sender: Channel for sending information which batteries are working. wait_for_data_sec: How long actor should wait before processing first request. It is a time needed to collect first components data. \"\"\" self . _wait_for_data_sec = wait_for_data_sec # NOTE: power_distributor_exponent should be received from ConfigManager self . power_distributor_exponent : float = 1.0 self . distribution_algorithm = DistributionAlgorithm ( self . power_distributor_exponent ) self . _bat_inv_map , self . _inv_bat_map = self . _get_components_pairs ( microgrid . get () . component_graph ) self . _battery_receivers : Dict [ int , Peekable [ BatteryData ]] = {} self . _inverter_receivers : Dict [ int , Peekable [ InverterData ]] = {} # The components in different requests be for the same components, or for # completely different components. They should not overlap. # Otherwise the PowerDistributingActor has no way to decide what request is more # important. It will execute both. And later request will override the previous # one. # That is why the queue of maxsize = total number of batteries should be enough. self . _request_queue : asyncio . Queue [ Tuple [ Request , _User ]] = asyncio . Queue ( maxsize = len ( self . _bat_inv_map ) ) self . _users_channels : Dict [ str , Bidirectional . Handle [ Result , Request ] ] = users_channels self . _users_tasks = self . _create_users_tasks () self . _started = asyncio . Event () self . _all_battery_status = BatteryPoolStatus ( battery_ids = set ( self . _bat_inv_map . keys ()), battery_status_sender = battery_status_sender , max_blocking_duration_sec = 30.0 , max_data_age_sec = 10.0 , )","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.run","text":"Run actor main function. It waits for new requests in task_queue and process it, and send set_power request with distributed power. The output of the set_power method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. Source code in frequenz/sdk/actor/power_distributing/power_distributing.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 async def run ( self ) -> None : \"\"\"Run actor main function. It waits for new requests in task_queue and process it, and send `set_power` request with distributed power. The output of the `set_power` method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time. \"\"\" await self . _create_channels () api = microgrid . get () . api_client # Wait few seconds to get data from the channels created above. await asyncio . sleep ( self . _wait_for_data_sec ) self . _started . set () while True : request , user = await self . _request_queue . get () try : pairs_data : List [ InvBatPair ] = self . _get_components_data ( request . batteries ) except KeyError as err : await user . channel . send ( Error ( request , str ( err ))) continue if len ( pairs_data ) == 0 : error_msg = f \"No data for the given batteries { str ( request . batteries ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue try : distribution = self . distribution_algorithm . distribute_power ( request . power , pairs_data ) except ValueError as err : error_msg = f \"Couldn't distribute power, error: { str ( err ) } \" await user . channel . send ( Error ( request , str ( error_msg ))) continue distributed_power_value = request . power - distribution . remaining_power battery_distribution = { self . _inv_bat_map [ bat_id ]: dist for bat_id , dist in distribution . distribution . items () } _logger . debug ( \" %s : Distributing power %d between the batteries %s \" , user . user_id , distributed_power_value , str ( battery_distribution ), ) failed_power , failed_batteries = await self . _set_distributed_power ( api , distribution , request . request_timeout_sec ) response : Success | PartialFailure if len ( failed_batteries ) > 0 : succeed_batteries = set ( battery_distribution . keys ()) - failed_batteries response = PartialFailure ( request = request , succeed_power = distributed_power_value , succeed_batteries = succeed_batteries , failed_power = failed_power , failed_batteries = failed_batteries , excess_power = distribution . remaining_power , ) else : succeed_batteries = set ( battery_distribution . keys ()) response = Success ( request = request , succeed_power = distributed_power_value , used_batteries = succeed_batteries , excess_power = distribution . remaining_power , ) asyncio . gather ( * [ self . _all_battery_status . update_status ( succeed_batteries , failed_batteries ), user . channel . send ( response ), ] )","title":"run()"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/","text":"frequenz.sdk.actor.power_distributing.request \u00a4 Definition of the user request. Classes \u00a4 frequenz.sdk.actor.power_distributing.request.Request dataclass \u00a4 Request from the user. Source code in frequenz/sdk/actor/power_distributing/request.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @dataclass class Request : \"\"\"Request from the user.\"\"\" # How much power to set power : int # In which batteries the power should be set batteries : Set [ int ] # Timeout for the server to respond on the requests. request_timeout_sec : float = 5.0 # If True and requested power value is above upper bound, then the power will be # decreased to match the bounds. Only the decreased power will be set. # If False and the requested power is above upper bound, then request won't # be processed. result.OutOfBound message will be send back to the user. adjust_power : bool = True","title":"request"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request","text":"Definition of the user request.","title":"request"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request","text":"Request from the user. Source code in frequenz/sdk/actor/power_distributing/request.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @dataclass class Request : \"\"\"Request from the user.\"\"\" # How much power to set power : int # In which batteries the power should be set batteries : Set [ int ] # Timeout for the server to respond on the requests. request_timeout_sec : float = 5.0 # If True and requested power value is above upper bound, then the power will be # decreased to match the bounds. Only the decreased power will be set. # If False and the requested power is above upper bound, then request won't # be processed. result.OutOfBound message will be send back to the user. adjust_power : bool = True","title":"Request"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/","text":"frequenz.sdk.actor.power_distributing.result \u00a4 Results from PowerDistributingActor. Classes \u00a4 frequenz.sdk.actor.power_distributing.result.Error \u00a4 Bases: Result Error occurred and power was not set. Source code in frequenz/sdk/actor/power_distributing/result.py 86 87 88 89 90 91 92 93 94 95 96 97 class Error ( Result ): \"\"\"Error occurred and power was not set.\"\"\" def __init__ ( self , request : Request , msg : str ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. msg: Error message explaining why error happened. \"\"\" super () . __init__ ( request ) self . msg : str = msg Functions \u00a4 __init__ ( request , msg ) \u00a4 Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request msg Error message explaining why error happened. TYPE: str Source code in frequenz/sdk/actor/power_distributing/result.py 89 90 91 92 93 94 95 96 97 def __init__ ( self , request : Request , msg : str ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. msg: Error message explaining why error happened. \"\"\" super () . __init__ ( request ) self . msg : str = msg frequenz.sdk.actor.power_distributing.result.Ignored \u00a4 Bases: Result Send if request was ignored. Request was ignored because new request for the same subset of batteries was received. Source code in frequenz/sdk/actor/power_distributing/result.py 119 120 121 122 123 124 class Ignored ( Result ): \"\"\"Send if request was ignored. Request was ignored because new request for the same subset of batteries was received. \"\"\" frequenz.sdk.actor.power_distributing.result.OutOfBound \u00a4 Bases: Result Send if power was not set because requested power was not within bounds. This message is send only if Request.adjust_power = False. Source code in frequenz/sdk/actor/power_distributing/result.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class OutOfBound ( Result ): \"\"\"Send if power was not set because requested power was not within bounds. This message is send only if Request.adjust_power = False. \"\"\" def __init__ ( self , request : Request , bound : int ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. bound: Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. \"\"\" super () . __init__ ( request ) self . bound : int = bound Functions \u00a4 __init__ ( request , bound ) \u00a4 Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request bound Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , request : Request , bound : int ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. bound: Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. \"\"\" super () . __init__ ( request ) self . bound : int = bound frequenz.sdk.actor.power_distributing.result.PartialFailure \u00a4 Bases: Result Send if any battery failed and didn't perform the request. Source code in frequenz/sdk/actor/power_distributing/result.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class PartialFailure ( Result ): \"\"\"Send if any battery failed and didn't perform the request.\"\"\" # It is very simple class with only data so it should be ok to disable pylint. # All these results should be dataclass but in python < 3.10 it is risky # to derive after dataclass. def __init__ ( # pylint: disable=too-many-arguments self , request : Request , succeed_power : int , succeed_batteries : Set [ int ], failed_power : int , failed_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. succeed_batteries: Subset of the requested batteries for which the request succeed. failed_power: Part of the requested power that failed. failed_batteries: Subset of the requested batteries for which the request failed. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . succeed_batteries : Set [ int ] = succeed_batteries self . failed_power : int = failed_power self . failed_batteries : Set [ int ] = failed_batteries self . excess_power : int = excess_power Functions \u00a4 __init__ ( request , succeed_power , succeed_batteries , failed_power , failed_batteries , excess_power ) \u00a4 Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request succeed_power Part of the requested power that was successfully set. TYPE: int succeed_batteries Subset of the requested batteries for which the request succeed. TYPE: Set [ int ] failed_power Part of the requested power that failed. TYPE: int failed_batteries Subset of the requested batteries for which the request failed. TYPE: Set [ int ] excess_power Part of the requested power that could not be fulfilled, because it was outside available power bounds. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( # pylint: disable=too-many-arguments self , request : Request , succeed_power : int , succeed_batteries : Set [ int ], failed_power : int , failed_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. succeed_batteries: Subset of the requested batteries for which the request succeed. failed_power: Part of the requested power that failed. failed_batteries: Subset of the requested batteries for which the request failed. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . succeed_batteries : Set [ int ] = succeed_batteries self . failed_power : int = failed_power self . failed_batteries : Set [ int ] = failed_batteries self . excess_power : int = excess_power frequenz.sdk.actor.power_distributing.result.Result \u00a4 Bases: ABC Base class for the power distributor result. Source code in frequenz/sdk/actor/power_distributing/result.py 12 13 14 15 16 17 18 19 20 21 class Result ( ABC ): \"\"\"Base class for the power distributor result.\"\"\" def __init__ ( self , request : Request ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. \"\"\" self . request : Request = request Functions \u00a4 __init__ ( request ) \u00a4 Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request Source code in frequenz/sdk/actor/power_distributing/result.py 15 16 17 18 19 20 21 def __init__ ( self , request : Request ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. \"\"\" self . request : Request = request frequenz.sdk.actor.power_distributing.result.Success \u00a4 Bases: Result Send if setting power for all batteries succeed. Source code in frequenz/sdk/actor/power_distributing/result.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Success ( Result ): \"\"\"Send if setting power for all batteries succeed.\"\"\" def __init__ ( self , request : Request , succeed_power : int , used_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. used_batteries: Subset of the requested batteries, that were used to realize the request. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . used_batteries : Set [ int ] = used_batteries self . excess_power : int = excess_power Functions \u00a4 __init__ ( request , succeed_power , used_batteries , excess_power ) \u00a4 Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request succeed_power Part of the requested power that was successfully set. TYPE: int used_batteries Subset of the requested batteries, that were used to realize the request. TYPE: Set [ int ] excess_power Part of the requested power that could not be fulfilled, because it was outside available power bounds. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , request : Request , succeed_power : int , used_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. used_batteries: Subset of the requested batteries, that were used to realize the request. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . used_batteries : Set [ int ] = used_batteries self . excess_power : int = excess_power","title":"result"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result","text":"Results from PowerDistributingActor.","title":"result"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error","text":"Bases: Result Error occurred and power was not set. Source code in frequenz/sdk/actor/power_distributing/result.py 86 87 88 89 90 91 92 93 94 95 96 97 class Error ( Result ): \"\"\"Error occurred and power was not set.\"\"\" def __init__ ( self , request : Request , msg : str ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. msg: Error message explaining why error happened. \"\"\" super () . __init__ ( request ) self . msg : str = msg","title":"Error"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error.__init__","text":"Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request msg Error message explaining why error happened. TYPE: str Source code in frequenz/sdk/actor/power_distributing/result.py 89 90 91 92 93 94 95 96 97 def __init__ ( self , request : Request , msg : str ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. msg: Error message explaining why error happened. \"\"\" super () . __init__ ( request ) self . msg : str = msg","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Ignored","text":"Bases: Result Send if request was ignored. Request was ignored because new request for the same subset of batteries was received. Source code in frequenz/sdk/actor/power_distributing/result.py 119 120 121 122 123 124 class Ignored ( Result ): \"\"\"Send if request was ignored. Request was ignored because new request for the same subset of batteries was received. \"\"\"","title":"Ignored"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBound","text":"Bases: Result Send if power was not set because requested power was not within bounds. This message is send only if Request.adjust_power = False. Source code in frequenz/sdk/actor/power_distributing/result.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class OutOfBound ( Result ): \"\"\"Send if power was not set because requested power was not within bounds. This message is send only if Request.adjust_power = False. \"\"\" def __init__ ( self , request : Request , bound : int ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. bound: Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. \"\"\" super () . __init__ ( request ) self . bound : int = bound","title":"OutOfBound"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBound-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBound.__init__","text":"Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request bound Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , request : Request , bound : int ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. bound: Total power bound for the requested batteries. If requested power < 0, then this value is lower bound. Otherwise it is upper bound. \"\"\" super () . __init__ ( request ) self . bound : int = bound","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure","text":"Bases: Result Send if any battery failed and didn't perform the request. Source code in frequenz/sdk/actor/power_distributing/result.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class PartialFailure ( Result ): \"\"\"Send if any battery failed and didn't perform the request.\"\"\" # It is very simple class with only data so it should be ok to disable pylint. # All these results should be dataclass but in python < 3.10 it is risky # to derive after dataclass. def __init__ ( # pylint: disable=too-many-arguments self , request : Request , succeed_power : int , succeed_batteries : Set [ int ], failed_power : int , failed_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. succeed_batteries: Subset of the requested batteries for which the request succeed. failed_power: Part of the requested power that failed. failed_batteries: Subset of the requested batteries for which the request failed. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . succeed_batteries : Set [ int ] = succeed_batteries self . failed_power : int = failed_power self . failed_batteries : Set [ int ] = failed_batteries self . excess_power : int = excess_power","title":"PartialFailure"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.__init__","text":"Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request succeed_power Part of the requested power that was successfully set. TYPE: int succeed_batteries Subset of the requested batteries for which the request succeed. TYPE: Set [ int ] failed_power Part of the requested power that failed. TYPE: int failed_batteries Subset of the requested batteries for which the request failed. TYPE: Set [ int ] excess_power Part of the requested power that could not be fulfilled, because it was outside available power bounds. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( # pylint: disable=too-many-arguments self , request : Request , succeed_power : int , succeed_batteries : Set [ int ], failed_power : int , failed_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. succeed_batteries: Subset of the requested batteries for which the request succeed. failed_power: Part of the requested power that failed. failed_batteries: Subset of the requested batteries for which the request failed. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . succeed_batteries : Set [ int ] = succeed_batteries self . failed_power : int = failed_power self . failed_batteries : Set [ int ] = failed_batteries self . excess_power : int = excess_power","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Result","text":"Bases: ABC Base class for the power distributor result. Source code in frequenz/sdk/actor/power_distributing/result.py 12 13 14 15 16 17 18 19 20 21 class Result ( ABC ): \"\"\"Base class for the power distributor result.\"\"\" def __init__ ( self , request : Request ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. \"\"\" self . request : Request = request","title":"Result"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Result-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Result.__init__","text":"Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request Source code in frequenz/sdk/actor/power_distributing/result.py 15 16 17 18 19 20 21 def __init__ ( self , request : Request ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. \"\"\" self . request : Request = request","title":"__init__()"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success","text":"Bases: Result Send if setting power for all batteries succeed. Source code in frequenz/sdk/actor/power_distributing/result.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Success ( Result ): \"\"\"Send if setting power for all batteries succeed.\"\"\" def __init__ ( self , request : Request , succeed_power : int , used_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. used_batteries: Subset of the requested batteries, that were used to realize the request. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . used_batteries : Set [ int ] = used_batteries self . excess_power : int = excess_power","title":"Success"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success.__init__","text":"Create class instance. PARAMETER DESCRIPTION request The user's request to which this message responds. TYPE: Request succeed_power Part of the requested power that was successfully set. TYPE: int used_batteries Subset of the requested batteries, that were used to realize the request. TYPE: Set [ int ] excess_power Part of the requested power that could not be fulfilled, because it was outside available power bounds. TYPE: int Source code in frequenz/sdk/actor/power_distributing/result.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , request : Request , succeed_power : int , used_batteries : Set [ int ], excess_power : int , ) -> None : \"\"\"Create class instance. Args: request: The user's request to which this message responds. succeed_power: Part of the requested power that was successfully set. used_batteries: Subset of the requested batteries, that were used to realize the request. excess_power: Part of the requested power that could not be fulfilled, because it was outside available power bounds. \"\"\" super () . __init__ ( request ) self . succeed_power : int = succeed_power self . used_batteries : Set [ int ] = used_batteries self . excess_power : int = excess_power","title":"__init__()"},{"location":"reference/frequenz/sdk/config/","text":"frequenz.sdk.config \u00a4 Config interface. Classes \u00a4 frequenz.sdk.config.Config \u00a4 Stores config variables. Config variables are read from a file. Only single file can be read. If new file is read, then previous configs will be forgotten. Source code in frequenz/sdk/config/_config.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 class Config : \"\"\" Stores config variables. Config variables are read from a file. Only single file can be read. If new file is read, then previous configs will be forgotten. \"\"\" def __init__ ( self , conf_vars : Dict [ str , Any ]): \"\"\"Instantiate the config store and read config variables from the file. Args: conf_vars: Dict containing configuration variables \"\"\" self . _conf_store : Dict [ str , Any ] = conf_vars def get ( self , key : str , default : Any = None ) -> Any : \"\"\"Get the value for the specified key. If the key is not in the configs, then return default. Args: key: Key to be searched. default: Value to be returned if the key is not found. Defaults to None. Returns: value in str format or default. \"\"\" return self . _conf_store . get ( key , default ) def get_dict ( self , key_prefix : str , expected_values_type : Optional [ T ] ) -> Dict [ str , Any ]: \"\"\"Get a dictionary based on config key prefixes. For example, if key_prefix is \"my_dict\", then the following config store: { 'some_key': 'some_value', 'my_dict_key1': 'value1', 'my_dict_key2': 'value2', } Will return: { 'key1': 'value1', 'key2': 'value2', } Args: key_prefix: Only get configuration variables starting with this prefix. expected_values_type: If provided, the value will be validated against this type. Returns: A dictionary containing the keys prefixed with `key_prefix` as keys (but with the prefix removed) and the values as values. \"\"\" result : Dict [ str , Any ] = {} for key , value in self . _conf_store . items (): if key . startswith ( key_prefix ): new_key = key [ len ( key_prefix ) :] if expected_values_type is not None : value = self . get_as ( key , expected_values_type ) result [ new_key ] = value return result def get_as ( self , key : str , expected_type : Any ) -> Any : \"\"\"Get and convert the value to specified type. Check if type of the value is as expected. If type is correct, then return converted value. Otherwise Raise ValueError. Type can be: * Any typing module type. * Any pydantic strict types (e.g. pydantic.StrictInt) Args: key: Key to be search expected_type: type for the value Raises: ValueError: If can't convert value to the expected type. KeyError: If specified key is not in config. Returns: Value for the specified key, converted to specified type. Example: For `var1='[1, 2.0, 3.5]'`: * `get_as(\"var1\", List[int])` -> `[1,2,3]` * `get_as(\"var1\", List[float])` -> `[1.0,2.0,3.5]` * `get_as(\"var1\", List[pydantic.StrictInt])` -> [ValueError][] * `get_as(\"var1\", List[pydantic.StrictFloat])` -> [ValueError][] For `var1='[1,2,3]'`: * `get_as(\"var1\", List[pydantic.StrictInt])` -> `[1,2,3]` \"\"\" value = self [ key ] if str is expected_type : return value try : parsed_value : Any = parse_raw_as ( expected_type , value ) except ( ValidationError , ValueError ) as err : raise ValueError ( f \"Could not convert config variable: { key } = ' { value } ' \" f \"to type { str ( expected_type ) } , err:\" + str ( err ) ) from err return parsed_value def __getitem__ ( self , key : str ) -> Any : \"\"\"Get the value for the specified key. If the key is not in the configs, then raise KeyError. Args: key: key to be searched. Raises: KeyError: If key is not in found. Returns: Dictionary if the corresponding value is a subsection in the .toml file or a primitive type it is a simple value. \"\"\" value = self . _conf_store . get ( key , None ) if value is None : raise KeyError ( f \"Unknown config name { key } \" ) return value def __contains__ ( self , key : str ) -> bool : \"\"\"Return whether the specified key is in the storage. Args: key: Config variable name. Returns: True if key is in the storage, otherwise returns False. \"\"\" return key in self . _conf_store Functions \u00a4 __contains__ ( key ) \u00a4 Return whether the specified key is in the storage. PARAMETER DESCRIPTION key Config variable name. TYPE: str RETURNS DESCRIPTION bool True if key is in the storage, otherwise returns False. Source code in frequenz/sdk/config/_config.py 152 153 154 155 156 157 158 159 160 161 def __contains__ ( self , key : str ) -> bool : \"\"\"Return whether the specified key is in the storage. Args: key: Config variable name. Returns: True if key is in the storage, otherwise returns False. \"\"\" return key in self . _conf_store __getitem__ ( key ) \u00a4 Get the value for the specified key. If the key is not in the configs, then raise KeyError. PARAMETER DESCRIPTION key key to be searched. TYPE: str RAISES DESCRIPTION KeyError If key is not in found. RETURNS DESCRIPTION Any Dictionary if the corresponding value is a subsection in the .toml file or a primitive type it is a simple value. Source code in frequenz/sdk/config/_config.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __getitem__ ( self , key : str ) -> Any : \"\"\"Get the value for the specified key. If the key is not in the configs, then raise KeyError. Args: key: key to be searched. Raises: KeyError: If key is not in found. Returns: Dictionary if the corresponding value is a subsection in the .toml file or a primitive type it is a simple value. \"\"\" value = self . _conf_store . get ( key , None ) if value is None : raise KeyError ( f \"Unknown config name { key } \" ) return value __init__ ( conf_vars ) \u00a4 Instantiate the config store and read config variables from the file. PARAMETER DESCRIPTION conf_vars Dict containing configuration variables TYPE: Dict [ str , Any ] Source code in frequenz/sdk/config/_config.py 25 26 27 28 29 30 31 def __init__ ( self , conf_vars : Dict [ str , Any ]): \"\"\"Instantiate the config store and read config variables from the file. Args: conf_vars: Dict containing configuration variables \"\"\" self . _conf_store : Dict [ str , Any ] = conf_vars get ( key , default = None ) \u00a4 Get the value for the specified key. If the key is not in the configs, then return default. PARAMETER DESCRIPTION key Key to be searched. TYPE: str default Value to be returned if the key is not found. Defaults to None. TYPE: Any DEFAULT: None RETURNS DESCRIPTION Any value in str format or default. Source code in frequenz/sdk/config/_config.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def get ( self , key : str , default : Any = None ) -> Any : \"\"\"Get the value for the specified key. If the key is not in the configs, then return default. Args: key: Key to be searched. default: Value to be returned if the key is not found. Defaults to None. Returns: value in str format or default. \"\"\" return self . _conf_store . get ( key , default ) get_as ( key , expected_type ) \u00a4 Get and convert the value to specified type. Check if type of the value is as expected. If type is correct, then return converted value. Otherwise Raise ValueError. Type can be Any typing module type. Any pydantic strict types (e.g. pydantic.StrictInt) PARAMETER DESCRIPTION key Key to be search TYPE: str expected_type type for the value TYPE: Any RAISES DESCRIPTION ValueError If can't convert value to the expected type. KeyError If specified key is not in config. RETURNS DESCRIPTION Any Value for the specified key, converted to specified type. Example For var1='[1, 2.0, 3.5]' : * get_as(\"var1\", List[int]) -> [1,2,3] * get_as(\"var1\", List[float]) -> [1.0,2.0,3.5] * get_as(\"var1\", List[pydantic.StrictInt]) -> ValueError * get_as(\"var1\", List[pydantic.StrictFloat]) -> ValueError For var1='[1,2,3]' : * get_as(\"var1\", List[pydantic.StrictInt]) -> [1,2,3] Source code in frequenz/sdk/config/_config.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def get_as ( self , key : str , expected_type : Any ) -> Any : \"\"\"Get and convert the value to specified type. Check if type of the value is as expected. If type is correct, then return converted value. Otherwise Raise ValueError. Type can be: * Any typing module type. * Any pydantic strict types (e.g. pydantic.StrictInt) Args: key: Key to be search expected_type: type for the value Raises: ValueError: If can't convert value to the expected type. KeyError: If specified key is not in config. Returns: Value for the specified key, converted to specified type. Example: For `var1='[1, 2.0, 3.5]'`: * `get_as(\"var1\", List[int])` -> `[1,2,3]` * `get_as(\"var1\", List[float])` -> `[1.0,2.0,3.5]` * `get_as(\"var1\", List[pydantic.StrictInt])` -> [ValueError][] * `get_as(\"var1\", List[pydantic.StrictFloat])` -> [ValueError][] For `var1='[1,2,3]'`: * `get_as(\"var1\", List[pydantic.StrictInt])` -> `[1,2,3]` \"\"\" value = self [ key ] if str is expected_type : return value try : parsed_value : Any = parse_raw_as ( expected_type , value ) except ( ValidationError , ValueError ) as err : raise ValueError ( f \"Could not convert config variable: { key } = ' { value } ' \" f \"to type { str ( expected_type ) } , err:\" + str ( err ) ) from err return parsed_value get_dict ( key_prefix , expected_values_type ) \u00a4 Get a dictionary based on config key prefixes. For example, if key_prefix is \"my_dict\", then the following config store: { 'some_key': 'some_value', 'my_dict_key1': 'value1', 'my_dict_key2': 'value2', } Will return { 'key1': 'value1', 'key2': 'value2', } PARAMETER DESCRIPTION key_prefix Only get configuration variables starting with this prefix. TYPE: str expected_values_type If provided, the value will be validated against this type. TYPE: Optional [ T ] RETURNS DESCRIPTION Dict [ str , Any ] A dictionary containing the keys prefixed with key_prefix as keys (but with the prefix removed) and the values as values. Source code in frequenz/sdk/config/_config.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def get_dict ( self , key_prefix : str , expected_values_type : Optional [ T ] ) -> Dict [ str , Any ]: \"\"\"Get a dictionary based on config key prefixes. For example, if key_prefix is \"my_dict\", then the following config store: { 'some_key': 'some_value', 'my_dict_key1': 'value1', 'my_dict_key2': 'value2', } Will return: { 'key1': 'value1', 'key2': 'value2', } Args: key_prefix: Only get configuration variables starting with this prefix. expected_values_type: If provided, the value will be validated against this type. Returns: A dictionary containing the keys prefixed with `key_prefix` as keys (but with the prefix removed) and the values as values. \"\"\" result : Dict [ str , Any ] = {} for key , value in self . _conf_store . items (): if key . startswith ( key_prefix ): new_key = key [ len ( key_prefix ) :] if expected_values_type is not None : value = self . get_as ( key , expected_values_type ) result [ new_key ] = value return result","title":"config"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config","text":"Config interface.","title":"config"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config","text":"Stores config variables. Config variables are read from a file. Only single file can be read. If new file is read, then previous configs will be forgotten. Source code in frequenz/sdk/config/_config.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 class Config : \"\"\" Stores config variables. Config variables are read from a file. Only single file can be read. If new file is read, then previous configs will be forgotten. \"\"\" def __init__ ( self , conf_vars : Dict [ str , Any ]): \"\"\"Instantiate the config store and read config variables from the file. Args: conf_vars: Dict containing configuration variables \"\"\" self . _conf_store : Dict [ str , Any ] = conf_vars def get ( self , key : str , default : Any = None ) -> Any : \"\"\"Get the value for the specified key. If the key is not in the configs, then return default. Args: key: Key to be searched. default: Value to be returned if the key is not found. Defaults to None. Returns: value in str format or default. \"\"\" return self . _conf_store . get ( key , default ) def get_dict ( self , key_prefix : str , expected_values_type : Optional [ T ] ) -> Dict [ str , Any ]: \"\"\"Get a dictionary based on config key prefixes. For example, if key_prefix is \"my_dict\", then the following config store: { 'some_key': 'some_value', 'my_dict_key1': 'value1', 'my_dict_key2': 'value2', } Will return: { 'key1': 'value1', 'key2': 'value2', } Args: key_prefix: Only get configuration variables starting with this prefix. expected_values_type: If provided, the value will be validated against this type. Returns: A dictionary containing the keys prefixed with `key_prefix` as keys (but with the prefix removed) and the values as values. \"\"\" result : Dict [ str , Any ] = {} for key , value in self . _conf_store . items (): if key . startswith ( key_prefix ): new_key = key [ len ( key_prefix ) :] if expected_values_type is not None : value = self . get_as ( key , expected_values_type ) result [ new_key ] = value return result def get_as ( self , key : str , expected_type : Any ) -> Any : \"\"\"Get and convert the value to specified type. Check if type of the value is as expected. If type is correct, then return converted value. Otherwise Raise ValueError. Type can be: * Any typing module type. * Any pydantic strict types (e.g. pydantic.StrictInt) Args: key: Key to be search expected_type: type for the value Raises: ValueError: If can't convert value to the expected type. KeyError: If specified key is not in config. Returns: Value for the specified key, converted to specified type. Example: For `var1='[1, 2.0, 3.5]'`: * `get_as(\"var1\", List[int])` -> `[1,2,3]` * `get_as(\"var1\", List[float])` -> `[1.0,2.0,3.5]` * `get_as(\"var1\", List[pydantic.StrictInt])` -> [ValueError][] * `get_as(\"var1\", List[pydantic.StrictFloat])` -> [ValueError][] For `var1='[1,2,3]'`: * `get_as(\"var1\", List[pydantic.StrictInt])` -> `[1,2,3]` \"\"\" value = self [ key ] if str is expected_type : return value try : parsed_value : Any = parse_raw_as ( expected_type , value ) except ( ValidationError , ValueError ) as err : raise ValueError ( f \"Could not convert config variable: { key } = ' { value } ' \" f \"to type { str ( expected_type ) } , err:\" + str ( err ) ) from err return parsed_value def __getitem__ ( self , key : str ) -> Any : \"\"\"Get the value for the specified key. If the key is not in the configs, then raise KeyError. Args: key: key to be searched. Raises: KeyError: If key is not in found. Returns: Dictionary if the corresponding value is a subsection in the .toml file or a primitive type it is a simple value. \"\"\" value = self . _conf_store . get ( key , None ) if value is None : raise KeyError ( f \"Unknown config name { key } \" ) return value def __contains__ ( self , key : str ) -> bool : \"\"\"Return whether the specified key is in the storage. Args: key: Config variable name. Returns: True if key is in the storage, otherwise returns False. \"\"\" return key in self . _conf_store","title":"Config"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.__contains__","text":"Return whether the specified key is in the storage. PARAMETER DESCRIPTION key Config variable name. TYPE: str RETURNS DESCRIPTION bool True if key is in the storage, otherwise returns False. Source code in frequenz/sdk/config/_config.py 152 153 154 155 156 157 158 159 160 161 def __contains__ ( self , key : str ) -> bool : \"\"\"Return whether the specified key is in the storage. Args: key: Config variable name. Returns: True if key is in the storage, otherwise returns False. \"\"\" return key in self . _conf_store","title":"__contains__()"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.__getitem__","text":"Get the value for the specified key. If the key is not in the configs, then raise KeyError. PARAMETER DESCRIPTION key key to be searched. TYPE: str RAISES DESCRIPTION KeyError If key is not in found. RETURNS DESCRIPTION Any Dictionary if the corresponding value is a subsection in the .toml file or a primitive type it is a simple value. Source code in frequenz/sdk/config/_config.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __getitem__ ( self , key : str ) -> Any : \"\"\"Get the value for the specified key. If the key is not in the configs, then raise KeyError. Args: key: key to be searched. Raises: KeyError: If key is not in found. Returns: Dictionary if the corresponding value is a subsection in the .toml file or a primitive type it is a simple value. \"\"\" value = self . _conf_store . get ( key , None ) if value is None : raise KeyError ( f \"Unknown config name { key } \" ) return value","title":"__getitem__()"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.__init__","text":"Instantiate the config store and read config variables from the file. PARAMETER DESCRIPTION conf_vars Dict containing configuration variables TYPE: Dict [ str , Any ] Source code in frequenz/sdk/config/_config.py 25 26 27 28 29 30 31 def __init__ ( self , conf_vars : Dict [ str , Any ]): \"\"\"Instantiate the config store and read config variables from the file. Args: conf_vars: Dict containing configuration variables \"\"\" self . _conf_store : Dict [ str , Any ] = conf_vars","title":"__init__()"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.get","text":"Get the value for the specified key. If the key is not in the configs, then return default. PARAMETER DESCRIPTION key Key to be searched. TYPE: str default Value to be returned if the key is not found. Defaults to None. TYPE: Any DEFAULT: None RETURNS DESCRIPTION Any value in str format or default. Source code in frequenz/sdk/config/_config.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def get ( self , key : str , default : Any = None ) -> Any : \"\"\"Get the value for the specified key. If the key is not in the configs, then return default. Args: key: Key to be searched. default: Value to be returned if the key is not found. Defaults to None. Returns: value in str format or default. \"\"\" return self . _conf_store . get ( key , default )","title":"get()"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.get_as","text":"Get and convert the value to specified type. Check if type of the value is as expected. If type is correct, then return converted value. Otherwise Raise ValueError. Type can be Any typing module type. Any pydantic strict types (e.g. pydantic.StrictInt) PARAMETER DESCRIPTION key Key to be search TYPE: str expected_type type for the value TYPE: Any RAISES DESCRIPTION ValueError If can't convert value to the expected type. KeyError If specified key is not in config. RETURNS DESCRIPTION Any Value for the specified key, converted to specified type. Example For var1='[1, 2.0, 3.5]' : * get_as(\"var1\", List[int]) -> [1,2,3] * get_as(\"var1\", List[float]) -> [1.0,2.0,3.5] * get_as(\"var1\", List[pydantic.StrictInt]) -> ValueError * get_as(\"var1\", List[pydantic.StrictFloat]) -> ValueError For var1='[1,2,3]' : * get_as(\"var1\", List[pydantic.StrictInt]) -> [1,2,3] Source code in frequenz/sdk/config/_config.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def get_as ( self , key : str , expected_type : Any ) -> Any : \"\"\"Get and convert the value to specified type. Check if type of the value is as expected. If type is correct, then return converted value. Otherwise Raise ValueError. Type can be: * Any typing module type. * Any pydantic strict types (e.g. pydantic.StrictInt) Args: key: Key to be search expected_type: type for the value Raises: ValueError: If can't convert value to the expected type. KeyError: If specified key is not in config. Returns: Value for the specified key, converted to specified type. Example: For `var1='[1, 2.0, 3.5]'`: * `get_as(\"var1\", List[int])` -> `[1,2,3]` * `get_as(\"var1\", List[float])` -> `[1.0,2.0,3.5]` * `get_as(\"var1\", List[pydantic.StrictInt])` -> [ValueError][] * `get_as(\"var1\", List[pydantic.StrictFloat])` -> [ValueError][] For `var1='[1,2,3]'`: * `get_as(\"var1\", List[pydantic.StrictInt])` -> `[1,2,3]` \"\"\" value = self [ key ] if str is expected_type : return value try : parsed_value : Any = parse_raw_as ( expected_type , value ) except ( ValidationError , ValueError ) as err : raise ValueError ( f \"Could not convert config variable: { key } = ' { value } ' \" f \"to type { str ( expected_type ) } , err:\" + str ( err ) ) from err return parsed_value","title":"get_as()"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.get_dict","text":"Get a dictionary based on config key prefixes. For example, if key_prefix is \"my_dict\", then the following config store: { 'some_key': 'some_value', 'my_dict_key1': 'value1', 'my_dict_key2': 'value2', } Will return { 'key1': 'value1', 'key2': 'value2', } PARAMETER DESCRIPTION key_prefix Only get configuration variables starting with this prefix. TYPE: str expected_values_type If provided, the value will be validated against this type. TYPE: Optional [ T ] RETURNS DESCRIPTION Dict [ str , Any ] A dictionary containing the keys prefixed with key_prefix as keys (but with the prefix removed) and the values as values. Source code in frequenz/sdk/config/_config.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def get_dict ( self , key_prefix : str , expected_values_type : Optional [ T ] ) -> Dict [ str , Any ]: \"\"\"Get a dictionary based on config key prefixes. For example, if key_prefix is \"my_dict\", then the following config store: { 'some_key': 'some_value', 'my_dict_key1': 'value1', 'my_dict_key2': 'value2', } Will return: { 'key1': 'value1', 'key2': 'value2', } Args: key_prefix: Only get configuration variables starting with this prefix. expected_values_type: If provided, the value will be validated against this type. Returns: A dictionary containing the keys prefixed with `key_prefix` as keys (but with the prefix removed) and the values as values. \"\"\" result : Dict [ str , Any ] = {} for key , value in self . _conf_store . items (): if key . startswith ( key_prefix ): new_key = key [ len ( key_prefix ) :] if expected_values_type is not None : value = self . get_as ( key , expected_values_type ) result [ new_key ] = value return result","title":"get_dict()"},{"location":"reference/frequenz/sdk/microgrid/","text":"frequenz.sdk.microgrid \u00a4 Microgrid monitoring and control system. This package provides a complete suite of data structures and functionality for monitoring and adjusting the state of a microgrid. Classes \u00a4 frequenz.sdk.microgrid.ComponentGraph \u00a4 Bases: ABC Interface for component graph implementations. Source code in frequenz/sdk/microgrid/_graph.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class ComponentGraph ( ABC ): \"\"\"Interface for component graph implementations.\"\"\" @abstractmethod def components ( self , component_id : Optional [ Set [ int ]] = None , component_category : Optional [ Set [ ComponentCategory ]] = None , ) -> Set [ Component ]: \"\"\"Fetch the components of the microgrid. Args: component_id: filter out any components not matching one of the provided IDs component_category: filter out any components not matching one of the provided types Returns: Set of the components currently connected to the microgrid, filtered by the provided `component_id` and `component_category` values. \"\"\" @abstractmethod def connections ( self , start : Optional [ Set [ int ]] = None , end : Optional [ Set [ int ]] = None , ) -> Set [ Connection ]: \"\"\"Fetch the connections between microgrid components. Args: start: filter out any connections whose `start` does not match one of these component IDs end: filter out any connections whose `end` does not match one of these component IDs Returns: Set of the connections between components in the microgrid, filtered by the provided `start`/`end` choices. \"\"\" @abstractmethod def predecessors ( self , component_id : int ) -> Set [ Component ]: \"\"\"Fetch the graph predecessors of the specified component. Args: component_id: numerical ID of the component whose predecessors should be fetched Returns: Set of IDs of the components that are predecessors of `component_id`, i.e. for which there is a connection from each of these components to `component_id`. Raises: KeyError: if the specified `component_id` is not in the graph \"\"\" @abstractmethod def successors ( self , component_id : int ) -> Set [ Component ]: \"\"\"Fetch the graph successors of the specified component. Args: component_id: numerical ID of the component whose successors should be fetched Returns: Set of IDs of the components that are successors of `component_id`, i.e. for which there is a connection from `component_id` to each of these components. Raises: KeyError: if the specified `component_id` is not in the graph \"\"\" Functions \u00a4 components ( component_id = None , component_category = None ) abstractmethod \u00a4 Fetch the components of the microgrid. PARAMETER DESCRIPTION component_id filter out any components not matching one of the provided IDs TYPE: Optional [ Set [ int ]] DEFAULT: None component_category filter out any components not matching one of the provided types TYPE: Optional [ Set [ ComponentCategory ]] DEFAULT: None RETURNS DESCRIPTION Set [ Component ] Set of the components currently connected to the microgrid, filtered by the provided component_id and component_category values. Source code in frequenz/sdk/microgrid/_graph.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @abstractmethod def components ( self , component_id : Optional [ Set [ int ]] = None , component_category : Optional [ Set [ ComponentCategory ]] = None , ) -> Set [ Component ]: \"\"\"Fetch the components of the microgrid. Args: component_id: filter out any components not matching one of the provided IDs component_category: filter out any components not matching one of the provided types Returns: Set of the components currently connected to the microgrid, filtered by the provided `component_id` and `component_category` values. \"\"\" connections ( start = None , end = None ) abstractmethod \u00a4 Fetch the connections between microgrid components. PARAMETER DESCRIPTION start filter out any connections whose start does not match one of these component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None end filter out any connections whose end does not match one of these component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None RETURNS DESCRIPTION Set [ Connection ] Set of the connections between components in the microgrid, filtered by the provided start / end choices. Source code in frequenz/sdk/microgrid/_graph.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @abstractmethod def connections ( self , start : Optional [ Set [ int ]] = None , end : Optional [ Set [ int ]] = None , ) -> Set [ Connection ]: \"\"\"Fetch the connections between microgrid components. Args: start: filter out any connections whose `start` does not match one of these component IDs end: filter out any connections whose `end` does not match one of these component IDs Returns: Set of the connections between components in the microgrid, filtered by the provided `start`/`end` choices. \"\"\" predecessors ( component_id ) abstractmethod \u00a4 Fetch the graph predecessors of the specified component. PARAMETER DESCRIPTION component_id numerical ID of the component whose predecessors should be fetched TYPE: int RETURNS DESCRIPTION Set [ Component ] Set of IDs of the components that are predecessors of component_id , i.e. for which there is a connection from each of these components to component_id . RAISES DESCRIPTION KeyError if the specified component_id is not in the graph Source code in frequenz/sdk/microgrid/_graph.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @abstractmethod def predecessors ( self , component_id : int ) -> Set [ Component ]: \"\"\"Fetch the graph predecessors of the specified component. Args: component_id: numerical ID of the component whose predecessors should be fetched Returns: Set of IDs of the components that are predecessors of `component_id`, i.e. for which there is a connection from each of these components to `component_id`. Raises: KeyError: if the specified `component_id` is not in the graph \"\"\" successors ( component_id ) abstractmethod \u00a4 Fetch the graph successors of the specified component. PARAMETER DESCRIPTION component_id numerical ID of the component whose successors should be fetched TYPE: int RETURNS DESCRIPTION Set [ Component ] Set of IDs of the components that are successors of component_id , i.e. for which there is a connection from component_id to each of these components. RAISES DESCRIPTION KeyError if the specified component_id is not in the graph Source code in frequenz/sdk/microgrid/_graph.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @abstractmethod def successors ( self , component_id : int ) -> Set [ Component ]: \"\"\"Fetch the graph successors of the specified component. Args: component_id: numerical ID of the component whose successors should be fetched Returns: Set of IDs of the components that are successors of `component_id`, i.e. for which there is a connection from `component_id` to each of these components. Raises: KeyError: if the specified `component_id` is not in the graph \"\"\" frequenz.sdk.microgrid.ConnectionManager \u00a4 Bases: ABC Creates and stores core features. Source code in frequenz/sdk/microgrid/_microgrid.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class ConnectionManager ( ABC ): \"\"\"Creates and stores core features.\"\"\" def __init__ ( self , host : str , port : int ) -> None : \"\"\"Create object instance. Args: host: server host port: server port \"\"\" super () . __init__ () self . _host : str = host self . _port : int = port @property def host ( self ) -> str : \"\"\"Get host of the currently connected server. Returns: host \"\"\" return self . _host @property def port ( self ) -> int : \"\"\"Get port of the currently connected server. Returns: port \"\"\" return self . _port @property @abstractmethod def api_client ( self ) -> MicrogridApiClient : \"\"\"Get MicrogridApiClient. Returns: api client \"\"\" @property @abstractmethod def component_graph ( self ) -> ComponentGraph : \"\"\"Get component graph. Returns: component graph \"\"\" async def _update_api ( self , host : str , port : int ) -> None : self . _host = host self . _port = port @abstractmethod async def _initialize ( self ) -> None : \"\"\"Initialize the object. This function should be called only once.\"\"\" Attributes \u00a4 api_client : MicrogridApiClient property abstractmethod \u00a4 Get MicrogridApiClient. RETURNS DESCRIPTION MicrogridApiClient api client component_graph : ComponentGraph property abstractmethod \u00a4 Get component graph. RETURNS DESCRIPTION ComponentGraph component graph host : str property \u00a4 Get host of the currently connected server. RETURNS DESCRIPTION str host port : int property \u00a4 Get port of the currently connected server. RETURNS DESCRIPTION int port Functions \u00a4 __init__ ( host , port ) \u00a4 Create object instance. PARAMETER DESCRIPTION host server host TYPE: str port server port TYPE: int Source code in frequenz/sdk/microgrid/_microgrid.py 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , host : str , port : int ) -> None : \"\"\"Create object instance. Args: host: server host port: server port \"\"\" super () . __init__ () self . _host : str = host self . _port : int = port Functions \u00a4 frequenz . sdk . microgrid . get () \u00a4 Get the MicrogridApi instance created by initialize(). This function should be only called after initialize(). RAISES DESCRIPTION RuntimeError Raised when: * If initialize() method was not called before this call. * If initialize() methods was called but was not awaited and instance was not created yet. RETURNS DESCRIPTION ConnectionManager MicrogridApi instance. Source code in frequenz/sdk/microgrid/_microgrid.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def get () -> ConnectionManager : \"\"\"Get the MicrogridApi instance created by initialize(). This function should be only called after initialize(). Raises: RuntimeError: Raised when: * If `initialize()` method was not called before this call. * If `initialize()` methods was called but was not awaited and instance was not created yet. Returns: MicrogridApi instance. \"\"\" if _MICROGRID is None : raise RuntimeError ( \"MicrogridApi is not initialized (or the initialization didn't \" \"finished yet). Call and/or await for initialize() to finish.\" ) return _MICROGRID frequenz . sdk . microgrid . initialize ( host , port ) async \u00a4 Initialize the MicrogridApi. This function should be called only once. PARAMETER DESCRIPTION host Microgrid host TYPE: str port Microgrid port TYPE: int RAISES DESCRIPTION AssertionError If method was called more then once. Source code in frequenz/sdk/microgrid/_microgrid.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 async def initialize ( host : str , port : int ) -> None : \"\"\"Initialize the MicrogridApi. This function should be called only once. Args: host: Microgrid host port: Microgrid port Raises: AssertionError: If method was called more then once. \"\"\" # From Doc: pylint just try to discourage this usage. # That doesn't mean you cannot use it. global _MICROGRID # pylint: disable=global-statement if _MICROGRID is not None : raise AssertionError ( \"MicrogridApi was already initialized.\" ) microgrid_api = _InsecureConnectionManager ( host , port ) await microgrid_api . _initialize () # pylint: disable=protected-access # Check again that _MICROGRID_API is None in case somebody had the great idea of # calling initialize() twice and in parallel. if _MICROGRID is not None : raise AssertionError ( \"MicrogridApi was already initialized.\" ) _MICROGRID = microgrid_api","title":"microgrid"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid","text":"Microgrid monitoring and control system. This package provides a complete suite of data structures and functionality for monitoring and adjusting the state of a microgrid.","title":"microgrid"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph","text":"Bases: ABC Interface for component graph implementations. Source code in frequenz/sdk/microgrid/_graph.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class ComponentGraph ( ABC ): \"\"\"Interface for component graph implementations.\"\"\" @abstractmethod def components ( self , component_id : Optional [ Set [ int ]] = None , component_category : Optional [ Set [ ComponentCategory ]] = None , ) -> Set [ Component ]: \"\"\"Fetch the components of the microgrid. Args: component_id: filter out any components not matching one of the provided IDs component_category: filter out any components not matching one of the provided types Returns: Set of the components currently connected to the microgrid, filtered by the provided `component_id` and `component_category` values. \"\"\" @abstractmethod def connections ( self , start : Optional [ Set [ int ]] = None , end : Optional [ Set [ int ]] = None , ) -> Set [ Connection ]: \"\"\"Fetch the connections between microgrid components. Args: start: filter out any connections whose `start` does not match one of these component IDs end: filter out any connections whose `end` does not match one of these component IDs Returns: Set of the connections between components in the microgrid, filtered by the provided `start`/`end` choices. \"\"\" @abstractmethod def predecessors ( self , component_id : int ) -> Set [ Component ]: \"\"\"Fetch the graph predecessors of the specified component. Args: component_id: numerical ID of the component whose predecessors should be fetched Returns: Set of IDs of the components that are predecessors of `component_id`, i.e. for which there is a connection from each of these components to `component_id`. Raises: KeyError: if the specified `component_id` is not in the graph \"\"\" @abstractmethod def successors ( self , component_id : int ) -> Set [ Component ]: \"\"\"Fetch the graph successors of the specified component. Args: component_id: numerical ID of the component whose successors should be fetched Returns: Set of IDs of the components that are successors of `component_id`, i.e. for which there is a connection from `component_id` to each of these components. Raises: KeyError: if the specified `component_id` is not in the graph \"\"\"","title":"ComponentGraph"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.components","text":"Fetch the components of the microgrid. PARAMETER DESCRIPTION component_id filter out any components not matching one of the provided IDs TYPE: Optional [ Set [ int ]] DEFAULT: None component_category filter out any components not matching one of the provided types TYPE: Optional [ Set [ ComponentCategory ]] DEFAULT: None RETURNS DESCRIPTION Set [ Component ] Set of the components currently connected to the microgrid, filtered by the provided component_id and component_category values. Source code in frequenz/sdk/microgrid/_graph.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @abstractmethod def components ( self , component_id : Optional [ Set [ int ]] = None , component_category : Optional [ Set [ ComponentCategory ]] = None , ) -> Set [ Component ]: \"\"\"Fetch the components of the microgrid. Args: component_id: filter out any components not matching one of the provided IDs component_category: filter out any components not matching one of the provided types Returns: Set of the components currently connected to the microgrid, filtered by the provided `component_id` and `component_category` values. \"\"\"","title":"components()"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.connections","text":"Fetch the connections between microgrid components. PARAMETER DESCRIPTION start filter out any connections whose start does not match one of these component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None end filter out any connections whose end does not match one of these component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None RETURNS DESCRIPTION Set [ Connection ] Set of the connections between components in the microgrid, filtered by the provided start / end choices. Source code in frequenz/sdk/microgrid/_graph.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @abstractmethod def connections ( self , start : Optional [ Set [ int ]] = None , end : Optional [ Set [ int ]] = None , ) -> Set [ Connection ]: \"\"\"Fetch the connections between microgrid components. Args: start: filter out any connections whose `start` does not match one of these component IDs end: filter out any connections whose `end` does not match one of these component IDs Returns: Set of the connections between components in the microgrid, filtered by the provided `start`/`end` choices. \"\"\"","title":"connections()"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.predecessors","text":"Fetch the graph predecessors of the specified component. PARAMETER DESCRIPTION component_id numerical ID of the component whose predecessors should be fetched TYPE: int RETURNS DESCRIPTION Set [ Component ] Set of IDs of the components that are predecessors of component_id , i.e. for which there is a connection from each of these components to component_id . RAISES DESCRIPTION KeyError if the specified component_id is not in the graph Source code in frequenz/sdk/microgrid/_graph.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @abstractmethod def predecessors ( self , component_id : int ) -> Set [ Component ]: \"\"\"Fetch the graph predecessors of the specified component. Args: component_id: numerical ID of the component whose predecessors should be fetched Returns: Set of IDs of the components that are predecessors of `component_id`, i.e. for which there is a connection from each of these components to `component_id`. Raises: KeyError: if the specified `component_id` is not in the graph \"\"\"","title":"predecessors()"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.successors","text":"Fetch the graph successors of the specified component. PARAMETER DESCRIPTION component_id numerical ID of the component whose successors should be fetched TYPE: int RETURNS DESCRIPTION Set [ Component ] Set of IDs of the components that are successors of component_id , i.e. for which there is a connection from component_id to each of these components. RAISES DESCRIPTION KeyError if the specified component_id is not in the graph Source code in frequenz/sdk/microgrid/_graph.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @abstractmethod def successors ( self , component_id : int ) -> Set [ Component ]: \"\"\"Fetch the graph successors of the specified component. Args: component_id: numerical ID of the component whose successors should be fetched Returns: Set of IDs of the components that are successors of `component_id`, i.e. for which there is a connection from `component_id` to each of these components. Raises: KeyError: if the specified `component_id` is not in the graph \"\"\"","title":"successors()"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ConnectionManager","text":"Bases: ABC Creates and stores core features. Source code in frequenz/sdk/microgrid/_microgrid.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class ConnectionManager ( ABC ): \"\"\"Creates and stores core features.\"\"\" def __init__ ( self , host : str , port : int ) -> None : \"\"\"Create object instance. Args: host: server host port: server port \"\"\" super () . __init__ () self . _host : str = host self . _port : int = port @property def host ( self ) -> str : \"\"\"Get host of the currently connected server. Returns: host \"\"\" return self . _host @property def port ( self ) -> int : \"\"\"Get port of the currently connected server. Returns: port \"\"\" return self . _port @property @abstractmethod def api_client ( self ) -> MicrogridApiClient : \"\"\"Get MicrogridApiClient. Returns: api client \"\"\" @property @abstractmethod def component_graph ( self ) -> ComponentGraph : \"\"\"Get component graph. Returns: component graph \"\"\" async def _update_api ( self , host : str , port : int ) -> None : self . _host = host self . _port = port @abstractmethod async def _initialize ( self ) -> None : \"\"\"Initialize the object. This function should be called only once.\"\"\"","title":"ConnectionManager"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ConnectionManager-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._microgrid.ConnectionManager.api_client","text":"Get MicrogridApiClient. RETURNS DESCRIPTION MicrogridApiClient api client","title":"api_client"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._microgrid.ConnectionManager.component_graph","text":"Get component graph. RETURNS DESCRIPTION ComponentGraph component graph","title":"component_graph"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._microgrid.ConnectionManager.host","text":"Get host of the currently connected server. RETURNS DESCRIPTION str host","title":"host"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._microgrid.ConnectionManager.port","text":"Get port of the currently connected server. RETURNS DESCRIPTION int port","title":"port"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ConnectionManager-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._microgrid.ConnectionManager.__init__","text":"Create object instance. PARAMETER DESCRIPTION host server host TYPE: str port server port TYPE: int Source code in frequenz/sdk/microgrid/_microgrid.py 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , host : str , port : int ) -> None : \"\"\"Create object instance. Args: host: server host port: server port \"\"\" super () . __init__ () self . _host : str = host self . _port : int = port","title":"__init__()"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.get","text":"Get the MicrogridApi instance created by initialize(). This function should be only called after initialize(). RAISES DESCRIPTION RuntimeError Raised when: * If initialize() method was not called before this call. * If initialize() methods was called but was not awaited and instance was not created yet. RETURNS DESCRIPTION ConnectionManager MicrogridApi instance. Source code in frequenz/sdk/microgrid/_microgrid.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def get () -> ConnectionManager : \"\"\"Get the MicrogridApi instance created by initialize(). This function should be only called after initialize(). Raises: RuntimeError: Raised when: * If `initialize()` method was not called before this call. * If `initialize()` methods was called but was not awaited and instance was not created yet. Returns: MicrogridApi instance. \"\"\" if _MICROGRID is None : raise RuntimeError ( \"MicrogridApi is not initialized (or the initialization didn't \" \"finished yet). Call and/or await for initialize() to finish.\" ) return _MICROGRID","title":"get()"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.initialize","text":"Initialize the MicrogridApi. This function should be called only once. PARAMETER DESCRIPTION host Microgrid host TYPE: str port Microgrid port TYPE: int RAISES DESCRIPTION AssertionError If method was called more then once. Source code in frequenz/sdk/microgrid/_microgrid.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 async def initialize ( host : str , port : int ) -> None : \"\"\"Initialize the MicrogridApi. This function should be called only once. Args: host: Microgrid host port: Microgrid port Raises: AssertionError: If method was called more then once. \"\"\" # From Doc: pylint just try to discourage this usage. # That doesn't mean you cannot use it. global _MICROGRID # pylint: disable=global-statement if _MICROGRID is not None : raise AssertionError ( \"MicrogridApi was already initialized.\" ) microgrid_api = _InsecureConnectionManager ( host , port ) await microgrid_api . _initialize () # pylint: disable=protected-access # Check again that _MICROGRID_API is None in case somebody had the great idea of # calling initialize() twice and in parallel. if _MICROGRID is not None : raise AssertionError ( \"MicrogridApi was already initialized.\" ) _MICROGRID = microgrid_api","title":"initialize()"},{"location":"reference/frequenz/sdk/microgrid/client/","text":"frequenz.sdk.microgrid.client \u00a4 Microgrid API client. This package provides an easy way to connect to the microgrid API. Classes \u00a4 frequenz.sdk.microgrid.client.Connection \u00a4 Bases: NamedTuple Metadata for a connection between microgrid components. Source code in frequenz/sdk/microgrid/client/_connection.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Connection ( NamedTuple ): \"\"\"Metadata for a connection between microgrid components.\"\"\" start : int end : int def is_valid ( self ) -> bool : \"\"\"Check if this instance contains valid data. Returns: `True` if `start >= 0`, `end > 0`, and `start != end`, `False` otherwise. \"\"\" return self . start >= 0 and self . end > 0 and self . start != self . end Functions \u00a4 is_valid () \u00a4 Check if this instance contains valid data. RETURNS DESCRIPTION bool True if start >= 0 , end > 0 , and start != end , False otherwise. Source code in frequenz/sdk/microgrid/client/_connection.py 15 16 17 18 19 20 21 22 def is_valid ( self ) -> bool : \"\"\"Check if this instance contains valid data. Returns: `True` if `start >= 0`, `end > 0`, and `start != end`, `False` otherwise. \"\"\" return self . start >= 0 and self . end > 0 and self . start != self . end frequenz.sdk.microgrid.client.ExponentialBackoff \u00a4 Bases: RetryStrategy Provides methods for calculating the exponential interval between retries. Source code in frequenz/sdk/microgrid/client/_retry.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 class ExponentialBackoff ( RetryStrategy ): \"\"\"Provides methods for calculating the exponential interval between retries.\"\"\" DEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL DEFAULT_MAX_INTERVAL = 60.0 DEFAULT_MULTIPLIER = 2.0 # pylint: disable=too-many-arguments def __init__ ( self , initial_interval : float = DEFAULT_INTERVAL , max_interval : float = DEFAULT_MAX_INTERVAL , multiplier : float = DEFAULT_MULTIPLIER , jitter : float = DEFAULT_RETRY_JITTER , limit : Optional [ int ] = None , ) -> None : \"\"\"Create a `ExponentialBackoff` instance. Args: initial_interval: time to wait for before the first retry, in seconds. max_interval: maximum interval, in seconds. multiplier: exponential increment for interval. jitter: a jitter to add to the retry interval. limit: max number of retries before giving up. `None` means no limit, and `0` means no retry. \"\"\" self . _initial = initial_interval self . _max = max_interval self . _multiplier = multiplier self . _jitter = jitter self . _limit = limit self . _count = 0 def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\" if self . _limit is not None and self . _count >= self . _limit : return None self . _count += 1 exp_backoff_interval = self . _initial * self . _multiplier ** ( self . _count - 1 ) return min ( exp_backoff_interval + random . uniform ( 0.0 , self . _jitter ), self . _max ) Functions \u00a4 __init__ ( initial_interval = DEFAULT_INTERVAL , max_interval = DEFAULT_MAX_INTERVAL , multiplier = DEFAULT_MULTIPLIER , jitter = DEFAULT_RETRY_JITTER , limit = None ) \u00a4 Create a ExponentialBackoff instance. PARAMETER DESCRIPTION initial_interval time to wait for before the first retry, in seconds. TYPE: float DEFAULT: DEFAULT_INTERVAL max_interval maximum interval, in seconds. TYPE: float DEFAULT: DEFAULT_MAX_INTERVAL multiplier exponential increment for interval. TYPE: float DEFAULT: DEFAULT_MULTIPLIER jitter a jitter to add to the retry interval. TYPE: float DEFAULT: DEFAULT_RETRY_JITTER limit max number of retries before giving up. None means no limit, and 0 means no retry. TYPE: Optional [ int ] DEFAULT: None Source code in frequenz/sdk/microgrid/client/_retry.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def __init__ ( self , initial_interval : float = DEFAULT_INTERVAL , max_interval : float = DEFAULT_MAX_INTERVAL , multiplier : float = DEFAULT_MULTIPLIER , jitter : float = DEFAULT_RETRY_JITTER , limit : Optional [ int ] = None , ) -> None : \"\"\"Create a `ExponentialBackoff` instance. Args: initial_interval: time to wait for before the first retry, in seconds. max_interval: maximum interval, in seconds. multiplier: exponential increment for interval. jitter: a jitter to add to the retry interval. limit: max number of retries before giving up. `None` means no limit, and `0` means no retry. \"\"\" self . _initial = initial_interval self . _max = max_interval self . _multiplier = multiplier self . _jitter = jitter self . _limit = limit self . _count = 0 next_interval () \u00a4 Return the time to wait before the next retry. Returns None if the retry limit has been reached, and no more retries are possible. RETURNS DESCRIPTION Optional [ float ] Time until next retry when below retry limit, and None otherwise. Source code in frequenz/sdk/microgrid/client/_retry.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\" if self . _limit is not None and self . _count >= self . _limit : return None self . _count += 1 exp_backoff_interval = self . _initial * self . _multiplier ** ( self . _count - 1 ) return min ( exp_backoff_interval + random . uniform ( 0.0 , self . _jitter ), self . _max ) frequenz.sdk.microgrid.client.LinearBackoff \u00a4 Bases: RetryStrategy Provides methods for calculating the interval between retries. Source code in frequenz/sdk/microgrid/client/_retry.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class LinearBackoff ( RetryStrategy ): \"\"\"Provides methods for calculating the interval between retries.\"\"\" def __init__ ( self , interval : float = DEFAULT_RETRY_INTERVAL , jitter : float = DEFAULT_RETRY_JITTER , limit : Optional [ int ] = None , ) -> None : \"\"\"Create a `LinearBackoff` instance. Args: interval: time to wait for before the next retry, in seconds. jitter: a jitter to add to the retry interval. limit: max number of retries before giving up. `None` means no limit, and `0` means no retry. \"\"\" self . _interval = interval self . _jitter = jitter self . _limit = limit self . _count = 0 def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\" if self . _limit is not None and self . _count >= self . _limit : return None self . _count += 1 return self . _interval + random . uniform ( 0.0 , self . _jitter ) Functions \u00a4 __init__ ( interval = DEFAULT_RETRY_INTERVAL , jitter = DEFAULT_RETRY_JITTER , limit = None ) \u00a4 Create a LinearBackoff instance. PARAMETER DESCRIPTION interval time to wait for before the next retry, in seconds. TYPE: float DEFAULT: DEFAULT_RETRY_INTERVAL jitter a jitter to add to the retry interval. TYPE: float DEFAULT: DEFAULT_RETRY_JITTER limit max number of retries before giving up. None means no limit, and 0 means no retry. TYPE: Optional [ int ] DEFAULT: None Source code in frequenz/sdk/microgrid/client/_retry.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def __init__ ( self , interval : float = DEFAULT_RETRY_INTERVAL , jitter : float = DEFAULT_RETRY_JITTER , limit : Optional [ int ] = None , ) -> None : \"\"\"Create a `LinearBackoff` instance. Args: interval: time to wait for before the next retry, in seconds. jitter: a jitter to add to the retry interval. limit: max number of retries before giving up. `None` means no limit, and `0` means no retry. \"\"\" self . _interval = interval self . _jitter = jitter self . _limit = limit self . _count = 0 next_interval () \u00a4 Return the time to wait before the next retry. Returns None if the retry limit has been reached, and no more retries are possible. RETURNS DESCRIPTION Optional [ float ] Time until next retry when below retry limit, and None otherwise. Source code in frequenz/sdk/microgrid/client/_retry.py 98 99 100 101 102 103 104 105 106 107 108 109 110 def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\" if self . _limit is not None and self . _count >= self . _limit : return None self . _count += 1 return self . _interval + random . uniform ( 0.0 , self . _jitter ) frequenz.sdk.microgrid.client.MicrogridApiClient \u00a4 Bases: ABC Base interface for microgrid API clients to implement. Source code in frequenz/sdk/microgrid/client/_client.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 class MicrogridApiClient ( ABC ): \"\"\"Base interface for microgrid API clients to implement.\"\"\" @abstractmethod async def components ( self ) -> Iterable [ Component ]: \"\"\"Fetch all the components present in the microgrid. Returns: Iterator whose elements are all the components in the microgrid. \"\"\" @abstractmethod async def connections ( self , starts : Optional [ Set [ int ]] = None , ends : Optional [ Set [ int ]] = None , ) -> Iterable [ Connection ]: \"\"\"Fetch the connections between components in the microgrid. Args: starts: if set and non-empty, only include connections whose start value matches one of the provided component IDs ends: if set and non-empty, only include connections whose end value matches one of the provided component IDs Returns: Microgrid connections matching the provided start and end filters. \"\"\" @abstractmethod async def meter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ MeterData ]: \"\"\"Return a channel receiver that provides a `MeterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the meter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime meter data. \"\"\" @abstractmethod async def battery_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ BatteryData ]: \"\"\"Return a channel receiver that provides a `BatteryData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the battery to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime battery data. \"\"\" @abstractmethod async def inverter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ InverterData ]: \"\"\"Return a channel receiver that provides an `InverterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the inverter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime inverter data. \"\"\" @abstractmethod async def ev_charger_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ EVChargerData ]: \"\"\"Return a channel receiver that provides an `EvChargeData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the ev charger to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime ev charger data. \"\"\" @abstractmethod async def set_power ( self , component_id : int , power_w : int ) -> Empty : \"\"\"Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. Args: component_id: id of the component to set power. power_w: power to set for the component. Returns: Empty response. \"\"\" @abstractmethod async def set_bounds ( self , component_id : int , lower : float , upper : float ) -> None : \"\"\"Send `SetBoundsParam`s received from a channel to nitrogen. Args: component_id: ID of the component to set bounds for. lower: Lower bound to be set for the component. upper: Upper bound to be set for the component. \"\"\" Functions \u00a4 battery_data ( component_id , maxsize = RECEIVER_MAX_SIZE ) async abstractmethod \u00a4 Return a channel receiver that provides a BatteryData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. PARAMETER DESCRIPTION component_id id of the battery to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ BatteryData ] A channel receiver that provides realtime battery data. Source code in frequenz/sdk/microgrid/client/_client.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @abstractmethod async def battery_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ BatteryData ]: \"\"\"Return a channel receiver that provides a `BatteryData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the battery to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime battery data. \"\"\" components () async abstractmethod \u00a4 Fetch all the components present in the microgrid. RETURNS DESCRIPTION Iterable [ Component ] Iterator whose elements are all the components in the microgrid. Source code in frequenz/sdk/microgrid/client/_client.py 64 65 66 67 68 69 70 @abstractmethod async def components ( self ) -> Iterable [ Component ]: \"\"\"Fetch all the components present in the microgrid. Returns: Iterator whose elements are all the components in the microgrid. \"\"\" connections ( starts = None , ends = None ) async abstractmethod \u00a4 Fetch the connections between components in the microgrid. PARAMETER DESCRIPTION starts if set and non-empty, only include connections whose start value matches one of the provided component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None ends if set and non-empty, only include connections whose end value matches one of the provided component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None RETURNS DESCRIPTION Iterable [ Connection ] Microgrid connections matching the provided start and end filters. Source code in frequenz/sdk/microgrid/client/_client.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @abstractmethod async def connections ( self , starts : Optional [ Set [ int ]] = None , ends : Optional [ Set [ int ]] = None , ) -> Iterable [ Connection ]: \"\"\"Fetch the connections between components in the microgrid. Args: starts: if set and non-empty, only include connections whose start value matches one of the provided component IDs ends: if set and non-empty, only include connections whose end value matches one of the provided component IDs Returns: Microgrid connections matching the provided start and end filters. \"\"\" ev_charger_data ( component_id , maxsize = RECEIVER_MAX_SIZE ) async abstractmethod \u00a4 Return a channel receiver that provides an EvChargeData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. PARAMETER DESCRIPTION component_id id of the ev charger to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ EVChargerData ] A channel receiver that provides realtime ev charger data. Source code in frequenz/sdk/microgrid/client/_client.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 @abstractmethod async def ev_charger_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ EVChargerData ]: \"\"\"Return a channel receiver that provides an `EvChargeData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the ev charger to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime ev charger data. \"\"\" inverter_data ( component_id , maxsize = RECEIVER_MAX_SIZE ) async abstractmethod \u00a4 Return a channel receiver that provides an InverterData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. PARAMETER DESCRIPTION component_id id of the inverter to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ InverterData ] A channel receiver that provides realtime inverter data. Source code in frequenz/sdk/microgrid/client/_client.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @abstractmethod async def inverter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ InverterData ]: \"\"\"Return a channel receiver that provides an `InverterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the inverter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime inverter data. \"\"\" meter_data ( component_id , maxsize = RECEIVER_MAX_SIZE ) async abstractmethod \u00a4 Return a channel receiver that provides a MeterData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. PARAMETER DESCRIPTION component_id id of the meter to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ MeterData ] A channel receiver that provides realtime meter data. Source code in frequenz/sdk/microgrid/client/_client.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @abstractmethod async def meter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ MeterData ]: \"\"\"Return a channel receiver that provides a `MeterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the meter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime meter data. \"\"\" set_bounds ( component_id , lower , upper ) async abstractmethod \u00a4 Send SetBoundsParam s received from a channel to nitrogen. PARAMETER DESCRIPTION component_id ID of the component to set bounds for. TYPE: int lower Lower bound to be set for the component. TYPE: float upper Upper bound to be set for the component. TYPE: float Source code in frequenz/sdk/microgrid/client/_client.py 187 188 189 190 191 192 193 194 195 @abstractmethod async def set_bounds ( self , component_id : int , lower : float , upper : float ) -> None : \"\"\"Send `SetBoundsParam`s received from a channel to nitrogen. Args: component_id: ID of the component to set bounds for. lower: Lower bound to be set for the component. upper: Upper bound to be set for the component. \"\"\" set_power ( component_id , power_w ) async abstractmethod \u00a4 Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. PARAMETER DESCRIPTION component_id id of the component to set power. TYPE: int power_w power to set for the component. TYPE: int RETURNS DESCRIPTION Empty Empty response. Source code in frequenz/sdk/microgrid/client/_client.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 @abstractmethod async def set_power ( self , component_id : int , power_w : int ) -> Empty : \"\"\"Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. Args: component_id: id of the component to set power. power_w: power to set for the component. Returns: Empty response. \"\"\" frequenz.sdk.microgrid.client.MicrogridGrpcClient \u00a4 Bases: MicrogridApiClient Microgrid API client implementation using gRPC as the underlying protocol. Source code in frequenz/sdk/microgrid/client/_client.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 class MicrogridGrpcClient ( MicrogridApiClient ): \"\"\"Microgrid API client implementation using gRPC as the underlying protocol.\"\"\" def __init__ ( self , grpc_channel : grpc . aio . Channel , target : str , retry_spec : RetryStrategy = LinearBackoff (), ) -> None : \"\"\"Initialize the class instance. Args: grpc_channel: asyncio-supporting gRPC channel target: server (host:port) to be used for asyncio-supporting gRPC channel that the client should use to contact the API retry_spec: Specs on how to retry if the connection to a streaming method gets lost. \"\"\" self . target = target self . api = MicrogridStub ( grpc_channel ) self . _component_streams : Dict [ int , Broadcast [ Any ]] = {} self . _retry_spec = retry_spec async def components ( self ) -> Iterable [ Component ]: \"\"\"Fetch all the components present in the microgrid. Returns: Iterator whose elements are all the components in the microgrid. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" try : # grpc.aio is missing types and mypy thinks this is not awaitable, # but it is component_list = await self . api . ListComponents ( microgrid_pb . ComponentFilter (), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] except grpc . aio . AioRpcError as err : msg = f \"Failed to list components. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) components_only = filter ( lambda c : c . category not in ( microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_SENSOR , microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_LOAD , ), component_list . components , ) result : Iterable [ Component ] = map ( lambda c : Component ( c . id , _component_category_from_protobuf ( c . category ), _component_type_from_protobuf ( c . category , c . inverter ), ), components_only , ) return result async def connections ( self , starts : Optional [ Set [ int ]] = None , ends : Optional [ Set [ int ]] = None , ) -> Iterable [ Connection ]: \"\"\"Fetch the connections between components in the microgrid. Args: starts: if set and non-empty, only include connections whose start value matches one of the provided component IDs ends: if set and non-empty, only include connections whose end value matches one of the provided component IDs Returns: Microgrid connections matching the provided start and end filters. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" connection_filter = microgrid_pb . ConnectionFilter ( starts = starts , ends = ends ) try : valid_components , all_connections = await asyncio . gather ( self . components (), # grpc.aio is missing types and mypy thinks this is not # awaitable, but it is cast ( Awaitable [ microgrid_pb . ConnectionList ], self . api . ListConnections ( connection_filter , timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ), ), ) except grpc . aio . AioRpcError as err : msg = f \"Failed to list connections. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) # Filter out the components filtered in `components` method. # id=0 is an exception indicating grid component. valid_ids = { c . component_id for c in valid_components } valid_ids . add ( 0 ) connections = filter ( lambda c : ( c . start in valid_ids and c . end in valid_ids ), all_connections . connections , ) result : Iterable [ Connection ] = map ( lambda c : Connection ( c . start , c . end ), connections ) return result async def _component_data_task ( self , component_id : int , transform : Callable [[ microgrid_pb . ComponentData ], _GenericComponentData ], sender : Sender [ _GenericComponentData ], ) -> None : \"\"\"Read data from the microgrid API and send to a channel. Args: component_id: id of the component to get data for. transform: A method for transforming raw component data into the desired output type. sender: A channel sender, to send the component data to. Raises: AioRpcError: if connection to Microgrid API cannot be established \"\"\" retry_spec : RetryStrategy = self . _retry_spec . copy () while True : logger . debug ( \"Making call to `GetComponentData`, for component_id= %d \" , component_id ) try : call = self . api . GetComponentData ( microgrid_pb . ComponentIdParam ( id = component_id ), ) # grpc.aio is missing types and mypy thinks this is not # async iterable, but it is async for msg in call : # type: ignore[attr-defined] await sender . send ( transform ( msg )) except grpc . aio . AioRpcError as err : api_details = f \"Microgrid API: { self . target } .\" logger . exception ( \"`GetComponentData`, for component_id= %d : exception: %s api: %s \" , component_id , err , api_details , ) if interval := retry_spec . next_interval (): logger . warning ( \"`GetComponentData`, for component_id= %d : connection ended, \" \"retrying %s in %0.3f seconds.\" , component_id , retry_spec . get_progress (), interval , ) await asyncio . sleep ( interval ) else : logger . warning ( \"`GetComponentData`, for component_id= %d : connection ended, \" \"retry limit exceeded %s .\" , component_id , retry_spec . get_progress (), ) break def _get_component_data_channel ( self , component_id : int , transform : Callable [[ microgrid_pb . ComponentData ], _GenericComponentData ], ) -> Broadcast [ _GenericComponentData ]: \"\"\"Return the broadcast channel for a given component_id. If a broadcast channel for the given component_id doesn't exist, create a new channel and a task for reading data from the microgrid api and sending them to the channel. Args: component_id: id of the component to get data for. transform: A method for transforming raw component data into the desired output type. Returns: The channel for the given component_id. \"\"\" if component_id in self . _component_streams : return self . _component_streams [ component_id ] task_name = f \"raw-component-data- { component_id } \" chan = Broadcast [ _GenericComponentData ]( task_name ) self . _component_streams [ component_id ] = chan asyncio . create_task ( self . _component_data_task ( component_id , transform , chan . new_sender (), ), name = task_name , ) return chan async def _expect_category ( self , component_id : int , expected_category : ComponentCategory , ) -> None : \"\"\"Check if the given component_id is of the expected type. Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: Component id to check. expected_category: Component category that the given id is expected to have. \"\"\" try : comp = next ( comp for comp in await self . components () if comp . component_id == component_id ) except StopIteration as exc : raise ValueError ( f \"Unable to find component with id { component_id } \" ) from exc if comp . category != expected_category : raise ValueError ( f \"Component id { component_id } is a { comp . category } \" f \", not a { expected_category } .\" ) async def meter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ MeterData ]: \"\"\"Return a channel receiver that provides a `MeterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the meter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime meter data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . METER , ) return self . _get_component_data_channel ( component_id , MeterData . from_proto , ) . new_receiver ( maxsize = maxsize ) async def battery_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ BatteryData ]: \"\"\"Return a channel receiver that provides a `BatteryData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the battery to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime battery data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . BATTERY , ) return self . _get_component_data_channel ( component_id , BatteryData . from_proto , ) . new_receiver ( maxsize = maxsize ) async def inverter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ InverterData ]: \"\"\"Return a channel receiver that provides an `InverterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the inverter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime inverter data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . INVERTER , ) return self . _get_component_data_channel ( component_id , InverterData . from_proto , ) . new_receiver ( maxsize = maxsize ) async def ev_charger_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ EVChargerData ]: \"\"\"Return a channel receiver that provides an `EvChargeData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the ev charger to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime ev charger data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . EV_CHARGER , ) return self . _get_component_data_channel ( component_id , EVChargerData . from_proto , ) . new_receiver ( maxsize = maxsize ) async def set_power ( self , component_id : int , power_w : int ) -> Empty : \"\"\"Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. Args: component_id: id of the component to set power. power_w: power to set for the component. Returns: Empty response. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" try : if power_w >= 0 : # grpc.aio is missing types and mypy thinks this is not # async iterable, but it is result : Empty = await self . api . Charge ( microgrid_pb . PowerLevelParam ( component_id = component_id , power_w = power_w ), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] else : # grpc.aio is missing types and mypy thinks this is not # async iterable, but it is power_w *= - 1 result = await self . api . Discharge ( microgrid_pb . PowerLevelParam ( component_id = component_id , power_w = power_w ), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] except grpc . aio . AioRpcError as err : msg = f \"Failed to set power. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) return result async def set_bounds ( self , component_id : int , lower : float , upper : float , ) -> None : \"\"\"Send `SetBoundsParam`s received from a channel to nitrogen. Args: component_id: ID of the component to set bounds for. lower: Lower bound to be set for the component. upper: Upper bound to be set for the component. Raises: ValueError: when upper bound is less than 0, or when lower bound is greater than 0. grpc.aio.AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" api_details = f \"Microgrid API: { self . target } .\" if upper < 0 : raise ValueError ( f \"Upper bound { upper } must be greater than or equal to 0.\" ) if lower > 0 : raise ValueError ( f \"Lower bound { upper } must be less than or equal to 0.\" ) # grpc.aio is missing types and mypy thinks request_iterator is # a required argument, but it is not set_bounds_call = self . api . SetBounds ( timeout = DEFAULT_GRPC_CALL_TIMEOUT , ) # type: ignore[call-arg] try : # grpc.aio is missing types and mypy thinks set_bounds_call can be Empty assert not isinstance ( set_bounds_call , Empty ) await set_bounds_call . write ( microgrid_pb . SetBoundsParam ( component_id = component_id , # pylint: disable=no-member,line-too-long target_metric = microgrid_pb . SetBoundsParam . TargetMetric . TARGET_METRIC_POWER_ACTIVE , bounds = common_pb . Bounds ( lower = lower , upper = upper ), ), ) except grpc . aio . AioRpcError as err : logger . error ( \"set_bounds write failed: %s , for message: %s , api: %s . Err: %s \" , err , next , api_details , err . details (), ) raise Functions \u00a4 __init__ ( grpc_channel , target , retry_spec = LinearBackoff ()) \u00a4 Initialize the class instance. PARAMETER DESCRIPTION grpc_channel asyncio-supporting gRPC channel TYPE: grpc . aio . Channel target server (host:port) to be used for asyncio-supporting gRPC channel that the client should use to contact the API TYPE: str retry_spec Specs on how to retry if the connection to a streaming method gets lost. TYPE: RetryStrategy DEFAULT: LinearBackoff() Source code in frequenz/sdk/microgrid/client/_client.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def __init__ ( self , grpc_channel : grpc . aio . Channel , target : str , retry_spec : RetryStrategy = LinearBackoff (), ) -> None : \"\"\"Initialize the class instance. Args: grpc_channel: asyncio-supporting gRPC channel target: server (host:port) to be used for asyncio-supporting gRPC channel that the client should use to contact the API retry_spec: Specs on how to retry if the connection to a streaming method gets lost. \"\"\" self . target = target self . api = MicrogridStub ( grpc_channel ) self . _component_streams : Dict [ int , Broadcast [ Any ]] = {} self . _retry_spec = retry_spec battery_data ( component_id , maxsize = RECEIVER_MAX_SIZE ) async \u00a4 Return a channel receiver that provides a BatteryData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. RAISES DESCRIPTION ValueError if the given id is unknown or has a different type. PARAMETER DESCRIPTION component_id id of the battery to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ BatteryData ] A channel receiver that provides realtime battery data. Source code in frequenz/sdk/microgrid/client/_client.py 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 async def battery_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ BatteryData ]: \"\"\"Return a channel receiver that provides a `BatteryData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the battery to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime battery data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . BATTERY , ) return self . _get_component_data_channel ( component_id , BatteryData . from_proto , ) . new_receiver ( maxsize = maxsize ) components () async \u00a4 Fetch all the components present in the microgrid. RETURNS DESCRIPTION Iterable [ Component ] Iterator whose elements are all the components in the microgrid. RAISES DESCRIPTION AioRpcError if connection to Microgrid API cannot be established or when the api call exceeded timeout Source code in frequenz/sdk/microgrid/client/_client.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 async def components ( self ) -> Iterable [ Component ]: \"\"\"Fetch all the components present in the microgrid. Returns: Iterator whose elements are all the components in the microgrid. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" try : # grpc.aio is missing types and mypy thinks this is not awaitable, # but it is component_list = await self . api . ListComponents ( microgrid_pb . ComponentFilter (), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] except grpc . aio . AioRpcError as err : msg = f \"Failed to list components. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) components_only = filter ( lambda c : c . category not in ( microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_SENSOR , microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_LOAD , ), component_list . components , ) result : Iterable [ Component ] = map ( lambda c : Component ( c . id , _component_category_from_protobuf ( c . category ), _component_type_from_protobuf ( c . category , c . inverter ), ), components_only , ) return result connections ( starts = None , ends = None ) async \u00a4 Fetch the connections between components in the microgrid. PARAMETER DESCRIPTION starts if set and non-empty, only include connections whose start value matches one of the provided component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None ends if set and non-empty, only include connections whose end value matches one of the provided component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None RETURNS DESCRIPTION Iterable [ Connection ] Microgrid connections matching the provided start and end filters. RAISES DESCRIPTION AioRpcError if connection to Microgrid API cannot be established or when the api call exceeded timeout Source code in frequenz/sdk/microgrid/client/_client.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 async def connections ( self , starts : Optional [ Set [ int ]] = None , ends : Optional [ Set [ int ]] = None , ) -> Iterable [ Connection ]: \"\"\"Fetch the connections between components in the microgrid. Args: starts: if set and non-empty, only include connections whose start value matches one of the provided component IDs ends: if set and non-empty, only include connections whose end value matches one of the provided component IDs Returns: Microgrid connections matching the provided start and end filters. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" connection_filter = microgrid_pb . ConnectionFilter ( starts = starts , ends = ends ) try : valid_components , all_connections = await asyncio . gather ( self . components (), # grpc.aio is missing types and mypy thinks this is not # awaitable, but it is cast ( Awaitable [ microgrid_pb . ConnectionList ], self . api . ListConnections ( connection_filter , timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ), ), ) except grpc . aio . AioRpcError as err : msg = f \"Failed to list connections. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) # Filter out the components filtered in `components` method. # id=0 is an exception indicating grid component. valid_ids = { c . component_id for c in valid_components } valid_ids . add ( 0 ) connections = filter ( lambda c : ( c . start in valid_ids and c . end in valid_ids ), all_connections . connections , ) result : Iterable [ Connection ] = map ( lambda c : Connection ( c . start , c . end ), connections ) return result ev_charger_data ( component_id , maxsize = RECEIVER_MAX_SIZE ) async \u00a4 Return a channel receiver that provides an EvChargeData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. RAISES DESCRIPTION ValueError if the given id is unknown or has a different type. PARAMETER DESCRIPTION component_id id of the ev charger to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ EVChargerData ] A channel receiver that provides realtime ev charger data. Source code in frequenz/sdk/microgrid/client/_client.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 async def ev_charger_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ EVChargerData ]: \"\"\"Return a channel receiver that provides an `EvChargeData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the ev charger to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime ev charger data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . EV_CHARGER , ) return self . _get_component_data_channel ( component_id , EVChargerData . from_proto , ) . new_receiver ( maxsize = maxsize ) inverter_data ( component_id , maxsize = RECEIVER_MAX_SIZE ) async \u00a4 Return a channel receiver that provides an InverterData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. RAISES DESCRIPTION ValueError if the given id is unknown or has a different type. PARAMETER DESCRIPTION component_id id of the inverter to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ InverterData ] A channel receiver that provides realtime inverter data. Source code in frequenz/sdk/microgrid/client/_client.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 async def inverter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ InverterData ]: \"\"\"Return a channel receiver that provides an `InverterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the inverter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime inverter data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . INVERTER , ) return self . _get_component_data_channel ( component_id , InverterData . from_proto , ) . new_receiver ( maxsize = maxsize ) meter_data ( component_id , maxsize = RECEIVER_MAX_SIZE ) async \u00a4 Return a channel receiver that provides a MeterData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. RAISES DESCRIPTION ValueError if the given id is unknown or has a different type. PARAMETER DESCRIPTION component_id id of the meter to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ MeterData ] A channel receiver that provides realtime meter data. Source code in frequenz/sdk/microgrid/client/_client.py 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 async def meter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ MeterData ]: \"\"\"Return a channel receiver that provides a `MeterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the meter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime meter data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . METER , ) return self . _get_component_data_channel ( component_id , MeterData . from_proto , ) . new_receiver ( maxsize = maxsize ) set_bounds ( component_id , lower , upper ) async \u00a4 Send SetBoundsParam s received from a channel to nitrogen. PARAMETER DESCRIPTION component_id ID of the component to set bounds for. TYPE: int lower Lower bound to be set for the component. TYPE: float upper Upper bound to be set for the component. TYPE: float RAISES DESCRIPTION ValueError when upper bound is less than 0, or when lower bound is greater than 0. grpc . aio . AioRpcError if connection to Microgrid API cannot be established or when the api call exceeded timeout Source code in frequenz/sdk/microgrid/client/_client.py 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 async def set_bounds ( self , component_id : int , lower : float , upper : float , ) -> None : \"\"\"Send `SetBoundsParam`s received from a channel to nitrogen. Args: component_id: ID of the component to set bounds for. lower: Lower bound to be set for the component. upper: Upper bound to be set for the component. Raises: ValueError: when upper bound is less than 0, or when lower bound is greater than 0. grpc.aio.AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" api_details = f \"Microgrid API: { self . target } .\" if upper < 0 : raise ValueError ( f \"Upper bound { upper } must be greater than or equal to 0.\" ) if lower > 0 : raise ValueError ( f \"Lower bound { upper } must be less than or equal to 0.\" ) # grpc.aio is missing types and mypy thinks request_iterator is # a required argument, but it is not set_bounds_call = self . api . SetBounds ( timeout = DEFAULT_GRPC_CALL_TIMEOUT , ) # type: ignore[call-arg] try : # grpc.aio is missing types and mypy thinks set_bounds_call can be Empty assert not isinstance ( set_bounds_call , Empty ) await set_bounds_call . write ( microgrid_pb . SetBoundsParam ( component_id = component_id , # pylint: disable=no-member,line-too-long target_metric = microgrid_pb . SetBoundsParam . TargetMetric . TARGET_METRIC_POWER_ACTIVE , bounds = common_pb . Bounds ( lower = lower , upper = upper ), ), ) except grpc . aio . AioRpcError as err : logger . error ( \"set_bounds write failed: %s , for message: %s , api: %s . Err: %s \" , err , next , api_details , err . details (), ) raise set_power ( component_id , power_w ) async \u00a4 Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. PARAMETER DESCRIPTION component_id id of the component to set power. TYPE: int power_w power to set for the component. TYPE: int RETURNS DESCRIPTION Empty Empty response. RAISES DESCRIPTION AioRpcError if connection to Microgrid API cannot be established or when the api call exceeded timeout Source code in frequenz/sdk/microgrid/client/_client.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 async def set_power ( self , component_id : int , power_w : int ) -> Empty : \"\"\"Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. Args: component_id: id of the component to set power. power_w: power to set for the component. Returns: Empty response. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" try : if power_w >= 0 : # grpc.aio is missing types and mypy thinks this is not # async iterable, but it is result : Empty = await self . api . Charge ( microgrid_pb . PowerLevelParam ( component_id = component_id , power_w = power_w ), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] else : # grpc.aio is missing types and mypy thinks this is not # async iterable, but it is power_w *= - 1 result = await self . api . Discharge ( microgrid_pb . PowerLevelParam ( component_id = component_id , power_w = power_w ), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] except grpc . aio . AioRpcError as err : msg = f \"Failed to set power. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) return result frequenz.sdk.microgrid.client.RetryStrategy \u00a4 Bases: ABC Interface for implementing retry strategies. Source code in frequenz/sdk/microgrid/client/_retry.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class RetryStrategy ( ABC ): \"\"\"Interface for implementing retry strategies.\"\"\" _limit : Optional [ int ] _count : int @abstractmethod def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\" def get_progress ( self ) -> str : \"\"\"Return a string denoting the retry progress. Returns: String denoting retry progress in the form \"(count/limit)\" \"\"\" if self . _limit is None : return f \"( { self . _count } /\u221e)\" return f \"( { self . _count } / { self . _limit } )\" def reset ( self ) -> None : \"\"\"Reset the retry counter. To be called as soon as a connection is successful. \"\"\" self . _count = 0 def copy ( self ) -> RetryStrategy : \"\"\"Create a new instance of `self`. Returns: A deepcopy of `self`. \"\"\" ret = deepcopy ( self ) ret . reset () return ret def __iter__ ( self ) -> Iterator [ float ]: \"\"\"Return an iterator over the retry intervals. Yields: Next retry interval in seconds. \"\"\" while True : interval = self . next_interval () if interval is None : break yield interval Functions \u00a4 __iter__ () \u00a4 Return an iterator over the retry intervals. YIELDS DESCRIPTION Iterator [ float ] Next retry interval in seconds. Source code in frequenz/sdk/microgrid/client/_retry.py 62 63 64 65 66 67 68 69 70 71 72 def __iter__ ( self ) -> Iterator [ float ]: \"\"\"Return an iterator over the retry intervals. Yields: Next retry interval in seconds. \"\"\" while True : interval = self . next_interval () if interval is None : break yield interval copy () \u00a4 Create a new instance of self . RETURNS DESCRIPTION RetryStrategy A deepcopy of self . Source code in frequenz/sdk/microgrid/client/_retry.py 52 53 54 55 56 57 58 59 60 def copy ( self ) -> RetryStrategy : \"\"\"Create a new instance of `self`. Returns: A deepcopy of `self`. \"\"\" ret = deepcopy ( self ) ret . reset () return ret get_progress () \u00a4 Return a string denoting the retry progress. RETURNS DESCRIPTION str String denoting retry progress in the form \"(count/limit)\" Source code in frequenz/sdk/microgrid/client/_retry.py 34 35 36 37 38 39 40 41 42 43 def get_progress ( self ) -> str : \"\"\"Return a string denoting the retry progress. Returns: String denoting retry progress in the form \"(count/limit)\" \"\"\" if self . _limit is None : return f \"( { self . _count } /\u221e)\" return f \"( { self . _count } / { self . _limit } )\" next_interval () abstractmethod \u00a4 Return the time to wait before the next retry. Returns None if the retry limit has been reached, and no more retries are possible. RETURNS DESCRIPTION Optional [ float ] Time until next retry when below retry limit, and None otherwise. Source code in frequenz/sdk/microgrid/client/_retry.py 23 24 25 26 27 28 29 30 31 32 @abstractmethod def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\" reset () \u00a4 Reset the retry counter. To be called as soon as a connection is successful. Source code in frequenz/sdk/microgrid/client/_retry.py 45 46 47 48 49 50 def reset ( self ) -> None : \"\"\"Reset the retry counter. To be called as soon as a connection is successful. \"\"\" self . _count = 0","title":"client"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client","text":"Microgrid API client. This package provides an easy way to connect to the microgrid API.","title":"client"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection","text":"Bases: NamedTuple Metadata for a connection between microgrid components. Source code in frequenz/sdk/microgrid/client/_connection.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Connection ( NamedTuple ): \"\"\"Metadata for a connection between microgrid components.\"\"\" start : int end : int def is_valid ( self ) -> bool : \"\"\"Check if this instance contains valid data. Returns: `True` if `start >= 0`, `end > 0`, and `start != end`, `False` otherwise. \"\"\" return self . start >= 0 and self . end > 0 and self . start != self . end","title":"Connection"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._connection.Connection.is_valid","text":"Check if this instance contains valid data. RETURNS DESCRIPTION bool True if start >= 0 , end > 0 , and start != end , False otherwise. Source code in frequenz/sdk/microgrid/client/_connection.py 15 16 17 18 19 20 21 22 def is_valid ( self ) -> bool : \"\"\"Check if this instance contains valid data. Returns: `True` if `start >= 0`, `end > 0`, and `start != end`, `False` otherwise. \"\"\" return self . start >= 0 and self . end > 0 and self . start != self . end","title":"is_valid()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff","text":"Bases: RetryStrategy Provides methods for calculating the exponential interval between retries. Source code in frequenz/sdk/microgrid/client/_retry.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 class ExponentialBackoff ( RetryStrategy ): \"\"\"Provides methods for calculating the exponential interval between retries.\"\"\" DEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL DEFAULT_MAX_INTERVAL = 60.0 DEFAULT_MULTIPLIER = 2.0 # pylint: disable=too-many-arguments def __init__ ( self , initial_interval : float = DEFAULT_INTERVAL , max_interval : float = DEFAULT_MAX_INTERVAL , multiplier : float = DEFAULT_MULTIPLIER , jitter : float = DEFAULT_RETRY_JITTER , limit : Optional [ int ] = None , ) -> None : \"\"\"Create a `ExponentialBackoff` instance. Args: initial_interval: time to wait for before the first retry, in seconds. max_interval: maximum interval, in seconds. multiplier: exponential increment for interval. jitter: a jitter to add to the retry interval. limit: max number of retries before giving up. `None` means no limit, and `0` means no retry. \"\"\" self . _initial = initial_interval self . _max = max_interval self . _multiplier = multiplier self . _jitter = jitter self . _limit = limit self . _count = 0 def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\" if self . _limit is not None and self . _count >= self . _limit : return None self . _count += 1 exp_backoff_interval = self . _initial * self . _multiplier ** ( self . _count - 1 ) return min ( exp_backoff_interval + random . uniform ( 0.0 , self . _jitter ), self . _max )","title":"ExponentialBackoff"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.ExponentialBackoff.__init__","text":"Create a ExponentialBackoff instance. PARAMETER DESCRIPTION initial_interval time to wait for before the first retry, in seconds. TYPE: float DEFAULT: DEFAULT_INTERVAL max_interval maximum interval, in seconds. TYPE: float DEFAULT: DEFAULT_MAX_INTERVAL multiplier exponential increment for interval. TYPE: float DEFAULT: DEFAULT_MULTIPLIER jitter a jitter to add to the retry interval. TYPE: float DEFAULT: DEFAULT_RETRY_JITTER limit max number of retries before giving up. None means no limit, and 0 means no retry. TYPE: Optional [ int ] DEFAULT: None Source code in frequenz/sdk/microgrid/client/_retry.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def __init__ ( self , initial_interval : float = DEFAULT_INTERVAL , max_interval : float = DEFAULT_MAX_INTERVAL , multiplier : float = DEFAULT_MULTIPLIER , jitter : float = DEFAULT_RETRY_JITTER , limit : Optional [ int ] = None , ) -> None : \"\"\"Create a `ExponentialBackoff` instance. Args: initial_interval: time to wait for before the first retry, in seconds. max_interval: maximum interval, in seconds. multiplier: exponential increment for interval. jitter: a jitter to add to the retry interval. limit: max number of retries before giving up. `None` means no limit, and `0` means no retry. \"\"\" self . _initial = initial_interval self . _max = max_interval self . _multiplier = multiplier self . _jitter = jitter self . _limit = limit self . _count = 0","title":"__init__()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.ExponentialBackoff.next_interval","text":"Return the time to wait before the next retry. Returns None if the retry limit has been reached, and no more retries are possible. RETURNS DESCRIPTION Optional [ float ] Time until next retry when below retry limit, and None otherwise. Source code in frequenz/sdk/microgrid/client/_retry.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\" if self . _limit is not None and self . _count >= self . _limit : return None self . _count += 1 exp_backoff_interval = self . _initial * self . _multiplier ** ( self . _count - 1 ) return min ( exp_backoff_interval + random . uniform ( 0.0 , self . _jitter ), self . _max )","title":"next_interval()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff","text":"Bases: RetryStrategy Provides methods for calculating the interval between retries. Source code in frequenz/sdk/microgrid/client/_retry.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class LinearBackoff ( RetryStrategy ): \"\"\"Provides methods for calculating the interval between retries.\"\"\" def __init__ ( self , interval : float = DEFAULT_RETRY_INTERVAL , jitter : float = DEFAULT_RETRY_JITTER , limit : Optional [ int ] = None , ) -> None : \"\"\"Create a `LinearBackoff` instance. Args: interval: time to wait for before the next retry, in seconds. jitter: a jitter to add to the retry interval. limit: max number of retries before giving up. `None` means no limit, and `0` means no retry. \"\"\" self . _interval = interval self . _jitter = jitter self . _limit = limit self . _count = 0 def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\" if self . _limit is not None and self . _count >= self . _limit : return None self . _count += 1 return self . _interval + random . uniform ( 0.0 , self . _jitter )","title":"LinearBackoff"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.LinearBackoff.__init__","text":"Create a LinearBackoff instance. PARAMETER DESCRIPTION interval time to wait for before the next retry, in seconds. TYPE: float DEFAULT: DEFAULT_RETRY_INTERVAL jitter a jitter to add to the retry interval. TYPE: float DEFAULT: DEFAULT_RETRY_JITTER limit max number of retries before giving up. None means no limit, and 0 means no retry. TYPE: Optional [ int ] DEFAULT: None Source code in frequenz/sdk/microgrid/client/_retry.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def __init__ ( self , interval : float = DEFAULT_RETRY_INTERVAL , jitter : float = DEFAULT_RETRY_JITTER , limit : Optional [ int ] = None , ) -> None : \"\"\"Create a `LinearBackoff` instance. Args: interval: time to wait for before the next retry, in seconds. jitter: a jitter to add to the retry interval. limit: max number of retries before giving up. `None` means no limit, and `0` means no retry. \"\"\" self . _interval = interval self . _jitter = jitter self . _limit = limit self . _count = 0","title":"__init__()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.LinearBackoff.next_interval","text":"Return the time to wait before the next retry. Returns None if the retry limit has been reached, and no more retries are possible. RETURNS DESCRIPTION Optional [ float ] Time until next retry when below retry limit, and None otherwise. Source code in frequenz/sdk/microgrid/client/_retry.py 98 99 100 101 102 103 104 105 106 107 108 109 110 def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\" if self . _limit is not None and self . _count >= self . _limit : return None self . _count += 1 return self . _interval + random . uniform ( 0.0 , self . _jitter )","title":"next_interval()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient","text":"Bases: ABC Base interface for microgrid API clients to implement. Source code in frequenz/sdk/microgrid/client/_client.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 class MicrogridApiClient ( ABC ): \"\"\"Base interface for microgrid API clients to implement.\"\"\" @abstractmethod async def components ( self ) -> Iterable [ Component ]: \"\"\"Fetch all the components present in the microgrid. Returns: Iterator whose elements are all the components in the microgrid. \"\"\" @abstractmethod async def connections ( self , starts : Optional [ Set [ int ]] = None , ends : Optional [ Set [ int ]] = None , ) -> Iterable [ Connection ]: \"\"\"Fetch the connections between components in the microgrid. Args: starts: if set and non-empty, only include connections whose start value matches one of the provided component IDs ends: if set and non-empty, only include connections whose end value matches one of the provided component IDs Returns: Microgrid connections matching the provided start and end filters. \"\"\" @abstractmethod async def meter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ MeterData ]: \"\"\"Return a channel receiver that provides a `MeterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the meter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime meter data. \"\"\" @abstractmethod async def battery_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ BatteryData ]: \"\"\"Return a channel receiver that provides a `BatteryData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the battery to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime battery data. \"\"\" @abstractmethod async def inverter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ InverterData ]: \"\"\"Return a channel receiver that provides an `InverterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the inverter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime inverter data. \"\"\" @abstractmethod async def ev_charger_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ EVChargerData ]: \"\"\"Return a channel receiver that provides an `EvChargeData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the ev charger to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime ev charger data. \"\"\" @abstractmethod async def set_power ( self , component_id : int , power_w : int ) -> Empty : \"\"\"Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. Args: component_id: id of the component to set power. power_w: power to set for the component. Returns: Empty response. \"\"\" @abstractmethod async def set_bounds ( self , component_id : int , lower : float , upper : float ) -> None : \"\"\"Send `SetBoundsParam`s received from a channel to nitrogen. Args: component_id: ID of the component to set bounds for. lower: Lower bound to be set for the component. upper: Upper bound to be set for the component. \"\"\"","title":"MicrogridApiClient"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.battery_data","text":"Return a channel receiver that provides a BatteryData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. PARAMETER DESCRIPTION component_id id of the battery to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ BatteryData ] A channel receiver that provides realtime battery data. Source code in frequenz/sdk/microgrid/client/_client.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @abstractmethod async def battery_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ BatteryData ]: \"\"\"Return a channel receiver that provides a `BatteryData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the battery to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime battery data. \"\"\"","title":"battery_data()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.components","text":"Fetch all the components present in the microgrid. RETURNS DESCRIPTION Iterable [ Component ] Iterator whose elements are all the components in the microgrid. Source code in frequenz/sdk/microgrid/client/_client.py 64 65 66 67 68 69 70 @abstractmethod async def components ( self ) -> Iterable [ Component ]: \"\"\"Fetch all the components present in the microgrid. Returns: Iterator whose elements are all the components in the microgrid. \"\"\"","title":"components()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.connections","text":"Fetch the connections between components in the microgrid. PARAMETER DESCRIPTION starts if set and non-empty, only include connections whose start value matches one of the provided component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None ends if set and non-empty, only include connections whose end value matches one of the provided component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None RETURNS DESCRIPTION Iterable [ Connection ] Microgrid connections matching the provided start and end filters. Source code in frequenz/sdk/microgrid/client/_client.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @abstractmethod async def connections ( self , starts : Optional [ Set [ int ]] = None , ends : Optional [ Set [ int ]] = None , ) -> Iterable [ Connection ]: \"\"\"Fetch the connections between components in the microgrid. Args: starts: if set and non-empty, only include connections whose start value matches one of the provided component IDs ends: if set and non-empty, only include connections whose end value matches one of the provided component IDs Returns: Microgrid connections matching the provided start and end filters. \"\"\"","title":"connections()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.ev_charger_data","text":"Return a channel receiver that provides an EvChargeData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. PARAMETER DESCRIPTION component_id id of the ev charger to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ EVChargerData ] A channel receiver that provides realtime ev charger data. Source code in frequenz/sdk/microgrid/client/_client.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 @abstractmethod async def ev_charger_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ EVChargerData ]: \"\"\"Return a channel receiver that provides an `EvChargeData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the ev charger to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime ev charger data. \"\"\"","title":"ev_charger_data()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.inverter_data","text":"Return a channel receiver that provides an InverterData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. PARAMETER DESCRIPTION component_id id of the inverter to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ InverterData ] A channel receiver that provides realtime inverter data. Source code in frequenz/sdk/microgrid/client/_client.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @abstractmethod async def inverter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ InverterData ]: \"\"\"Return a channel receiver that provides an `InverterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the inverter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime inverter data. \"\"\"","title":"inverter_data()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.meter_data","text":"Return a channel receiver that provides a MeterData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. PARAMETER DESCRIPTION component_id id of the meter to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ MeterData ] A channel receiver that provides realtime meter data. Source code in frequenz/sdk/microgrid/client/_client.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @abstractmethod async def meter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ MeterData ]: \"\"\"Return a channel receiver that provides a `MeterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Args: component_id: id of the meter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime meter data. \"\"\"","title":"meter_data()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.set_bounds","text":"Send SetBoundsParam s received from a channel to nitrogen. PARAMETER DESCRIPTION component_id ID of the component to set bounds for. TYPE: int lower Lower bound to be set for the component. TYPE: float upper Upper bound to be set for the component. TYPE: float Source code in frequenz/sdk/microgrid/client/_client.py 187 188 189 190 191 192 193 194 195 @abstractmethod async def set_bounds ( self , component_id : int , lower : float , upper : float ) -> None : \"\"\"Send `SetBoundsParam`s received from a channel to nitrogen. Args: component_id: ID of the component to set bounds for. lower: Lower bound to be set for the component. upper: Upper bound to be set for the component. \"\"\"","title":"set_bounds()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.set_power","text":"Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. PARAMETER DESCRIPTION component_id id of the component to set power. TYPE: int power_w power to set for the component. TYPE: int RETURNS DESCRIPTION Empty Empty response. Source code in frequenz/sdk/microgrid/client/_client.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 @abstractmethod async def set_power ( self , component_id : int , power_w : int ) -> Empty : \"\"\"Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. Args: component_id: id of the component to set power. power_w: power to set for the component. Returns: Empty response. \"\"\"","title":"set_power()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient","text":"Bases: MicrogridApiClient Microgrid API client implementation using gRPC as the underlying protocol. Source code in frequenz/sdk/microgrid/client/_client.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 class MicrogridGrpcClient ( MicrogridApiClient ): \"\"\"Microgrid API client implementation using gRPC as the underlying protocol.\"\"\" def __init__ ( self , grpc_channel : grpc . aio . Channel , target : str , retry_spec : RetryStrategy = LinearBackoff (), ) -> None : \"\"\"Initialize the class instance. Args: grpc_channel: asyncio-supporting gRPC channel target: server (host:port) to be used for asyncio-supporting gRPC channel that the client should use to contact the API retry_spec: Specs on how to retry if the connection to a streaming method gets lost. \"\"\" self . target = target self . api = MicrogridStub ( grpc_channel ) self . _component_streams : Dict [ int , Broadcast [ Any ]] = {} self . _retry_spec = retry_spec async def components ( self ) -> Iterable [ Component ]: \"\"\"Fetch all the components present in the microgrid. Returns: Iterator whose elements are all the components in the microgrid. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" try : # grpc.aio is missing types and mypy thinks this is not awaitable, # but it is component_list = await self . api . ListComponents ( microgrid_pb . ComponentFilter (), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] except grpc . aio . AioRpcError as err : msg = f \"Failed to list components. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) components_only = filter ( lambda c : c . category not in ( microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_SENSOR , microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_LOAD , ), component_list . components , ) result : Iterable [ Component ] = map ( lambda c : Component ( c . id , _component_category_from_protobuf ( c . category ), _component_type_from_protobuf ( c . category , c . inverter ), ), components_only , ) return result async def connections ( self , starts : Optional [ Set [ int ]] = None , ends : Optional [ Set [ int ]] = None , ) -> Iterable [ Connection ]: \"\"\"Fetch the connections between components in the microgrid. Args: starts: if set and non-empty, only include connections whose start value matches one of the provided component IDs ends: if set and non-empty, only include connections whose end value matches one of the provided component IDs Returns: Microgrid connections matching the provided start and end filters. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" connection_filter = microgrid_pb . ConnectionFilter ( starts = starts , ends = ends ) try : valid_components , all_connections = await asyncio . gather ( self . components (), # grpc.aio is missing types and mypy thinks this is not # awaitable, but it is cast ( Awaitable [ microgrid_pb . ConnectionList ], self . api . ListConnections ( connection_filter , timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ), ), ) except grpc . aio . AioRpcError as err : msg = f \"Failed to list connections. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) # Filter out the components filtered in `components` method. # id=0 is an exception indicating grid component. valid_ids = { c . component_id for c in valid_components } valid_ids . add ( 0 ) connections = filter ( lambda c : ( c . start in valid_ids and c . end in valid_ids ), all_connections . connections , ) result : Iterable [ Connection ] = map ( lambda c : Connection ( c . start , c . end ), connections ) return result async def _component_data_task ( self , component_id : int , transform : Callable [[ microgrid_pb . ComponentData ], _GenericComponentData ], sender : Sender [ _GenericComponentData ], ) -> None : \"\"\"Read data from the microgrid API and send to a channel. Args: component_id: id of the component to get data for. transform: A method for transforming raw component data into the desired output type. sender: A channel sender, to send the component data to. Raises: AioRpcError: if connection to Microgrid API cannot be established \"\"\" retry_spec : RetryStrategy = self . _retry_spec . copy () while True : logger . debug ( \"Making call to `GetComponentData`, for component_id= %d \" , component_id ) try : call = self . api . GetComponentData ( microgrid_pb . ComponentIdParam ( id = component_id ), ) # grpc.aio is missing types and mypy thinks this is not # async iterable, but it is async for msg in call : # type: ignore[attr-defined] await sender . send ( transform ( msg )) except grpc . aio . AioRpcError as err : api_details = f \"Microgrid API: { self . target } .\" logger . exception ( \"`GetComponentData`, for component_id= %d : exception: %s api: %s \" , component_id , err , api_details , ) if interval := retry_spec . next_interval (): logger . warning ( \"`GetComponentData`, for component_id= %d : connection ended, \" \"retrying %s in %0.3f seconds.\" , component_id , retry_spec . get_progress (), interval , ) await asyncio . sleep ( interval ) else : logger . warning ( \"`GetComponentData`, for component_id= %d : connection ended, \" \"retry limit exceeded %s .\" , component_id , retry_spec . get_progress (), ) break def _get_component_data_channel ( self , component_id : int , transform : Callable [[ microgrid_pb . ComponentData ], _GenericComponentData ], ) -> Broadcast [ _GenericComponentData ]: \"\"\"Return the broadcast channel for a given component_id. If a broadcast channel for the given component_id doesn't exist, create a new channel and a task for reading data from the microgrid api and sending them to the channel. Args: component_id: id of the component to get data for. transform: A method for transforming raw component data into the desired output type. Returns: The channel for the given component_id. \"\"\" if component_id in self . _component_streams : return self . _component_streams [ component_id ] task_name = f \"raw-component-data- { component_id } \" chan = Broadcast [ _GenericComponentData ]( task_name ) self . _component_streams [ component_id ] = chan asyncio . create_task ( self . _component_data_task ( component_id , transform , chan . new_sender (), ), name = task_name , ) return chan async def _expect_category ( self , component_id : int , expected_category : ComponentCategory , ) -> None : \"\"\"Check if the given component_id is of the expected type. Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: Component id to check. expected_category: Component category that the given id is expected to have. \"\"\" try : comp = next ( comp for comp in await self . components () if comp . component_id == component_id ) except StopIteration as exc : raise ValueError ( f \"Unable to find component with id { component_id } \" ) from exc if comp . category != expected_category : raise ValueError ( f \"Component id { component_id } is a { comp . category } \" f \", not a { expected_category } .\" ) async def meter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ MeterData ]: \"\"\"Return a channel receiver that provides a `MeterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the meter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime meter data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . METER , ) return self . _get_component_data_channel ( component_id , MeterData . from_proto , ) . new_receiver ( maxsize = maxsize ) async def battery_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ BatteryData ]: \"\"\"Return a channel receiver that provides a `BatteryData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the battery to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime battery data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . BATTERY , ) return self . _get_component_data_channel ( component_id , BatteryData . from_proto , ) . new_receiver ( maxsize = maxsize ) async def inverter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ InverterData ]: \"\"\"Return a channel receiver that provides an `InverterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the inverter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime inverter data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . INVERTER , ) return self . _get_component_data_channel ( component_id , InverterData . from_proto , ) . new_receiver ( maxsize = maxsize ) async def ev_charger_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ EVChargerData ]: \"\"\"Return a channel receiver that provides an `EvChargeData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the ev charger to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime ev charger data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . EV_CHARGER , ) return self . _get_component_data_channel ( component_id , EVChargerData . from_proto , ) . new_receiver ( maxsize = maxsize ) async def set_power ( self , component_id : int , power_w : int ) -> Empty : \"\"\"Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. Args: component_id: id of the component to set power. power_w: power to set for the component. Returns: Empty response. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" try : if power_w >= 0 : # grpc.aio is missing types and mypy thinks this is not # async iterable, but it is result : Empty = await self . api . Charge ( microgrid_pb . PowerLevelParam ( component_id = component_id , power_w = power_w ), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] else : # grpc.aio is missing types and mypy thinks this is not # async iterable, but it is power_w *= - 1 result = await self . api . Discharge ( microgrid_pb . PowerLevelParam ( component_id = component_id , power_w = power_w ), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] except grpc . aio . AioRpcError as err : msg = f \"Failed to set power. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) return result async def set_bounds ( self , component_id : int , lower : float , upper : float , ) -> None : \"\"\"Send `SetBoundsParam`s received from a channel to nitrogen. Args: component_id: ID of the component to set bounds for. lower: Lower bound to be set for the component. upper: Upper bound to be set for the component. Raises: ValueError: when upper bound is less than 0, or when lower bound is greater than 0. grpc.aio.AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" api_details = f \"Microgrid API: { self . target } .\" if upper < 0 : raise ValueError ( f \"Upper bound { upper } must be greater than or equal to 0.\" ) if lower > 0 : raise ValueError ( f \"Lower bound { upper } must be less than or equal to 0.\" ) # grpc.aio is missing types and mypy thinks request_iterator is # a required argument, but it is not set_bounds_call = self . api . SetBounds ( timeout = DEFAULT_GRPC_CALL_TIMEOUT , ) # type: ignore[call-arg] try : # grpc.aio is missing types and mypy thinks set_bounds_call can be Empty assert not isinstance ( set_bounds_call , Empty ) await set_bounds_call . write ( microgrid_pb . SetBoundsParam ( component_id = component_id , # pylint: disable=no-member,line-too-long target_metric = microgrid_pb . SetBoundsParam . TargetMetric . TARGET_METRIC_POWER_ACTIVE , bounds = common_pb . Bounds ( lower = lower , upper = upper ), ), ) except grpc . aio . AioRpcError as err : logger . error ( \"set_bounds write failed: %s , for message: %s , api: %s . Err: %s \" , err , next , api_details , err . details (), ) raise","title":"MicrogridGrpcClient"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.__init__","text":"Initialize the class instance. PARAMETER DESCRIPTION grpc_channel asyncio-supporting gRPC channel TYPE: grpc . aio . Channel target server (host:port) to be used for asyncio-supporting gRPC channel that the client should use to contact the API TYPE: str retry_spec Specs on how to retry if the connection to a streaming method gets lost. TYPE: RetryStrategy DEFAULT: LinearBackoff() Source code in frequenz/sdk/microgrid/client/_client.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def __init__ ( self , grpc_channel : grpc . aio . Channel , target : str , retry_spec : RetryStrategy = LinearBackoff (), ) -> None : \"\"\"Initialize the class instance. Args: grpc_channel: asyncio-supporting gRPC channel target: server (host:port) to be used for asyncio-supporting gRPC channel that the client should use to contact the API retry_spec: Specs on how to retry if the connection to a streaming method gets lost. \"\"\" self . target = target self . api = MicrogridStub ( grpc_channel ) self . _component_streams : Dict [ int , Broadcast [ Any ]] = {} self . _retry_spec = retry_spec","title":"__init__()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.battery_data","text":"Return a channel receiver that provides a BatteryData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. RAISES DESCRIPTION ValueError if the given id is unknown or has a different type. PARAMETER DESCRIPTION component_id id of the battery to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ BatteryData ] A channel receiver that provides realtime battery data. Source code in frequenz/sdk/microgrid/client/_client.py 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 async def battery_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ BatteryData ]: \"\"\"Return a channel receiver that provides a `BatteryData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the battery to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime battery data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . BATTERY , ) return self . _get_component_data_channel ( component_id , BatteryData . from_proto , ) . new_receiver ( maxsize = maxsize )","title":"battery_data()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.components","text":"Fetch all the components present in the microgrid. RETURNS DESCRIPTION Iterable [ Component ] Iterator whose elements are all the components in the microgrid. RAISES DESCRIPTION AioRpcError if connection to Microgrid API cannot be established or when the api call exceeded timeout Source code in frequenz/sdk/microgrid/client/_client.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 async def components ( self ) -> Iterable [ Component ]: \"\"\"Fetch all the components present in the microgrid. Returns: Iterator whose elements are all the components in the microgrid. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" try : # grpc.aio is missing types and mypy thinks this is not awaitable, # but it is component_list = await self . api . ListComponents ( microgrid_pb . ComponentFilter (), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] except grpc . aio . AioRpcError as err : msg = f \"Failed to list components. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) components_only = filter ( lambda c : c . category not in ( microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_SENSOR , microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_LOAD , ), component_list . components , ) result : Iterable [ Component ] = map ( lambda c : Component ( c . id , _component_category_from_protobuf ( c . category ), _component_type_from_protobuf ( c . category , c . inverter ), ), components_only , ) return result","title":"components()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.connections","text":"Fetch the connections between components in the microgrid. PARAMETER DESCRIPTION starts if set and non-empty, only include connections whose start value matches one of the provided component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None ends if set and non-empty, only include connections whose end value matches one of the provided component IDs TYPE: Optional [ Set [ int ]] DEFAULT: None RETURNS DESCRIPTION Iterable [ Connection ] Microgrid connections matching the provided start and end filters. RAISES DESCRIPTION AioRpcError if connection to Microgrid API cannot be established or when the api call exceeded timeout Source code in frequenz/sdk/microgrid/client/_client.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 async def connections ( self , starts : Optional [ Set [ int ]] = None , ends : Optional [ Set [ int ]] = None , ) -> Iterable [ Connection ]: \"\"\"Fetch the connections between components in the microgrid. Args: starts: if set and non-empty, only include connections whose start value matches one of the provided component IDs ends: if set and non-empty, only include connections whose end value matches one of the provided component IDs Returns: Microgrid connections matching the provided start and end filters. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" connection_filter = microgrid_pb . ConnectionFilter ( starts = starts , ends = ends ) try : valid_components , all_connections = await asyncio . gather ( self . components (), # grpc.aio is missing types and mypy thinks this is not # awaitable, but it is cast ( Awaitable [ microgrid_pb . ConnectionList ], self . api . ListConnections ( connection_filter , timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ), ), ) except grpc . aio . AioRpcError as err : msg = f \"Failed to list connections. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) # Filter out the components filtered in `components` method. # id=0 is an exception indicating grid component. valid_ids = { c . component_id for c in valid_components } valid_ids . add ( 0 ) connections = filter ( lambda c : ( c . start in valid_ids and c . end in valid_ids ), all_connections . connections , ) result : Iterable [ Connection ] = map ( lambda c : Connection ( c . start , c . end ), connections ) return result","title":"connections()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.ev_charger_data","text":"Return a channel receiver that provides an EvChargeData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. RAISES DESCRIPTION ValueError if the given id is unknown or has a different type. PARAMETER DESCRIPTION component_id id of the ev charger to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ EVChargerData ] A channel receiver that provides realtime ev charger data. Source code in frequenz/sdk/microgrid/client/_client.py 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 async def ev_charger_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ EVChargerData ]: \"\"\"Return a channel receiver that provides an `EvChargeData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the ev charger to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime ev charger data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . EV_CHARGER , ) return self . _get_component_data_channel ( component_id , EVChargerData . from_proto , ) . new_receiver ( maxsize = maxsize )","title":"ev_charger_data()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.inverter_data","text":"Return a channel receiver that provides an InverterData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. RAISES DESCRIPTION ValueError if the given id is unknown or has a different type. PARAMETER DESCRIPTION component_id id of the inverter to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ InverterData ] A channel receiver that provides realtime inverter data. Source code in frequenz/sdk/microgrid/client/_client.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 async def inverter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ InverterData ]: \"\"\"Return a channel receiver that provides an `InverterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the inverter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime inverter data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . INVERTER , ) return self . _get_component_data_channel ( component_id , InverterData . from_proto , ) . new_receiver ( maxsize = maxsize )","title":"inverter_data()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.meter_data","text":"Return a channel receiver that provides a MeterData stream. If only the latest value is required, the Receiver returned by this method can be converted into a Peekable with the into_peekable method on the Receiver. RAISES DESCRIPTION ValueError if the given id is unknown or has a different type. PARAMETER DESCRIPTION component_id id of the meter to get data for. TYPE: int maxsize Size of the receiver's buffer. TYPE: int DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ MeterData ] A channel receiver that provides realtime meter data. Source code in frequenz/sdk/microgrid/client/_client.py 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 async def meter_data ( self , component_id : int , maxsize : int = RECEIVER_MAX_SIZE , ) -> Receiver [ MeterData ]: \"\"\"Return a channel receiver that provides a `MeterData` stream. If only the latest value is required, the `Receiver` returned by this method can be converted into a `Peekable` with the `into_peekable` method on the `Receiver.` Raises: ValueError: if the given id is unknown or has a different type. Args: component_id: id of the meter to get data for. maxsize: Size of the receiver's buffer. Returns: A channel receiver that provides realtime meter data. \"\"\" await self . _expect_category ( component_id , ComponentCategory . METER , ) return self . _get_component_data_channel ( component_id , MeterData . from_proto , ) . new_receiver ( maxsize = maxsize )","title":"meter_data()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.set_bounds","text":"Send SetBoundsParam s received from a channel to nitrogen. PARAMETER DESCRIPTION component_id ID of the component to set bounds for. TYPE: int lower Lower bound to be set for the component. TYPE: float upper Upper bound to be set for the component. TYPE: float RAISES DESCRIPTION ValueError when upper bound is less than 0, or when lower bound is greater than 0. grpc . aio . AioRpcError if connection to Microgrid API cannot be established or when the api call exceeded timeout Source code in frequenz/sdk/microgrid/client/_client.py 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 async def set_bounds ( self , component_id : int , lower : float , upper : float , ) -> None : \"\"\"Send `SetBoundsParam`s received from a channel to nitrogen. Args: component_id: ID of the component to set bounds for. lower: Lower bound to be set for the component. upper: Upper bound to be set for the component. Raises: ValueError: when upper bound is less than 0, or when lower bound is greater than 0. grpc.aio.AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" api_details = f \"Microgrid API: { self . target } .\" if upper < 0 : raise ValueError ( f \"Upper bound { upper } must be greater than or equal to 0.\" ) if lower > 0 : raise ValueError ( f \"Lower bound { upper } must be less than or equal to 0.\" ) # grpc.aio is missing types and mypy thinks request_iterator is # a required argument, but it is not set_bounds_call = self . api . SetBounds ( timeout = DEFAULT_GRPC_CALL_TIMEOUT , ) # type: ignore[call-arg] try : # grpc.aio is missing types and mypy thinks set_bounds_call can be Empty assert not isinstance ( set_bounds_call , Empty ) await set_bounds_call . write ( microgrid_pb . SetBoundsParam ( component_id = component_id , # pylint: disable=no-member,line-too-long target_metric = microgrid_pb . SetBoundsParam . TargetMetric . TARGET_METRIC_POWER_ACTIVE , bounds = common_pb . Bounds ( lower = lower , upper = upper ), ), ) except grpc . aio . AioRpcError as err : logger . error ( \"set_bounds write failed: %s , for message: %s , api: %s . Err: %s \" , err , next , api_details , err . details (), ) raise","title":"set_bounds()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.set_power","text":"Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. PARAMETER DESCRIPTION component_id id of the component to set power. TYPE: int power_w power to set for the component. TYPE: int RETURNS DESCRIPTION Empty Empty response. RAISES DESCRIPTION AioRpcError if connection to Microgrid API cannot be established or when the api call exceeded timeout Source code in frequenz/sdk/microgrid/client/_client.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 async def set_power ( self , component_id : int , power_w : int ) -> Empty : \"\"\"Send request to the Microgrid to set power for component. If power > 0, then component will be charged with this power. If power < 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component. Args: component_id: id of the component to set power. power_w: power to set for the component. Returns: Empty response. Raises: AioRpcError: if connection to Microgrid API cannot be established or when the api call exceeded timeout \"\"\" try : if power_w >= 0 : # grpc.aio is missing types and mypy thinks this is not # async iterable, but it is result : Empty = await self . api . Charge ( microgrid_pb . PowerLevelParam ( component_id = component_id , power_w = power_w ), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] else : # grpc.aio is missing types and mypy thinks this is not # async iterable, but it is power_w *= - 1 result = await self . api . Discharge ( microgrid_pb . PowerLevelParam ( component_id = component_id , power_w = power_w ), timeout = DEFAULT_GRPC_CALL_TIMEOUT , # type: ignore[arg-type] ) # type: ignore[misc] except grpc . aio . AioRpcError as err : msg = f \"Failed to set power. Microgrid API: { self . target } . Err: { err . details () } \" raise grpc . aio . AioRpcError ( code = err . code (), initial_metadata = err . initial_metadata (), trailing_metadata = err . trailing_metadata (), details = msg , debug_error_string = err . debug_error_string (), ) return result","title":"set_power()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy","text":"Bases: ABC Interface for implementing retry strategies. Source code in frequenz/sdk/microgrid/client/_retry.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class RetryStrategy ( ABC ): \"\"\"Interface for implementing retry strategies.\"\"\" _limit : Optional [ int ] _count : int @abstractmethod def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\" def get_progress ( self ) -> str : \"\"\"Return a string denoting the retry progress. Returns: String denoting retry progress in the form \"(count/limit)\" \"\"\" if self . _limit is None : return f \"( { self . _count } /\u221e)\" return f \"( { self . _count } / { self . _limit } )\" def reset ( self ) -> None : \"\"\"Reset the retry counter. To be called as soon as a connection is successful. \"\"\" self . _count = 0 def copy ( self ) -> RetryStrategy : \"\"\"Create a new instance of `self`. Returns: A deepcopy of `self`. \"\"\" ret = deepcopy ( self ) ret . reset () return ret def __iter__ ( self ) -> Iterator [ float ]: \"\"\"Return an iterator over the retry intervals. Yields: Next retry interval in seconds. \"\"\" while True : interval = self . next_interval () if interval is None : break yield interval","title":"RetryStrategy"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.RetryStrategy.__iter__","text":"Return an iterator over the retry intervals. YIELDS DESCRIPTION Iterator [ float ] Next retry interval in seconds. Source code in frequenz/sdk/microgrid/client/_retry.py 62 63 64 65 66 67 68 69 70 71 72 def __iter__ ( self ) -> Iterator [ float ]: \"\"\"Return an iterator over the retry intervals. Yields: Next retry interval in seconds. \"\"\" while True : interval = self . next_interval () if interval is None : break yield interval","title":"__iter__()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.RetryStrategy.copy","text":"Create a new instance of self . RETURNS DESCRIPTION RetryStrategy A deepcopy of self . Source code in frequenz/sdk/microgrid/client/_retry.py 52 53 54 55 56 57 58 59 60 def copy ( self ) -> RetryStrategy : \"\"\"Create a new instance of `self`. Returns: A deepcopy of `self`. \"\"\" ret = deepcopy ( self ) ret . reset () return ret","title":"copy()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.RetryStrategy.get_progress","text":"Return a string denoting the retry progress. RETURNS DESCRIPTION str String denoting retry progress in the form \"(count/limit)\" Source code in frequenz/sdk/microgrid/client/_retry.py 34 35 36 37 38 39 40 41 42 43 def get_progress ( self ) -> str : \"\"\"Return a string denoting the retry progress. Returns: String denoting retry progress in the form \"(count/limit)\" \"\"\" if self . _limit is None : return f \"( { self . _count } /\u221e)\" return f \"( { self . _count } / { self . _limit } )\"","title":"get_progress()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.RetryStrategy.next_interval","text":"Return the time to wait before the next retry. Returns None if the retry limit has been reached, and no more retries are possible. RETURNS DESCRIPTION Optional [ float ] Time until next retry when below retry limit, and None otherwise. Source code in frequenz/sdk/microgrid/client/_retry.py 23 24 25 26 27 28 29 30 31 32 @abstractmethod def next_interval ( self ) -> Optional [ float ]: \"\"\"Return the time to wait before the next retry. Returns `None` if the retry limit has been reached, and no more retries are possible. Returns: Time until next retry when below retry limit, and None otherwise. \"\"\"","title":"next_interval()"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.RetryStrategy.reset","text":"Reset the retry counter. To be called as soon as a connection is successful. Source code in frequenz/sdk/microgrid/client/_retry.py 45 46 47 48 49 50 def reset ( self ) -> None : \"\"\"Reset the retry counter. To be called as soon as a connection is successful. \"\"\" self . _count = 0","title":"reset()"},{"location":"reference/frequenz/sdk/microgrid/component/","text":"frequenz.sdk.microgrid.component \u00a4 Microgrid component abstractions. This package provides classes to operate con microgrid components. Classes \u00a4 frequenz.sdk.microgrid.component.BatteryData dataclass \u00a4 Bases: ComponentData A wrapper class for holding battery data. Source code in frequenz/sdk/microgrid/component/_component_data.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @dataclass ( frozen = True ) class BatteryData ( ComponentData ): \"\"\"A wrapper class for holding battery data.\"\"\" soc : float \"\"\"Battery's overall SoC in percent (%).\"\"\" soc_lower_bound : float \"\"\"The SoC below which discharge commands will be blocked by the system, in percent (%). \"\"\" soc_upper_bound : float \"\"\"The SoC above which charge commands will be blocked by the system, in percent (%). \"\"\" capacity : float \"\"\"The capacity of the battery in Wh (Watt-hour).\"\"\" power_lower_bound : float \"\"\"The maximum discharge power, in watts, represented in the passive sign convention. this will be a negative number, or zero if no discharging is possible. \"\"\" power_upper_bound : float \"\"\"The maximum charge power, in Watts, represented in the passive sign convention. This will be a positive number, or zero if no charging is possible. \"\"\" temperature_max : float \"\"\"The maximum temperature of all the blocks in a battery, in Celcius (\u00b0C).\"\"\" _relay_state : battery_pb . RelayState . ValueType \"\"\"State of the battery relay.\"\"\" _component_state : battery_pb . ComponentState . ValueType \"\"\"State of the battery.\"\"\" _errors : List [ battery_pb . Error ] \"\"\"List of errors in protobuf struct.\"\"\" @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> BatteryData : \"\"\"Create BatteryData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of BatteryData created from the protobuf message. \"\"\" battery_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), soc = raw . battery . data . soc . avg , soc_lower_bound = raw . battery . data . soc . system_bounds . lower , soc_upper_bound = raw . battery . data . soc . system_bounds . upper , capacity = raw . battery . properties . capacity , power_lower_bound = raw . battery . data . dc . power . system_bounds . lower , power_upper_bound = raw . battery . data . dc . power . system_bounds . upper , temperature_max = raw . battery . data . temperature . max , _relay_state = raw . battery . state . relay_state , _component_state = raw . battery . state . component_state , _errors = list ( raw . battery . errors ), ) battery_data . _set_raw ( raw = raw ) return battery_data Attributes \u00a4 capacity : float class-attribute \u00a4 The capacity of the battery in Wh (Watt-hour). power_lower_bound : float class-attribute \u00a4 The maximum discharge power, in watts, represented in the passive sign convention. this will be a negative number, or zero if no discharging is possible. power_upper_bound : float class-attribute \u00a4 The maximum charge power, in Watts, represented in the passive sign convention. This will be a positive number, or zero if no charging is possible. soc : float class-attribute \u00a4 Battery's overall SoC in percent (%). soc_lower_bound : float class-attribute \u00a4 The SoC below which discharge commands will be blocked by the system, in percent (%). soc_upper_bound : float class-attribute \u00a4 The SoC above which charge commands will be blocked by the system, in percent (%). temperature_max : float class-attribute \u00a4 The maximum temperature of all the blocks in a battery, in Celcius (\u00b0C). Functions \u00a4 from_proto ( raw ) classmethod \u00a4 Create BatteryData from a protobuf message. PARAMETER DESCRIPTION raw raw component data as decoded from the wire. TYPE: microgrid_pb . ComponentData RETURNS DESCRIPTION BatteryData Instance of BatteryData created from the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_data.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> BatteryData : \"\"\"Create BatteryData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of BatteryData created from the protobuf message. \"\"\" battery_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), soc = raw . battery . data . soc . avg , soc_lower_bound = raw . battery . data . soc . system_bounds . lower , soc_upper_bound = raw . battery . data . soc . system_bounds . upper , capacity = raw . battery . properties . capacity , power_lower_bound = raw . battery . data . dc . power . system_bounds . lower , power_upper_bound = raw . battery . data . dc . power . system_bounds . upper , temperature_max = raw . battery . data . temperature . max , _relay_state = raw . battery . state . relay_state , _component_state = raw . battery . state . component_state , _errors = list ( raw . battery . errors ), ) battery_data . _set_raw ( raw = raw ) return battery_data frequenz.sdk.microgrid.component.Component dataclass \u00a4 Metadata for a single microgrid component. Source code in frequenz/sdk/microgrid/component/_component.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @dataclass ( frozen = True ) class Component : \"\"\"Metadata for a single microgrid component.\"\"\" component_id : int category : ComponentCategory type : Optional [ ComponentType ] = None def is_valid ( self ) -> bool : \"\"\"Check if this instance contains valid data. Returns: `True` if `id > 0` and `type` is a valid `ComponentCategory`, or if `id == 0` and `type` is `GRID`, `False` otherwise \"\"\" return ( self . component_id > 0 and any ( t == self . category for t in ComponentCategory ) ) or ( self . component_id == 0 and self . category == ComponentCategory . GRID ) Functions \u00a4 is_valid () \u00a4 Check if this instance contains valid data. RETURNS DESCRIPTION bool True if id > 0 and type is a valid ComponentCategory , or if id == 0 and type is GRID , False otherwise Source code in frequenz/sdk/microgrid/component/_component.py 109 110 111 112 113 114 115 116 117 118 def is_valid ( self ) -> bool : \"\"\"Check if this instance contains valid data. Returns: `True` if `id > 0` and `type` is a valid `ComponentCategory`, or if `id == 0` and `type` is `GRID`, `False` otherwise \"\"\" return ( self . component_id > 0 and any ( t == self . category for t in ComponentCategory ) ) or ( self . component_id == 0 and self . category == ComponentCategory . GRID ) frequenz.sdk.microgrid.component.ComponentCategory \u00a4 Bases: Enum Possible types of microgrid component. Source code in frequenz/sdk/microgrid/component/_component.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class ComponentCategory ( Enum ): \"\"\"Possible types of microgrid component.\"\"\" NONE = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_UNSPECIFIED GRID = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_GRID JUNCTION = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_JUNCTION METER = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_METER INVERTER = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_INVERTER BATTERY = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_BATTERY EV_CHARGER = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_EV_CHARGER LOAD = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_LOAD # types not yet supported by the API but which can be inferred # from available graph info PV_ARRAY = 1000001 CHP = 1000002 # combined heat and power plant frequenz.sdk.microgrid.component.ComponentData dataclass \u00a4 Bases: ABC A private base class for strongly typed component data classes. Source code in frequenz/sdk/microgrid/component/_component_data.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @dataclass ( frozen = True ) class ComponentData ( ABC ): \"\"\"A private base class for strongly typed component data classes.\"\"\" component_id : int \"\"\"The ID identifying this component in the microgrid.\"\"\" timestamp : datetime \"\"\"The timestamp of when the data was measured.\"\"\" # The `raw` attribute is excluded from the constructor as it can only be provided # when instantiating `ComponentData` using the `from_proto` method, which reads # data from a protobuf message. The whole protobuf message is stored as the `raw` # attribute. When `ComponentData` is not instantiated from a protobuf message, # i.e. using the constructor, `raw` will be set to `None`. raw : Optional [ microgrid_pb . ComponentData ] = field ( default = None , init = False ) \"\"\"Raw component data as decoded from the wire.\"\"\" def _set_raw ( self , raw : microgrid_pb . ComponentData ) -> None : \"\"\"Store raw protobuf message. It is preferred to keep the dataclasses immutable (frozen) and make the `raw` attribute read-only, which is why the approach of writing to `__dict__` was used, instead of mutating the `self.raw = raw` attribute directly. Args: raw: raw component data as decoded from the wire. \"\"\" self . __dict__ [ \"raw\" ] = raw @classmethod @abstractmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> ComponentData : \"\"\"Create ComponentData from a protobuf message. Args: raw: raw component data as decoded from the wire. \"\"\" Attributes \u00a4 component_id : int class-attribute \u00a4 The ID identifying this component in the microgrid. raw : Optional [ microgrid_pb . ComponentData ] = field ( default = None , init = False ) class-attribute \u00a4 Raw component data as decoded from the wire. timestamp : datetime class-attribute \u00a4 The timestamp of when the data was measured. Functions \u00a4 from_proto ( raw ) abstractmethod classmethod \u00a4 Create ComponentData from a protobuf message. PARAMETER DESCRIPTION raw raw component data as decoded from the wire. TYPE: microgrid_pb . ComponentData Source code in frequenz/sdk/microgrid/component/_component_data.py 49 50 51 52 53 54 55 56 @classmethod @abstractmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> ComponentData : \"\"\"Create ComponentData from a protobuf message. Args: raw: raw component data as decoded from the wire. \"\"\" frequenz.sdk.microgrid.component.ComponentMetricId \u00a4 Bases: Enum An enum representing the various metrics available in the microgrid. Source code in frequenz/sdk/microgrid/component/_component.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class ComponentMetricId ( Enum ): \"\"\"An enum representing the various metrics available in the microgrid.\"\"\" ACTIVE_POWER = \"active_power\" CURRENT_PHASE_1 = \"current_phase_1\" CURRENT_PHASE_2 = \"current_phase_2\" CURRENT_PHASE_3 = \"current_phase_3\" VOLTAGE_PHASE_1 = \"voltage_phase_1\" VOLTAGE_PHASE_2 = \"voltage_phase_2\" VOLTAGE_PHASE_3 = \"voltage_phase_3\" SOC = \"soc\" SOC_LOWER_BOUND = \"soc_lower_bound\" SOC_UPPER_BOUND = \"soc_upper_bound\" CAPACITY = \"capacity\" POWER_LOWER_BOUND = \"power_lower_bound\" POWER_UPPER_BOUND = \"power_upper_bound\" ACTIVE_POWER_LOWER_BOUND = \"active_power_lower_bound\" ACTIVE_POWER_UPPER_BOUND = \"active_power_upper_bound\" frequenz.sdk.microgrid.component.EVChargerCableState \u00a4 Bases: Enum Cable states of an EV Charger. Source code in frequenz/sdk/microgrid/component/_component_states.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class EVChargerCableState ( Enum ): \"\"\"Cable states of an EV Charger.\"\"\" UNSPECIFIED = ev_charger_pb . CableState . CABLE_STATE_UNSPECIFIED UNPLUGGED = ev_charger_pb . CableState . CABLE_STATE_UNPLUGGED CHARGING_STATION_PLUGGED = ( ev_charger_pb . CableState . CABLE_STATE_CHARGING_STATION_PLUGGED ) CHARGING_STATION_LOCKED = ( ev_charger_pb . CableState . CABLE_STATE_CHARGING_STATION_LOCKED ) EV_PLUGGED = ev_charger_pb . CableState . CABLE_STATE_EV_PLUGGED EV_LOCKED = ev_charger_pb . CableState . CABLE_STATE_EV_LOCKED @classmethod def from_pb ( cls , evc_state : ev_charger_pb . CableState . ValueType ) -> EVChargerCableState : \"\"\"Convert a protobuf CableState value to EVChargerCableState enum. Args: evc_state: protobuf cable state to convert. Returns: Enum value corresponding to the protobuf message. \"\"\" if not any ( t . value == evc_state for t in EVChargerCableState ): return cls . UNSPECIFIED return EVChargerCableState ( evc_state ) Functions \u00a4 from_pb ( evc_state ) classmethod \u00a4 Convert a protobuf CableState value to EVChargerCableState enum. PARAMETER DESCRIPTION evc_state protobuf cable state to convert. TYPE: ev_charger_pb . CableState . ValueType RETURNS DESCRIPTION EVChargerCableState Enum value corresponding to the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_states.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @classmethod def from_pb ( cls , evc_state : ev_charger_pb . CableState . ValueType ) -> EVChargerCableState : \"\"\"Convert a protobuf CableState value to EVChargerCableState enum. Args: evc_state: protobuf cable state to convert. Returns: Enum value corresponding to the protobuf message. \"\"\" if not any ( t . value == evc_state for t in EVChargerCableState ): return cls . UNSPECIFIED return EVChargerCableState ( evc_state ) frequenz.sdk.microgrid.component.EVChargerComponentState \u00a4 Bases: Enum Component State of an EV Charger. Source code in frequenz/sdk/microgrid/component/_component_states.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class EVChargerComponentState ( Enum ): \"\"\"Component State of an EV Charger.\"\"\" UNSPECIFIED = ev_charger_pb . ComponentState . COMPONENT_STATE_UNSPECIFIED STARTING = ev_charger_pb . ComponentState . COMPONENT_STATE_STARTING NOT_READY = ev_charger_pb . ComponentState . COMPONENT_STATE_NOT_READY READY = ev_charger_pb . ComponentState . COMPONENT_STATE_READY CHARGING = ev_charger_pb . ComponentState . COMPONENT_STATE_CHARGING DISCHARGING = ev_charger_pb . ComponentState . COMPONENT_STATE_DISCHARGING ERROR = ev_charger_pb . ComponentState . COMPONENT_STATE_ERROR AUTHORIZATION_REJECTED = ( ev_charger_pb . ComponentState . COMPONENT_STATE_AUTHORIZATION_REJECTED ) INTERRUPTED = ev_charger_pb . ComponentState . COMPONENT_STATE_INTERRUPTED @classmethod def from_pb ( cls , evc_state : ev_charger_pb . ComponentState . ValueType ) -> EVChargerComponentState : \"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum. Args: evc_state: protobuf component state to convert. Returns: Enum value corresponding to the protobuf message. \"\"\" if not any ( t . value == evc_state for t in EVChargerComponentState ): return cls . UNSPECIFIED return EVChargerComponentState ( evc_state ) Functions \u00a4 from_pb ( evc_state ) classmethod \u00a4 Convert a protobuf ComponentState value to EVChargerComponentState enum. PARAMETER DESCRIPTION evc_state protobuf component state to convert. TYPE: ev_charger_pb . ComponentState . ValueType RETURNS DESCRIPTION EVChargerComponentState Enum value corresponding to the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_states.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @classmethod def from_pb ( cls , evc_state : ev_charger_pb . ComponentState . ValueType ) -> EVChargerComponentState : \"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum. Args: evc_state: protobuf component state to convert. Returns: Enum value corresponding to the protobuf message. \"\"\" if not any ( t . value == evc_state for t in EVChargerComponentState ): return cls . UNSPECIFIED return EVChargerComponentState ( evc_state ) frequenz.sdk.microgrid.component.EVChargerData dataclass \u00a4 Bases: ComponentData A wrapper class for holding ev_charger data. Source code in frequenz/sdk/microgrid/component/_component_data.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 @dataclass ( frozen = True ) class EVChargerData ( ComponentData ): \"\"\"A wrapper class for holding ev_charger data.\"\"\" active_power : float \"\"\"The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid. \"\"\" current_per_phase : Tuple [ float , float , float ] \"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid. \"\"\" voltage_per_phase : Tuple [ float , float , float ] \"\"\"The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1,2 and 3 respectively. \"\"\" cable_state : EVChargerCableState \"\"\"The state of the ev charger's cable.\"\"\" component_state : EVChargerComponentState \"\"\"The state of the ev charger.\"\"\" @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> EVChargerData : \"\"\"Create EVChargerData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of EVChargerData created from the protobuf message. \"\"\" ev_charger_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . ev_charger . data . ac . power_active . value , current_per_phase = ( raw . ev_charger . data . ac . phase_1 . current . value , raw . ev_charger . data . ac . phase_2 . current . value , raw . ev_charger . data . ac . phase_3 . current . value , ), voltage_per_phase = ( raw . ev_charger . data . ac . phase_1 . voltage . value , raw . ev_charger . data . ac . phase_2 . voltage . value , raw . ev_charger . data . ac . phase_3 . voltage . value , ), cable_state = EVChargerCableState . from_pb ( raw . ev_charger . state . cable_state ), component_state = EVChargerComponentState . from_pb ( raw . ev_charger . state . component_state ), ) ev_charger_data . _set_raw ( raw = raw ) return ev_charger_data Attributes \u00a4 active_power : float class-attribute \u00a4 The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid. cable_state : EVChargerCableState class-attribute \u00a4 The state of the ev charger's cable. component_state : EVChargerComponentState class-attribute \u00a4 The state of the ev charger. current_per_phase : Tuple [ float , float , float ] class-attribute \u00a4 AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid. voltage_per_phase : Tuple [ float , float , float ] class-attribute \u00a4 The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1,2 and 3 respectively. Functions \u00a4 from_proto ( raw ) classmethod \u00a4 Create EVChargerData from a protobuf message. PARAMETER DESCRIPTION raw raw component data as decoded from the wire. TYPE: microgrid_pb . ComponentData RETURNS DESCRIPTION EVChargerData Instance of EVChargerData created from the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_data.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> EVChargerData : \"\"\"Create EVChargerData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of EVChargerData created from the protobuf message. \"\"\" ev_charger_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . ev_charger . data . ac . power_active . value , current_per_phase = ( raw . ev_charger . data . ac . phase_1 . current . value , raw . ev_charger . data . ac . phase_2 . current . value , raw . ev_charger . data . ac . phase_3 . current . value , ), voltage_per_phase = ( raw . ev_charger . data . ac . phase_1 . voltage . value , raw . ev_charger . data . ac . phase_2 . voltage . value , raw . ev_charger . data . ac . phase_3 . voltage . value , ), cable_state = EVChargerCableState . from_pb ( raw . ev_charger . state . cable_state ), component_state = EVChargerComponentState . from_pb ( raw . ev_charger . state . component_state ), ) ev_charger_data . _set_raw ( raw = raw ) return ev_charger_data frequenz.sdk.microgrid.component.InverterData dataclass \u00a4 Bases: ComponentData A wrapper class for holding inverter data. Source code in frequenz/sdk/microgrid/component/_component_data.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @dataclass ( frozen = True ) class InverterData ( ComponentData ): \"\"\"A wrapper class for holding inverter data.\"\"\" active_power : float \"\"\"The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid. \"\"\" active_power_lower_bound : float \"\"\"The maximum discharge power, in Watts, represented in the passive sign convention. This will be a negative number, or zero if no discharging is possible. \"\"\" active_power_upper_bound : float \"\"\"The maximum charge power, in Watts, represented in the passive sign convention. This will be a positive number, or zero if no charging is possible. \"\"\" _component_state : inverter_pb . ComponentState . ValueType \"\"\"State of the inverter.\"\"\" _errors : List [ inverter_pb . Error ] \"\"\"List of errors from the component.\"\"\" @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> InverterData : \"\"\"Create InverterData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of InverterData created from the protobuf message. \"\"\" inverter_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . inverter . data . ac . power_active . value , active_power_lower_bound = raw . inverter . data . ac . power_active . system_bounds . lower , active_power_upper_bound = raw . inverter . data . ac . power_active . system_bounds . upper , _component_state = raw . inverter . state . component_state , _errors = list ( raw . inverter . errors ), ) inverter_data . _set_raw ( raw = raw ) return inverter_data Attributes \u00a4 active_power : float class-attribute \u00a4 The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid. active_power_lower_bound : float class-attribute \u00a4 The maximum discharge power, in Watts, represented in the passive sign convention. This will be a negative number, or zero if no discharging is possible. active_power_upper_bound : float class-attribute \u00a4 The maximum charge power, in Watts, represented in the passive sign convention. This will be a positive number, or zero if no charging is possible. Functions \u00a4 from_proto ( raw ) classmethod \u00a4 Create InverterData from a protobuf message. PARAMETER DESCRIPTION raw raw component data as decoded from the wire. TYPE: microgrid_pb . ComponentData RETURNS DESCRIPTION InverterData Instance of InverterData created from the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_data.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> InverterData : \"\"\"Create InverterData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of InverterData created from the protobuf message. \"\"\" inverter_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . inverter . data . ac . power_active . value , active_power_lower_bound = raw . inverter . data . ac . power_active . system_bounds . lower , active_power_upper_bound = raw . inverter . data . ac . power_active . system_bounds . upper , _component_state = raw . inverter . state . component_state , _errors = list ( raw . inverter . errors ), ) inverter_data . _set_raw ( raw = raw ) return inverter_data frequenz.sdk.microgrid.component.InverterType \u00a4 Bases: ComponentType Enum representing inverter types. Source code in frequenz/sdk/microgrid/component/_component.py 20 21 22 23 24 25 26 class InverterType ( ComponentType ): \"\"\"Enum representing inverter types.\"\"\" NONE = inverter_pb . Type . TYPE_UNSPECIFIED BATTERY = inverter_pb . Type . TYPE_BATTERY SOLAR = inverter_pb . Type . TYPE_SOLAR HYBRID = inverter_pb . Type . TYPE_HYBRID frequenz.sdk.microgrid.component.MeterData dataclass \u00a4 Bases: ComponentData A wrapper class for holding meter data. Source code in frequenz/sdk/microgrid/component/_component_data.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @dataclass ( frozen = True ) class MeterData ( ComponentData ): \"\"\"A wrapper class for holding meter data.\"\"\" active_power : float \"\"\"The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid. \"\"\" current_per_phase : Tuple [ float , float , float ] \"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid. \"\"\" voltage_per_phase : Tuple [ float , float , float ] \"\"\"The ac voltage in volts (v) between the line and the neutral wire for phase/line 1,2 and 3 respectively. \"\"\" frequency : float \"\"\"The AC power frequency in Hertz (Hz).\"\"\" @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> MeterData : \"\"\"Create MeterData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of MeterData created from the protobuf message. \"\"\" meter_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . meter . data . ac . power_active . value , current_per_phase = ( raw . meter . data . ac . phase_1 . current . value , raw . meter . data . ac . phase_2 . current . value , raw . meter . data . ac . phase_3 . current . value , ), voltage_per_phase = ( raw . meter . data . ac . phase_1 . voltage . value , raw . meter . data . ac . phase_2 . voltage . value , raw . meter . data . ac . phase_3 . voltage . value , ), frequency = raw . meter . data . ac . frequency . value , ) meter_data . _set_raw ( raw = raw ) return meter_data Attributes \u00a4 active_power : float class-attribute \u00a4 The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid. current_per_phase : Tuple [ float , float , float ] class-attribute \u00a4 AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid. frequency : float class-attribute \u00a4 The AC power frequency in Hertz (Hz). voltage_per_phase : Tuple [ float , float , float ] class-attribute \u00a4 The ac voltage in volts (v) between the line and the neutral wire for phase/line 1,2 and 3 respectively. Functions \u00a4 from_proto ( raw ) classmethod \u00a4 Create MeterData from a protobuf message. PARAMETER DESCRIPTION raw raw component data as decoded from the wire. TYPE: microgrid_pb . ComponentData RETURNS DESCRIPTION MeterData Instance of MeterData created from the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_data.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> MeterData : \"\"\"Create MeterData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of MeterData created from the protobuf message. \"\"\" meter_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . meter . data . ac . power_active . value , current_per_phase = ( raw . meter . data . ac . phase_1 . current . value , raw . meter . data . ac . phase_2 . current . value , raw . meter . data . ac . phase_3 . current . value , ), voltage_per_phase = ( raw . meter . data . ac . phase_1 . voltage . value , raw . meter . data . ac . phase_2 . voltage . value , raw . meter . data . ac . phase_3 . voltage . value , ), frequency = raw . meter . data . ac . frequency . value , ) meter_data . _set_raw ( raw = raw ) return meter_data","title":"component"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component","text":"Microgrid component abstractions. This package provides classes to operate con microgrid components.","title":"component"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData","text":"Bases: ComponentData A wrapper class for holding battery data. Source code in frequenz/sdk/microgrid/component/_component_data.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @dataclass ( frozen = True ) class BatteryData ( ComponentData ): \"\"\"A wrapper class for holding battery data.\"\"\" soc : float \"\"\"Battery's overall SoC in percent (%).\"\"\" soc_lower_bound : float \"\"\"The SoC below which discharge commands will be blocked by the system, in percent (%). \"\"\" soc_upper_bound : float \"\"\"The SoC above which charge commands will be blocked by the system, in percent (%). \"\"\" capacity : float \"\"\"The capacity of the battery in Wh (Watt-hour).\"\"\" power_lower_bound : float \"\"\"The maximum discharge power, in watts, represented in the passive sign convention. this will be a negative number, or zero if no discharging is possible. \"\"\" power_upper_bound : float \"\"\"The maximum charge power, in Watts, represented in the passive sign convention. This will be a positive number, or zero if no charging is possible. \"\"\" temperature_max : float \"\"\"The maximum temperature of all the blocks in a battery, in Celcius (\u00b0C).\"\"\" _relay_state : battery_pb . RelayState . ValueType \"\"\"State of the battery relay.\"\"\" _component_state : battery_pb . ComponentState . ValueType \"\"\"State of the battery.\"\"\" _errors : List [ battery_pb . Error ] \"\"\"List of errors in protobuf struct.\"\"\" @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> BatteryData : \"\"\"Create BatteryData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of BatteryData created from the protobuf message. \"\"\" battery_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), soc = raw . battery . data . soc . avg , soc_lower_bound = raw . battery . data . soc . system_bounds . lower , soc_upper_bound = raw . battery . data . soc . system_bounds . upper , capacity = raw . battery . properties . capacity , power_lower_bound = raw . battery . data . dc . power . system_bounds . lower , power_upper_bound = raw . battery . data . dc . power . system_bounds . upper , temperature_max = raw . battery . data . temperature . max , _relay_state = raw . battery . state . relay_state , _component_state = raw . battery . state . component_state , _errors = list ( raw . battery . errors ), ) battery_data . _set_raw ( raw = raw ) return battery_data","title":"BatteryData"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.capacity","text":"The capacity of the battery in Wh (Watt-hour).","title":"capacity"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.power_lower_bound","text":"The maximum discharge power, in watts, represented in the passive sign convention. this will be a negative number, or zero if no discharging is possible.","title":"power_lower_bound"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.power_upper_bound","text":"The maximum charge power, in Watts, represented in the passive sign convention. This will be a positive number, or zero if no charging is possible.","title":"power_upper_bound"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.soc","text":"Battery's overall SoC in percent (%).","title":"soc"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.soc_lower_bound","text":"The SoC below which discharge commands will be blocked by the system, in percent (%).","title":"soc_lower_bound"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.soc_upper_bound","text":"The SoC above which charge commands will be blocked by the system, in percent (%).","title":"soc_upper_bound"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.temperature_max","text":"The maximum temperature of all the blocks in a battery, in Celcius (\u00b0C).","title":"temperature_max"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.from_proto","text":"Create BatteryData from a protobuf message. PARAMETER DESCRIPTION raw raw component data as decoded from the wire. TYPE: microgrid_pb . ComponentData RETURNS DESCRIPTION BatteryData Instance of BatteryData created from the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_data.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> BatteryData : \"\"\"Create BatteryData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of BatteryData created from the protobuf message. \"\"\" battery_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), soc = raw . battery . data . soc . avg , soc_lower_bound = raw . battery . data . soc . system_bounds . lower , soc_upper_bound = raw . battery . data . soc . system_bounds . upper , capacity = raw . battery . properties . capacity , power_lower_bound = raw . battery . data . dc . power . system_bounds . lower , power_upper_bound = raw . battery . data . dc . power . system_bounds . upper , temperature_max = raw . battery . data . temperature . max , _relay_state = raw . battery . state . relay_state , _component_state = raw . battery . state . component_state , _errors = list ( raw . battery . errors ), ) battery_data . _set_raw ( raw = raw ) return battery_data","title":"from_proto()"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component","text":"Metadata for a single microgrid component. Source code in frequenz/sdk/microgrid/component/_component.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @dataclass ( frozen = True ) class Component : \"\"\"Metadata for a single microgrid component.\"\"\" component_id : int category : ComponentCategory type : Optional [ ComponentType ] = None def is_valid ( self ) -> bool : \"\"\"Check if this instance contains valid data. Returns: `True` if `id > 0` and `type` is a valid `ComponentCategory`, or if `id == 0` and `type` is `GRID`, `False` otherwise \"\"\" return ( self . component_id > 0 and any ( t == self . category for t in ComponentCategory ) ) or ( self . component_id == 0 and self . category == ComponentCategory . GRID )","title":"Component"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component.Component.is_valid","text":"Check if this instance contains valid data. RETURNS DESCRIPTION bool True if id > 0 and type is a valid ComponentCategory , or if id == 0 and type is GRID , False otherwise Source code in frequenz/sdk/microgrid/component/_component.py 109 110 111 112 113 114 115 116 117 118 def is_valid ( self ) -> bool : \"\"\"Check if this instance contains valid data. Returns: `True` if `id > 0` and `type` is a valid `ComponentCategory`, or if `id == 0` and `type` is `GRID`, `False` otherwise \"\"\" return ( self . component_id > 0 and any ( t == self . category for t in ComponentCategory ) ) or ( self . component_id == 0 and self . category == ComponentCategory . GRID )","title":"is_valid()"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory","text":"Bases: Enum Possible types of microgrid component. Source code in frequenz/sdk/microgrid/component/_component.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class ComponentCategory ( Enum ): \"\"\"Possible types of microgrid component.\"\"\" NONE = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_UNSPECIFIED GRID = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_GRID JUNCTION = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_JUNCTION METER = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_METER INVERTER = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_INVERTER BATTERY = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_BATTERY EV_CHARGER = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_EV_CHARGER LOAD = microgrid_pb . ComponentCategory . COMPONENT_CATEGORY_LOAD # types not yet supported by the API but which can be inferred # from available graph info PV_ARRAY = 1000001 CHP = 1000002 # combined heat and power plant","title":"ComponentCategory"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData","text":"Bases: ABC A private base class for strongly typed component data classes. Source code in frequenz/sdk/microgrid/component/_component_data.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @dataclass ( frozen = True ) class ComponentData ( ABC ): \"\"\"A private base class for strongly typed component data classes.\"\"\" component_id : int \"\"\"The ID identifying this component in the microgrid.\"\"\" timestamp : datetime \"\"\"The timestamp of when the data was measured.\"\"\" # The `raw` attribute is excluded from the constructor as it can only be provided # when instantiating `ComponentData` using the `from_proto` method, which reads # data from a protobuf message. The whole protobuf message is stored as the `raw` # attribute. When `ComponentData` is not instantiated from a protobuf message, # i.e. using the constructor, `raw` will be set to `None`. raw : Optional [ microgrid_pb . ComponentData ] = field ( default = None , init = False ) \"\"\"Raw component data as decoded from the wire.\"\"\" def _set_raw ( self , raw : microgrid_pb . ComponentData ) -> None : \"\"\"Store raw protobuf message. It is preferred to keep the dataclasses immutable (frozen) and make the `raw` attribute read-only, which is why the approach of writing to `__dict__` was used, instead of mutating the `self.raw = raw` attribute directly. Args: raw: raw component data as decoded from the wire. \"\"\" self . __dict__ [ \"raw\" ] = raw @classmethod @abstractmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> ComponentData : \"\"\"Create ComponentData from a protobuf message. Args: raw: raw component data as decoded from the wire. \"\"\"","title":"ComponentData"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.ComponentData.component_id","text":"The ID identifying this component in the microgrid.","title":"component_id"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.ComponentData.raw","text":"Raw component data as decoded from the wire.","title":"raw"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.ComponentData.timestamp","text":"The timestamp of when the data was measured.","title":"timestamp"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.ComponentData.from_proto","text":"Create ComponentData from a protobuf message. PARAMETER DESCRIPTION raw raw component data as decoded from the wire. TYPE: microgrid_pb . ComponentData Source code in frequenz/sdk/microgrid/component/_component_data.py 49 50 51 52 53 54 55 56 @classmethod @abstractmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> ComponentData : \"\"\"Create ComponentData from a protobuf message. Args: raw: raw component data as decoded from the wire. \"\"\"","title":"from_proto()"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId","text":"Bases: Enum An enum representing the various metrics available in the microgrid. Source code in frequenz/sdk/microgrid/component/_component.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class ComponentMetricId ( Enum ): \"\"\"An enum representing the various metrics available in the microgrid.\"\"\" ACTIVE_POWER = \"active_power\" CURRENT_PHASE_1 = \"current_phase_1\" CURRENT_PHASE_2 = \"current_phase_2\" CURRENT_PHASE_3 = \"current_phase_3\" VOLTAGE_PHASE_1 = \"voltage_phase_1\" VOLTAGE_PHASE_2 = \"voltage_phase_2\" VOLTAGE_PHASE_3 = \"voltage_phase_3\" SOC = \"soc\" SOC_LOWER_BOUND = \"soc_lower_bound\" SOC_UPPER_BOUND = \"soc_upper_bound\" CAPACITY = \"capacity\" POWER_LOWER_BOUND = \"power_lower_bound\" POWER_UPPER_BOUND = \"power_upper_bound\" ACTIVE_POWER_LOWER_BOUND = \"active_power_lower_bound\" ACTIVE_POWER_UPPER_BOUND = \"active_power_upper_bound\"","title":"ComponentMetricId"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState","text":"Bases: Enum Cable states of an EV Charger. Source code in frequenz/sdk/microgrid/component/_component_states.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class EVChargerCableState ( Enum ): \"\"\"Cable states of an EV Charger.\"\"\" UNSPECIFIED = ev_charger_pb . CableState . CABLE_STATE_UNSPECIFIED UNPLUGGED = ev_charger_pb . CableState . CABLE_STATE_UNPLUGGED CHARGING_STATION_PLUGGED = ( ev_charger_pb . CableState . CABLE_STATE_CHARGING_STATION_PLUGGED ) CHARGING_STATION_LOCKED = ( ev_charger_pb . CableState . CABLE_STATE_CHARGING_STATION_LOCKED ) EV_PLUGGED = ev_charger_pb . CableState . CABLE_STATE_EV_PLUGGED EV_LOCKED = ev_charger_pb . CableState . CABLE_STATE_EV_LOCKED @classmethod def from_pb ( cls , evc_state : ev_charger_pb . CableState . ValueType ) -> EVChargerCableState : \"\"\"Convert a protobuf CableState value to EVChargerCableState enum. Args: evc_state: protobuf cable state to convert. Returns: Enum value corresponding to the protobuf message. \"\"\" if not any ( t . value == evc_state for t in EVChargerCableState ): return cls . UNSPECIFIED return EVChargerCableState ( evc_state )","title":"EVChargerCableState"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_states.EVChargerCableState.from_pb","text":"Convert a protobuf CableState value to EVChargerCableState enum. PARAMETER DESCRIPTION evc_state protobuf cable state to convert. TYPE: ev_charger_pb . CableState . ValueType RETURNS DESCRIPTION EVChargerCableState Enum value corresponding to the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_states.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @classmethod def from_pb ( cls , evc_state : ev_charger_pb . CableState . ValueType ) -> EVChargerCableState : \"\"\"Convert a protobuf CableState value to EVChargerCableState enum. Args: evc_state: protobuf cable state to convert. Returns: Enum value corresponding to the protobuf message. \"\"\" if not any ( t . value == evc_state for t in EVChargerCableState ): return cls . UNSPECIFIED return EVChargerCableState ( evc_state )","title":"from_pb()"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState","text":"Bases: Enum Component State of an EV Charger. Source code in frequenz/sdk/microgrid/component/_component_states.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class EVChargerComponentState ( Enum ): \"\"\"Component State of an EV Charger.\"\"\" UNSPECIFIED = ev_charger_pb . ComponentState . COMPONENT_STATE_UNSPECIFIED STARTING = ev_charger_pb . ComponentState . COMPONENT_STATE_STARTING NOT_READY = ev_charger_pb . ComponentState . COMPONENT_STATE_NOT_READY READY = ev_charger_pb . ComponentState . COMPONENT_STATE_READY CHARGING = ev_charger_pb . ComponentState . COMPONENT_STATE_CHARGING DISCHARGING = ev_charger_pb . ComponentState . COMPONENT_STATE_DISCHARGING ERROR = ev_charger_pb . ComponentState . COMPONENT_STATE_ERROR AUTHORIZATION_REJECTED = ( ev_charger_pb . ComponentState . COMPONENT_STATE_AUTHORIZATION_REJECTED ) INTERRUPTED = ev_charger_pb . ComponentState . COMPONENT_STATE_INTERRUPTED @classmethod def from_pb ( cls , evc_state : ev_charger_pb . ComponentState . ValueType ) -> EVChargerComponentState : \"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum. Args: evc_state: protobuf component state to convert. Returns: Enum value corresponding to the protobuf message. \"\"\" if not any ( t . value == evc_state for t in EVChargerComponentState ): return cls . UNSPECIFIED return EVChargerComponentState ( evc_state )","title":"EVChargerComponentState"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_states.EVChargerComponentState.from_pb","text":"Convert a protobuf ComponentState value to EVChargerComponentState enum. PARAMETER DESCRIPTION evc_state protobuf component state to convert. TYPE: ev_charger_pb . ComponentState . ValueType RETURNS DESCRIPTION EVChargerComponentState Enum value corresponding to the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_states.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @classmethod def from_pb ( cls , evc_state : ev_charger_pb . ComponentState . ValueType ) -> EVChargerComponentState : \"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum. Args: evc_state: protobuf component state to convert. Returns: Enum value corresponding to the protobuf message. \"\"\" if not any ( t . value == evc_state for t in EVChargerComponentState ): return cls . UNSPECIFIED return EVChargerComponentState ( evc_state )","title":"from_pb()"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData","text":"Bases: ComponentData A wrapper class for holding ev_charger data. Source code in frequenz/sdk/microgrid/component/_component_data.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 @dataclass ( frozen = True ) class EVChargerData ( ComponentData ): \"\"\"A wrapper class for holding ev_charger data.\"\"\" active_power : float \"\"\"The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid. \"\"\" current_per_phase : Tuple [ float , float , float ] \"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid. \"\"\" voltage_per_phase : Tuple [ float , float , float ] \"\"\"The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1,2 and 3 respectively. \"\"\" cable_state : EVChargerCableState \"\"\"The state of the ev charger's cable.\"\"\" component_state : EVChargerComponentState \"\"\"The state of the ev charger.\"\"\" @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> EVChargerData : \"\"\"Create EVChargerData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of EVChargerData created from the protobuf message. \"\"\" ev_charger_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . ev_charger . data . ac . power_active . value , current_per_phase = ( raw . ev_charger . data . ac . phase_1 . current . value , raw . ev_charger . data . ac . phase_2 . current . value , raw . ev_charger . data . ac . phase_3 . current . value , ), voltage_per_phase = ( raw . ev_charger . data . ac . phase_1 . voltage . value , raw . ev_charger . data . ac . phase_2 . voltage . value , raw . ev_charger . data . ac . phase_3 . voltage . value , ), cable_state = EVChargerCableState . from_pb ( raw . ev_charger . state . cable_state ), component_state = EVChargerComponentState . from_pb ( raw . ev_charger . state . component_state ), ) ev_charger_data . _set_raw ( raw = raw ) return ev_charger_data","title":"EVChargerData"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.active_power","text":"The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.","title":"active_power"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.cable_state","text":"The state of the ev charger's cable.","title":"cable_state"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.component_state","text":"The state of the ev charger.","title":"component_state"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.current_per_phase","text":"AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.","title":"current_per_phase"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.voltage_per_phase","text":"The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1,2 and 3 respectively.","title":"voltage_per_phase"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.from_proto","text":"Create EVChargerData from a protobuf message. PARAMETER DESCRIPTION raw raw component data as decoded from the wire. TYPE: microgrid_pb . ComponentData RETURNS DESCRIPTION EVChargerData Instance of EVChargerData created from the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_data.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> EVChargerData : \"\"\"Create EVChargerData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of EVChargerData created from the protobuf message. \"\"\" ev_charger_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . ev_charger . data . ac . power_active . value , current_per_phase = ( raw . ev_charger . data . ac . phase_1 . current . value , raw . ev_charger . data . ac . phase_2 . current . value , raw . ev_charger . data . ac . phase_3 . current . value , ), voltage_per_phase = ( raw . ev_charger . data . ac . phase_1 . voltage . value , raw . ev_charger . data . ac . phase_2 . voltage . value , raw . ev_charger . data . ac . phase_3 . voltage . value , ), cable_state = EVChargerCableState . from_pb ( raw . ev_charger . state . cable_state ), component_state = EVChargerComponentState . from_pb ( raw . ev_charger . state . component_state ), ) ev_charger_data . _set_raw ( raw = raw ) return ev_charger_data","title":"from_proto()"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData","text":"Bases: ComponentData A wrapper class for holding inverter data. Source code in frequenz/sdk/microgrid/component/_component_data.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @dataclass ( frozen = True ) class InverterData ( ComponentData ): \"\"\"A wrapper class for holding inverter data.\"\"\" active_power : float \"\"\"The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid. \"\"\" active_power_lower_bound : float \"\"\"The maximum discharge power, in Watts, represented in the passive sign convention. This will be a negative number, or zero if no discharging is possible. \"\"\" active_power_upper_bound : float \"\"\"The maximum charge power, in Watts, represented in the passive sign convention. This will be a positive number, or zero if no charging is possible. \"\"\" _component_state : inverter_pb . ComponentState . ValueType \"\"\"State of the inverter.\"\"\" _errors : List [ inverter_pb . Error ] \"\"\"List of errors from the component.\"\"\" @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> InverterData : \"\"\"Create InverterData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of InverterData created from the protobuf message. \"\"\" inverter_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . inverter . data . ac . power_active . value , active_power_lower_bound = raw . inverter . data . ac . power_active . system_bounds . lower , active_power_upper_bound = raw . inverter . data . ac . power_active . system_bounds . upper , _component_state = raw . inverter . state . component_state , _errors = list ( raw . inverter . errors ), ) inverter_data . _set_raw ( raw = raw ) return inverter_data","title":"InverterData"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.InverterData.active_power","text":"The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.","title":"active_power"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.InverterData.active_power_lower_bound","text":"The maximum discharge power, in Watts, represented in the passive sign convention. This will be a negative number, or zero if no discharging is possible.","title":"active_power_lower_bound"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.InverterData.active_power_upper_bound","text":"The maximum charge power, in Watts, represented in the passive sign convention. This will be a positive number, or zero if no charging is possible.","title":"active_power_upper_bound"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.InverterData.from_proto","text":"Create InverterData from a protobuf message. PARAMETER DESCRIPTION raw raw component data as decoded from the wire. TYPE: microgrid_pb . ComponentData RETURNS DESCRIPTION InverterData Instance of InverterData created from the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_data.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> InverterData : \"\"\"Create InverterData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of InverterData created from the protobuf message. \"\"\" inverter_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . inverter . data . ac . power_active . value , active_power_lower_bound = raw . inverter . data . ac . power_active . system_bounds . lower , active_power_upper_bound = raw . inverter . data . ac . power_active . system_bounds . upper , _component_state = raw . inverter . state . component_state , _errors = list ( raw . inverter . errors ), ) inverter_data . _set_raw ( raw = raw ) return inverter_data","title":"from_proto()"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType","text":"Bases: ComponentType Enum representing inverter types. Source code in frequenz/sdk/microgrid/component/_component.py 20 21 22 23 24 25 26 class InverterType ( ComponentType ): \"\"\"Enum representing inverter types.\"\"\" NONE = inverter_pb . Type . TYPE_UNSPECIFIED BATTERY = inverter_pb . Type . TYPE_BATTERY SOLAR = inverter_pb . Type . TYPE_SOLAR HYBRID = inverter_pb . Type . TYPE_HYBRID","title":"InverterType"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData","text":"Bases: ComponentData A wrapper class for holding meter data. Source code in frequenz/sdk/microgrid/component/_component_data.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @dataclass ( frozen = True ) class MeterData ( ComponentData ): \"\"\"A wrapper class for holding meter data.\"\"\" active_power : float \"\"\"The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid. \"\"\" current_per_phase : Tuple [ float , float , float ] \"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid. \"\"\" voltage_per_phase : Tuple [ float , float , float ] \"\"\"The ac voltage in volts (v) between the line and the neutral wire for phase/line 1,2 and 3 respectively. \"\"\" frequency : float \"\"\"The AC power frequency in Hertz (Hz).\"\"\" @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> MeterData : \"\"\"Create MeterData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of MeterData created from the protobuf message. \"\"\" meter_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . meter . data . ac . power_active . value , current_per_phase = ( raw . meter . data . ac . phase_1 . current . value , raw . meter . data . ac . phase_2 . current . value , raw . meter . data . ac . phase_3 . current . value , ), voltage_per_phase = ( raw . meter . data . ac . phase_1 . voltage . value , raw . meter . data . ac . phase_2 . voltage . value , raw . meter . data . ac . phase_3 . voltage . value , ), frequency = raw . meter . data . ac . frequency . value , ) meter_data . _set_raw ( raw = raw ) return meter_data","title":"MeterData"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.MeterData.active_power","text":"The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.","title":"active_power"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.MeterData.current_per_phase","text":"AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.","title":"current_per_phase"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.MeterData.frequency","text":"The AC power frequency in Hertz (Hz).","title":"frequency"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.MeterData.voltage_per_phase","text":"The ac voltage in volts (v) between the line and the neutral wire for phase/line 1,2 and 3 respectively.","title":"voltage_per_phase"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.MeterData.from_proto","text":"Create MeterData from a protobuf message. PARAMETER DESCRIPTION raw raw component data as decoded from the wire. TYPE: microgrid_pb . ComponentData RETURNS DESCRIPTION MeterData Instance of MeterData created from the protobuf message. Source code in frequenz/sdk/microgrid/component/_component_data.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @classmethod def from_proto ( cls , raw : microgrid_pb . ComponentData ) -> MeterData : \"\"\"Create MeterData from a protobuf message. Args: raw: raw component data as decoded from the wire. Returns: Instance of MeterData created from the protobuf message. \"\"\" meter_data = cls ( component_id = raw . id , timestamp = raw . ts . ToDatetime ( tzinfo = timezone . utc ), active_power = raw . meter . data . ac . power_active . value , current_per_phase = ( raw . meter . data . ac . phase_1 . current . value , raw . meter . data . ac . phase_2 . current . value , raw . meter . data . ac . phase_3 . current . value , ), voltage_per_phase = ( raw . meter . data . ac . phase_1 . voltage . value , raw . meter . data . ac . phase_2 . voltage . value , raw . meter . data . ac . phase_3 . voltage . value , ), frequency = raw . meter . data . ac . frequency . value , ) meter_data . _set_raw ( raw = raw ) return meter_data","title":"from_proto()"},{"location":"reference/frequenz/sdk/power/","text":"frequenz.sdk.power \u00a4 Utilities to manage power in a microgrid. Classes \u00a4 frequenz.sdk.power.DistributionAlgorithm \u00a4 Distribute power between many components. The purpose of this tool is to keep equal SoC level in the batteries. It takes total power that should be to be set for some subset of battery-inverter pairs. The total power is distributed between given battery-inverter pairs. Distribution is calculated based on data below: Battery current SoC. Battery upper and lower SoC bound. Battery capacity. Battery lower and upper power bound. Inverter lower and upper active power bound. Distribution algorithm \u00a4 Lets assume that: N - number of batteries power_w - power to distribute capacity[i] - capacity of i'th battery available_soc[i] - how much SoC remained to reach: SoC upper bound - if need to distribute power that charges inverters. SoC lower bound - if need to distribute power that discharges inverters. 0 - if SoC is outside SoC bounds. total_capacity - sum(c for c in capacity.values()) capacity_ratio[i] - capacity[i]/total_capacity We would like our distribution to meet the equation: distribution [ i ] = power_w * capacity_ratio [ i ] * x [ i ] where: sum ( capacity_ratio [ i ] * x [ i ] for i in range ( N )) == 1 Let y be our unknown, the proportion to discharge each battery would be (1): x [ i ] = available_soc [ i ] * y We can compute y from equation above (2): sum ( capacity_ratio [ i ] * x [ i ] for i in range ( N )) == 1 # => sum ( capacity_ratio [ i ] * available_soc [ i ] * y for i in range ( N )) == 1 # => y = 1 / sum ( capacity_ratio [ i ] * available_soc [ i ]) Now we know everything and we can compute distribution: distribution [ i ] = power_w * capacity_ratio [ i ] * x [ i ] # from (1) distribution [ i ] = \\ power_w * capacity_ratio [ i ] * available_soc [ i ] * y # from (2) distribution [ i ] = power_w * capacity_ratio [ i ] * available_soc [ i ] * \\ 1 / sum ( capacity_ratio [ i ] * available_soc [ i ]) Let: battery_availability_ratio [ i ] = capacity_ratio [ i ] * available_soc [ i ] total_battery_availability_ratio = sum ( battery_availability_ratio ) Then: distribution [ i ] = power_w * battery_availability_ratio [ i ] \\ / total_battery_availability_ratio Source code in frequenz/sdk/power/_distribution_algorithm.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 class DistributionAlgorithm : r \"\"\"Distribute power between many components. The purpose of this tool is to keep equal SoC level in the batteries. It takes total power that should be to be set for some subset of battery-inverter pairs. The total power is distributed between given battery-inverter pairs. Distribution is calculated based on data below: * Battery current SoC. * Battery upper and lower SoC bound. * Battery capacity. * Battery lower and upper power bound. * Inverter lower and upper active power bound. # Distribution algorithm Lets assume that: * `N` - number of batteries * `power_w` - power to distribute * `capacity[i]` - capacity of i'th battery * `available_soc[i]` - how much SoC remained to reach: * SoC upper bound - if need to distribute power that charges inverters. * SoC lower bound - if need to distribute power that discharges inverters. * `0` - if SoC is outside SoC bounds. * `total_capacity` - `sum(c for c in capacity.values())` * `capacity_ratio[i]` - `capacity[i]/total_capacity` We would like our distribution to meet the equation: ``` python distribution[i] = power_w * capacity_ratio[i] * x[i] ``` where: ``` python sum(capacity_ratio[i] * x[i] for i in range(N)) == 1 ``` Let `y` be our unknown, the proportion to discharge each battery would be (1): ``` python x[i] = available_soc[i]*y ``` We can compute `y` from equation above (2): ``` python sum(capacity_ratio[i] * x[i] for i in range(N)) == 1 # => sum(capacity_ratio[i] * available_soc[i] * y for i in range(N)) == 1 # => y = 1 / sum(capacity_ratio[i] * available_soc[i]) ``` Now we know everything and we can compute distribution: ``` python distribution[i] = power_w * capacity_ratio[i] * x[i] # from (1) distribution[i] = \\ power_w * capacity_ratio[i] * available_soc[i] * y # from (2) distribution[i] = power_w * capacity_ratio[i] * available_soc[i] * \\ 1/sum(capacity_ratio[i] * available_soc[i]) ``` Let: ``` python battery_availability_ratio[i] = capacity_ratio[i] * available_soc[i] total_battery_availability_ratio = sum(battery_availability_ratio) ``` Then: ``` python distribution[i] = power_w * battery_availability_ratio[i] \\ / total_battery_availability_ratio ``` \"\"\" def __init__ ( self , distributor_exponent : float = 1 ) -> None : \"\"\"Create distribution algorithm instance. Args: distributor_exponent: How fast the batteries should strive to the equal SoC level. Should be float >= 0. Defaults=1. For example for distributor_exponent equal: * 1 - means that proportion will be linear from SoC. * 2 - means proportion would be like squared from SoC * 3 - means proportion would be like x^3 from SoC. Example: Lets say we have two batteries `Bat1` and `Bat2`. All parameters except SoC are equal. SoC bounds for each battery is `lower = 20`, `upper = 80`. # Example 1 Let: * `Bat1.soc = 70` and `Bat2.soc = 50`. * `Bat1.available_soc = 10`, `Bat2.available_soc = 30` * `Bat1.available_soc / Bat2.available_soc = 3` We need to distribute 8000W. If `distribution_exponent` is: * `0`: distribution for each battery will be the equal. ``` python Bat1.distribution = 4000; Bat2.distribution = 4000 ``` * `1`: then `Bat2` will have 3x more power assigned then `Bat1`. ``` python 10 * x + 30 * x = 8000 x = 200 Bat1.distribution = 2000; Bat2.distribution = 6000 ``` * `2`: then `Bat2` will have 9x more power assigned then `Bat1`. ``` python 10^2 * x + 30^2 * x = 8000 x = 80 Bat1.distribution = 800; Bat2.distribution = 7200 ``` * `3`: then `Bat2` will have 27x more power assigned then `Bat1`. ``` python 10^3 * x + 30^3 * x = 8000 x = 0,285714286 Bat1.distribution = 285; Bat2.distribution = 7715 ``` # Example 2 Let: * `Bat1.soc = 50` and `Bat2.soc = 20`. * `Bat1.available_soc = 30`, `Bat2.available_soc = 60` * `Bat1.available_soc / Bat2.available_soc = 2` We need to distribute 900W. If `distribution_exponent` is: * `0`: distribution for each battery will be the same. ``` python Bat1.distribution = 4500; Bat2.distribution = 450 ``` * `1`: then `Bat2` will have 2x more power assigned then `Bat1`. ``` python 30 * x + 60 * x = 900 x = 100 Bat1.distribution = 300; Bat2.distribution = 600 ``` * `2`: then `Bat2` will have 4x more power assigned then `Bat1`. ``` python 30^2 * x + 60^2 * x = 900 x = 0.2 Bat1.distribution = 180; Bat2.distribution = 720 ``` * `3`: then `Bat2` will have 8x more power assigned then `Bat1`. ``` python 30^3 * x + 60^3 * x = 900 x = 0,003703704 Bat1.distribution = 100; Bat2.distribution = 800 ``` # Example 3 Let: * `Bat1.soc = 44` and `Bat2.soc = 64`. * `Bat1.available_soc = 36 (80 - 44)`, `Bat2.available_soc = 16 (80 - 64)` We need to distribute 900W. If `distribution_exponent` is: * `0`: distribution for each battery will be the equal. ``` python Bat1.distribution = 450; Bat2.distribution = 450 ``` * `0.5`: then `Bat2` will have 6/4x more power assigned then `Bat1`. ``` python sqrt(36) * x + sqrt(16) * x = 900 x = 100 Bat1.distribution = 600; Bat2.distribution = 400 ``` Raises: ValueError: If distributor_exponent < 0 \"\"\" super () . __init__ () if distributor_exponent < 0 : raise ValueError ( \"Distribution factor should be float >= 0.\" ) self . _distributor_exponent : float = distributor_exponent def _total_capacity ( self , components : List [ InvBatPair ]) -> float : \"\"\"Sum capacity between all batteries in the components list. Args: components: list of the components Raises: ValueError: If total capacity is 0. Returns: Sum of all batteries capacity in the components list. \"\"\" total_capacity : float = sum ( bat . capacity for bat , _ in components ) if total_capacity == 0.0 : msg = \"All batteries have capacity 0.\" _logger . error ( msg ) raise ValueError ( msg ) return total_capacity def _compute_battery_availability_ratio ( self , components : List [ InvBatPair ], available_soc : Dict [ int , float ] ) -> Tuple [ List [ Tuple [ InvBatPair , float ]], float ]: r \"\"\"Compute battery ratio and the total sum of all of them. battery_availability_ratio = capacity_ratio[i] * available_soc[i] Where: capacity_ratio[i] = components[i].battery.capacity \\ / sum(battery.capacity for battery, _ in components) Args: components: list of the components available_soc: How much SoC remained to reach * SoC upper bound - if need to distribute consumption power * SoC lower bound - if need to distribute supply power Returns: Tuple where first argument is battery availability ratio for each battery-inverter pair. The list is sorted by ratio in descending order. The second element of the tuple is total sum of all battery ratios in the list. \"\"\" total_capacity = self . _total_capacity ( components ) battery_availability_ratio : List [ Tuple [ InvBatPair , float ]] = [] total_battery_availability_ratio : float = 0.0 for pair in components : battery = pair [ 0 ] capacity_ratio = battery . capacity / total_capacity soc_factor = pow ( available_soc [ battery . component_id ], self . _distributor_exponent ) ratio = capacity_ratio * soc_factor battery_availability_ratio . append (( pair , ratio )) total_battery_availability_ratio += ratio battery_availability_ratio . sort ( key = lambda item : item [ 1 ], reverse = True ) return battery_availability_ratio , total_battery_availability_ratio def _distribute_power ( self , components : List [ InvBatPair ], power_w : int , available_soc : Dict [ int , float ], upper_bounds : Dict [ int , int ], ) -> DistributionResult : # pylint: disable=too-many-locals \"\"\"Distribute power between given components. After this method power should be distributed between batteries in a way that equalize SoC between batteries. Args: components: list of components. power_w: power to distribute available_soc: how much SoC remained to reach: * SoC upper bound - if need to distribute consumption power * SoC lower bound - if need to distribute supply power upper_bounds: Min between upper bound of each pair in the components list: * supply upper bound - if need to distribute consumption power * consumption lower bound - if need to distribute supply power Returns: Distribution result. \"\"\" ( battery_availability_ratio , sum_ratio , ) = self . _compute_battery_availability_ratio ( components , available_soc ) distribution : Dict [ int , int ] = {} # sum_ratio == 0 means that all batteries are fully charged / discharged if sum_ratio == 0.0 : distribution = { inverter . component_id : 0 for _ , inverter in components } return DistributionResult ( distribution , power_w ) distributed_power = 0 power_to_distribute : int = power_w used_ratio : float = 0.0 ratio = sum_ratio for pair , battery_ratio in battery_availability_ratio : inverter = pair [ 1 ] # ratio = 0, means all remaining batteries reach max SoC lvl or have no # capacity if ratio == 0.0 : distribution [ inverter . component_id ] = 0 continue distribution [ inverter . component_id ] = floor ( power_to_distribute * battery_ratio / ratio ) used_ratio += battery_ratio # If the power allocated for that inverter is out of bound, # then we need to distribute more power over all remaining batteries. upper_bound = upper_bounds [ inverter . component_id ] if distribution [ inverter . component_id ] > upper_bound : distribution [ inverter . component_id ] = upper_bound distributed_power += upper_bound # Distribute only the remaining power. power_to_distribute = power_w - distributed_power # Distribute between remaining batteries ratio = sum_ratio - used_ratio else : distributed_power += distribution [ inverter . component_id ] return DistributionResult ( distribution , power_w - distributed_power ) def _greedy_distribute_remaining_power ( self , distribution : Dict [ int , int ], upper_bounds : Dict [ int , int ], remaining_power : int , ) -> DistributionResult : \"\"\"Add remaining power greedily to the given distribution. Distribution for each inverter will not exceed its upper bound. Args: distribution: distribution upper_bounds: upper bounds inverter and adjacent battery in distribution. remaining_power: power to distribute Returns: Return the power for each inverter in given distribution. \"\"\" if remaining_power == 0 : return DistributionResult ( distribution , remaining_power ) new_distribution : Dict [ int , int ] = {} for inverter_id , power in distribution . items (): if remaining_power == 0 or power == 0 : new_distribution [ inverter_id ] = power else : remaining_power_capacity : int = upper_bounds [ inverter_id ] - power to_add = min ( remaining_power_capacity , remaining_power ) new_distribution [ inverter_id ] = power + to_add remaining_power -= to_add return DistributionResult ( new_distribution , remaining_power ) def distribute_power ( self , power : int , components : List [ InvBatPair ] ) -> DistributionResult : \"\"\"Distribute given power between given components. Args: power: Power to distribute components: InvBatPaired components data. Each pair should have data for battery and adjacent inverter. Returns: Distribution result \"\"\" if power >= 0 : return self . _distribute_consume_power ( power , components ) return self . _distribute_supply_power ( power , components ) def _distribute_consume_power ( self , power_w : int , components : List [ InvBatPair ] ) -> DistributionResult : \"\"\"Distribute power between the given components. Distribute power in a way that the SoC level between given components will: * stay on the same level, equal in all given components * will try to align himself to the same level. Args: power_w: power to distribute components: list of components between which the power should be distributed. Returns: Distribution result, batteries with no SoC and capacity won't be used. \"\"\" # If SoC exceeded bound then remaining SoC should be 0. # Otherwise algorithm would try to supply power from that battery # in order to keep equal SoC level. available_soc : Dict [ int , float ] = {} for battery , _ in components : available_soc [ battery . component_id ] = max ( 0.0 , battery . soc_upper_bound - battery . soc ) bounds : Dict [ int , int ] = {} for battery , inverter in components : # We can supply/consume with int only inverter_bound = inverter . active_power_upper_bound battery_bound = battery . power_upper_bound bounds [ inverter . component_id ] = floor ( min ( inverter_bound , battery_bound )) result : DistributionResult = self . _distribute_power ( components , power_w , available_soc , bounds ) return self . _greedy_distribute_remaining_power ( result . distribution , bounds , result . remaining_power ) def _distribute_supply_power ( self , power_w : int , components : List [ InvBatPair ] ) -> DistributionResult : \"\"\"Distribute power between the given components. Distribute power in a way that the SoC level between given components will: * stay on the same level, equal in all given components * will try to align himself to the same level. Args: power_w: power to distribute components: list of components between which the power should be distributed. Returns: Distribution result. \"\"\" available_soc : Dict [ int , float ] = {} for battery , _ in components : available_soc [ battery . component_id ] = max ( 0.0 , battery . soc - battery . soc_lower_bound ) bounds : Dict [ int , int ] = {} for battery , inverter in components : # We can consume with int only inverter_bound = inverter . active_power_lower_bound battery_bound = battery . power_lower_bound bounds [ inverter . component_id ] = - 1 * ceil ( max ( inverter_bound , battery_bound ) ) result : DistributionResult = self . _distribute_power ( components , - 1 * power_w , available_soc , bounds ) result = self . _greedy_distribute_remaining_power ( result . distribution , bounds , result . remaining_power ) for inverter_id in result . distribution . keys (): result . distribution [ inverter_id ] *= - 1 result . remaining_power *= - 1 return result Functions \u00a4 __init__ ( distributor_exponent = 1 ) \u00a4 Create distribution algorithm instance. PARAMETER DESCRIPTION distributor_exponent How fast the batteries should strive to the equal SoC level. Should be float >= 0. Defaults=1. For example for distributor_exponent equal: * 1 - means that proportion will be linear from SoC. * 2 - means proportion would be like squared from SoC * 3 - means proportion would be like x^3 from SoC. TYPE: float DEFAULT: 1 Example Lets say we have two batteries Bat1 and Bat2 . All parameters except SoC are equal. SoC bounds for each battery is lower = 20 , upper = 80 . Example 1 \u00a4 Let: Bat1.soc = 70 and Bat2.soc = 50 . Bat1.available_soc = 10 , Bat2.available_soc = 30 Bat1.available_soc / Bat2.available_soc = 3 We need to distribute 8000W. If distribution_exponent is: 0 : distribution for each battery will be the equal. Bat1 . distribution = 4000 ; Bat2 . distribution = 4000 1 : then Bat2 will have 3x more power assigned then Bat1 . 10 * x + 30 * x = 8000 x = 200 Bat1 . distribution = 2000 ; Bat2 . distribution = 6000 2 : then Bat2 will have 9x more power assigned then Bat1 . 10 ^ 2 * x + 30 ^ 2 * x = 8000 x = 80 Bat1 . distribution = 800 ; Bat2 . distribution = 7200 3 : then Bat2 will have 27x more power assigned then Bat1 . 10 ^ 3 * x + 30 ^ 3 * x = 8000 x = 0 , 285714286 Bat1 . distribution = 285 ; Bat2 . distribution = 7715 Example 2 \u00a4 Let: Bat1.soc = 50 and Bat2.soc = 20 . Bat1.available_soc = 30 , Bat2.available_soc = 60 Bat1.available_soc / Bat2.available_soc = 2 We need to distribute 900W. If distribution_exponent is: 0 : distribution for each battery will be the same. Bat1 . distribution = 4500 ; Bat2 . distribution = 450 1 : then Bat2 will have 2x more power assigned then Bat1 . 30 * x + 60 * x = 900 x = 100 Bat1 . distribution = 300 ; Bat2 . distribution = 600 2 : then Bat2 will have 4x more power assigned then Bat1 . 30 ^ 2 * x + 60 ^ 2 * x = 900 x = 0.2 Bat1 . distribution = 180 ; Bat2 . distribution = 720 3 : then Bat2 will have 8x more power assigned then Bat1 . 30 ^ 3 * x + 60 ^ 3 * x = 900 x = 0 , 003703704 Bat1 . distribution = 100 ; Bat2 . distribution = 800 Example 3 \u00a4 Let: Bat1.soc = 44 and Bat2.soc = 64 . Bat1.available_soc = 36 (80 - 44) , Bat2.available_soc = 16 (80 - 64) We need to distribute 900W. If distribution_exponent is: 0 : distribution for each battery will be the equal. Bat1 . distribution = 450 ; Bat2 . distribution = 450 0.5 : then Bat2 will have 6/4x more power assigned then Bat1 . sqrt ( 36 ) * x + sqrt ( 16 ) * x = 900 x = 100 Bat1 . distribution = 600 ; Bat2 . distribution = 400 RAISES DESCRIPTION ValueError If distributor_exponent < 0 Source code in frequenz/sdk/power/_distribution_algorithm.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def __init__ ( self , distributor_exponent : float = 1 ) -> None : \"\"\"Create distribution algorithm instance. Args: distributor_exponent: How fast the batteries should strive to the equal SoC level. Should be float >= 0. Defaults=1. For example for distributor_exponent equal: * 1 - means that proportion will be linear from SoC. * 2 - means proportion would be like squared from SoC * 3 - means proportion would be like x^3 from SoC. Example: Lets say we have two batteries `Bat1` and `Bat2`. All parameters except SoC are equal. SoC bounds for each battery is `lower = 20`, `upper = 80`. # Example 1 Let: * `Bat1.soc = 70` and `Bat2.soc = 50`. * `Bat1.available_soc = 10`, `Bat2.available_soc = 30` * `Bat1.available_soc / Bat2.available_soc = 3` We need to distribute 8000W. If `distribution_exponent` is: * `0`: distribution for each battery will be the equal. ``` python Bat1.distribution = 4000; Bat2.distribution = 4000 ``` * `1`: then `Bat2` will have 3x more power assigned then `Bat1`. ``` python 10 * x + 30 * x = 8000 x = 200 Bat1.distribution = 2000; Bat2.distribution = 6000 ``` * `2`: then `Bat2` will have 9x more power assigned then `Bat1`. ``` python 10^2 * x + 30^2 * x = 8000 x = 80 Bat1.distribution = 800; Bat2.distribution = 7200 ``` * `3`: then `Bat2` will have 27x more power assigned then `Bat1`. ``` python 10^3 * x + 30^3 * x = 8000 x = 0,285714286 Bat1.distribution = 285; Bat2.distribution = 7715 ``` # Example 2 Let: * `Bat1.soc = 50` and `Bat2.soc = 20`. * `Bat1.available_soc = 30`, `Bat2.available_soc = 60` * `Bat1.available_soc / Bat2.available_soc = 2` We need to distribute 900W. If `distribution_exponent` is: * `0`: distribution for each battery will be the same. ``` python Bat1.distribution = 4500; Bat2.distribution = 450 ``` * `1`: then `Bat2` will have 2x more power assigned then `Bat1`. ``` python 30 * x + 60 * x = 900 x = 100 Bat1.distribution = 300; Bat2.distribution = 600 ``` * `2`: then `Bat2` will have 4x more power assigned then `Bat1`. ``` python 30^2 * x + 60^2 * x = 900 x = 0.2 Bat1.distribution = 180; Bat2.distribution = 720 ``` * `3`: then `Bat2` will have 8x more power assigned then `Bat1`. ``` python 30^3 * x + 60^3 * x = 900 x = 0,003703704 Bat1.distribution = 100; Bat2.distribution = 800 ``` # Example 3 Let: * `Bat1.soc = 44` and `Bat2.soc = 64`. * `Bat1.available_soc = 36 (80 - 44)`, `Bat2.available_soc = 16 (80 - 64)` We need to distribute 900W. If `distribution_exponent` is: * `0`: distribution for each battery will be the equal. ``` python Bat1.distribution = 450; Bat2.distribution = 450 ``` * `0.5`: then `Bat2` will have 6/4x more power assigned then `Bat1`. ``` python sqrt(36) * x + sqrt(16) * x = 900 x = 100 Bat1.distribution = 600; Bat2.distribution = 400 ``` Raises: ValueError: If distributor_exponent < 0 \"\"\" super () . __init__ () if distributor_exponent < 0 : raise ValueError ( \"Distribution factor should be float >= 0.\" ) self . _distributor_exponent : float = distributor_exponent distribute_power ( power , components ) \u00a4 Distribute given power between given components. PARAMETER DESCRIPTION power Power to distribute TYPE: int components InvBatPaired components data. Each pair should have data for battery and adjacent inverter. TYPE: List [ InvBatPair ] RETURNS DESCRIPTION DistributionResult Distribution result Source code in frequenz/sdk/power/_distribution_algorithm.py 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 def distribute_power ( self , power : int , components : List [ InvBatPair ] ) -> DistributionResult : \"\"\"Distribute given power between given components. Args: power: Power to distribute components: InvBatPaired components data. Each pair should have data for battery and adjacent inverter. Returns: Distribution result \"\"\" if power >= 0 : return self . _distribute_consume_power ( power , components ) return self . _distribute_supply_power ( power , components ) frequenz.sdk.power.DistributionResult dataclass \u00a4 Distribution result. Source code in frequenz/sdk/power/_distribution_algorithm.py 26 27 28 29 30 31 32 33 34 35 36 37 38 @dataclass class DistributionResult : \"\"\"Distribution result.\"\"\" distribution : Dict [ int , int ] \"\"\"The power to be set for each inverter. The key is inverter ID, and the value is the power that should be set for that inverter. \"\"\" remaining_power : int \"\"\"The power which could not be distributed because of bounds.\"\"\" Attributes \u00a4 distribution : Dict [ int , int ] class-attribute \u00a4 The power to be set for each inverter. The key is inverter ID, and the value is the power that should be set for that inverter. remaining_power : int class-attribute \u00a4 The power which could not be distributed because of bounds. frequenz.sdk.power.InvBatPair \u00a4 Bases: NamedTuple InvBatPair with inverter and adjacent battery data. Source code in frequenz/sdk/power/_distribution_algorithm.py 16 17 18 19 20 21 22 23 class InvBatPair ( NamedTuple ): \"\"\"InvBatPair with inverter and adjacent battery data.\"\"\" battery : BatteryData \"\"\"The battery data.\"\"\" inverter : InverterData \"\"\"The inverter data.\"\"\" Attributes \u00a4 battery : BatteryData class-attribute \u00a4 The battery data. inverter : InverterData class-attribute \u00a4 The inverter data.","title":"power"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power","text":"Utilities to manage power in a microgrid.","title":"power"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.DistributionAlgorithm","text":"Distribute power between many components. The purpose of this tool is to keep equal SoC level in the batteries. It takes total power that should be to be set for some subset of battery-inverter pairs. The total power is distributed between given battery-inverter pairs. Distribution is calculated based on data below: Battery current SoC. Battery upper and lower SoC bound. Battery capacity. Battery lower and upper power bound. Inverter lower and upper active power bound.","title":"DistributionAlgorithm"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.DistributionAlgorithm--distribution-algorithm","text":"Lets assume that: N - number of batteries power_w - power to distribute capacity[i] - capacity of i'th battery available_soc[i] - how much SoC remained to reach: SoC upper bound - if need to distribute power that charges inverters. SoC lower bound - if need to distribute power that discharges inverters. 0 - if SoC is outside SoC bounds. total_capacity - sum(c for c in capacity.values()) capacity_ratio[i] - capacity[i]/total_capacity We would like our distribution to meet the equation: distribution [ i ] = power_w * capacity_ratio [ i ] * x [ i ] where: sum ( capacity_ratio [ i ] * x [ i ] for i in range ( N )) == 1 Let y be our unknown, the proportion to discharge each battery would be (1): x [ i ] = available_soc [ i ] * y We can compute y from equation above (2): sum ( capacity_ratio [ i ] * x [ i ] for i in range ( N )) == 1 # => sum ( capacity_ratio [ i ] * available_soc [ i ] * y for i in range ( N )) == 1 # => y = 1 / sum ( capacity_ratio [ i ] * available_soc [ i ]) Now we know everything and we can compute distribution: distribution [ i ] = power_w * capacity_ratio [ i ] * x [ i ] # from (1) distribution [ i ] = \\ power_w * capacity_ratio [ i ] * available_soc [ i ] * y # from (2) distribution [ i ] = power_w * capacity_ratio [ i ] * available_soc [ i ] * \\ 1 / sum ( capacity_ratio [ i ] * available_soc [ i ]) Let: battery_availability_ratio [ i ] = capacity_ratio [ i ] * available_soc [ i ] total_battery_availability_ratio = sum ( battery_availability_ratio ) Then: distribution [ i ] = power_w * battery_availability_ratio [ i ] \\ / total_battery_availability_ratio Source code in frequenz/sdk/power/_distribution_algorithm.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 class DistributionAlgorithm : r \"\"\"Distribute power between many components. The purpose of this tool is to keep equal SoC level in the batteries. It takes total power that should be to be set for some subset of battery-inverter pairs. The total power is distributed between given battery-inverter pairs. Distribution is calculated based on data below: * Battery current SoC. * Battery upper and lower SoC bound. * Battery capacity. * Battery lower and upper power bound. * Inverter lower and upper active power bound. # Distribution algorithm Lets assume that: * `N` - number of batteries * `power_w` - power to distribute * `capacity[i]` - capacity of i'th battery * `available_soc[i]` - how much SoC remained to reach: * SoC upper bound - if need to distribute power that charges inverters. * SoC lower bound - if need to distribute power that discharges inverters. * `0` - if SoC is outside SoC bounds. * `total_capacity` - `sum(c for c in capacity.values())` * `capacity_ratio[i]` - `capacity[i]/total_capacity` We would like our distribution to meet the equation: ``` python distribution[i] = power_w * capacity_ratio[i] * x[i] ``` where: ``` python sum(capacity_ratio[i] * x[i] for i in range(N)) == 1 ``` Let `y` be our unknown, the proportion to discharge each battery would be (1): ``` python x[i] = available_soc[i]*y ``` We can compute `y` from equation above (2): ``` python sum(capacity_ratio[i] * x[i] for i in range(N)) == 1 # => sum(capacity_ratio[i] * available_soc[i] * y for i in range(N)) == 1 # => y = 1 / sum(capacity_ratio[i] * available_soc[i]) ``` Now we know everything and we can compute distribution: ``` python distribution[i] = power_w * capacity_ratio[i] * x[i] # from (1) distribution[i] = \\ power_w * capacity_ratio[i] * available_soc[i] * y # from (2) distribution[i] = power_w * capacity_ratio[i] * available_soc[i] * \\ 1/sum(capacity_ratio[i] * available_soc[i]) ``` Let: ``` python battery_availability_ratio[i] = capacity_ratio[i] * available_soc[i] total_battery_availability_ratio = sum(battery_availability_ratio) ``` Then: ``` python distribution[i] = power_w * battery_availability_ratio[i] \\ / total_battery_availability_ratio ``` \"\"\" def __init__ ( self , distributor_exponent : float = 1 ) -> None : \"\"\"Create distribution algorithm instance. Args: distributor_exponent: How fast the batteries should strive to the equal SoC level. Should be float >= 0. Defaults=1. For example for distributor_exponent equal: * 1 - means that proportion will be linear from SoC. * 2 - means proportion would be like squared from SoC * 3 - means proportion would be like x^3 from SoC. Example: Lets say we have two batteries `Bat1` and `Bat2`. All parameters except SoC are equal. SoC bounds for each battery is `lower = 20`, `upper = 80`. # Example 1 Let: * `Bat1.soc = 70` and `Bat2.soc = 50`. * `Bat1.available_soc = 10`, `Bat2.available_soc = 30` * `Bat1.available_soc / Bat2.available_soc = 3` We need to distribute 8000W. If `distribution_exponent` is: * `0`: distribution for each battery will be the equal. ``` python Bat1.distribution = 4000; Bat2.distribution = 4000 ``` * `1`: then `Bat2` will have 3x more power assigned then `Bat1`. ``` python 10 * x + 30 * x = 8000 x = 200 Bat1.distribution = 2000; Bat2.distribution = 6000 ``` * `2`: then `Bat2` will have 9x more power assigned then `Bat1`. ``` python 10^2 * x + 30^2 * x = 8000 x = 80 Bat1.distribution = 800; Bat2.distribution = 7200 ``` * `3`: then `Bat2` will have 27x more power assigned then `Bat1`. ``` python 10^3 * x + 30^3 * x = 8000 x = 0,285714286 Bat1.distribution = 285; Bat2.distribution = 7715 ``` # Example 2 Let: * `Bat1.soc = 50` and `Bat2.soc = 20`. * `Bat1.available_soc = 30`, `Bat2.available_soc = 60` * `Bat1.available_soc / Bat2.available_soc = 2` We need to distribute 900W. If `distribution_exponent` is: * `0`: distribution for each battery will be the same. ``` python Bat1.distribution = 4500; Bat2.distribution = 450 ``` * `1`: then `Bat2` will have 2x more power assigned then `Bat1`. ``` python 30 * x + 60 * x = 900 x = 100 Bat1.distribution = 300; Bat2.distribution = 600 ``` * `2`: then `Bat2` will have 4x more power assigned then `Bat1`. ``` python 30^2 * x + 60^2 * x = 900 x = 0.2 Bat1.distribution = 180; Bat2.distribution = 720 ``` * `3`: then `Bat2` will have 8x more power assigned then `Bat1`. ``` python 30^3 * x + 60^3 * x = 900 x = 0,003703704 Bat1.distribution = 100; Bat2.distribution = 800 ``` # Example 3 Let: * `Bat1.soc = 44` and `Bat2.soc = 64`. * `Bat1.available_soc = 36 (80 - 44)`, `Bat2.available_soc = 16 (80 - 64)` We need to distribute 900W. If `distribution_exponent` is: * `0`: distribution for each battery will be the equal. ``` python Bat1.distribution = 450; Bat2.distribution = 450 ``` * `0.5`: then `Bat2` will have 6/4x more power assigned then `Bat1`. ``` python sqrt(36) * x + sqrt(16) * x = 900 x = 100 Bat1.distribution = 600; Bat2.distribution = 400 ``` Raises: ValueError: If distributor_exponent < 0 \"\"\" super () . __init__ () if distributor_exponent < 0 : raise ValueError ( \"Distribution factor should be float >= 0.\" ) self . _distributor_exponent : float = distributor_exponent def _total_capacity ( self , components : List [ InvBatPair ]) -> float : \"\"\"Sum capacity between all batteries in the components list. Args: components: list of the components Raises: ValueError: If total capacity is 0. Returns: Sum of all batteries capacity in the components list. \"\"\" total_capacity : float = sum ( bat . capacity for bat , _ in components ) if total_capacity == 0.0 : msg = \"All batteries have capacity 0.\" _logger . error ( msg ) raise ValueError ( msg ) return total_capacity def _compute_battery_availability_ratio ( self , components : List [ InvBatPair ], available_soc : Dict [ int , float ] ) -> Tuple [ List [ Tuple [ InvBatPair , float ]], float ]: r \"\"\"Compute battery ratio and the total sum of all of them. battery_availability_ratio = capacity_ratio[i] * available_soc[i] Where: capacity_ratio[i] = components[i].battery.capacity \\ / sum(battery.capacity for battery, _ in components) Args: components: list of the components available_soc: How much SoC remained to reach * SoC upper bound - if need to distribute consumption power * SoC lower bound - if need to distribute supply power Returns: Tuple where first argument is battery availability ratio for each battery-inverter pair. The list is sorted by ratio in descending order. The second element of the tuple is total sum of all battery ratios in the list. \"\"\" total_capacity = self . _total_capacity ( components ) battery_availability_ratio : List [ Tuple [ InvBatPair , float ]] = [] total_battery_availability_ratio : float = 0.0 for pair in components : battery = pair [ 0 ] capacity_ratio = battery . capacity / total_capacity soc_factor = pow ( available_soc [ battery . component_id ], self . _distributor_exponent ) ratio = capacity_ratio * soc_factor battery_availability_ratio . append (( pair , ratio )) total_battery_availability_ratio += ratio battery_availability_ratio . sort ( key = lambda item : item [ 1 ], reverse = True ) return battery_availability_ratio , total_battery_availability_ratio def _distribute_power ( self , components : List [ InvBatPair ], power_w : int , available_soc : Dict [ int , float ], upper_bounds : Dict [ int , int ], ) -> DistributionResult : # pylint: disable=too-many-locals \"\"\"Distribute power between given components. After this method power should be distributed between batteries in a way that equalize SoC between batteries. Args: components: list of components. power_w: power to distribute available_soc: how much SoC remained to reach: * SoC upper bound - if need to distribute consumption power * SoC lower bound - if need to distribute supply power upper_bounds: Min between upper bound of each pair in the components list: * supply upper bound - if need to distribute consumption power * consumption lower bound - if need to distribute supply power Returns: Distribution result. \"\"\" ( battery_availability_ratio , sum_ratio , ) = self . _compute_battery_availability_ratio ( components , available_soc ) distribution : Dict [ int , int ] = {} # sum_ratio == 0 means that all batteries are fully charged / discharged if sum_ratio == 0.0 : distribution = { inverter . component_id : 0 for _ , inverter in components } return DistributionResult ( distribution , power_w ) distributed_power = 0 power_to_distribute : int = power_w used_ratio : float = 0.0 ratio = sum_ratio for pair , battery_ratio in battery_availability_ratio : inverter = pair [ 1 ] # ratio = 0, means all remaining batteries reach max SoC lvl or have no # capacity if ratio == 0.0 : distribution [ inverter . component_id ] = 0 continue distribution [ inverter . component_id ] = floor ( power_to_distribute * battery_ratio / ratio ) used_ratio += battery_ratio # If the power allocated for that inverter is out of bound, # then we need to distribute more power over all remaining batteries. upper_bound = upper_bounds [ inverter . component_id ] if distribution [ inverter . component_id ] > upper_bound : distribution [ inverter . component_id ] = upper_bound distributed_power += upper_bound # Distribute only the remaining power. power_to_distribute = power_w - distributed_power # Distribute between remaining batteries ratio = sum_ratio - used_ratio else : distributed_power += distribution [ inverter . component_id ] return DistributionResult ( distribution , power_w - distributed_power ) def _greedy_distribute_remaining_power ( self , distribution : Dict [ int , int ], upper_bounds : Dict [ int , int ], remaining_power : int , ) -> DistributionResult : \"\"\"Add remaining power greedily to the given distribution. Distribution for each inverter will not exceed its upper bound. Args: distribution: distribution upper_bounds: upper bounds inverter and adjacent battery in distribution. remaining_power: power to distribute Returns: Return the power for each inverter in given distribution. \"\"\" if remaining_power == 0 : return DistributionResult ( distribution , remaining_power ) new_distribution : Dict [ int , int ] = {} for inverter_id , power in distribution . items (): if remaining_power == 0 or power == 0 : new_distribution [ inverter_id ] = power else : remaining_power_capacity : int = upper_bounds [ inverter_id ] - power to_add = min ( remaining_power_capacity , remaining_power ) new_distribution [ inverter_id ] = power + to_add remaining_power -= to_add return DistributionResult ( new_distribution , remaining_power ) def distribute_power ( self , power : int , components : List [ InvBatPair ] ) -> DistributionResult : \"\"\"Distribute given power between given components. Args: power: Power to distribute components: InvBatPaired components data. Each pair should have data for battery and adjacent inverter. Returns: Distribution result \"\"\" if power >= 0 : return self . _distribute_consume_power ( power , components ) return self . _distribute_supply_power ( power , components ) def _distribute_consume_power ( self , power_w : int , components : List [ InvBatPair ] ) -> DistributionResult : \"\"\"Distribute power between the given components. Distribute power in a way that the SoC level between given components will: * stay on the same level, equal in all given components * will try to align himself to the same level. Args: power_w: power to distribute components: list of components between which the power should be distributed. Returns: Distribution result, batteries with no SoC and capacity won't be used. \"\"\" # If SoC exceeded bound then remaining SoC should be 0. # Otherwise algorithm would try to supply power from that battery # in order to keep equal SoC level. available_soc : Dict [ int , float ] = {} for battery , _ in components : available_soc [ battery . component_id ] = max ( 0.0 , battery . soc_upper_bound - battery . soc ) bounds : Dict [ int , int ] = {} for battery , inverter in components : # We can supply/consume with int only inverter_bound = inverter . active_power_upper_bound battery_bound = battery . power_upper_bound bounds [ inverter . component_id ] = floor ( min ( inverter_bound , battery_bound )) result : DistributionResult = self . _distribute_power ( components , power_w , available_soc , bounds ) return self . _greedy_distribute_remaining_power ( result . distribution , bounds , result . remaining_power ) def _distribute_supply_power ( self , power_w : int , components : List [ InvBatPair ] ) -> DistributionResult : \"\"\"Distribute power between the given components. Distribute power in a way that the SoC level between given components will: * stay on the same level, equal in all given components * will try to align himself to the same level. Args: power_w: power to distribute components: list of components between which the power should be distributed. Returns: Distribution result. \"\"\" available_soc : Dict [ int , float ] = {} for battery , _ in components : available_soc [ battery . component_id ] = max ( 0.0 , battery . soc - battery . soc_lower_bound ) bounds : Dict [ int , int ] = {} for battery , inverter in components : # We can consume with int only inverter_bound = inverter . active_power_lower_bound battery_bound = battery . power_lower_bound bounds [ inverter . component_id ] = - 1 * ceil ( max ( inverter_bound , battery_bound ) ) result : DistributionResult = self . _distribute_power ( components , - 1 * power_w , available_soc , bounds ) result = self . _greedy_distribute_remaining_power ( result . distribution , bounds , result . remaining_power ) for inverter_id in result . distribution . keys (): result . distribution [ inverter_id ] *= - 1 result . remaining_power *= - 1 return result","title":"Distribution algorithm"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.DistributionAlgorithm-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionAlgorithm.__init__","text":"Create distribution algorithm instance. PARAMETER DESCRIPTION distributor_exponent How fast the batteries should strive to the equal SoC level. Should be float >= 0. Defaults=1. For example for distributor_exponent equal: * 1 - means that proportion will be linear from SoC. * 2 - means proportion would be like squared from SoC * 3 - means proportion would be like x^3 from SoC. TYPE: float DEFAULT: 1 Example Lets say we have two batteries Bat1 and Bat2 . All parameters except SoC are equal. SoC bounds for each battery is lower = 20 , upper = 80 .","title":"__init__()"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionAlgorithm.__init__--example-1","text":"Let: Bat1.soc = 70 and Bat2.soc = 50 . Bat1.available_soc = 10 , Bat2.available_soc = 30 Bat1.available_soc / Bat2.available_soc = 3 We need to distribute 8000W. If distribution_exponent is: 0 : distribution for each battery will be the equal. Bat1 . distribution = 4000 ; Bat2 . distribution = 4000 1 : then Bat2 will have 3x more power assigned then Bat1 . 10 * x + 30 * x = 8000 x = 200 Bat1 . distribution = 2000 ; Bat2 . distribution = 6000 2 : then Bat2 will have 9x more power assigned then Bat1 . 10 ^ 2 * x + 30 ^ 2 * x = 8000 x = 80 Bat1 . distribution = 800 ; Bat2 . distribution = 7200 3 : then Bat2 will have 27x more power assigned then Bat1 . 10 ^ 3 * x + 30 ^ 3 * x = 8000 x = 0 , 285714286 Bat1 . distribution = 285 ; Bat2 . distribution = 7715","title":"Example 1"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionAlgorithm.__init__--example-2","text":"Let: Bat1.soc = 50 and Bat2.soc = 20 . Bat1.available_soc = 30 , Bat2.available_soc = 60 Bat1.available_soc / Bat2.available_soc = 2 We need to distribute 900W. If distribution_exponent is: 0 : distribution for each battery will be the same. Bat1 . distribution = 4500 ; Bat2 . distribution = 450 1 : then Bat2 will have 2x more power assigned then Bat1 . 30 * x + 60 * x = 900 x = 100 Bat1 . distribution = 300 ; Bat2 . distribution = 600 2 : then Bat2 will have 4x more power assigned then Bat1 . 30 ^ 2 * x + 60 ^ 2 * x = 900 x = 0.2 Bat1 . distribution = 180 ; Bat2 . distribution = 720 3 : then Bat2 will have 8x more power assigned then Bat1 . 30 ^ 3 * x + 60 ^ 3 * x = 900 x = 0 , 003703704 Bat1 . distribution = 100 ; Bat2 . distribution = 800","title":"Example 2"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionAlgorithm.__init__--example-3","text":"Let: Bat1.soc = 44 and Bat2.soc = 64 . Bat1.available_soc = 36 (80 - 44) , Bat2.available_soc = 16 (80 - 64) We need to distribute 900W. If distribution_exponent is: 0 : distribution for each battery will be the equal. Bat1 . distribution = 450 ; Bat2 . distribution = 450 0.5 : then Bat2 will have 6/4x more power assigned then Bat1 . sqrt ( 36 ) * x + sqrt ( 16 ) * x = 900 x = 100 Bat1 . distribution = 600 ; Bat2 . distribution = 400 RAISES DESCRIPTION ValueError If distributor_exponent < 0 Source code in frequenz/sdk/power/_distribution_algorithm.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def __init__ ( self , distributor_exponent : float = 1 ) -> None : \"\"\"Create distribution algorithm instance. Args: distributor_exponent: How fast the batteries should strive to the equal SoC level. Should be float >= 0. Defaults=1. For example for distributor_exponent equal: * 1 - means that proportion will be linear from SoC. * 2 - means proportion would be like squared from SoC * 3 - means proportion would be like x^3 from SoC. Example: Lets say we have two batteries `Bat1` and `Bat2`. All parameters except SoC are equal. SoC bounds for each battery is `lower = 20`, `upper = 80`. # Example 1 Let: * `Bat1.soc = 70` and `Bat2.soc = 50`. * `Bat1.available_soc = 10`, `Bat2.available_soc = 30` * `Bat1.available_soc / Bat2.available_soc = 3` We need to distribute 8000W. If `distribution_exponent` is: * `0`: distribution for each battery will be the equal. ``` python Bat1.distribution = 4000; Bat2.distribution = 4000 ``` * `1`: then `Bat2` will have 3x more power assigned then `Bat1`. ``` python 10 * x + 30 * x = 8000 x = 200 Bat1.distribution = 2000; Bat2.distribution = 6000 ``` * `2`: then `Bat2` will have 9x more power assigned then `Bat1`. ``` python 10^2 * x + 30^2 * x = 8000 x = 80 Bat1.distribution = 800; Bat2.distribution = 7200 ``` * `3`: then `Bat2` will have 27x more power assigned then `Bat1`. ``` python 10^3 * x + 30^3 * x = 8000 x = 0,285714286 Bat1.distribution = 285; Bat2.distribution = 7715 ``` # Example 2 Let: * `Bat1.soc = 50` and `Bat2.soc = 20`. * `Bat1.available_soc = 30`, `Bat2.available_soc = 60` * `Bat1.available_soc / Bat2.available_soc = 2` We need to distribute 900W. If `distribution_exponent` is: * `0`: distribution for each battery will be the same. ``` python Bat1.distribution = 4500; Bat2.distribution = 450 ``` * `1`: then `Bat2` will have 2x more power assigned then `Bat1`. ``` python 30 * x + 60 * x = 900 x = 100 Bat1.distribution = 300; Bat2.distribution = 600 ``` * `2`: then `Bat2` will have 4x more power assigned then `Bat1`. ``` python 30^2 * x + 60^2 * x = 900 x = 0.2 Bat1.distribution = 180; Bat2.distribution = 720 ``` * `3`: then `Bat2` will have 8x more power assigned then `Bat1`. ``` python 30^3 * x + 60^3 * x = 900 x = 0,003703704 Bat1.distribution = 100; Bat2.distribution = 800 ``` # Example 3 Let: * `Bat1.soc = 44` and `Bat2.soc = 64`. * `Bat1.available_soc = 36 (80 - 44)`, `Bat2.available_soc = 16 (80 - 64)` We need to distribute 900W. If `distribution_exponent` is: * `0`: distribution for each battery will be the equal. ``` python Bat1.distribution = 450; Bat2.distribution = 450 ``` * `0.5`: then `Bat2` will have 6/4x more power assigned then `Bat1`. ``` python sqrt(36) * x + sqrt(16) * x = 900 x = 100 Bat1.distribution = 600; Bat2.distribution = 400 ``` Raises: ValueError: If distributor_exponent < 0 \"\"\" super () . __init__ () if distributor_exponent < 0 : raise ValueError ( \"Distribution factor should be float >= 0.\" ) self . _distributor_exponent : float = distributor_exponent","title":"Example 3"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionAlgorithm.distribute_power","text":"Distribute given power between given components. PARAMETER DESCRIPTION power Power to distribute TYPE: int components InvBatPaired components data. Each pair should have data for battery and adjacent inverter. TYPE: List [ InvBatPair ] RETURNS DESCRIPTION DistributionResult Distribution result Source code in frequenz/sdk/power/_distribution_algorithm.py 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 def distribute_power ( self , power : int , components : List [ InvBatPair ] ) -> DistributionResult : \"\"\"Distribute given power between given components. Args: power: Power to distribute components: InvBatPaired components data. Each pair should have data for battery and adjacent inverter. Returns: Distribution result \"\"\" if power >= 0 : return self . _distribute_consume_power ( power , components ) return self . _distribute_supply_power ( power , components )","title":"distribute_power()"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.DistributionResult","text":"Distribution result. Source code in frequenz/sdk/power/_distribution_algorithm.py 26 27 28 29 30 31 32 33 34 35 36 37 38 @dataclass class DistributionResult : \"\"\"Distribution result.\"\"\" distribution : Dict [ int , int ] \"\"\"The power to be set for each inverter. The key is inverter ID, and the value is the power that should be set for that inverter. \"\"\" remaining_power : int \"\"\"The power which could not be distributed because of bounds.\"\"\"","title":"DistributionResult"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.DistributionResult-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionResult.distribution","text":"The power to be set for each inverter. The key is inverter ID, and the value is the power that should be set for that inverter.","title":"distribution"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionResult.remaining_power","text":"The power which could not be distributed because of bounds.","title":"remaining_power"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.InvBatPair","text":"Bases: NamedTuple InvBatPair with inverter and adjacent battery data. Source code in frequenz/sdk/power/_distribution_algorithm.py 16 17 18 19 20 21 22 23 class InvBatPair ( NamedTuple ): \"\"\"InvBatPair with inverter and adjacent battery data.\"\"\" battery : BatteryData \"\"\"The battery data.\"\"\" inverter : InverterData \"\"\"The inverter data.\"\"\"","title":"InvBatPair"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.InvBatPair-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.InvBatPair.battery","text":"The battery data.","title":"battery"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.InvBatPair.inverter","text":"The inverter data.","title":"inverter"},{"location":"reference/frequenz/sdk/timeseries/","text":"frequenz.sdk.timeseries \u00a4 Handling of timeseries streams. A timeseries is a stream (normally an async iterator) of Sample s. Classes \u00a4 frequenz.sdk.timeseries.Sample dataclass \u00a4 A measurement taken at a particular point in time. The value could be None if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp. Source code in frequenz/sdk/timeseries/_base_types.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @dataclass ( frozen = True , order = True ) class Sample : \"\"\"A measurement taken at a particular point in time. The `value` could be `None` if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp. \"\"\" timestamp : datetime = field ( compare = True ) \"\"\"The time when this sample was generated.\"\"\" value : Optional [ float ] = field ( compare = False , default = None ) \"\"\"The value of this sample.\"\"\" Attributes \u00a4 timestamp : datetime = field ( compare = True ) class-attribute \u00a4 The time when this sample was generated. value : Optional [ float ] = field ( compare = False , default = None ) class-attribute \u00a4 The value of this sample. frequenz.sdk.timeseries.Sample3Phase dataclass \u00a4 A 3-phase measurement made at a particular point in time. Each of the value fields could be None if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp. Source code in frequenz/sdk/timeseries/_base_types.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @dataclass ( frozen = True ) class Sample3Phase : \"\"\"A 3-phase measurement made at a particular point in time. Each of the `value` fields could be `None` if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp. \"\"\" timestamp : datetime \"\"\"The time when this sample was generated.\"\"\" value_p1 : Optional [ float ] \"\"\"The value of the 1st phase in this sample.\"\"\" value_p2 : Optional [ float ] \"\"\"The value of the 2nd phase in this sample.\"\"\" value_p3 : Optional [ float ] \"\"\"The value of the 3rd phase in this sample.\"\"\" Attributes \u00a4 timestamp : datetime class-attribute \u00a4 The time when this sample was generated. value_p1 : Optional [ float ] class-attribute \u00a4 The value of the 1st phase in this sample. value_p2 : Optional [ float ] class-attribute \u00a4 The value of the 2nd phase in this sample. value_p3 : Optional [ float ] class-attribute \u00a4 The value of the 3rd phase in this sample.","title":"timeseries"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries","text":"Handling of timeseries streams. A timeseries is a stream (normally an async iterator) of Sample s.","title":"timeseries"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample","text":"A measurement taken at a particular point in time. The value could be None if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp. Source code in frequenz/sdk/timeseries/_base_types.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @dataclass ( frozen = True , order = True ) class Sample : \"\"\"A measurement taken at a particular point in time. The `value` could be `None` if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp. \"\"\" timestamp : datetime = field ( compare = True ) \"\"\"The time when this sample was generated.\"\"\" value : Optional [ float ] = field ( compare = False , default = None ) \"\"\"The value of this sample.\"\"\"","title":"Sample"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample.timestamp","text":"The time when this sample was generated.","title":"timestamp"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample.value","text":"The value of this sample.","title":"value"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase","text":"A 3-phase measurement made at a particular point in time. Each of the value fields could be None if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp. Source code in frequenz/sdk/timeseries/_base_types.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @dataclass ( frozen = True ) class Sample3Phase : \"\"\"A 3-phase measurement made at a particular point in time. Each of the `value` fields could be `None` if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp. \"\"\" timestamp : datetime \"\"\"The time when this sample was generated.\"\"\" value_p1 : Optional [ float ] \"\"\"The value of the 1st phase in this sample.\"\"\" value_p2 : Optional [ float ] \"\"\"The value of the 2nd phase in this sample.\"\"\" value_p3 : Optional [ float ] \"\"\"The value of the 3rd phase in this sample.\"\"\"","title":"Sample3Phase"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.timestamp","text":"The time when this sample was generated.","title":"timestamp"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.value_p1","text":"The value of the 1st phase in this sample.","title":"value_p1"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.value_p2","text":"The value of the 2nd phase in this sample.","title":"value_p2"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.value_p3","text":"The value of the 3rd phase in this sample.","title":"value_p3"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/","text":"frequenz.sdk.timeseries.battery_pool \u00a4 Manage a pool of batteries. Classes \u00a4 frequenz.sdk.timeseries.battery_pool.BatteryPool \u00a4 Calculate high level metrics for a pool of the batteries. BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class BatteryPool : \"\"\"Calculate high level metrics for a pool of the batteries. BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset. \"\"\" def __init__ ( self , batteries_status_receiver : Receiver [ BatteryStatus ], min_update_interval : timedelta , batteries_id : Set [ int ] | None = None , ) -> None : \"\"\"Create the class instance. Args: batteries_status_receiver: Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. min_update_interval: Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. batteries_id: Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. \"\"\" if batteries_id : self . _batteries : Set [ int ] = batteries_id else : self . _batteries = self . _get_all_batteries () self . _working_batteries : set [ int ] = set () self . _update_battery_status_task = asyncio . create_task ( self . _update_battery_status ( batteries_status_receiver ) ) self . _min_update_interval = min_update_interval self . _active_methods : dict [ str , AggregateMethod [ Any ]] = {} @property def battery_ids ( self ) -> Set [ int ]: \"\"\"Return ids of the batteries in the pool. Returns: Ids of the batteries in the pool \"\"\" return self . _batteries async def soc ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ SoCMetrics | None ]: \"\"\"Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + SoCCalculator . name () if method_name not in self . _active_methods : calculator = SoCCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def capacity ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ CapacityMetrics | None ]: \"\"\"Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + CapacityCalculator . name () if method_name not in self . _active_methods : calculator = CapacityCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def power_bounds ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ PowerMetrics | None ]: \"\"\"Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receivers channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + PowerBoundsCalculator . name () if method_name not in self . _active_methods : calculator = PowerBoundsCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def stop ( self ) -> None : \"\"\"Stop all pending async tasks.\"\"\" await asyncio . gather ( * [ method . stop () for method in self . _active_methods . values ()], cancel_and_await ( self . _update_battery_status_task ), ) def _get_all_batteries ( self ) -> Set [ int ]: \"\"\"Get all batteries from the microgrid. Returns: All batteries in the microgrid. \"\"\" graph = microgrid . get () . component_graph return { battery . component_id for battery in graph . components ( component_category = { ComponentCategory . BATTERY } ) } async def _update_battery_status ( self , receiver : Receiver [ BatteryStatus ]) -> None : async for status in receiver : self . _working_batteries = status . get_working_batteries ( self . _batteries # type: ignore[arg-type] ) for item in self . _active_methods . values (): item . update_working_batteries ( self . _working_batteries ) Attributes \u00a4 battery_ids : Set [ int ] property \u00a4 Return ids of the batteries in the pool. RETURNS DESCRIPTION Set [ int ] Ids of the batteries in the pool Functions \u00a4 __init__ ( batteries_status_receiver , min_update_interval , batteries_id = None ) \u00a4 Create the class instance. PARAMETER DESCRIPTION batteries_status_receiver Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. TYPE: Receiver [ BatteryStatus ] min_update_interval Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. TYPE: timedelta batteries_id Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. TYPE: Set [ int ] | None DEFAULT: None Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , batteries_status_receiver : Receiver [ BatteryStatus ], min_update_interval : timedelta , batteries_id : Set [ int ] | None = None , ) -> None : \"\"\"Create the class instance. Args: batteries_status_receiver: Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. min_update_interval: Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. batteries_id: Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. \"\"\" if batteries_id : self . _batteries : Set [ int ] = batteries_id else : self . _batteries = self . _get_all_batteries () self . _working_batteries : set [ int ] = set () self . _update_battery_status_task = asyncio . create_task ( self . _update_battery_status ( batteries_status_receiver ) ) self . _min_update_interval = min_update_interval self . _active_methods : dict [ str , AggregateMethod [ Any ]] = {} capacity ( maxsize = RECEIVER_MAX_SIZE ) async \u00a4 Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. PARAMETER DESCRIPTION maxsize Maxsize of the receiver channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ CapacityMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 async def capacity ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ CapacityMetrics | None ]: \"\"\"Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + CapacityCalculator . name () if method_name not in self . _active_methods : calculator = CapacityCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) power_bounds ( maxsize = RECEIVER_MAX_SIZE ) async \u00a4 Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. PARAMETER DESCRIPTION maxsize Maxsize of the receivers channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ PowerMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 async def power_bounds ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ PowerMetrics | None ]: \"\"\"Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receivers channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + PowerBoundsCalculator . name () if method_name not in self . _active_methods : calculator = PowerBoundsCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) soc ( maxsize = RECEIVER_MAX_SIZE ) async \u00a4 Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. PARAMETER DESCRIPTION maxsize Maxsize of the receiver channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ SoCMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 async def soc ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ SoCMetrics | None ]: \"\"\"Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + SoCCalculator . name () if method_name not in self . _active_methods : calculator = SoCCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) stop () async \u00a4 Stop all pending async tasks. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 164 165 166 167 168 169 async def stop ( self ) -> None : \"\"\"Stop all pending async tasks.\"\"\" await asyncio . gather ( * [ method . stop () for method in self . _active_methods . values ()], cancel_and_await ( self . _update_battery_status_task ), ) frequenz.sdk.timeseries.battery_pool.Bound dataclass \u00a4 Lower and upper bound values. Source code in frequenz/sdk/timeseries/battery_pool/_result_types.py 10 11 12 13 14 15 16 17 18 @dataclass class Bound : \"\"\"Lower and upper bound values.\"\"\" lower : float \"\"\"Lower bound.\"\"\" upper : float \"\"\"Upper bound.\"\"\" Attributes \u00a4 lower : float class-attribute \u00a4 Lower bound. upper : float class-attribute \u00a4 Upper bound. frequenz.sdk.timeseries.battery_pool.CapacityMetrics dataclass \u00a4 Capacity metrics. Source code in frequenz/sdk/timeseries/battery_pool/_result_types.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @dataclass class CapacityMetrics : \"\"\"Capacity metrics.\"\"\" # compare = False tells the dataclass to not use name for comparison methods timestamp : datetime = field ( compare = False ) \"\"\"Timestamp of the metrics,\"\"\" total_capacity : float \"\"\"Total batteries capacity. Calculated with the formula: ``` working_batteries: Set[BatteryData] # working batteries from the battery pool total_capacity = sum(battery.capacity for battery in working_batteries) ``` \"\"\" bound : Bound \"\"\"Capacity bounds. Bounds are calculated with the formula: ``` working_batteries: Set[BatteryData] # working batteries from the battery bound.lower = sum( battery.capacity * battery.soc_lower_bound for battery in working_batteries) bound.upper = sum( battery.capacity * battery.soc_upper_bound for battery in working_batteries) ``` \"\"\" Attributes \u00a4 bound : Bound class-attribute \u00a4 Capacity bounds. Bounds are calculated with the formula: working_batteries: Set[BatteryData] # working batteries from the battery bound.lower = sum( battery.capacity * battery.soc_lower_bound for battery in working_batteries) bound.upper = sum( battery.capacity * battery.soc_upper_bound for battery in working_batteries) timestamp : datetime = field ( compare = False ) class-attribute \u00a4 Timestamp of the metrics, total_capacity : float class-attribute \u00a4 Total batteries capacity. Calculated with the formula: working_batteries: Set[BatteryData] # working batteries from the battery pool total_capacity = sum(battery.capacity for battery in working_batteries) frequenz.sdk.timeseries.battery_pool.PowerMetrics dataclass \u00a4 Power bounds metrics. Source code in frequenz/sdk/timeseries/battery_pool/_result_types.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @dataclass class PowerMetrics : \"\"\"Power bounds metrics.\"\"\" # compare = False tells the dataclass to not use name for comparison methods timestamp : datetime = field ( compare = False ) \"\"\"Timestamp of the metrics.\"\"\" supply_bound : Bound \"\"\"Supply power bounds. Upper bound is always 0 and will be supported later. Lower bound is negative number calculated with with the formula: ``` working_pairs: Set[BatteryData, InverterData] # working batteries from the battery pool and adjacent inverters supply_bound.lower = sum( max( battery.power_lower_bound, inverter.active_power_lower_bound) for each working battery in battery pool ) ) ``` \"\"\" consume_bound : Bound \"\"\"Consume power bounds. Lower bound is always 0 and will be supported later. Upper bound is positive number calculated with with the formula: ``` working_pairs: Set[BatteryData, InverterData] # working batteries from the battery pool and adjacent inverters consume_bound.upper = sum( min( battery.power_upper_bound, inverter.active_power_upper_bound) for each working battery in battery pool ) ) ``` \"\"\" Attributes \u00a4 consume_bound : Bound class-attribute \u00a4 Consume power bounds. Lower bound is always 0 and will be supported later. Upper bound is positive number calculated with with the formula: working_pairs: Set[BatteryData, InverterData] # working batteries from the battery pool and adjacent inverters consume_bound.upper = sum( min( battery.power_upper_bound, inverter.active_power_upper_bound) for each working battery in battery pool ) ) supply_bound : Bound class-attribute \u00a4 Supply power bounds. Upper bound is always 0 and will be supported later. Lower bound is negative number calculated with with the formula: working_pairs: Set[BatteryData, InverterData] # working batteries from the battery pool and adjacent inverters supply_bound.lower = sum( max( battery.power_lower_bound, inverter.active_power_lower_bound) for each working battery in battery pool ) ) timestamp : datetime = field ( compare = False ) class-attribute \u00a4 Timestamp of the metrics. frequenz.sdk.timeseries.battery_pool.SoCMetrics dataclass \u00a4 Soc metrics. Source code in frequenz/sdk/timeseries/battery_pool/_result_types.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @dataclass class SoCMetrics : \"\"\"Soc metrics.\"\"\" # compare = False tells the dataclass to not use name for comparison methods timestamp : datetime = field ( compare = False ) \"\"\"Timestamp of the metrics.\"\"\" average_soc : float \"\"\"Average soc. Average soc is calculated with the formula: ``` working_batteries: Set[BatteryData] # working batteries from the battery pool used_capacity = sum(battery.capacity * battery.soc for battery in working_batteries) total_capacity = sum(battery.capacity for battery in working_batteries) average_soc = used_capacity/total_capacity ``` \"\"\" bound : Bound \"\"\"SoC bounds weighted by capacity. Bounds are calculated with the formula: capacity_lower_bound = sum( battery.capacity * battery.soc_lower_bound for battery in working_batteries) capacity_upper_bound = sum( battery.capacity * battery.soc_upper_bound for battery in working_batteries) total_capacity = sum(battery.capacity for battery in working_batteries) bound.lower = capacity_lower_bound/total_capacity bound.upper = capacity_upper_bound/total_capacity \"\"\" Attributes \u00a4 average_soc : float class-attribute \u00a4 Average soc. Average soc is calculated with the formula: working_batteries: Set[BatteryData] # working batteries from the battery pool used_capacity = sum(battery.capacity * battery.soc for battery in working_batteries) total_capacity = sum(battery.capacity for battery in working_batteries) average_soc = used_capacity/total_capacity bound : Bound class-attribute \u00a4 SoC bounds weighted by capacity. Bounds are calculated with the formula: capacity_lower_bound = sum( battery.capacity * battery.soc_lower_bound for battery in working_batteries) capacity_upper_bound = sum( battery.capacity * battery.soc_upper_bound for battery in working_batteries) total_capacity = sum(battery.capacity for battery in working_batteries) bound.lower = capacity_lower_bound/total_capacity bound.upper = capacity_upper_bound/total_capacity timestamp : datetime = field ( compare = False ) class-attribute \u00a4 Timestamp of the metrics.","title":"battery_pool"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool","text":"Manage a pool of batteries.","title":"battery_pool"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool","text":"Calculate high level metrics for a pool of the batteries. BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class BatteryPool : \"\"\"Calculate high level metrics for a pool of the batteries. BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset. \"\"\" def __init__ ( self , batteries_status_receiver : Receiver [ BatteryStatus ], min_update_interval : timedelta , batteries_id : Set [ int ] | None = None , ) -> None : \"\"\"Create the class instance. Args: batteries_status_receiver: Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. min_update_interval: Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. batteries_id: Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. \"\"\" if batteries_id : self . _batteries : Set [ int ] = batteries_id else : self . _batteries = self . _get_all_batteries () self . _working_batteries : set [ int ] = set () self . _update_battery_status_task = asyncio . create_task ( self . _update_battery_status ( batteries_status_receiver ) ) self . _min_update_interval = min_update_interval self . _active_methods : dict [ str , AggregateMethod [ Any ]] = {} @property def battery_ids ( self ) -> Set [ int ]: \"\"\"Return ids of the batteries in the pool. Returns: Ids of the batteries in the pool \"\"\" return self . _batteries async def soc ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ SoCMetrics | None ]: \"\"\"Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + SoCCalculator . name () if method_name not in self . _active_methods : calculator = SoCCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def capacity ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ CapacityMetrics | None ]: \"\"\"Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + CapacityCalculator . name () if method_name not in self . _active_methods : calculator = CapacityCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def power_bounds ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ PowerMetrics | None ]: \"\"\"Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receivers channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + PowerBoundsCalculator . name () if method_name not in self . _active_methods : calculator = PowerBoundsCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def stop ( self ) -> None : \"\"\"Stop all pending async tasks.\"\"\" await asyncio . gather ( * [ method . stop () for method in self . _active_methods . values ()], cancel_and_await ( self . _update_battery_status_task ), ) def _get_all_batteries ( self ) -> Set [ int ]: \"\"\"Get all batteries from the microgrid. Returns: All batteries in the microgrid. \"\"\" graph = microgrid . get () . component_graph return { battery . component_id for battery in graph . components ( component_category = { ComponentCategory . BATTERY } ) } async def _update_battery_status ( self , receiver : Receiver [ BatteryStatus ]) -> None : async for status in receiver : self . _working_batteries = status . get_working_batteries ( self . _batteries # type: ignore[arg-type] ) for item in self . _active_methods . values (): item . update_working_batteries ( self . _working_batteries )","title":"BatteryPool"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.battery_ids","text":"Return ids of the batteries in the pool. RETURNS DESCRIPTION Set [ int ] Ids of the batteries in the pool","title":"battery_ids"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.__init__","text":"Create the class instance. PARAMETER DESCRIPTION batteries_status_receiver Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. TYPE: Receiver [ BatteryStatus ] min_update_interval Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. TYPE: timedelta batteries_id Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. TYPE: Set [ int ] | None DEFAULT: None Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , batteries_status_receiver : Receiver [ BatteryStatus ], min_update_interval : timedelta , batteries_id : Set [ int ] | None = None , ) -> None : \"\"\"Create the class instance. Args: batteries_status_receiver: Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. min_update_interval: Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. batteries_id: Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. \"\"\" if batteries_id : self . _batteries : Set [ int ] = batteries_id else : self . _batteries = self . _get_all_batteries () self . _working_batteries : set [ int ] = set () self . _update_battery_status_task = asyncio . create_task ( self . _update_battery_status ( batteries_status_receiver ) ) self . _min_update_interval = min_update_interval self . _active_methods : dict [ str , AggregateMethod [ Any ]] = {}","title":"__init__()"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.capacity","text":"Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. PARAMETER DESCRIPTION maxsize Maxsize of the receiver channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ CapacityMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 async def capacity ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ CapacityMetrics | None ]: \"\"\"Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + CapacityCalculator . name () if method_name not in self . _active_methods : calculator = CapacityCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize )","title":"capacity()"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.power_bounds","text":"Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. PARAMETER DESCRIPTION maxsize Maxsize of the receivers channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ PowerMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 async def power_bounds ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ PowerMetrics | None ]: \"\"\"Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receivers channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + PowerBoundsCalculator . name () if method_name not in self . _active_methods : calculator = PowerBoundsCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize )","title":"power_bounds()"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.soc","text":"Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. PARAMETER DESCRIPTION maxsize Maxsize of the receiver channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ SoCMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 async def soc ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ SoCMetrics | None ]: \"\"\"Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + SoCCalculator . name () if method_name not in self . _active_methods : calculator = SoCCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize )","title":"soc()"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.stop","text":"Stop all pending async tasks. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 164 165 166 167 168 169 async def stop ( self ) -> None : \"\"\"Stop all pending async tasks.\"\"\" await asyncio . gather ( * [ method . stop () for method in self . _active_methods . values ()], cancel_and_await ( self . _update_battery_status_task ), )","title":"stop()"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Bound","text":"Lower and upper bound values. Source code in frequenz/sdk/timeseries/battery_pool/_result_types.py 10 11 12 13 14 15 16 17 18 @dataclass class Bound : \"\"\"Lower and upper bound values.\"\"\" lower : float \"\"\"Lower bound.\"\"\" upper : float \"\"\"Upper bound.\"\"\"","title":"Bound"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Bound-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.Bound.lower","text":"Lower bound.","title":"lower"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.Bound.upper","text":"Upper bound.","title":"upper"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.CapacityMetrics","text":"Capacity metrics. Source code in frequenz/sdk/timeseries/battery_pool/_result_types.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @dataclass class CapacityMetrics : \"\"\"Capacity metrics.\"\"\" # compare = False tells the dataclass to not use name for comparison methods timestamp : datetime = field ( compare = False ) \"\"\"Timestamp of the metrics,\"\"\" total_capacity : float \"\"\"Total batteries capacity. Calculated with the formula: ``` working_batteries: Set[BatteryData] # working batteries from the battery pool total_capacity = sum(battery.capacity for battery in working_batteries) ``` \"\"\" bound : Bound \"\"\"Capacity bounds. Bounds are calculated with the formula: ``` working_batteries: Set[BatteryData] # working batteries from the battery bound.lower = sum( battery.capacity * battery.soc_lower_bound for battery in working_batteries) bound.upper = sum( battery.capacity * battery.soc_upper_bound for battery in working_batteries) ``` \"\"\"","title":"CapacityMetrics"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.CapacityMetrics-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.CapacityMetrics.bound","text":"Capacity bounds. Bounds are calculated with the formula: working_batteries: Set[BatteryData] # working batteries from the battery bound.lower = sum( battery.capacity * battery.soc_lower_bound for battery in working_batteries) bound.upper = sum( battery.capacity * battery.soc_upper_bound for battery in working_batteries)","title":"bound"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.CapacityMetrics.timestamp","text":"Timestamp of the metrics,","title":"timestamp"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.CapacityMetrics.total_capacity","text":"Total batteries capacity. Calculated with the formula: working_batteries: Set[BatteryData] # working batteries from the battery pool total_capacity = sum(battery.capacity for battery in working_batteries)","title":"total_capacity"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics","text":"Power bounds metrics. Source code in frequenz/sdk/timeseries/battery_pool/_result_types.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @dataclass class PowerMetrics : \"\"\"Power bounds metrics.\"\"\" # compare = False tells the dataclass to not use name for comparison methods timestamp : datetime = field ( compare = False ) \"\"\"Timestamp of the metrics.\"\"\" supply_bound : Bound \"\"\"Supply power bounds. Upper bound is always 0 and will be supported later. Lower bound is negative number calculated with with the formula: ``` working_pairs: Set[BatteryData, InverterData] # working batteries from the battery pool and adjacent inverters supply_bound.lower = sum( max( battery.power_lower_bound, inverter.active_power_lower_bound) for each working battery in battery pool ) ) ``` \"\"\" consume_bound : Bound \"\"\"Consume power bounds. Lower bound is always 0 and will be supported later. Upper bound is positive number calculated with with the formula: ``` working_pairs: Set[BatteryData, InverterData] # working batteries from the battery pool and adjacent inverters consume_bound.upper = sum( min( battery.power_upper_bound, inverter.active_power_upper_bound) for each working battery in battery pool ) ) ``` \"\"\"","title":"PowerMetrics"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.PowerMetrics.consume_bound","text":"Consume power bounds. Lower bound is always 0 and will be supported later. Upper bound is positive number calculated with with the formula: working_pairs: Set[BatteryData, InverterData] # working batteries from the battery pool and adjacent inverters consume_bound.upper = sum( min( battery.power_upper_bound, inverter.active_power_upper_bound) for each working battery in battery pool ) )","title":"consume_bound"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.PowerMetrics.supply_bound","text":"Supply power bounds. Upper bound is always 0 and will be supported later. Lower bound is negative number calculated with with the formula: working_pairs: Set[BatteryData, InverterData] # working batteries from the battery pool and adjacent inverters supply_bound.lower = sum( max( battery.power_lower_bound, inverter.active_power_lower_bound) for each working battery in battery pool ) )","title":"supply_bound"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.PowerMetrics.timestamp","text":"Timestamp of the metrics.","title":"timestamp"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.SoCMetrics","text":"Soc metrics. Source code in frequenz/sdk/timeseries/battery_pool/_result_types.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @dataclass class SoCMetrics : \"\"\"Soc metrics.\"\"\" # compare = False tells the dataclass to not use name for comparison methods timestamp : datetime = field ( compare = False ) \"\"\"Timestamp of the metrics.\"\"\" average_soc : float \"\"\"Average soc. Average soc is calculated with the formula: ``` working_batteries: Set[BatteryData] # working batteries from the battery pool used_capacity = sum(battery.capacity * battery.soc for battery in working_batteries) total_capacity = sum(battery.capacity for battery in working_batteries) average_soc = used_capacity/total_capacity ``` \"\"\" bound : Bound \"\"\"SoC bounds weighted by capacity. Bounds are calculated with the formula: capacity_lower_bound = sum( battery.capacity * battery.soc_lower_bound for battery in working_batteries) capacity_upper_bound = sum( battery.capacity * battery.soc_upper_bound for battery in working_batteries) total_capacity = sum(battery.capacity for battery in working_batteries) bound.lower = capacity_lower_bound/total_capacity bound.upper = capacity_upper_bound/total_capacity \"\"\"","title":"SoCMetrics"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.SoCMetrics-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.SoCMetrics.average_soc","text":"Average soc. Average soc is calculated with the formula: working_batteries: Set[BatteryData] # working batteries from the battery pool used_capacity = sum(battery.capacity * battery.soc for battery in working_batteries) total_capacity = sum(battery.capacity for battery in working_batteries) average_soc = used_capacity/total_capacity","title":"average_soc"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.SoCMetrics.bound","text":"SoC bounds weighted by capacity. Bounds are calculated with the formula: capacity_lower_bound = sum( battery.capacity * battery.soc_lower_bound for battery in working_batteries) capacity_upper_bound = sum( battery.capacity * battery.soc_upper_bound for battery in working_batteries) total_capacity = sum(battery.capacity for battery in working_batteries) bound.lower = capacity_lower_bound/total_capacity bound.upper = capacity_upper_bound/total_capacity","title":"bound"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.SoCMetrics.timestamp","text":"Timestamp of the metrics.","title":"timestamp"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/","text":"frequenz.sdk.timeseries.battery_pool.battery_pool \u00a4 User interface for requesting aggregated battery-inverter data. Attributes \u00a4 Classes \u00a4 frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool \u00a4 Calculate high level metrics for a pool of the batteries. BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class BatteryPool : \"\"\"Calculate high level metrics for a pool of the batteries. BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset. \"\"\" def __init__ ( self , batteries_status_receiver : Receiver [ BatteryStatus ], min_update_interval : timedelta , batteries_id : Set [ int ] | None = None , ) -> None : \"\"\"Create the class instance. Args: batteries_status_receiver: Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. min_update_interval: Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. batteries_id: Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. \"\"\" if batteries_id : self . _batteries : Set [ int ] = batteries_id else : self . _batteries = self . _get_all_batteries () self . _working_batteries : set [ int ] = set () self . _update_battery_status_task = asyncio . create_task ( self . _update_battery_status ( batteries_status_receiver ) ) self . _min_update_interval = min_update_interval self . _active_methods : dict [ str , AggregateMethod [ Any ]] = {} @property def battery_ids ( self ) -> Set [ int ]: \"\"\"Return ids of the batteries in the pool. Returns: Ids of the batteries in the pool \"\"\" return self . _batteries async def soc ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ SoCMetrics | None ]: \"\"\"Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + SoCCalculator . name () if method_name not in self . _active_methods : calculator = SoCCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def capacity ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ CapacityMetrics | None ]: \"\"\"Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + CapacityCalculator . name () if method_name not in self . _active_methods : calculator = CapacityCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def power_bounds ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ PowerMetrics | None ]: \"\"\"Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receivers channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + PowerBoundsCalculator . name () if method_name not in self . _active_methods : calculator = PowerBoundsCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def stop ( self ) -> None : \"\"\"Stop all pending async tasks.\"\"\" await asyncio . gather ( * [ method . stop () for method in self . _active_methods . values ()], cancel_and_await ( self . _update_battery_status_task ), ) def _get_all_batteries ( self ) -> Set [ int ]: \"\"\"Get all batteries from the microgrid. Returns: All batteries in the microgrid. \"\"\" graph = microgrid . get () . component_graph return { battery . component_id for battery in graph . components ( component_category = { ComponentCategory . BATTERY } ) } async def _update_battery_status ( self , receiver : Receiver [ BatteryStatus ]) -> None : async for status in receiver : self . _working_batteries = status . get_working_batteries ( self . _batteries # type: ignore[arg-type] ) for item in self . _active_methods . values (): item . update_working_batteries ( self . _working_batteries ) Attributes \u00a4 battery_ids : Set [ int ] property \u00a4 Return ids of the batteries in the pool. RETURNS DESCRIPTION Set [ int ] Ids of the batteries in the pool Functions \u00a4 __init__ ( batteries_status_receiver , min_update_interval , batteries_id = None ) \u00a4 Create the class instance. PARAMETER DESCRIPTION batteries_status_receiver Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. TYPE: Receiver [ BatteryStatus ] min_update_interval Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. TYPE: timedelta batteries_id Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. TYPE: Set [ int ] | None DEFAULT: None Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , batteries_status_receiver : Receiver [ BatteryStatus ], min_update_interval : timedelta , batteries_id : Set [ int ] | None = None , ) -> None : \"\"\"Create the class instance. Args: batteries_status_receiver: Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. min_update_interval: Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. batteries_id: Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. \"\"\" if batteries_id : self . _batteries : Set [ int ] = batteries_id else : self . _batteries = self . _get_all_batteries () self . _working_batteries : set [ int ] = set () self . _update_battery_status_task = asyncio . create_task ( self . _update_battery_status ( batteries_status_receiver ) ) self . _min_update_interval = min_update_interval self . _active_methods : dict [ str , AggregateMethod [ Any ]] = {} capacity ( maxsize = RECEIVER_MAX_SIZE ) async \u00a4 Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. PARAMETER DESCRIPTION maxsize Maxsize of the receiver channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ CapacityMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 async def capacity ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ CapacityMetrics | None ]: \"\"\"Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + CapacityCalculator . name () if method_name not in self . _active_methods : calculator = CapacityCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) power_bounds ( maxsize = RECEIVER_MAX_SIZE ) async \u00a4 Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. PARAMETER DESCRIPTION maxsize Maxsize of the receivers channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ PowerMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 async def power_bounds ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ PowerMetrics | None ]: \"\"\"Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receivers channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + PowerBoundsCalculator . name () if method_name not in self . _active_methods : calculator = PowerBoundsCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) soc ( maxsize = RECEIVER_MAX_SIZE ) async \u00a4 Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. PARAMETER DESCRIPTION maxsize Maxsize of the receiver channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ SoCMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 async def soc ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ SoCMetrics | None ]: \"\"\"Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + SoCCalculator . name () if method_name not in self . _active_methods : calculator = SoCCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) stop () async \u00a4 Stop all pending async tasks. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 164 165 166 167 168 169 async def stop ( self ) -> None : \"\"\"Stop all pending async tasks.\"\"\" await asyncio . gather ( * [ method . stop () for method in self . _active_methods . values ()], cancel_and_await ( self . _update_battery_status_task ), ) Functions \u00a4","title":"battery_pool"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool","text":"User interface for requesting aggregated battery-inverter data.","title":"battery_pool"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool","text":"Calculate high level metrics for a pool of the batteries. BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 class BatteryPool : \"\"\"Calculate high level metrics for a pool of the batteries. BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset. \"\"\" def __init__ ( self , batteries_status_receiver : Receiver [ BatteryStatus ], min_update_interval : timedelta , batteries_id : Set [ int ] | None = None , ) -> None : \"\"\"Create the class instance. Args: batteries_status_receiver: Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. min_update_interval: Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. batteries_id: Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. \"\"\" if batteries_id : self . _batteries : Set [ int ] = batteries_id else : self . _batteries = self . _get_all_batteries () self . _working_batteries : set [ int ] = set () self . _update_battery_status_task = asyncio . create_task ( self . _update_battery_status ( batteries_status_receiver ) ) self . _min_update_interval = min_update_interval self . _active_methods : dict [ str , AggregateMethod [ Any ]] = {} @property def battery_ids ( self ) -> Set [ int ]: \"\"\"Return ids of the batteries in the pool. Returns: Ids of the batteries in the pool \"\"\" return self . _batteries async def soc ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ SoCMetrics | None ]: \"\"\"Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + SoCCalculator . name () if method_name not in self . _active_methods : calculator = SoCCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def capacity ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ CapacityMetrics | None ]: \"\"\"Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + CapacityCalculator . name () if method_name not in self . _active_methods : calculator = CapacityCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def power_bounds ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ PowerMetrics | None ]: \"\"\"Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receivers channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + PowerBoundsCalculator . name () if method_name not in self . _active_methods : calculator = PowerBoundsCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize ) async def stop ( self ) -> None : \"\"\"Stop all pending async tasks.\"\"\" await asyncio . gather ( * [ method . stop () for method in self . _active_methods . values ()], cancel_and_await ( self . _update_battery_status_task ), ) def _get_all_batteries ( self ) -> Set [ int ]: \"\"\"Get all batteries from the microgrid. Returns: All batteries in the microgrid. \"\"\" graph = microgrid . get () . component_graph return { battery . component_id for battery in graph . components ( component_category = { ComponentCategory . BATTERY } ) } async def _update_battery_status ( self , receiver : Receiver [ BatteryStatus ]) -> None : async for status in receiver : self . _working_batteries = status . get_working_batteries ( self . _batteries # type: ignore[arg-type] ) for item in self . _active_methods . values (): item . update_working_batteries ( self . _working_batteries )","title":"BatteryPool"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool-attributes","text":"","title":"Attributes"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.battery_ids","text":"Return ids of the batteries in the pool. RETURNS DESCRIPTION Set [ int ] Ids of the batteries in the pool","title":"battery_ids"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.__init__","text":"Create the class instance. PARAMETER DESCRIPTION batteries_status_receiver Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. TYPE: Receiver [ BatteryStatus ] min_update_interval Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. TYPE: timedelta batteries_id Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. TYPE: Set [ int ] | None DEFAULT: None Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , batteries_status_receiver : Receiver [ BatteryStatus ], min_update_interval : timedelta , batteries_id : Set [ int ] | None = None , ) -> None : \"\"\"Create the class instance. Args: batteries_status_receiver: Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery. min_update_interval: Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them. batteries_id: Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used. \"\"\" if batteries_id : self . _batteries : Set [ int ] = batteries_id else : self . _batteries = self . _get_all_batteries () self . _working_batteries : set [ int ] = set () self . _update_battery_status_task = asyncio . create_task ( self . _update_battery_status ( batteries_status_receiver ) ) self . _min_update_interval = min_update_interval self . _active_methods : dict [ str , AggregateMethod [ Any ]] = {}","title":"__init__()"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.capacity","text":"Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. PARAMETER DESCRIPTION maxsize Maxsize of the receiver channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ CapacityMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 async def capacity ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ CapacityMetrics | None ]: \"\"\"Get receiver to receive new capacity metrics when they change. Capacity formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + CapacityCalculator . name () if method_name not in self . _active_methods : calculator = CapacityCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize )","title":"capacity()"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.power_bounds","text":"Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. PARAMETER DESCRIPTION maxsize Maxsize of the receivers channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ PowerMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 async def power_bounds ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ PowerMetrics | None ]: \"\"\"Get receiver to receive new power bounds when they change. Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics. Args: maxsize: Maxsize of the receivers channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + PowerBoundsCalculator . name () if method_name not in self . _active_methods : calculator = PowerBoundsCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize )","title":"power_bounds()"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.soc","text":"Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. PARAMETER DESCRIPTION maxsize Maxsize of the receiver channel. TYPE: int | None DEFAULT: RECEIVER_MAX_SIZE RETURNS DESCRIPTION Receiver [ SoCMetrics | None] Receiver for this metric. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 async def soc ( self , maxsize : int | None = RECEIVER_MAX_SIZE ) -> Receiver [ SoCMetrics | None ]: \"\"\"Get receiver to receive new soc metrics when they change. Soc formulas are described in the receiver return type. None will be send if there is no component to calculate metric. Args: maxsize: Maxsize of the receiver channel. Returns: Receiver for this metric. \"\"\" method_name = SendOnUpdate . name () + \"_\" + SoCCalculator . name () if method_name not in self . _active_methods : calculator = SoCCalculator ( self . _batteries ) self . _active_methods [ method_name ] = SendOnUpdate ( metric_calculator = calculator , working_batteries = self . _working_batteries , min_update_interval = self . _min_update_interval , ) running_method = self . _active_methods [ method_name ] return running_method . new_receiver ( maxsize )","title":"soc()"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.stop","text":"Stop all pending async tasks. Source code in frequenz/sdk/timeseries/battery_pool/battery_pool.py 164 165 166 167 168 169 async def stop ( self ) -> None : \"\"\"Stop all pending async tasks.\"\"\" await asyncio . gather ( * [ method . stop () for method in self . _active_methods . values ()], cancel_and_await ( self . _update_battery_status_task ), )","title":"stop()"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/","text":"frequenz.sdk.timeseries.ev_charger_pool \u00a4 Interactions with EV Chargers. Classes \u00a4 frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool \u00a4 Interactions with EV Chargers. Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class EVChargerPool : \"\"\"Interactions with EV Chargers.\"\"\" def __init__ ( self , channel_registry : ChannelRegistry , resampler_subscription_sender : Sender [ ComponentMetricRequest ], component_ids : set [ int ] | None = None , ) -> None : \"\"\"Create an `EVChargerPool` instance. Args: channel_registry: A channel registry instance shared with the resampling actor. resampler_subscription_sender: A sender for sending metric requests to the resampling actor. component_ids: An optional list of component_ids belonging to this pool. If not specified, IDs of all EV Chargers in the microgrid will be fetched from the component graph. \"\"\" self . _channel_registry : ChannelRegistry = channel_registry self . _resampler_subscription_sender : Sender [ ComponentMetricRequest ] = resampler_subscription_sender self . _component_ids : set [ int ] = set () if component_ids is not None : self . _component_ids = component_ids else : graph = microgrid . get () . component_graph self . _component_ids = { evc . component_id for evc in graph . components ( component_category = { ComponentCategory . EV_CHARGER } ) } self . _namespace : str = f \"ev-charger-pool- { uuid . uuid4 () } \" self . _formula_pool : FormulaEnginePool = FormulaEnginePool ( self . _namespace , self . _channel_registry , self . _resampler_subscription_sender , ) async def total_current ( self ) -> FormulaReceiver3Phase : \"\"\"Fetch the total current for the EV Chargers in the pool. If a formula engine to calculate EV Charger current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream EV Charger current values. \"\"\" return await self . _formula_pool . from_generator ( \"ev_charger_total_current\" , EVChargerCurrentFormula , FormulaGeneratorConfig ( component_ids = self . _component_ids ), ) async def total_power ( self ) -> FormulaReceiver : \"\"\"Fetch the total power for the EV Chargers in the pool. If a formula engine to calculate EV Charger power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream EV Charger power values. \"\"\" return await self . _formula_pool . from_generator ( \"ev_charger_total_power\" , EVChargerPowerFormula , FormulaGeneratorConfig ( component_ids = self . _component_ids ), ) async def current ( self , component_id : int ) -> FormulaReceiver3Phase : \"\"\"Fetch the 3-phase current for the given EV Charger id. Args: component_id: id of the EV Charger to stream current values for. Returns: A *new* receiver that will stream 3-phase current values for the given EV Charger. Raises: EVChargerPoolError: if the given component_id is not part of the pool. \"\"\" if component_id not in self . _component_ids : raise EVChargerPoolError ( f \" { component_id =} is not part of the EVChargerPool\" f \" (with ids= { self . _component_ids } )\" ) return await self . _formula_pool . from_generator ( f \"ev_charger_current_ { component_id } \" , EVChargerCurrentFormula , FormulaGeneratorConfig ( component_ids = { component_id }), ) async def power ( self , component_id : int ) -> FormulaReceiver : \"\"\"Fetch the power for the given EV Charger id. Args: component_id: id of the EV Charger to stream power values for. Returns: A *new* receiver that will stream power values for the given EV Charger. Raises: EVChargerPoolError: if the given component_id is not part of the pool. \"\"\" if component_id not in self . _component_ids : raise EVChargerPoolError ( f \" { component_id =} is not part of the EVChargerPool\" f \" (with ids= { self . _component_ids } )\" ) return await self . _formula_pool . from_generator ( f \"ev_charger_current_ { component_id } \" , EVChargerPowerFormula , FormulaGeneratorConfig ( component_ids = { component_id }), ) Functions \u00a4 __init__ ( channel_registry , resampler_subscription_sender , component_ids = None ) \u00a4 Create an EVChargerPool instance. PARAMETER DESCRIPTION channel_registry A channel registry instance shared with the resampling actor. TYPE: ChannelRegistry resampler_subscription_sender A sender for sending metric requests to the resampling actor. TYPE: Sender [ ComponentMetricRequest ] component_ids An optional list of component_ids belonging to this pool. If not specified, IDs of all EV Chargers in the microgrid will be fetched from the component graph. TYPE: set [ int ] | None DEFAULT: None Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def __init__ ( self , channel_registry : ChannelRegistry , resampler_subscription_sender : Sender [ ComponentMetricRequest ], component_ids : set [ int ] | None = None , ) -> None : \"\"\"Create an `EVChargerPool` instance. Args: channel_registry: A channel registry instance shared with the resampling actor. resampler_subscription_sender: A sender for sending metric requests to the resampling actor. component_ids: An optional list of component_ids belonging to this pool. If not specified, IDs of all EV Chargers in the microgrid will be fetched from the component graph. \"\"\" self . _channel_registry : ChannelRegistry = channel_registry self . _resampler_subscription_sender : Sender [ ComponentMetricRequest ] = resampler_subscription_sender self . _component_ids : set [ int ] = set () if component_ids is not None : self . _component_ids = component_ids else : graph = microgrid . get () . component_graph self . _component_ids = { evc . component_id for evc in graph . components ( component_category = { ComponentCategory . EV_CHARGER } ) } self . _namespace : str = f \"ev-charger-pool- { uuid . uuid4 () } \" self . _formula_pool : FormulaEnginePool = FormulaEnginePool ( self . _namespace , self . _channel_registry , self . _resampler_subscription_sender , ) current ( component_id ) async \u00a4 Fetch the 3-phase current for the given EV Charger id. PARAMETER DESCRIPTION component_id id of the EV Charger to stream current values for. TYPE: int RETURNS DESCRIPTION FormulaReceiver3Phase A new receiver that will stream 3-phase current values for the given EV Charger. RAISES DESCRIPTION EVChargerPoolError if the given component_id is not part of the pool. Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 async def current ( self , component_id : int ) -> FormulaReceiver3Phase : \"\"\"Fetch the 3-phase current for the given EV Charger id. Args: component_id: id of the EV Charger to stream current values for. Returns: A *new* receiver that will stream 3-phase current values for the given EV Charger. Raises: EVChargerPoolError: if the given component_id is not part of the pool. \"\"\" if component_id not in self . _component_ids : raise EVChargerPoolError ( f \" { component_id =} is not part of the EVChargerPool\" f \" (with ids= { self . _component_ids } )\" ) return await self . _formula_pool . from_generator ( f \"ev_charger_current_ { component_id } \" , EVChargerCurrentFormula , FormulaGeneratorConfig ( component_ids = { component_id }), ) power ( component_id ) async \u00a4 Fetch the power for the given EV Charger id. PARAMETER DESCRIPTION component_id id of the EV Charger to stream power values for. TYPE: int RETURNS DESCRIPTION FormulaReceiver A new receiver that will stream power values for the given EV Charger. RAISES DESCRIPTION EVChargerPoolError if the given component_id is not part of the pool. Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 async def power ( self , component_id : int ) -> FormulaReceiver : \"\"\"Fetch the power for the given EV Charger id. Args: component_id: id of the EV Charger to stream power values for. Returns: A *new* receiver that will stream power values for the given EV Charger. Raises: EVChargerPoolError: if the given component_id is not part of the pool. \"\"\" if component_id not in self . _component_ids : raise EVChargerPoolError ( f \" { component_id =} is not part of the EVChargerPool\" f \" (with ids= { self . _component_ids } )\" ) return await self . _formula_pool . from_generator ( f \"ev_charger_current_ { component_id } \" , EVChargerPowerFormula , FormulaGeneratorConfig ( component_ids = { component_id }), ) total_current () async \u00a4 Fetch the total current for the EV Chargers in the pool. If a formula engine to calculate EV Charger current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver3Phase A new receiver that will stream EV Charger current values. Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 async def total_current ( self ) -> FormulaReceiver3Phase : \"\"\"Fetch the total current for the EV Chargers in the pool. If a formula engine to calculate EV Charger current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream EV Charger current values. \"\"\" return await self . _formula_pool . from_generator ( \"ev_charger_total_current\" , EVChargerCurrentFormula , FormulaGeneratorConfig ( component_ids = self . _component_ids ), ) total_power () async \u00a4 Fetch the total power for the EV Chargers in the pool. If a formula engine to calculate EV Charger power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver A new receiver that will stream EV Charger power values. Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 async def total_power ( self ) -> FormulaReceiver : \"\"\"Fetch the total power for the EV Chargers in the pool. If a formula engine to calculate EV Charger power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream EV Charger power values. \"\"\" return await self . _formula_pool . from_generator ( \"ev_charger_total_power\" , EVChargerPowerFormula , FormulaGeneratorConfig ( component_ids = self . _component_ids ), )","title":"ev_charger_pool"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool","text":"Interactions with EV Chargers.","title":"ev_charger_pool"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool","text":"Interactions with EV Chargers. Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class EVChargerPool : \"\"\"Interactions with EV Chargers.\"\"\" def __init__ ( self , channel_registry : ChannelRegistry , resampler_subscription_sender : Sender [ ComponentMetricRequest ], component_ids : set [ int ] | None = None , ) -> None : \"\"\"Create an `EVChargerPool` instance. Args: channel_registry: A channel registry instance shared with the resampling actor. resampler_subscription_sender: A sender for sending metric requests to the resampling actor. component_ids: An optional list of component_ids belonging to this pool. If not specified, IDs of all EV Chargers in the microgrid will be fetched from the component graph. \"\"\" self . _channel_registry : ChannelRegistry = channel_registry self . _resampler_subscription_sender : Sender [ ComponentMetricRequest ] = resampler_subscription_sender self . _component_ids : set [ int ] = set () if component_ids is not None : self . _component_ids = component_ids else : graph = microgrid . get () . component_graph self . _component_ids = { evc . component_id for evc in graph . components ( component_category = { ComponentCategory . EV_CHARGER } ) } self . _namespace : str = f \"ev-charger-pool- { uuid . uuid4 () } \" self . _formula_pool : FormulaEnginePool = FormulaEnginePool ( self . _namespace , self . _channel_registry , self . _resampler_subscription_sender , ) async def total_current ( self ) -> FormulaReceiver3Phase : \"\"\"Fetch the total current for the EV Chargers in the pool. If a formula engine to calculate EV Charger current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream EV Charger current values. \"\"\" return await self . _formula_pool . from_generator ( \"ev_charger_total_current\" , EVChargerCurrentFormula , FormulaGeneratorConfig ( component_ids = self . _component_ids ), ) async def total_power ( self ) -> FormulaReceiver : \"\"\"Fetch the total power for the EV Chargers in the pool. If a formula engine to calculate EV Charger power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream EV Charger power values. \"\"\" return await self . _formula_pool . from_generator ( \"ev_charger_total_power\" , EVChargerPowerFormula , FormulaGeneratorConfig ( component_ids = self . _component_ids ), ) async def current ( self , component_id : int ) -> FormulaReceiver3Phase : \"\"\"Fetch the 3-phase current for the given EV Charger id. Args: component_id: id of the EV Charger to stream current values for. Returns: A *new* receiver that will stream 3-phase current values for the given EV Charger. Raises: EVChargerPoolError: if the given component_id is not part of the pool. \"\"\" if component_id not in self . _component_ids : raise EVChargerPoolError ( f \" { component_id =} is not part of the EVChargerPool\" f \" (with ids= { self . _component_ids } )\" ) return await self . _formula_pool . from_generator ( f \"ev_charger_current_ { component_id } \" , EVChargerCurrentFormula , FormulaGeneratorConfig ( component_ids = { component_id }), ) async def power ( self , component_id : int ) -> FormulaReceiver : \"\"\"Fetch the power for the given EV Charger id. Args: component_id: id of the EV Charger to stream power values for. Returns: A *new* receiver that will stream power values for the given EV Charger. Raises: EVChargerPoolError: if the given component_id is not part of the pool. \"\"\" if component_id not in self . _component_ids : raise EVChargerPoolError ( f \" { component_id =} is not part of the EVChargerPool\" f \" (with ids= { self . _component_ids } )\" ) return await self . _formula_pool . from_generator ( f \"ev_charger_current_ { component_id } \" , EVChargerPowerFormula , FormulaGeneratorConfig ( component_ids = { component_id }), )","title":"EVChargerPool"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.__init__","text":"Create an EVChargerPool instance. PARAMETER DESCRIPTION channel_registry A channel registry instance shared with the resampling actor. TYPE: ChannelRegistry resampler_subscription_sender A sender for sending metric requests to the resampling actor. TYPE: Sender [ ComponentMetricRequest ] component_ids An optional list of component_ids belonging to this pool. If not specified, IDs of all EV Chargers in the microgrid will be fetched from the component graph. TYPE: set [ int ] | None DEFAULT: None Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def __init__ ( self , channel_registry : ChannelRegistry , resampler_subscription_sender : Sender [ ComponentMetricRequest ], component_ids : set [ int ] | None = None , ) -> None : \"\"\"Create an `EVChargerPool` instance. Args: channel_registry: A channel registry instance shared with the resampling actor. resampler_subscription_sender: A sender for sending metric requests to the resampling actor. component_ids: An optional list of component_ids belonging to this pool. If not specified, IDs of all EV Chargers in the microgrid will be fetched from the component graph. \"\"\" self . _channel_registry : ChannelRegistry = channel_registry self . _resampler_subscription_sender : Sender [ ComponentMetricRequest ] = resampler_subscription_sender self . _component_ids : set [ int ] = set () if component_ids is not None : self . _component_ids = component_ids else : graph = microgrid . get () . component_graph self . _component_ids = { evc . component_id for evc in graph . components ( component_category = { ComponentCategory . EV_CHARGER } ) } self . _namespace : str = f \"ev-charger-pool- { uuid . uuid4 () } \" self . _formula_pool : FormulaEnginePool = FormulaEnginePool ( self . _namespace , self . _channel_registry , self . _resampler_subscription_sender , )","title":"__init__()"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.current","text":"Fetch the 3-phase current for the given EV Charger id. PARAMETER DESCRIPTION component_id id of the EV Charger to stream current values for. TYPE: int RETURNS DESCRIPTION FormulaReceiver3Phase A new receiver that will stream 3-phase current values for the given EV Charger. RAISES DESCRIPTION EVChargerPoolError if the given component_id is not part of the pool. Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 async def current ( self , component_id : int ) -> FormulaReceiver3Phase : \"\"\"Fetch the 3-phase current for the given EV Charger id. Args: component_id: id of the EV Charger to stream current values for. Returns: A *new* receiver that will stream 3-phase current values for the given EV Charger. Raises: EVChargerPoolError: if the given component_id is not part of the pool. \"\"\" if component_id not in self . _component_ids : raise EVChargerPoolError ( f \" { component_id =} is not part of the EVChargerPool\" f \" (with ids= { self . _component_ids } )\" ) return await self . _formula_pool . from_generator ( f \"ev_charger_current_ { component_id } \" , EVChargerCurrentFormula , FormulaGeneratorConfig ( component_ids = { component_id }), )","title":"current()"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.power","text":"Fetch the power for the given EV Charger id. PARAMETER DESCRIPTION component_id id of the EV Charger to stream power values for. TYPE: int RETURNS DESCRIPTION FormulaReceiver A new receiver that will stream power values for the given EV Charger. RAISES DESCRIPTION EVChargerPoolError if the given component_id is not part of the pool. Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 async def power ( self , component_id : int ) -> FormulaReceiver : \"\"\"Fetch the power for the given EV Charger id. Args: component_id: id of the EV Charger to stream power values for. Returns: A *new* receiver that will stream power values for the given EV Charger. Raises: EVChargerPoolError: if the given component_id is not part of the pool. \"\"\" if component_id not in self . _component_ids : raise EVChargerPoolError ( f \" { component_id =} is not part of the EVChargerPool\" f \" (with ids= { self . _component_ids } )\" ) return await self . _formula_pool . from_generator ( f \"ev_charger_current_ { component_id } \" , EVChargerPowerFormula , FormulaGeneratorConfig ( component_ids = { component_id }), )","title":"power()"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.total_current","text":"Fetch the total current for the EV Chargers in the pool. If a formula engine to calculate EV Charger current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver3Phase A new receiver that will stream EV Charger current values. Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 async def total_current ( self ) -> FormulaReceiver3Phase : \"\"\"Fetch the total current for the EV Chargers in the pool. If a formula engine to calculate EV Charger current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream EV Charger current values. \"\"\" return await self . _formula_pool . from_generator ( \"ev_charger_total_current\" , EVChargerCurrentFormula , FormulaGeneratorConfig ( component_ids = self . _component_ids ), )","title":"total_current()"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.total_power","text":"Fetch the total power for the EV Chargers in the pool. If a formula engine to calculate EV Charger power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver A new receiver that will stream EV Charger power values. Source code in frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 async def total_power ( self ) -> FormulaReceiver : \"\"\"Fetch the total power for the EV Chargers in the pool. If a formula engine to calculate EV Charger power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream EV Charger power values. \"\"\" return await self . _formula_pool . from_generator ( \"ev_charger_total_power\" , EVChargerPowerFormula , FormulaGeneratorConfig ( component_ids = self . _component_ids ), )","title":"total_power()"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/","text":"frequenz.sdk.timeseries.logical_meter \u00a4 A logical meter for calculating high level metrics for a microgrid. Classes \u00a4 frequenz.sdk.timeseries.logical_meter.LogicalMeter \u00a4 A logical meter for calculating high level metrics in a microgrid. LogicalMeter provides methods for fetching power values from different points in the microgrid. These methods return FormulaReceiver objects, which can be used like normal Receiver s, but can also be composed to form higher-order formula streams. Example channel_registry = ChannelRegistry ( name = \"data-registry\" ) # Create a channels for sending/receiving subscription requests data_source_request_channel = Broadcast [ ComponentMetricRequest ]( \"data-source\" ) data_source_request_sender = data_source_request_channel . new_sender () data_source_request_receiver = data_source_request_channel . new_receiver () resampling_request_channel = Broadcast [ ComponentMetricRequest ]( \"resample\" ) resampling_request_sender = resampling_request_channel . new_sender () resampling_request_receiver = resampling_request_channel . new_receiver () # Instantiate a data sourcing actor _data_sourcing_actor = DataSourcingActor ( request_receiver = data_source_request_receiver , registry = channel_registry ) # Instantiate a resampling actor _resampling_actor = ComponentMetricsResamplingActor ( channel_registry = channel_registry , data_sourcing_request_sender = data_source_request_sender , resampling_request_receiver = resampling_request_receiver , config = ResamplerConfig ( resampling_period_s = 1 ), ) # Create a logical meter instance logical_meter = LogicalMeter ( channel_registry , resampling_request_sender , microgrid . get () . component_graph , ) # Get a receiver for a builtin formula grid_power_recv = logical_meter . grid_power () for grid_power_sample in grid_power_recv : print ( grid_power_sample ) # or compose formula receivers to create a new formula net_power_recv = ( ( logical_meter . grid_power () - logical_meter . battery_power () - logical_meter . pv_power () ) . build ( \"net_power\" ) . new_receiver () ) for net_power_sample in net_power_recv : print ( net_power_sample ) Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class LogicalMeter : \"\"\"A logical meter for calculating high level metrics in a microgrid. LogicalMeter provides methods for fetching power values from different points in the microgrid. These methods return `FormulaReceiver` objects, which can be used like normal `Receiver`s, but can also be composed to form higher-order formula streams. Example: ``` python channel_registry = ChannelRegistry(name=\"data-registry\") # Create a channels for sending/receiving subscription requests data_source_request_channel = Broadcast[ComponentMetricRequest](\"data-source\") data_source_request_sender = data_source_request_channel.new_sender() data_source_request_receiver = data_source_request_channel.new_receiver() resampling_request_channel = Broadcast[ComponentMetricRequest](\"resample\") resampling_request_sender = resampling_request_channel.new_sender() resampling_request_receiver = resampling_request_channel.new_receiver() # Instantiate a data sourcing actor _data_sourcing_actor = DataSourcingActor( request_receiver=data_source_request_receiver, registry=channel_registry ) # Instantiate a resampling actor _resampling_actor = ComponentMetricsResamplingActor( channel_registry=channel_registry, data_sourcing_request_sender=data_source_request_sender, resampling_request_receiver=resampling_request_receiver, config=ResamplerConfig(resampling_period_s=1), ) # Create a logical meter instance logical_meter = LogicalMeter( channel_registry, resampling_request_sender, microgrid.get().component_graph, ) # Get a receiver for a builtin formula grid_power_recv = logical_meter.grid_power() for grid_power_sample in grid_power_recv: print(grid_power_sample) # or compose formula receivers to create a new formula net_power_recv = ( ( logical_meter.grid_power() - logical_meter.battery_power() - logical_meter.pv_power() ) .build(\"net_power\") .new_receiver() ) for net_power_sample in net_power_recv: print(net_power_sample) ``` \"\"\" def __init__ ( self , channel_registry : ChannelRegistry , resampler_subscription_sender : Sender [ ComponentMetricRequest ], component_graph : ComponentGraph , ) -> None : \"\"\"Create a `LogicalMeter instance`. Args: channel_registry: A channel registry instance shared with the resampling actor. resampler_subscription_sender: A sender for sending metric requests to the resampling actor. component_graph: The component graph representing the microgrid. \"\"\" self . _channel_registry = channel_registry self . _resampler_subscription_sender = resampler_subscription_sender # Use a randomly generated uuid to create a unique namespace name for the local # meter to use when communicating with the resampling actor. self . _namespace = f \"logical-meter- { uuid . uuid4 () } \" self . _component_graph = component_graph self . _formula_pool = FormulaEnginePool ( self . _namespace , self . _channel_registry , self . _resampler_subscription_sender , ) async def start_formula ( self , formula : str , component_metric_id : ComponentMetricId , nones_are_zeros : bool = False , ) -> FormulaReceiver : \"\"\"Start execution of the given formula. Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and these operators: +, -, *, /, (, ). For example, the input string: \"#20 + #5\" is a formula for adding metrics from two components with ids 20 and 5. Args: formula: formula to execute. component_metric_id: The metric ID to use when fetching receivers from the resampling actor. nones_are_zeros: Whether to treat None values from the stream as 0s. If False, the returned value will be a None. Returns: A FormulaReceiver that streams values with the formulas applied. \"\"\" return await self . _formula_pool . from_string ( formula , component_metric_id , nones_are_zeros ) async def grid_power ( self ) -> FormulaReceiver : \"\"\"Fetch the grid power for the microgrid. If a formula engine to calculate grid power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream grid_power values. \"\"\" return await self . _formula_pool . from_generator ( \"grid_power\" , GridPowerFormula ) async def grid_current ( self ) -> FormulaReceiver3Phase : \"\"\"Fetch the grid power for the microgrid. If a formula engine to calculate grid current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream grid_current values. \"\"\" return await self . _formula_pool . from_generator ( \"grid_current\" , GridCurrentFormula ) async def battery_power ( self ) -> FormulaReceiver : \"\"\"Fetch the cumulative battery power in the microgrid. If a formula engine to calculate cumulative battery power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream battery_power values. \"\"\" return await self . _formula_pool . from_generator ( \"battery_power\" , BatteryPowerFormula ) async def pv_power ( self ) -> FormulaReceiver : \"\"\"Fetch the PV power production in the microgrid. If a formula engine to calculate PV power production is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream PV power production values. \"\"\" return await self . _formula_pool . from_generator ( \"pv_power\" , PVPowerFormula ) Functions \u00a4 __init__ ( channel_registry , resampler_subscription_sender , component_graph ) \u00a4 Create a LogicalMeter instance . PARAMETER DESCRIPTION channel_registry A channel registry instance shared with the resampling actor. TYPE: ChannelRegistry resampler_subscription_sender A sender for sending metric requests to the resampling actor. TYPE: Sender [ ComponentMetricRequest ] component_graph The component graph representing the microgrid. TYPE: ComponentGraph Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def __init__ ( self , channel_registry : ChannelRegistry , resampler_subscription_sender : Sender [ ComponentMetricRequest ], component_graph : ComponentGraph , ) -> None : \"\"\"Create a `LogicalMeter instance`. Args: channel_registry: A channel registry instance shared with the resampling actor. resampler_subscription_sender: A sender for sending metric requests to the resampling actor. component_graph: The component graph representing the microgrid. \"\"\" self . _channel_registry = channel_registry self . _resampler_subscription_sender = resampler_subscription_sender # Use a randomly generated uuid to create a unique namespace name for the local # meter to use when communicating with the resampling actor. self . _namespace = f \"logical-meter- { uuid . uuid4 () } \" self . _component_graph = component_graph self . _formula_pool = FormulaEnginePool ( self . _namespace , self . _channel_registry , self . _resampler_subscription_sender , ) battery_power () async \u00a4 Fetch the cumulative battery power in the microgrid. If a formula engine to calculate cumulative battery power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver A new receiver that will stream battery_power values. Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 async def battery_power ( self ) -> FormulaReceiver : \"\"\"Fetch the cumulative battery power in the microgrid. If a formula engine to calculate cumulative battery power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream battery_power values. \"\"\" return await self . _formula_pool . from_generator ( \"battery_power\" , BatteryPowerFormula ) grid_current () async \u00a4 Fetch the grid power for the microgrid. If a formula engine to calculate grid current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver3Phase A new receiver that will stream grid_current values. Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 async def grid_current ( self ) -> FormulaReceiver3Phase : \"\"\"Fetch the grid power for the microgrid. If a formula engine to calculate grid current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream grid_current values. \"\"\" return await self . _formula_pool . from_generator ( \"grid_current\" , GridCurrentFormula ) grid_power () async \u00a4 Fetch the grid power for the microgrid. If a formula engine to calculate grid power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver A new receiver that will stream grid_power values. Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 143 144 145 146 147 148 149 150 151 152 153 154 async def grid_power ( self ) -> FormulaReceiver : \"\"\"Fetch the grid power for the microgrid. If a formula engine to calculate grid power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream grid_power values. \"\"\" return await self . _formula_pool . from_generator ( \"grid_power\" , GridPowerFormula ) pv_power () async \u00a4 Fetch the PV power production in the microgrid. If a formula engine to calculate PV power production is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver A new receiver that will stream PV power production values. Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 186 187 188 189 190 191 192 193 194 195 196 197 async def pv_power ( self ) -> FormulaReceiver : \"\"\"Fetch the PV power production in the microgrid. If a formula engine to calculate PV power production is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream PV power production values. \"\"\" return await self . _formula_pool . from_generator ( \"pv_power\" , PVPowerFormula ) start_formula ( formula , component_metric_id , nones_are_zeros = False ) async \u00a4 Start execution of the given formula. Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and these operators: +, -, *, /, (, ). For example, the input string: \"#20 + #5\" is a formula for adding metrics from two components with ids 20 and 5. PARAMETER DESCRIPTION formula formula to execute. TYPE: str component_metric_id The metric ID to use when fetching receivers from the resampling actor. TYPE: ComponentMetricId nones_are_zeros Whether to treat None values from the stream as 0s. If False, the returned value will be a None. TYPE: bool DEFAULT: False RETURNS DESCRIPTION FormulaReceiver A FormulaReceiver that streams values with the formulas applied. Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 async def start_formula ( self , formula : str , component_metric_id : ComponentMetricId , nones_are_zeros : bool = False , ) -> FormulaReceiver : \"\"\"Start execution of the given formula. Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and these operators: +, -, *, /, (, ). For example, the input string: \"#20 + #5\" is a formula for adding metrics from two components with ids 20 and 5. Args: formula: formula to execute. component_metric_id: The metric ID to use when fetching receivers from the resampling actor. nones_are_zeros: Whether to treat None values from the stream as 0s. If False, the returned value will be a None. Returns: A FormulaReceiver that streams values with the formulas applied. \"\"\" return await self . _formula_pool . from_string ( formula , component_metric_id , nones_are_zeros )","title":"logical_meter"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter","text":"A logical meter for calculating high level metrics for a microgrid.","title":"logical_meter"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter-classes","text":"","title":"Classes"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter","text":"A logical meter for calculating high level metrics in a microgrid. LogicalMeter provides methods for fetching power values from different points in the microgrid. These methods return FormulaReceiver objects, which can be used like normal Receiver s, but can also be composed to form higher-order formula streams. Example channel_registry = ChannelRegistry ( name = \"data-registry\" ) # Create a channels for sending/receiving subscription requests data_source_request_channel = Broadcast [ ComponentMetricRequest ]( \"data-source\" ) data_source_request_sender = data_source_request_channel . new_sender () data_source_request_receiver = data_source_request_channel . new_receiver () resampling_request_channel = Broadcast [ ComponentMetricRequest ]( \"resample\" ) resampling_request_sender = resampling_request_channel . new_sender () resampling_request_receiver = resampling_request_channel . new_receiver () # Instantiate a data sourcing actor _data_sourcing_actor = DataSourcingActor ( request_receiver = data_source_request_receiver , registry = channel_registry ) # Instantiate a resampling actor _resampling_actor = ComponentMetricsResamplingActor ( channel_registry = channel_registry , data_sourcing_request_sender = data_source_request_sender , resampling_request_receiver = resampling_request_receiver , config = ResamplerConfig ( resampling_period_s = 1 ), ) # Create a logical meter instance logical_meter = LogicalMeter ( channel_registry , resampling_request_sender , microgrid . get () . component_graph , ) # Get a receiver for a builtin formula grid_power_recv = logical_meter . grid_power () for grid_power_sample in grid_power_recv : print ( grid_power_sample ) # or compose formula receivers to create a new formula net_power_recv = ( ( logical_meter . grid_power () - logical_meter . battery_power () - logical_meter . pv_power () ) . build ( \"net_power\" ) . new_receiver () ) for net_power_sample in net_power_recv : print ( net_power_sample ) Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class LogicalMeter : \"\"\"A logical meter for calculating high level metrics in a microgrid. LogicalMeter provides methods for fetching power values from different points in the microgrid. These methods return `FormulaReceiver` objects, which can be used like normal `Receiver`s, but can also be composed to form higher-order formula streams. Example: ``` python channel_registry = ChannelRegistry(name=\"data-registry\") # Create a channels for sending/receiving subscription requests data_source_request_channel = Broadcast[ComponentMetricRequest](\"data-source\") data_source_request_sender = data_source_request_channel.new_sender() data_source_request_receiver = data_source_request_channel.new_receiver() resampling_request_channel = Broadcast[ComponentMetricRequest](\"resample\") resampling_request_sender = resampling_request_channel.new_sender() resampling_request_receiver = resampling_request_channel.new_receiver() # Instantiate a data sourcing actor _data_sourcing_actor = DataSourcingActor( request_receiver=data_source_request_receiver, registry=channel_registry ) # Instantiate a resampling actor _resampling_actor = ComponentMetricsResamplingActor( channel_registry=channel_registry, data_sourcing_request_sender=data_source_request_sender, resampling_request_receiver=resampling_request_receiver, config=ResamplerConfig(resampling_period_s=1), ) # Create a logical meter instance logical_meter = LogicalMeter( channel_registry, resampling_request_sender, microgrid.get().component_graph, ) # Get a receiver for a builtin formula grid_power_recv = logical_meter.grid_power() for grid_power_sample in grid_power_recv: print(grid_power_sample) # or compose formula receivers to create a new formula net_power_recv = ( ( logical_meter.grid_power() - logical_meter.battery_power() - logical_meter.pv_power() ) .build(\"net_power\") .new_receiver() ) for net_power_sample in net_power_recv: print(net_power_sample) ``` \"\"\" def __init__ ( self , channel_registry : ChannelRegistry , resampler_subscription_sender : Sender [ ComponentMetricRequest ], component_graph : ComponentGraph , ) -> None : \"\"\"Create a `LogicalMeter instance`. Args: channel_registry: A channel registry instance shared with the resampling actor. resampler_subscription_sender: A sender for sending metric requests to the resampling actor. component_graph: The component graph representing the microgrid. \"\"\" self . _channel_registry = channel_registry self . _resampler_subscription_sender = resampler_subscription_sender # Use a randomly generated uuid to create a unique namespace name for the local # meter to use when communicating with the resampling actor. self . _namespace = f \"logical-meter- { uuid . uuid4 () } \" self . _component_graph = component_graph self . _formula_pool = FormulaEnginePool ( self . _namespace , self . _channel_registry , self . _resampler_subscription_sender , ) async def start_formula ( self , formula : str , component_metric_id : ComponentMetricId , nones_are_zeros : bool = False , ) -> FormulaReceiver : \"\"\"Start execution of the given formula. Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and these operators: +, -, *, /, (, ). For example, the input string: \"#20 + #5\" is a formula for adding metrics from two components with ids 20 and 5. Args: formula: formula to execute. component_metric_id: The metric ID to use when fetching receivers from the resampling actor. nones_are_zeros: Whether to treat None values from the stream as 0s. If False, the returned value will be a None. Returns: A FormulaReceiver that streams values with the formulas applied. \"\"\" return await self . _formula_pool . from_string ( formula , component_metric_id , nones_are_zeros ) async def grid_power ( self ) -> FormulaReceiver : \"\"\"Fetch the grid power for the microgrid. If a formula engine to calculate grid power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream grid_power values. \"\"\" return await self . _formula_pool . from_generator ( \"grid_power\" , GridPowerFormula ) async def grid_current ( self ) -> FormulaReceiver3Phase : \"\"\"Fetch the grid power for the microgrid. If a formula engine to calculate grid current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream grid_current values. \"\"\" return await self . _formula_pool . from_generator ( \"grid_current\" , GridCurrentFormula ) async def battery_power ( self ) -> FormulaReceiver : \"\"\"Fetch the cumulative battery power in the microgrid. If a formula engine to calculate cumulative battery power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream battery_power values. \"\"\" return await self . _formula_pool . from_generator ( \"battery_power\" , BatteryPowerFormula ) async def pv_power ( self ) -> FormulaReceiver : \"\"\"Fetch the PV power production in the microgrid. If a formula engine to calculate PV power production is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream PV power production values. \"\"\" return await self . _formula_pool . from_generator ( \"pv_power\" , PVPowerFormula )","title":"LogicalMeter"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter-functions","text":"","title":"Functions"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.__init__","text":"Create a LogicalMeter instance . PARAMETER DESCRIPTION channel_registry A channel registry instance shared with the resampling actor. TYPE: ChannelRegistry resampler_subscription_sender A sender for sending metric requests to the resampling actor. TYPE: Sender [ ComponentMetricRequest ] component_graph The component graph representing the microgrid. TYPE: ComponentGraph Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def __init__ ( self , channel_registry : ChannelRegistry , resampler_subscription_sender : Sender [ ComponentMetricRequest ], component_graph : ComponentGraph , ) -> None : \"\"\"Create a `LogicalMeter instance`. Args: channel_registry: A channel registry instance shared with the resampling actor. resampler_subscription_sender: A sender for sending metric requests to the resampling actor. component_graph: The component graph representing the microgrid. \"\"\" self . _channel_registry = channel_registry self . _resampler_subscription_sender = resampler_subscription_sender # Use a randomly generated uuid to create a unique namespace name for the local # meter to use when communicating with the resampling actor. self . _namespace = f \"logical-meter- { uuid . uuid4 () } \" self . _component_graph = component_graph self . _formula_pool = FormulaEnginePool ( self . _namespace , self . _channel_registry , self . _resampler_subscription_sender , )","title":"__init__()"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.battery_power","text":"Fetch the cumulative battery power in the microgrid. If a formula engine to calculate cumulative battery power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver A new receiver that will stream battery_power values. Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 async def battery_power ( self ) -> FormulaReceiver : \"\"\"Fetch the cumulative battery power in the microgrid. If a formula engine to calculate cumulative battery power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream battery_power values. \"\"\" return await self . _formula_pool . from_generator ( \"battery_power\" , BatteryPowerFormula )","title":"battery_power()"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.grid_current","text":"Fetch the grid power for the microgrid. If a formula engine to calculate grid current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver3Phase A new receiver that will stream grid_current values. Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 async def grid_current ( self ) -> FormulaReceiver3Phase : \"\"\"Fetch the grid power for the microgrid. If a formula engine to calculate grid current is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream grid_current values. \"\"\" return await self . _formula_pool . from_generator ( \"grid_current\" , GridCurrentFormula )","title":"grid_current()"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.grid_power","text":"Fetch the grid power for the microgrid. If a formula engine to calculate grid power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver A new receiver that will stream grid_power values. Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 143 144 145 146 147 148 149 150 151 152 153 154 async def grid_power ( self ) -> FormulaReceiver : \"\"\"Fetch the grid power for the microgrid. If a formula engine to calculate grid power is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream grid_power values. \"\"\" return await self . _formula_pool . from_generator ( \"grid_power\" , GridPowerFormula )","title":"grid_power()"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.pv_power","text":"Fetch the PV power production in the microgrid. If a formula engine to calculate PV power production is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. RETURNS DESCRIPTION FormulaReceiver A new receiver that will stream PV power production values. Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 186 187 188 189 190 191 192 193 194 195 196 197 async def pv_power ( self ) -> FormulaReceiver : \"\"\"Fetch the PV power production in the microgrid. If a formula engine to calculate PV power production is not already running, it will be started. Else, it will return a new receiver to the already existing data stream. Returns: A *new* receiver that will stream PV power production values. \"\"\" return await self . _formula_pool . from_generator ( \"pv_power\" , PVPowerFormula )","title":"pv_power()"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.start_formula","text":"Start execution of the given formula. Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and these operators: +, -, *, /, (, ). For example, the input string: \"#20 + #5\" is a formula for adding metrics from two components with ids 20 and 5. PARAMETER DESCRIPTION formula formula to execute. TYPE: str component_metric_id The metric ID to use when fetching receivers from the resampling actor. TYPE: ComponentMetricId nones_are_zeros Whether to treat None values from the stream as 0s. If False, the returned value will be a None. TYPE: bool DEFAULT: False RETURNS DESCRIPTION FormulaReceiver A FormulaReceiver that streams values with the formulas applied. Source code in frequenz/sdk/timeseries/logical_meter/_logical_meter.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 async def start_formula ( self , formula : str , component_metric_id : ComponentMetricId , nones_are_zeros : bool = False , ) -> FormulaReceiver : \"\"\"Start execution of the given formula. Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and these operators: +, -, *, /, (, ). For example, the input string: \"#20 + #5\" is a formula for adding metrics from two components with ids 20 and 5. Args: formula: formula to execute. component_metric_id: The metric ID to use when fetching receivers from the resampling actor. nones_are_zeros: Whether to treat None values from the stream as 0s. If False, the returned value will be a None. Returns: A FormulaReceiver that streams values with the formulas applied. \"\"\" return await self . _formula_pool . from_string ( formula , component_metric_id , nones_are_zeros )","title":"start_formula()"}]}