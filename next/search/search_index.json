{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Python SDK","text":"<p>A development kit to interact with the Frequenz development platform.</p>"},{"location":"#supported-python-versions","title":"Supported Python versions","text":"<ul> <li>Only Python 3.11 is fully supported (tested).</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to <code>frequenz-sdk</code>","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install nox toml\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_sdk.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_sdk.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_sdk.py\nnox -R -s mypy -- test/test_sdk.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[docs-gen]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    clean from template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit    a pull request if an update is needed, wait until it is merged, and update    the latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    create a new    announcement    about the release, and upload a new package to    PyPI automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Development</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>conftest</li> <li>frequenz<ul> <li>sdk<ul> <li>actor<ul> <li>power_distributing<ul> <li>power_distributing</li> <li>request</li> <li>result</li> </ul> </li> </ul> </li> <li>config</li> <li>microgrid<ul> <li>client</li> <li>component</li> <li>connection_manager</li> </ul> </li> <li>power</li> <li>timeseries<ul> <li>battery_pool<ul> <li>battery_pool</li> </ul> </li> <li>ev_charger_pool</li> <li>logical_meter</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/conftest/","title":"conftest","text":""},{"location":"reference/conftest/#conftest","title":"<code>conftest</code>","text":"<p>Pytest plugin to validate docstring code examples.</p> <p>Code examples are often wrapped in triple backticks (```) within our docstrings. This plugin extracts these code examples and validates them using pylint.</p>"},{"location":"reference/conftest/#conftest-classes","title":"Classes","text":""},{"location":"reference/conftest/#conftest.CustomPythonCodeBlockParser","title":"<code>conftest.CustomPythonCodeBlockParser</code>","text":"<p>         Bases: <code>CodeBlockParser</code></p> <p>Code block parser that validates extracted code examples using pylint.</p> <p>This parser is a modified version of the default Python code block parser from the Sybil library. It uses pylint to validate the extracted code examples.</p> <p>All code examples are preceded by the original file's import statements as well as an wildcard import of the file itself. This allows us to use the code examples as if they were part of the original file.</p> <p>Additionally, the code example is padded with empty lines to make sure the line numbers are correct.</p> <p>Pylint warnings which are unimportant for code examples are disabled.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>class CustomPythonCodeBlockParser(CodeBlockParser):\n\"\"\"Code block parser that validates extracted code examples using pylint.\n\n    This parser is a modified version of the default Python code block parser\n    from the Sybil library.\n    It uses pylint to validate the extracted code examples.\n\n    All code examples are preceded by the original file's import statements as\n    well as an wildcard import of the file itself.\n    This allows us to use the code examples as if they were part of the original\n    file.\n\n    Additionally, the code example is padded with empty lines to make sure the\n    line numbers are correct.\n\n    Pylint warnings which are unimportant for code examples are disabled.\n    \"\"\"\n\n    def __init__(self):\n\"\"\"Initialize the parser.\"\"\"\n        super().__init__(\"python\")\n\n    def evaluate(self, example: Example) -&gt; None | str:\n\"\"\"Validate the extracted code example using pylint.\n\n        Args:\n            example: The extracted code example.\n\n        Returns:\n            None if the code example is valid, otherwise the pylint output.\n        \"\"\"\n        # Get the import statements for the original file\n        import_header = get_import_statements(example.document.text)\n        # Add a wildcard import of the original file\n        import_header.append(\n            path_to_import_statement(Path(os.path.relpath(example.path)))\n        )\n        # Add microgrid as default import\n        import_header.append(\"from frequenz.sdk import microgrid\")\n        imports_code = \"\\n\".join(import_header)\n\n        # Dedent the code example\n        # There is also example.parsed that is already prepared, but it has\n        # empty lines stripped and thus fucks up the line numbers.\n        example_code = textwrap.dedent(\n            example.document.text[example.start : example.end]\n        )\n        # Remove first line (the line with the triple backticks)\n        example_code = example_code[example_code.find(\"\\n\") + 1 :]\n\n        example_with_imports = FORMAT_STRING.format(\n            disable_pylint=PYLINT_DISABLE_COMMENT.format(\"disable\"),\n            imports=imports_code,\n            enable_pylint=PYLINT_DISABLE_COMMENT.format(\"enable\"),\n            code=example_code,\n        )\n\n        # Make sure the line numbers are correct\n        source = pad(\n            example_with_imports,\n            example.line - imports_code.count(\"\\n\") - FORMAT_STRING.count(\"\\n\"),\n        )\n\n        # pylint disable parameters\n        pylint_disable_params = [\n            \"missing-module-docstring\",\n            \"missing-class-docstring\",\n            \"missing-function-docstring\",\n            \"reimported\",\n            \"unused-variable\",\n            \"no-name-in-module\",\n            \"await-outside-async\",\n        ]\n\n        response = validate_with_pylint(source, example.path, pylint_disable_params)\n\n        if len(response) &gt; 0:\n            return (\n                f\"Pylint validation failed for code example:\\n\"\n                f\"{example_with_imports}\\nOutput: {response}\"\n            )\n\n        return None\n</code></pre>"},{"location":"reference/conftest/#conftest.CustomPythonCodeBlockParser-functions","title":"Functions","text":""},{"location":"reference/conftest/#conftest.CustomPythonCodeBlockParser.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the parser.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>def __init__(self):\n\"\"\"Initialize the parser.\"\"\"\n    super().__init__(\"python\")\n</code></pre>"},{"location":"reference/conftest/#conftest.CustomPythonCodeBlockParser.evaluate","title":"<code>evaluate(example)</code>","text":"<p>Validate the extracted code example using pylint.</p> PARAMETER DESCRIPTION <code>example</code> <p>The extracted code example.</p> <p> TYPE: <code>Example</code> </p> RETURNS DESCRIPTION <code>None | str</code> <p>None if the code example is valid, otherwise the pylint output.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>def evaluate(self, example: Example) -&gt; None | str:\n\"\"\"Validate the extracted code example using pylint.\n\n    Args:\n        example: The extracted code example.\n\n    Returns:\n        None if the code example is valid, otherwise the pylint output.\n    \"\"\"\n    # Get the import statements for the original file\n    import_header = get_import_statements(example.document.text)\n    # Add a wildcard import of the original file\n    import_header.append(\n        path_to_import_statement(Path(os.path.relpath(example.path)))\n    )\n    # Add microgrid as default import\n    import_header.append(\"from frequenz.sdk import microgrid\")\n    imports_code = \"\\n\".join(import_header)\n\n    # Dedent the code example\n    # There is also example.parsed that is already prepared, but it has\n    # empty lines stripped and thus fucks up the line numbers.\n    example_code = textwrap.dedent(\n        example.document.text[example.start : example.end]\n    )\n    # Remove first line (the line with the triple backticks)\n    example_code = example_code[example_code.find(\"\\n\") + 1 :]\n\n    example_with_imports = FORMAT_STRING.format(\n        disable_pylint=PYLINT_DISABLE_COMMENT.format(\"disable\"),\n        imports=imports_code,\n        enable_pylint=PYLINT_DISABLE_COMMENT.format(\"enable\"),\n        code=example_code,\n    )\n\n    # Make sure the line numbers are correct\n    source = pad(\n        example_with_imports,\n        example.line - imports_code.count(\"\\n\") - FORMAT_STRING.count(\"\\n\"),\n    )\n\n    # pylint disable parameters\n    pylint_disable_params = [\n        \"missing-module-docstring\",\n        \"missing-class-docstring\",\n        \"missing-function-docstring\",\n        \"reimported\",\n        \"unused-variable\",\n        \"no-name-in-module\",\n        \"await-outside-async\",\n    ]\n\n    response = validate_with_pylint(source, example.path, pylint_disable_params)\n\n    if len(response) &gt; 0:\n        return (\n            f\"Pylint validation failed for code example:\\n\"\n            f\"{example_with_imports}\\nOutput: {response}\"\n        )\n\n    return None\n</code></pre>"},{"location":"reference/conftest/#conftest-functions","title":"Functions","text":""},{"location":"reference/conftest/#conftest.get_import_statements","title":"<code>conftest.get_import_statements(code)</code>","text":"<p>Get all import statements from a given code string.</p> PARAMETER DESCRIPTION <code>code</code> <p>The code to extract import statements from.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of import statements.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>def get_import_statements(code: str) -&gt; list[str]:\n\"\"\"Get all import statements from a given code string.\n\n    Args:\n        code: The code to extract import statements from.\n\n    Returns:\n        A list of import statements.\n    \"\"\"\n    tree = ast.parse(code)\n    import_statements = []\n\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.Import, ast.ImportFrom)):\n            import_statement = ast.get_source_segment(code, node)\n            import_statements.append(import_statement)\n\n    return import_statements\n</code></pre>"},{"location":"reference/conftest/#conftest.path_to_import_statement","title":"<code>conftest.path_to_import_statement(path)</code>","text":"<p>Convert a path to a Python file to an import statement.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path to convert.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The import statement.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the path does not point to a Python file.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>def path_to_import_statement(path: Path) -&gt; str:\n\"\"\"Convert a path to a Python file to an import statement.\n\n    Args:\n        path: The path to convert.\n\n    Returns:\n        The import statement.\n\n    Raises:\n        ValueError: If the path does not point to a Python file.\n    \"\"\"\n    # Make the path relative to the present working directory\n    if path.is_absolute():\n        path = path.relative_to(Path.cwd())\n\n    # Check if the path is a Python file\n    if path.suffix != \".py\":\n        raise ValueError(\"Path must point to a Python file (.py)\")\n\n    # Remove 'src' prefix if present\n    parts = path.parts\n    if parts[0] == \"src\":\n        parts = parts[1:]\n\n    # Remove the '.py' extension and join parts with '.'\n    module_path = \".\".join(parts)[:-3]\n\n    # Create the import statement\n    import_statement = f\"from {module_path} import *\"\n    return import_statement\n</code></pre>"},{"location":"reference/conftest/#conftest.validate_with_pylint","title":"<code>conftest.validate_with_pylint(code_example, path, disable_params)</code>","text":"<p>Validate a code example using pylint.</p> PARAMETER DESCRIPTION <code>code_example</code> <p>The code example to validate.</p> <p> TYPE: <code>str</code> </p> <code>path</code> <p>The path to the original file.</p> <p> TYPE: <code>str</code> </p> <code>disable_params</code> <p>The pylint disable parameters.</p> <p> TYPE: <code>list[str]</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of pylint messages.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/conftest.py</code> <pre><code>def validate_with_pylint(\n    code_example: str, path: str, disable_params: list[str]\n) -&gt; list[str]:\n\"\"\"Validate a code example using pylint.\n\n    Args:\n        code_example: The code example to validate.\n        path: The path to the original file.\n        disable_params: The pylint disable parameters.\n\n    Returns:\n        A list of pylint messages.\n    \"\"\"\n    try:\n        pylint_command = [\n            \"pylint\",\n            \"--disable\",\n            \",\".join(disable_params),\n            \"--from-stdin\",\n            path,\n        ]\n\n        subprocess.run(\n            pylint_command,\n            input=code_example,\n            text=True,\n            capture_output=True,\n            check=True,\n        )\n    except subprocess.CalledProcessError as exception:\n        return exception.output.splitlines()\n\n    return []\n</code></pre>"},{"location":"reference/frequenz/sdk/","title":"sdk","text":""},{"location":"reference/frequenz/sdk/#frequenz.sdk","title":"<code>frequenz.sdk</code>","text":"<p>Frequenz Python SDK.</p>"},{"location":"reference/frequenz/sdk/actor/","title":"actor","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor","title":"<code>frequenz.sdk.actor</code>","text":"<p>A base class for creating simple composable actors.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry","title":"<code>frequenz.sdk.actor.ChannelRegistry</code>","text":"<p>Dynamically creates, own and provide access to channels.</p> <p>It can be used by actors to dynamically establish a communication channel between each other.  Channels are identified by string names.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_channel_registry.py</code> <pre><code>class ChannelRegistry:\n\"\"\"Dynamically creates, own and provide access to channels.\n\n    It can be used by actors to dynamically establish a communication channel\n    between each other.  Channels are identified by string names.\n    \"\"\"\n\n    def __init__(self, *, name: str) -&gt; None:\n\"\"\"Create a `ChannelRegistry` instance.\n\n        Args:\n            name: A unique name for the registry.\n        \"\"\"\n        self._name = name\n        self._channels: Dict[str, Broadcast[Any]] = {}\n\n    def new_sender(self, key: str) -&gt; Sender[Any]:\n\"\"\"Get a sender to a dynamically created channel with the given key.\n\n        Args:\n            key: A key to identify the channel.\n\n        Returns:\n            A sender to a dynamically created channel with the given key.\n        \"\"\"\n        if key not in self._channels:\n            self._channels[key] = Broadcast(f\"{self._name}-{key}\")\n        return self._channels[key].new_sender()\n\n    def new_receiver(self, key: str) -&gt; Receiver[Any]:\n\"\"\"Get a receiver to a dynamically created channel with the given key.\n\n        Args:\n            key: A key to identify the channel.\n\n        Returns:\n            A receiver for a dynamically created channel with the given key.\n        \"\"\"\n        if key not in self._channels:\n            self._channels[key] = Broadcast(f\"{self._name}-{key}\")\n        return self._channels[key].new_receiver()\n\n    async def _close_channel(self, key: str) -&gt; None:\n\"\"\"Close a channel with the given key.\n\n        This method is private and should only be used in special cases.\n\n        Args:\n            key: A key to identify the channel.\n        \"\"\"\n        if key in self._channels:\n            if channel := self._channels.pop(key, None):\n                await channel.close()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ChannelRegistry-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._channel_registry.ChannelRegistry.__init__","title":"<code>__init__(*, name)</code>","text":"<p>Create a <code>ChannelRegistry</code> instance.</p> PARAMETER DESCRIPTION <code>name</code> <p>A unique name for the registry.</p> <p> TYPE: <code>str</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def __init__(self, *, name: str) -&gt; None:\n\"\"\"Create a `ChannelRegistry` instance.\n\n    Args:\n        name: A unique name for the registry.\n    \"\"\"\n    self._name = name\n    self._channels: Dict[str, Broadcast[Any]] = {}\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._channel_registry.ChannelRegistry.new_receiver","title":"<code>new_receiver(key)</code>","text":"<p>Get a receiver to a dynamically created channel with the given key.</p> PARAMETER DESCRIPTION <code>key</code> <p>A key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Receiver[Any]</code> <p>A receiver for a dynamically created channel with the given key.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def new_receiver(self, key: str) -&gt; Receiver[Any]:\n\"\"\"Get a receiver to a dynamically created channel with the given key.\n\n    Args:\n        key: A key to identify the channel.\n\n    Returns:\n        A receiver for a dynamically created channel with the given key.\n    \"\"\"\n    if key not in self._channels:\n        self._channels[key] = Broadcast(f\"{self._name}-{key}\")\n    return self._channels[key].new_receiver()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._channel_registry.ChannelRegistry.new_sender","title":"<code>new_sender(key)</code>","text":"<p>Get a sender to a dynamically created channel with the given key.</p> PARAMETER DESCRIPTION <code>key</code> <p>A key to identify the channel.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Sender[Any]</code> <p>A sender to a dynamically created channel with the given key.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_channel_registry.py</code> <pre><code>def new_sender(self, key: str) -&gt; Sender[Any]:\n\"\"\"Get a sender to a dynamically created channel with the given key.\n\n    Args:\n        key: A key to identify the channel.\n\n    Returns:\n        A sender to a dynamically created channel with the given key.\n    \"\"\"\n    if key not in self._channels:\n        self._channels[key] = Broadcast(f\"{self._name}-{key}\")\n    return self._channels[key].new_sender()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest","title":"<code>frequenz.sdk.actor.ComponentMetricRequest</code>  <code>dataclass</code>","text":"<p>A request object to start streaming a metric for a component.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_data_sourcing/microgrid_api_source.py</code> <pre><code>@dataclass\nclass ComponentMetricRequest:\n\"\"\"A request object to start streaming a metric for a component.\"\"\"\n\n    namespace: str\n\"\"\"The namespace that this request belongs to.\n\n    Metric requests with a shared namespace enable the reuse of channels within\n    that namespace.\n\n    If for example, an actor making a multiple requests, uses the name of the\n    actor as the namespace, then requests from the actor will get reused when\n    possible.\n    \"\"\"\n\n    component_id: int\n\"\"\"The ID of the requested component.\"\"\"\n\n    metric_id: ComponentMetricId\n\"\"\"The ID of the requested component's metric.\"\"\"\n\n    start_time: Optional[datetime]\n\"\"\"The start time from which data is required.\n\n    When None, we will stream only live data.\n    \"\"\"\n\n    def get_channel_name(self) -&gt; str:\n\"\"\"Return a channel name constructed from Self.\n\n        This channel name can be used by the sending side and receiving sides to\n        identify the right channel from the ChannelRegistry.\n\n        Returns:\n            A string denoting a channel name.\n        \"\"\"\n        return (\n            f\"component-stream::{self.component_id}::{self.metric_id.name}::\"\n            f\"{self.start_time}::{self.namespace}\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.microgrid_api_source.ComponentMetricRequest.component_id","title":"<code>component_id: int</code>  <code>instance-attribute</code>","text":"<p>The ID of the requested component.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.microgrid_api_source.ComponentMetricRequest.metric_id","title":"<code>metric_id: ComponentMetricId</code>  <code>instance-attribute</code>","text":"<p>The ID of the requested component's metric.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.microgrid_api_source.ComponentMetricRequest.namespace","title":"<code>namespace: str</code>  <code>instance-attribute</code>","text":"<p>The namespace that this request belongs to.</p> <p>Metric requests with a shared namespace enable the reuse of channels within that namespace.</p> <p>If for example, an actor making a multiple requests, uses the name of the actor as the namespace, then requests from the actor will get reused when possible.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.microgrid_api_source.ComponentMetricRequest.start_time","title":"<code>start_time: Optional[datetime]</code>  <code>instance-attribute</code>","text":"<p>The start time from which data is required.</p> <p>When None, we will stream only live data.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricRequest-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.microgrid_api_source.ComponentMetricRequest.get_channel_name","title":"<code>get_channel_name()</code>","text":"<p>Return a channel name constructed from Self.</p> <p>This channel name can be used by the sending side and receiving sides to identify the right channel from the ChannelRegistry.</p> RETURNS DESCRIPTION <code>str</code> <p>A string denoting a channel name.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_data_sourcing/microgrid_api_source.py</code> <pre><code>def get_channel_name(self) -&gt; str:\n\"\"\"Return a channel name constructed from Self.\n\n    This channel name can be used by the sending side and receiving sides to\n    identify the right channel from the ChannelRegistry.\n\n    Returns:\n        A string denoting a channel name.\n    \"\"\"\n    return (\n        f\"component-stream::{self.component_id}::{self.metric_id.name}::\"\n        f\"{self.start_time}::{self.namespace}\"\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor","title":"<code>frequenz.sdk.actor.ComponentMetricsResamplingActor</code>","text":"<p>An actor to resample microgrid component metrics.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_resampling.py</code> <pre><code>@actor\nclass ComponentMetricsResamplingActor:\n\"\"\"An actor to resample microgrid component metrics.\"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        *,\n        channel_registry: ChannelRegistry,\n        data_sourcing_request_sender: Sender[ComponentMetricRequest],\n        resampling_request_receiver: Receiver[ComponentMetricRequest],\n        config: ResamplerConfig,\n    ) -&gt; None:\n\"\"\"Initialize an instance.\n\n        Args:\n            channel_registry: The channel registry used to get senders and\n                receivers for data sourcing subscriptions.\n            data_sourcing_request_sender: The sender used to send requests to\n                the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor]\n                to subscribe to component metrics.\n            resampling_request_receiver: The receiver to use to receive new\n                resampmling subscription requests.\n            config: The configuration for the resampler.\n        \"\"\"\n        self._channel_registry: ChannelRegistry = channel_registry\n        self._data_sourcing_request_sender: Sender[\n            ComponentMetricRequest\n        ] = data_sourcing_request_sender\n        self._resampling_request_receiver: Receiver[\n            ComponentMetricRequest\n        ] = resampling_request_receiver\n        self._resampler: Resampler = Resampler(config)\n        self._active_req_channels: set[str] = set()\n\n    async def _subscribe(self, request: ComponentMetricRequest) -&gt; None:\n\"\"\"Request data for a component metric.\n\n        Args:\n            request: The request for component metric data.\n        \"\"\"\n        request_channel_name = request.get_channel_name()\n\n        # If we are already handling this request, there is nothing to do.\n        if request_channel_name in self._active_req_channels:\n            return\n\n        self._active_req_channels.add(request_channel_name)\n\n        data_source_request = dataclasses.replace(\n            request, namespace=request.namespace + \":Source\"\n        )\n        data_source_channel_name = data_source_request.get_channel_name()\n        await self._data_sourcing_request_sender.send(data_source_request)\n        receiver = self._channel_registry.new_receiver(data_source_channel_name)\n\n        # This is a temporary hack until the Sender implementation uses\n        # exceptions to report errors.\n        sender = self._channel_registry.new_sender(request.get_channel_name())\n\n        async def sink_adapter(sample: Sample) -&gt; None:\n            await sender.send(sample)\n\n        self._resampler.add_timeseries(request_channel_name, receiver, sink_adapter)\n\n    async def _process_resampling_requests(self) -&gt; None:\n\"\"\"Process resampling data requests.\"\"\"\n        async for request in self._resampling_request_receiver:\n            await self._subscribe(request)\n\n    async def run(self) -&gt; None:\n\"\"\"Resample known component metrics and process resampling requests.\n\n        If there is a resampling error while resampling some component metric,\n        then that metric will be discarded and not resampled any more. Any\n        other error will be propagated (most likely ending in the actor being\n        restarted).\n\n        Raises:\n            RuntimeError: If there is some unexpected error while resampling or\n                handling requests.\n\n        # noqa: DAR401 error\n        \"\"\"\n        tasks_to_cancel: set[asyncio.Task[None]] = set()\n        try:\n            subscriptions_task = asyncio.create_task(\n                self._process_resampling_requests()\n            )\n            tasks_to_cancel.add(subscriptions_task)\n\n            while True:\n                resampling_task = asyncio.create_task(self._resampler.resample())\n                tasks_to_cancel.add(resampling_task)\n                done, _ = await asyncio.wait(\n                    [resampling_task, subscriptions_task],\n                    return_when=asyncio.FIRST_COMPLETED,\n                )\n\n                if subscriptions_task in done:\n                    tasks_to_cancel.remove(subscriptions_task)\n                    raise RuntimeError(\n                        \"There was a problem with the subscriptions channel.\"\n                    )\n\n                if resampling_task in done:\n                    tasks_to_cancel.remove(resampling_task)\n                    # The resampler shouldn't end without an exception\n                    error = resampling_task.exception()\n                    assert (\n                        error is not None\n                    ), \"The resample() function shouldn't exit normally.\"\n\n                    # We don't know what to do with something other than\n                    # ResamplingError, so propagate the exception if that is the\n                    # case.\n                    if not isinstance(error, ResamplingError):\n                        raise error\n                    for source, source_error in error.exceptions.items():\n                        _logger.error(\n                            \"Error resampling source %s, removing source...\", source\n                        )\n                        removed = self._resampler.remove_timeseries(source)\n                        if not removed:\n                            _logger.warning(\n                                \"Got an exception from an unknown source: \"\n                                \"source=%r, exception=%r\",\n                                source,\n                                source_error,\n                            )\n                    # The resampling_task will be re-created if we reached this point\n        finally:\n            await asyncio.gather(*[cancel_and_await(t) for t in tasks_to_cancel])\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ComponentMetricsResamplingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._resampling.ComponentMetricsResamplingActor.__init__","title":"<code>__init__(*, channel_registry, data_sourcing_request_sender, resampling_request_receiver, config)</code>","text":"<p>Initialize an instance.</p> PARAMETER DESCRIPTION <code>channel_registry</code> <p>The channel registry used to get senders and receivers for data sourcing subscriptions.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>data_sourcing_request_sender</code> <p>The sender used to send requests to the <code>DataSourcingActor</code> to subscribe to component metrics.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>resampling_request_receiver</code> <p>The receiver to use to receive new resampmling subscription requests.</p> <p> TYPE: <code>Receiver[ComponentMetricRequest]</code> </p> <code>config</code> <p>The configuration for the resampler.</p> <p> TYPE: <code>ResamplerConfig</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_resampling.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    *,\n    channel_registry: ChannelRegistry,\n    data_sourcing_request_sender: Sender[ComponentMetricRequest],\n    resampling_request_receiver: Receiver[ComponentMetricRequest],\n    config: ResamplerConfig,\n) -&gt; None:\n\"\"\"Initialize an instance.\n\n    Args:\n        channel_registry: The channel registry used to get senders and\n            receivers for data sourcing subscriptions.\n        data_sourcing_request_sender: The sender used to send requests to\n            the [`DataSourcingActor`][frequenz.sdk.actor.DataSourcingActor]\n            to subscribe to component metrics.\n        resampling_request_receiver: The receiver to use to receive new\n            resampmling subscription requests.\n        config: The configuration for the resampler.\n    \"\"\"\n    self._channel_registry: ChannelRegistry = channel_registry\n    self._data_sourcing_request_sender: Sender[\n        ComponentMetricRequest\n    ] = data_sourcing_request_sender\n    self._resampling_request_receiver: Receiver[\n        ComponentMetricRequest\n    ] = resampling_request_receiver\n    self._resampler: Resampler = Resampler(config)\n    self._active_req_channels: set[str] = set()\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._resampling.ComponentMetricsResamplingActor.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Resample known component metrics and process resampling requests.</p> <p>If there is a resampling error while resampling some component metric, then that metric will be discarded and not resampled any more. Any other error will be propagated (most likely ending in the actor being restarted).</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If there is some unexpected error while resampling or handling requests.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._resampling.ComponentMetricsResamplingActor.run--noqa-dar401-error","title":"noqa: DAR401 error","text":"Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_resampling.py</code> <pre><code>async def run(self) -&gt; None:\n\"\"\"Resample known component metrics and process resampling requests.\n\n    If there is a resampling error while resampling some component metric,\n    then that metric will be discarded and not resampled any more. Any\n    other error will be propagated (most likely ending in the actor being\n    restarted).\n\n    Raises:\n        RuntimeError: If there is some unexpected error while resampling or\n            handling requests.\n\n    # noqa: DAR401 error\n    \"\"\"\n    tasks_to_cancel: set[asyncio.Task[None]] = set()\n    try:\n        subscriptions_task = asyncio.create_task(\n            self._process_resampling_requests()\n        )\n        tasks_to_cancel.add(subscriptions_task)\n\n        while True:\n            resampling_task = asyncio.create_task(self._resampler.resample())\n            tasks_to_cancel.add(resampling_task)\n            done, _ = await asyncio.wait(\n                [resampling_task, subscriptions_task],\n                return_when=asyncio.FIRST_COMPLETED,\n            )\n\n            if subscriptions_task in done:\n                tasks_to_cancel.remove(subscriptions_task)\n                raise RuntimeError(\n                    \"There was a problem with the subscriptions channel.\"\n                )\n\n            if resampling_task in done:\n                tasks_to_cancel.remove(resampling_task)\n                # The resampler shouldn't end without an exception\n                error = resampling_task.exception()\n                assert (\n                    error is not None\n                ), \"The resample() function shouldn't exit normally.\"\n\n                # We don't know what to do with something other than\n                # ResamplingError, so propagate the exception if that is the\n                # case.\n                if not isinstance(error, ResamplingError):\n                    raise error\n                for source, source_error in error.exceptions.items():\n                    _logger.error(\n                        \"Error resampling source %s, removing source...\", source\n                    )\n                    removed = self._resampler.remove_timeseries(source)\n                    if not removed:\n                        _logger.warning(\n                            \"Got an exception from an unknown source: \"\n                            \"source=%r, exception=%r\",\n                            source,\n                            source_error,\n                        )\n                # The resampling_task will be re-created if we reached this point\n    finally:\n        await asyncio.gather(*[cancel_and_await(t) for t in tasks_to_cancel])\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor","title":"<code>frequenz.sdk.actor.ConfigManagingActor</code>","text":"<p>Manages config variables.</p> <p>Config variables are read from file. Only single file can be read. If new file is read, then previous configs will be forgotten.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_config_managing.py</code> <pre><code>@actor\nclass ConfigManagingActor:\n\"\"\"\n    Manages config variables.\n\n    Config variables are read from file.\n    Only single file can be read.\n    If new file is read, then previous configs will be forgotten.\n    \"\"\"\n\n    def __init__(\n        self,\n        conf_file: str,\n        output: Sender[Config],\n        event_types: Optional[Set[FileWatcher.EventType]] = None,\n    ) -&gt; None:\n\"\"\"Read config variables from the file.\n\n        Args:\n            conf_file: Path to file with config variables.\n            output: Channel to publish updates to.\n            event_types: Which types of events should update the config and\n                trigger a notification.\n        \"\"\"\n        self._conf_file: str = conf_file\n        self._conf_dir: str = os.path.dirname(conf_file)\n        self._file_watcher = FileWatcher(\n            paths=[self._conf_dir], event_types=event_types\n        )\n        self._output = output\n\n    def _read_config(self) -&gt; Dict[str, Any]:\n\"\"\"Read the contents of the config file.\n\n        Raises:\n            ValueError: if config file cannot be read.\n\n        Returns:\n            A dictionary containing configuration variables.\n        \"\"\"\n        try:\n            return toml.load(self._conf_file)\n        except ValueError as err:\n            logging.error(\"Can't read config file, err: %s\", err)\n            raise\n\n    async def send_config(self) -&gt; None:\n\"\"\"Send config file using a broadcast channel.\"\"\"\n        conf_vars = self._read_config()\n        config = Config(conf_vars)\n        await self._output.send(config)\n\n    async def run(self) -&gt; None:\n\"\"\"Watch config file and update when modified.\n\n        At startup, the Config Manager sends the current config so that it\n        can be cache in the Broadcast channel and served to receivers even if\n        there hasn't been any change to the config file itself.\n        \"\"\"\n        await self.send_config()\n\n        async for path in self._file_watcher:\n            if str(path) == self._conf_file:\n                _logger.info(\n                    \"Update configs, because file %s was modified.\",\n                    self._conf_file,\n                )\n                await self.send_config()\n\n        _logger.debug(\"ConfigManager stopped.\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ConfigManagingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._config_managing.ConfigManagingActor.__init__","title":"<code>__init__(conf_file, output, event_types=None)</code>","text":"<p>Read config variables from the file.</p> PARAMETER DESCRIPTION <code>conf_file</code> <p>Path to file with config variables.</p> <p> TYPE: <code>str</code> </p> <code>output</code> <p>Channel to publish updates to.</p> <p> TYPE: <code>Sender[Config]</code> </p> <code>event_types</code> <p>Which types of events should update the config and trigger a notification.</p> <p> TYPE: <code>Optional[Set[FileWatcher.EventType]]</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_config_managing.py</code> <pre><code>def __init__(\n    self,\n    conf_file: str,\n    output: Sender[Config],\n    event_types: Optional[Set[FileWatcher.EventType]] = None,\n) -&gt; None:\n\"\"\"Read config variables from the file.\n\n    Args:\n        conf_file: Path to file with config variables.\n        output: Channel to publish updates to.\n        event_types: Which types of events should update the config and\n            trigger a notification.\n    \"\"\"\n    self._conf_file: str = conf_file\n    self._conf_dir: str = os.path.dirname(conf_file)\n    self._file_watcher = FileWatcher(\n        paths=[self._conf_dir], event_types=event_types\n    )\n    self._output = output\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._config_managing.ConfigManagingActor.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Watch config file and update when modified.</p> <p>At startup, the Config Manager sends the current config so that it can be cache in the Broadcast channel and served to receivers even if there hasn't been any change to the config file itself.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_config_managing.py</code> <pre><code>async def run(self) -&gt; None:\n\"\"\"Watch config file and update when modified.\n\n    At startup, the Config Manager sends the current config so that it\n    can be cache in the Broadcast channel and served to receivers even if\n    there hasn't been any change to the config file itself.\n    \"\"\"\n    await self.send_config()\n\n    async for path in self._file_watcher:\n        if str(path) == self._conf_file:\n            _logger.info(\n                \"Update configs, because file %s was modified.\",\n                self._conf_file,\n            )\n            await self.send_config()\n\n    _logger.debug(\"ConfigManager stopped.\")\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._config_managing.ConfigManagingActor.send_config","title":"<code>send_config()</code>  <code>async</code>","text":"<p>Send config file using a broadcast channel.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_config_managing.py</code> <pre><code>async def send_config(self) -&gt; None:\n\"\"\"Send config file using a broadcast channel.\"\"\"\n    conf_vars = self._read_config()\n    config = Config(conf_vars)\n    await self._output.send(config)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor","title":"<code>frequenz.sdk.actor.DataSourcingActor</code>","text":"<p>An actor that provides data streams of metrics as time series.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_data_sourcing/data_sourcing.py</code> <pre><code>@actor\nclass DataSourcingActor:\n\"\"\"An actor that provides data streams of metrics as time series.\"\"\"\n\n    def __init__(\n        self,\n        request_receiver: Receiver[ComponentMetricRequest],\n        registry: ChannelRegistry,\n    ) -&gt; None:\n\"\"\"Create a `DataSourcingActor` instance.\n\n        Args:\n            request_receiver: A channel receiver to accept metric requests from.\n            registry: A channel registry.  To be replaced by a singleton\n                instance.\n        \"\"\"\n        self._request_receiver = request_receiver\n        self._microgrid_api_source = MicrogridApiSource(registry)\n\n    async def run(self) -&gt; None:\n\"\"\"Run the actor.\"\"\"\n        async for request in self._request_receiver:\n            await self._microgrid_api_source.add_metric(request)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.DataSourcingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.data_sourcing.DataSourcingActor.__init__","title":"<code>__init__(request_receiver, registry)</code>","text":"<p>Create a <code>DataSourcingActor</code> instance.</p> PARAMETER DESCRIPTION <code>request_receiver</code> <p>A channel receiver to accept metric requests from.</p> <p> TYPE: <code>Receiver[ComponentMetricRequest]</code> </p> <code>registry</code> <p>A channel registry.  To be replaced by a singleton instance.</p> <p> TYPE: <code>ChannelRegistry</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_data_sourcing/data_sourcing.py</code> <pre><code>def __init__(\n    self,\n    request_receiver: Receiver[ComponentMetricRequest],\n    registry: ChannelRegistry,\n) -&gt; None:\n\"\"\"Create a `DataSourcingActor` instance.\n\n    Args:\n        request_receiver: A channel receiver to accept metric requests from.\n        registry: A channel registry.  To be replaced by a singleton\n            instance.\n    \"\"\"\n    self._request_receiver = request_receiver\n    self._microgrid_api_source = MicrogridApiSource(registry)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor._data_sourcing.data_sourcing.DataSourcingActor.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Run the actor.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_data_sourcing/data_sourcing.py</code> <pre><code>async def run(self) -&gt; None:\n\"\"\"Run the actor.\"\"\"\n    async for request in self._request_receiver:\n        await self._microgrid_api_source.add_metric(request)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig","title":"<code>frequenz.sdk.actor.ResamplerConfig</code>  <code>dataclass</code>","text":"<p>Resampler configuration.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_resampling.py</code> <pre><code>@dataclass(frozen=True)\nclass ResamplerConfig:\n\"\"\"Resampler configuration.\"\"\"\n\n    resampling_period: timedelta\n\"\"\"The resampling period.\n\n    This is the time it passes between resampled data should be calculated.\n\n    It must be a positive time span.\n    \"\"\"\n\n    max_data_age_in_periods: float = 3.0\n\"\"\"The maximum age a sample can have to be considered *relevant* for resampling.\n\n    Expressed in number of periods, where period is the `resampling_period`\n    if we are downsampling (resampling period bigger than the input period) or\n    the input sampling period if we are upsampling (input period bigger than\n    the resampling period).\n\n    It must be bigger than 1.0.\n\n    Example:\n        If `resampling_period` is 3 seconds, the input sampling period is\n        1 and `max_data_age_in_periods` is 2, then data older than 3*2\n        = 6 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n\n        If `resampling_period` is 3 seconds, the input sampling period is\n        5 and `max_data_age_in_periods` is 2, then data older than 5*2\n        = 10 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n    \"\"\"\n\n    resampling_function: ResamplingFunction = average\n\"\"\"The resampling function.\n\n    This function will be applied to the sequence of relevant samples at\n    a given time. The result of the function is what is sent as the resampled\n    value.\n    \"\"\"\n\n    initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n\"\"\"The initial length of the resampling buffer.\n\n    The buffer could grow or shrink depending on the source properties,\n    like sampling rate, to make sure all the requested past sampling periods\n    can be stored.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n\"\"\"The minimum length of the resampling buffer that will emit a warning.\n\n    If a buffer grows bigger than this value, it will emit a warning in the\n    logs, so buffers don't grow too big inadvertently.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n\"\"\"The maximum length of the resampling buffer.\n\n    Buffers won't be allowed to grow beyond this point even if it would be\n    needed to keep all the requested past sampling periods. An error will be\n    emitted in the logs if the buffer length needs to be truncated to this\n    value.\n\n    It must be at bigger than `warn_buffer_len`.\n    \"\"\"\n\n    align_to: datetime | None = UNIX_EPOCH\n\"\"\"The time to align the resampling period to.\n\n    The resampling period will be aligned to this time, so the first resampled\n    sample will be at the first multiple of `resampling_period` starting from\n    `align_to`. It must be an aware datetime and can be in the future too.\n\n    If `align_to` is `None`, the resampling period will be aligned to the\n    time the resampler is created.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n\n        Raises:\n            ValueError: If any value is out of range.\n        \"\"\"\n        if self.resampling_period.total_seconds() &lt; 0.0:\n            raise ValueError(\n                f\"resampling_period ({self.resampling_period}) must be positive\"\n            )\n        if self.max_data_age_in_periods &lt; 1.0:\n            raise ValueError(\n                f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n            )\n        if self.warn_buffer_len &lt; 1:\n            raise ValueError(\n                f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n            )\n        if self.max_buffer_len &lt;= self.warn_buffer_len:\n            raise ValueError(\n                f\"max_buffer_len ({self.max_buffer_len}) should \"\n                f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n            )\n\n        if self.initial_buffer_len &lt; 1:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n            )\n        if self.initial_buffer_len &gt; self.max_buffer_len:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n                f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n                \"initial_buffer_len or a bigger max_buffer_len\"\n            )\n        if self.initial_buffer_len &gt; self.warn_buffer_len:\n            _logger.warning(\n                \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n                self.initial_buffer_len,\n                self.warn_buffer_len,\n            )\n        if self.align_to is not None and self.align_to.tzinfo is None:\n            raise ValueError(\n                f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.align_to","title":"<code>align_to: datetime | None = UNIX_EPOCH</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The time to align the resampling period to.</p> <p>The resampling period will be aligned to this time, so the first resampled sample will be at the first multiple of <code>resampling_period</code> starting from <code>align_to</code>. It must be an aware datetime and can be in the future too.</p> <p>If <code>align_to</code> is <code>None</code>, the resampling period will be aligned to the time the resampler is created.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.initial_buffer_len","title":"<code>initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The initial length of the resampling buffer.</p> <p>The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.max_buffer_len","title":"<code>max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The maximum length of the resampling buffer.</p> <p>Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value.</p> <p>It must be at bigger than <code>warn_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.max_data_age_in_periods","title":"<code>max_data_age_in_periods: float = 3.0</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The maximum age a sample can have to be considered relevant for resampling.</p> <p>Expressed in number of periods, where period is the <code>resampling_period</code> if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period).</p> <p>It must be bigger than 1.0.</p> Example <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 1 and <code>max_data_age_in_periods</code> is 2, then data older than 3*2 = 6 seconds will be discarded when creating a new sample and never passed to the resampling function.</p> <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 5 and <code>max_data_age_in_periods</code> is 2, then data older than 5*2 = 10 seconds will be discarded when creating a new sample and never passed to the resampling function.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.resampling_function","title":"<code>resampling_function: ResamplingFunction = average</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The resampling function.</p> <p>This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.resampling_period","title":"<code>resampling_period: timedelta</code>  <code>instance-attribute</code>","text":"<p>The resampling period.</p> <p>This is the time it passes between resampled data should be calculated.</p> <p>It must be a positive time span.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.warn_buffer_len","title":"<code>warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The minimum length of the resampling buffer that will emit a warning.</p> <p>If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertently.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.ResamplerConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.timeseries._resampling.ResamplerConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check that config values are valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any value is out of range.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_resampling.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n\n    Raises:\n        ValueError: If any value is out of range.\n    \"\"\"\n    if self.resampling_period.total_seconds() &lt; 0.0:\n        raise ValueError(\n            f\"resampling_period ({self.resampling_period}) must be positive\"\n        )\n    if self.max_data_age_in_periods &lt; 1.0:\n        raise ValueError(\n            f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n        )\n    if self.warn_buffer_len &lt; 1:\n        raise ValueError(\n            f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n        )\n    if self.max_buffer_len &lt;= self.warn_buffer_len:\n        raise ValueError(\n            f\"max_buffer_len ({self.max_buffer_len}) should \"\n            f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n        )\n\n    if self.initial_buffer_len &lt; 1:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n        )\n    if self.initial_buffer_len &gt; self.max_buffer_len:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n            f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n            \"initial_buffer_len or a bigger max_buffer_len\"\n        )\n    if self.initial_buffer_len &gt; self.warn_buffer_len:\n        _logger.warning(\n            \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n            self.initial_buffer_len,\n            self.warn_buffer_len,\n        )\n    if self.align_to is not None and self.align_to.tzinfo is None:\n        raise ValueError(\n            f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.actor","title":"<code>frequenz.sdk.actor.actor(cls)</code>","text":"<p>Decorate a class into a simple composable actor.</p> <p>A actor using the <code>actor</code> decorator should define an <code>async def run(self)</code> method, that loops over incoming data, and sends results out.</p> <p>Channels can be used to implement communication between actors, as shown in the examples below.</p> PARAMETER DESCRIPTION <code>cls</code> <p>the class to decorate.</p> <p> TYPE: <code>Callable[_P, _R]</code> </p> RETURNS DESCRIPTION <code>Type[_R]</code> <p>The decorated class.</p> RAISES DESCRIPTION <code>TypeError</code> <p>when the class doesn't have a <code>run</code> method as per spec.</p> <p>Example (one actor receiving from two receivers): <pre><code>from frequenz.channels import Broadcast, Receiver, Sender\nfrom frequenz.channels.util import Select\n@actor\nclass EchoActor:\n    def __init__(\n        self,\n        name: str,\n        recv1: Receiver[bool],\n        recv2: Receiver[bool],\n        output: Sender[bool],\n    ) -&gt; None:\n        self.name = name\n\n        self._recv1 = recv1\n        self._recv2 = recv2\n        self._output = output\n\n    async def run(self) -&gt; None:\n        select = Select(channel_1=self._recv1, channel_2=self._recv2)\n        while await select.ready():\n            if msg := select.channel_1:\n                await self._output.send(msg.inner)\n            elif msg := select.channel_2:\n                await self._output.send(msg.inner)\n\n\ninput_chan_1: Broadcast[bool] = Broadcast(\"input_chan_1\")\ninput_chan_2: Broadcast[bool] = Broadcast(\"input_chan_2\")\n\necho_chan: Broadcast[bool] = Broadcast(\"EchoChannel\")\n\necho_actor = EchoActor(\n    \"EchoActor\",\n    recv1=input_chan_1.new_receiver(),\n    recv2=input_chan_2.new_receiver(),\n    output=echo_chan.new_sender(),\n)\necho_rx = echo_chan.new_receiver()\n\nawait input_chan_2.new_sender().send(True)\nreceived_msg = await echo_rx.receive()\n</code></pre></p> <p>Example (two Actors composed): <pre><code>from frequenz.channels import Broadcast, Receiver, Sender\n@actor\nclass Actor1:\n    def __init__(\n        self,\n        name: str,\n        recv: Receiver[bool],\n        output: Sender[bool],\n    ) -&gt; None:\n        self.name = name\n        self._recv = recv\n        self._output = output\n\n    async def run(self) -&gt; None:\n        async for msg in self._recv:\n            await self._output.send(msg)\n\n\n@actor\nclass Actor2:\n    def __init__(\n        self,\n        name: str,\n        recv: Receiver[bool],\n        output: Sender[bool],\n    ) -&gt; None:\n        self.name = name\n        self._recv = recv\n        self._output = output\n\n    async def run(self) -&gt; None:\n        async for msg in self._recv:\n            await self._output.send(msg)\n\ninput_chan: Broadcast[bool] = Broadcast(\"Input to A1\")\na1_chan: Broadcast[bool] = Broadcast(\"A1 stream\")\na2_chan: Broadcast[bool] = Broadcast(\"A2 stream\")\na_1 = Actor1(\n    name=\"ActorOne\",\n    recv=input_chan.new_receiver(),\n    output=a1_chan.new_sender(),\n)\na_2 = Actor2(\n    name=\"ActorTwo\",\n    recv=a1_chan.new_receiver(),\n    output=a2_chan.new_sender(),\n)\n\na2_rx = a2_chan.new_receiver()\n\nawait input_chan.new_sender().send(True)\nreceived_msg = await a2_rx.receive()\n</code></pre></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_decorator.py</code> <pre><code>def actor(cls: Callable[_P, _R]) -&gt; Type[_R]:\n\"\"\"Decorate a class into a simple composable actor.\n\n    A actor using the `actor` decorator should define an `async def run(self)`\n    method, that loops over incoming data, and sends results out.\n\n    Channels can be used to implement communication between actors, as shown in\n    the examples below.\n\n    Args:\n        cls: the class to decorate.\n\n    Returns:\n        The decorated class.\n\n    Raises:\n        TypeError: when the class doesn't have a `run` method as per spec.\n\n    Example (one actor receiving from two receivers):\n    ```python\n    from frequenz.channels import Broadcast, Receiver, Sender\n    from frequenz.channels.util import Select\n    @actor\n    class EchoActor:\n        def __init__(\n            self,\n            name: str,\n            recv1: Receiver[bool],\n            recv2: Receiver[bool],\n            output: Sender[bool],\n        ) -&gt; None:\n            self.name = name\n\n            self._recv1 = recv1\n            self._recv2 = recv2\n            self._output = output\n\n        async def run(self) -&gt; None:\n            select = Select(channel_1=self._recv1, channel_2=self._recv2)\n            while await select.ready():\n                if msg := select.channel_1:\n                    await self._output.send(msg.inner)\n                elif msg := select.channel_2:\n                    await self._output.send(msg.inner)\n\n\n    input_chan_1: Broadcast[bool] = Broadcast(\"input_chan_1\")\n    input_chan_2: Broadcast[bool] = Broadcast(\"input_chan_2\")\n\n    echo_chan: Broadcast[bool] = Broadcast(\"EchoChannel\")\n\n    echo_actor = EchoActor(\n        \"EchoActor\",\n        recv1=input_chan_1.new_receiver(),\n        recv2=input_chan_2.new_receiver(),\n        output=echo_chan.new_sender(),\n    )\n    echo_rx = echo_chan.new_receiver()\n\n    await input_chan_2.new_sender().send(True)\n    received_msg = await echo_rx.receive()\n    ```\n\n    Example (two Actors composed):\n    ```python\n    from frequenz.channels import Broadcast, Receiver, Sender\n    @actor\n    class Actor1:\n        def __init__(\n            self,\n            name: str,\n            recv: Receiver[bool],\n            output: Sender[bool],\n        ) -&gt; None:\n            self.name = name\n            self._recv = recv\n            self._output = output\n\n        async def run(self) -&gt; None:\n            async for msg in self._recv:\n                await self._output.send(msg)\n\n\n    @actor\n    class Actor2:\n        def __init__(\n            self,\n            name: str,\n            recv: Receiver[bool],\n            output: Sender[bool],\n        ) -&gt; None:\n            self.name = name\n            self._recv = recv\n            self._output = output\n\n        async def run(self) -&gt; None:\n            async for msg in self._recv:\n                await self._output.send(msg)\n\n    input_chan: Broadcast[bool] = Broadcast(\"Input to A1\")\n    a1_chan: Broadcast[bool] = Broadcast(\"A1 stream\")\n    a2_chan: Broadcast[bool] = Broadcast(\"A2 stream\")\n    a_1 = Actor1(\n        name=\"ActorOne\",\n        recv=input_chan.new_receiver(),\n        output=a1_chan.new_sender(),\n    )\n    a_2 = Actor2(\n        name=\"ActorTwo\",\n        recv=a1_chan.new_receiver(),\n        output=a2_chan.new_sender(),\n    )\n\n    a2_rx = a2_chan.new_receiver()\n\n    await input_chan.new_sender().send(True)\n    received_msg = await a2_rx.receive()\n    ```\n\n    \"\"\"\n    if not inspect.isclass(cls):\n        raise TypeError(\"The `@actor` decorator can only be applied for classes.\")\n\n    _check_run_method_exists(cls)\n\n    class ActorClass(cls, BaseActor):  # type: ignore\n\"\"\"A wrapper class to make an actor.\"\"\"\n\n        def __init__(self, *args: _P.args, **kwargs: _P.kwargs) -&gt; None:\n\"\"\"Create an `ActorClass` instance.\n\n            Also call __init__ on `cls`.\n\n            Args:\n                *args: Any positional arguments to `cls.__init__`.\n                **kwargs: Any keyword arguments to `cls.__init__`.\n            \"\"\"\n            super().__init__(*args, **kwargs)\n            self._actor_task = asyncio.create_task(self._start_actor())\n\n        async def _start_actor(self) -&gt; None:\n\"\"\"Run the main logic of the actor as a coroutine.\n\n            Raises:\n                asyncio.CancelledError: when the actor's task gets cancelled.\n            \"\"\"\n            _logger.debug(\"Starting actor: %s\", cls.__name__)\n            number_of_restarts = 0\n            while (\n                self.restart_limit is None or number_of_restarts &lt;= self.restart_limit\n            ):\n                if number_of_restarts &gt; 0:\n                    _logger.info(\"Restarting actor: %s\", cls.__name__)\n\n                try:\n                    await super().run()\n                except asyncio.CancelledError:\n                    _logger.debug(\"Cancelling actor: %s\", cls.__name__)\n                    raise\n                except Exception:  # pylint: disable=broad-except\n                    _logger.exception(\"Actor (%s) crashed\", cls.__name__)\n                finally:\n                    number_of_restarts += 1\n\n            _logger.info(\"Shutting down actor: %s\", cls.__name__)\n\n        async def _stop(self) -&gt; None:\n\"\"\"Stop an running actor.\"\"\"\n            await cancel_and_await(self._actor_task)\n\n        async def join(self) -&gt; None:\n\"\"\"Await the actor's task, and return when the task completes.\"\"\"\n            await self._actor_task\n\n    return ActorClass\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/#frequenz.sdk.actor.run","title":"<code>frequenz.sdk.actor.run(*actors)</code>  <code>async</code>","text":"<p>Await the completion of all actors.</p> PARAMETER DESCRIPTION <code>actors</code> <p>the actors to be awaited.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>if any of the actors is not an instance of BaseActor.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/_run_utils.py</code> <pre><code>async def run(*actors: Any) -&gt; None:\n\"\"\"Await the completion of all actors.\n\n    Args:\n        actors: the actors to be awaited.\n\n    Raises:\n        AssertionError: if any of the actors is not an instance of BaseActor.\n    \"\"\"\n    # Check that each actor is an instance of BaseActor at runtime,\n    # due to the indirection created by the actor decorator.\n    for actor in actors:\n        assert isinstance(actor, BaseActor), f\"{actor} is not an instance of BaseActor\"\n\n    pending_tasks = set()\n    for actor in actors:\n        pending_tasks.add(asyncio.create_task(actor.join(), name=str(actor)))\n\n    # Currently the actor decorator manages the life-cycle of the actor tasks\n    while pending_tasks:\n        done_tasks, pending_tasks = await asyncio.wait(\n            pending_tasks, return_when=asyncio.FIRST_COMPLETED\n        )\n\n        # This should always be only one task, but we handle many for extra safety\n        for task in done_tasks:\n            # Cancellation needs to be checked first, otherwise the other methods\n            # could raise a CancelledError\n            if task.cancelled():\n                _logger.info(\"The actor %s was cancelled\", task.get_name())\n            elif exception := task.exception():\n                _logger.error(\n                    \"The actor %s was finished due to an uncaught exception\",\n                    task.get_name(),\n                    exc_info=exception,\n                )\n            else:\n                _logger.info(\"The actor %s finished normally\", task.get_name())\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/","title":"power_distributing","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing","title":"<code>frequenz.sdk.actor.power_distributing</code>","text":"<p>This module provides feature to set power between many batteries.</p> <p>Distributing power is very important to keep the microgrid ready for the power requirements. This module provides PowerDistributingActor that knows how to distribute power. It also provides all the secondary features that should be used to communicate with PowerDistributingActor and send requests for charging or discharging power.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus","title":"<code>frequenz.sdk.actor.power_distributing.BatteryStatus</code>  <code>dataclass</code>","text":"<p>Status of the batteries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/_battery_pool_status.py</code> <pre><code>@dataclass\nclass BatteryStatus:\n\"\"\"Status of the batteries.\"\"\"\n\n    working: Set[int]\n\"\"\"Set of working battery ids.\"\"\"\n\n    uncertain: Set[int]\n\"\"\"Set of batteries that should be used only if there are no working batteries.\"\"\"\n\n    def get_working_batteries(self, batteries: abc.Set[int]) -&gt; Set[int]:\n\"\"\"From the given set of batteries return working batteries.\n\n        Args:\n            batteries: Set of batteries\n\n        Returns:\n            Subset with working batteries.\n        \"\"\"\n        working = self.working.intersection(batteries)\n        if len(working) &gt; 0:\n            return working\n        return self.uncertain.intersection(batteries)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing._battery_pool_status.BatteryStatus.uncertain","title":"<code>uncertain: Set[int]</code>  <code>instance-attribute</code>","text":"<p>Set of batteries that should be used only if there are no working batteries.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing._battery_pool_status.BatteryStatus.working","title":"<code>working: Set[int]</code>  <code>instance-attribute</code>","text":"<p>Set of working battery ids.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.BatteryStatus-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing._battery_pool_status.BatteryStatus.get_working_batteries","title":"<code>get_working_batteries(batteries)</code>","text":"<p>From the given set of batteries return working batteries.</p> PARAMETER DESCRIPTION <code>batteries</code> <p>Set of batteries</p> <p> TYPE: <code>abc.Set[int]</code> </p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Subset with working batteries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/_battery_pool_status.py</code> <pre><code>def get_working_batteries(self, batteries: abc.Set[int]) -&gt; Set[int]:\n\"\"\"From the given set of batteries return working batteries.\n\n    Args:\n        batteries: Set of batteries\n\n    Returns:\n        Subset with working batteries.\n    \"\"\"\n    working = self.working.intersection(batteries)\n    if len(working) &gt; 0:\n        return working\n    return self.uncertain.intersection(batteries)\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error","title":"<code>frequenz.sdk.actor.power_distributing.Error</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Result</code></p> <p>Result returned when an error occurred and power was not set at all.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Error(Result):\n\"\"\"Result returned when an error occurred and power was not set at all.\"\"\"\n\n    msg: str\n\"\"\"The error message explaining why error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Error-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.result.Error.msg","title":"<code>msg: str</code>  <code>instance-attribute</code>","text":"<p>The error message explaining why error happened.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBound","title":"<code>frequenz.sdk.actor.power_distributing.OutOfBound</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Result</code></p> <p>Result returned when the power was not set because it was out of bounds.</p> <p>This result happens when the originating request was done with <code>adjust_power = False</code> and the requested power is not within the batteries bounds.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass OutOfBound(Result):\n\"\"\"Result returned when the power was not set because it was out of bounds.\n\n    This result happens when the originating request was done with\n    `adjust_power = False` and the requested power is not within the batteries bounds.\n    \"\"\"\n\n    bound: float\n\"\"\"The total power bound for the requested batteries.\n\n    If the requested power negative, then this value is the lower bound.\n    Otherwise it is upper bound.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.OutOfBound-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.result.OutOfBound.bound","title":"<code>bound: float</code>  <code>instance-attribute</code>","text":"<p>The total power bound for the requested batteries.</p> <p>If the requested power negative, then this value is the lower bound. Otherwise it is upper bound.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure","title":"<code>frequenz.sdk.actor.power_distributing.PartialFailure</code>  <code>dataclass</code>","text":"<p>         Bases: <code>_BaseSuccessMixin</code>, <code>Result</code></p> <p>Result returned when any battery failed to perform the request.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PartialFailure(_BaseSuccessMixin, Result):\n\"\"\"Result returned when any battery failed to perform the request.\"\"\"\n\n    failed_power: float\n\"\"\"The part of the requested power that failed to be set.\"\"\"\n\n    failed_batteries: set[int]\n\"\"\"The subset of batteries for which the request failed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PartialFailure-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_batteries","title":"<code>failed_batteries: set[int]</code>  <code>instance-attribute</code>","text":"<p>The subset of batteries for which the request failed.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_power","title":"<code>failed_power: float</code>  <code>instance-attribute</code>","text":"<p>The part of the requested power that failed to be set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor","title":"<code>frequenz.sdk.actor.power_distributing.PowerDistributingActor</code>","text":"<p>Actor to distribute the power between batteries in a microgrid.</p> <p>The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time.</p> <p>For each user a bidirectional channel needs to be created through which they can send and receive requests and responses.</p> <p>It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout_sec + time for processing the request.</p> <p>Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED.</p> <ul> <li>If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed.</li> </ul> Example <pre><code>from frequenz.sdk import microgrid\nfrom frequenz.sdk.microgrid.component import ComponentCategory\nfrom frequenz.sdk.actor import ResamplerConfig\nfrom frequenz.sdk.actor.power_distributing import (\n    PowerDistributingActor,\n    Request,\n    Result,\n    Success,\n    Error,\n    PartialFailure,\n    Ignored,\n)\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom datetime import timedelta\nfrom frequenz.sdk import actor\n\nHOST = \"localhost\"\nPORT = 50051\n\nawait microgrid.initialize(\n    HOST,\n    PORT,\n    ResamplerConfig(resampling_period=timedelta(seconds=1))\n)\n\ngraph = microgrid.connection_manager.get().component_graph\n\nbatteries = graph.components(component_category={ComponentCategory.BATTERY})\nbatteries_ids = {c.component_id for c in batteries}\n\nbattery_status_channel = Broadcast[BatteryStatus](\"battery-status\")\n\nchannel = Broadcast[Request](\"power_distributor\")\nchannel_registry = ChannelRegistry(name=\"power_distributor\")\npower_distributor = PowerDistributingActor(\n    requests_receiver=channel.new_receiver(),\n    channel_registry=channel_registry,\n    battery_status_sender=battery_status_channel.new_sender(),\n)\n\nsender = channel.new_sender()\nnamespace: str = \"namespace\"\n# Set power 1200W to given batteries.\nrequest = Request(\n    namespace=namespace,\n    power=1200.0,\n    batteries=batteries_ids,\n    request_timeout_sec=10.0\n)\nawait sender.send(request)\nresult_rx = channel_registry.new_receiver(namespace)\n\n# It is recommended to use timeout when waiting for the response!\nresult: Result = await asyncio.wait_for(result_rx.receive(), timeout=10)\n\nif isinstance(result, Success):\n    print(\"Command succeed\")\nelif isinstance(result, PartialFailure):\n    print(\n        f\"Batteries {result.failed_batteries} failed, total failed power\"                 f\"{result.failed_power}\"\n    )\nelif isinstance(result, Ignored):\n    print(\"Request was ignored, because of newer request\")\nelif isinstance(result, Error):\n    print(f\"Request failed with error: {result.msg}\")\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>@actor\nclass PowerDistributingActor:\n    # pylint: disable=too-many-instance-attributes\n\"\"\"Actor to distribute the power between batteries in a microgrid.\n\n    The purpose of this tool is to keep an equal SoC level in all batteries.\n    The PowerDistributingActor can have many concurrent users which at this time\n    need to be known at construction time.\n\n    For each user a bidirectional channel needs to be created through which\n    they can send and receive requests and responses.\n\n    It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if\n    the processing function fails then the response will never come.\n    The timeout should be Result:request_timeout_sec + time for processing the request.\n\n    Edge cases:\n    * If there are 2 requests to be processed for the same subset of batteries, then\n    only the latest request will be processed. Older request will be ignored. User with\n    older request will get response with Result.Status.IGNORED.\n\n    * If there are 2 requests and their subset of batteries is different but they\n    overlap (they have at least one common battery), then then both batteries\n    will be processed. However it is not expected so the proper error log will be\n    printed.\n\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.microgrid.component import ComponentCategory\n        from frequenz.sdk.actor import ResamplerConfig\n        from frequenz.sdk.actor.power_distributing import (\n            PowerDistributingActor,\n            Request,\n            Result,\n            Success,\n            Error,\n            PartialFailure,\n            Ignored,\n        )\n        from frequenz.channels import Broadcast, Receiver, Sender\n        from datetime import timedelta\n        from frequenz.sdk import actor\n\n        HOST = \"localhost\"\n        PORT = 50051\n\n        await microgrid.initialize(\n            HOST,\n            PORT,\n            ResamplerConfig(resampling_period=timedelta(seconds=1))\n        )\n\n        graph = microgrid.connection_manager.get().component_graph\n\n        batteries = graph.components(component_category={ComponentCategory.BATTERY})\n        batteries_ids = {c.component_id for c in batteries}\n\n        battery_status_channel = Broadcast[BatteryStatus](\"battery-status\")\n\n        channel = Broadcast[Request](\"power_distributor\")\n        channel_registry = ChannelRegistry(name=\"power_distributor\")\n        power_distributor = PowerDistributingActor(\n            requests_receiver=channel.new_receiver(),\n            channel_registry=channel_registry,\n            battery_status_sender=battery_status_channel.new_sender(),\n        )\n\n        sender = channel.new_sender()\n        namespace: str = \"namespace\"\n        # Set power 1200W to given batteries.\n        request = Request(\n            namespace=namespace,\n            power=1200.0,\n            batteries=batteries_ids,\n            request_timeout_sec=10.0\n        )\n        await sender.send(request)\n        result_rx = channel_registry.new_receiver(namespace)\n\n        # It is recommended to use timeout when waiting for the response!\n        result: Result = await asyncio.wait_for(result_rx.receive(), timeout=10)\n\n        if isinstance(result, Success):\n            print(\"Command succeed\")\n        elif isinstance(result, PartialFailure):\n            print(\n                f\"Batteries {result.failed_batteries} failed, total failed power\" \\\n                f\"{result.failed_power}\"\n            )\n        elif isinstance(result, Ignored):\n            print(\"Request was ignored, because of newer request\")\n        elif isinstance(result, Error):\n            print(f\"Request failed with error: {result.msg}\")\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        requests_receiver: Receiver[Request],\n        channel_registry: ChannelRegistry,\n        battery_status_sender: Sender[BatteryStatus],\n        wait_for_data_sec: float = 2,\n    ) -&gt; None:\n\"\"\"Create class instance.\n\n        Args:\n            requests_receiver: Receiver for receiving power requests from other actors.\n            channel_registry: Channel registry for creating result channels dynamically\n                for each request namespace.\n            battery_status_sender: Channel for sending information which batteries are\n                working.\n            wait_for_data_sec: How long actor should wait before processing first\n                request. It is a time needed to collect first components data.\n        \"\"\"\n        self._requests_receiver = requests_receiver\n        self._channel_registry = channel_registry\n        self._wait_for_data_sec = wait_for_data_sec\n        self._result_senders: Dict[str, Sender[Result]] = {}\n\"\"\"Dictionary of result senders for each request namespace.\n\n        They are for channels owned by the channel registry, we just hold a reference\n        to their senders, for fast access.\n        \"\"\"\n\n        # NOTE: power_distributor_exponent should be received from ConfigManager\n        self.power_distributor_exponent: float = 1.0\n        self.distribution_algorithm = DistributionAlgorithm(\n            self.power_distributor_exponent\n        )\n\n        self._bat_inv_map, self._inv_bat_map = self._get_components_pairs(\n            connection_manager.get().component_graph\n        )\n        self._battery_receivers: Dict[int, Peekable[BatteryData]] = {}\n        self._inverter_receivers: Dict[int, Peekable[InverterData]] = {}\n\n        self._all_battery_status = BatteryPoolStatus(\n            battery_ids=set(self._bat_inv_map.keys()),\n            battery_status_sender=battery_status_sender,\n            max_blocking_duration_sec=30.0,\n            max_data_age_sec=10.0,\n        )\n\n        self._cached_metrics: dict[int, _CacheEntry | None] = {\n            bat_id: None for bat_id, _ in self._bat_inv_map.items()\n        }\n\n    def _get_upper_bound(self, batteries: abc.Set[int], include_broken: bool) -&gt; float:\n\"\"\"Get total upper bound of power to be set for given batteries.\n\n        Note, output of that function doesn't guarantee that this bound will be\n        the same when the request is processed.\n\n        Args:\n            batteries: List of batteries\n            include_broken: whether all batteries in the batteries set in the\n                request must be used regardless the status.\n\n        Returns:\n            Upper bound for `set_power` operation.\n        \"\"\"\n        pairs_data: List[InvBatPair] = self._get_components_data(\n            batteries, include_broken\n        )\n        return sum(\n            min(battery.power_upper_bound, inverter.active_power_upper_bound)\n            for battery, inverter in pairs_data\n        )\n\n    def _get_lower_bound(self, batteries: abc.Set[int], include_broken: bool) -&gt; float:\n\"\"\"Get total lower bound of power to be set for given batteries.\n\n        Note, output of that function doesn't guarantee that this bound will be\n        the same when the request is processed.\n\n        Args:\n            batteries: List of batteries\n            include_broken: whether all batteries in the batteries set in the\n                request must be used regardless the status.\n\n        Returns:\n            Lower bound for `set_power` operation.\n        \"\"\"\n        pairs_data: List[InvBatPair] = self._get_components_data(\n            batteries, include_broken\n        )\n        return sum(\n            max(battery.power_lower_bound, inverter.active_power_lower_bound)\n            for battery, inverter in pairs_data\n        )\n\n    async def _send_result(self, namespace: str, result: Result) -&gt; None:\n\"\"\"Send result to the user.\n\n        Args:\n            namespace: namespace of the sender, to identify the result channel with.\n            result: Result to send out.\n        \"\"\"\n        if not namespace in self._result_senders:\n            self._result_senders[namespace] = self._channel_registry.new_sender(\n                namespace\n            )\n\n        await self._result_senders[namespace].send(result)\n\n    async def run(self) -&gt; None:\n\"\"\"Run actor main function.\n\n        It waits for new requests in task_queue and process it, and send\n        `set_power` request with distributed power.\n        The output of the `set_power` method is processed.\n        Every battery and inverter that failed or didn't respond in time will be marked\n        as broken for some time.\n        \"\"\"\n        await self._create_channels()\n\n        api = connection_manager.get().api_client\n\n        # Wait few seconds to get data from the channels created above.\n        await asyncio.sleep(self._wait_for_data_sec)\n\n        async for request in self._requests_receiver:\n            error = self._check_request(request)\n            if error:\n                await self._send_result(request.namespace, error)\n                continue\n\n            try:\n                pairs_data: List[InvBatPair] = self._get_components_data(\n                    request.batteries, request.include_broken_batteries\n                )\n            except KeyError as err:\n                await self._send_result(\n                    request.namespace, Error(request=request, msg=str(err))\n                )\n                continue\n\n            if not pairs_data and not request.include_broken_batteries:\n                error_msg = f\"No data for the given batteries {str(request.batteries)}\"\n                await self._send_result(\n                    request.namespace, Error(request=request, msg=str(error_msg))\n                )\n                continue\n\n            try:\n                distribution = self._get_power_distribution(request, pairs_data)\n            except ValueError as err:\n                error_msg = f\"Couldn't distribute power, error: {str(err)}\"\n                await self._send_result(\n                    request.namespace, Error(request=request, msg=str(error_msg))\n                )\n                continue\n\n            distributed_power_value = request.power - distribution.remaining_power\n            battery_distribution = {\n                self._inv_bat_map[bat_id]: dist\n                for bat_id, dist in distribution.distribution.items()\n            }\n            _logger.debug(\n                \"Distributing power %d between the batteries %s\",\n                distributed_power_value,\n                str(battery_distribution),\n            )\n\n            failed_power, failed_batteries = await self._set_distributed_power(\n                api, distribution, request.request_timeout_sec\n            )\n\n            response: Success | PartialFailure\n            if len(failed_batteries) &gt; 0:\n                succeed_batteries = set(battery_distribution.keys()) - failed_batteries\n                response = PartialFailure(\n                    request=request,\n                    succeeded_power=distributed_power_value,\n                    succeeded_batteries=succeed_batteries,\n                    failed_power=failed_power,\n                    failed_batteries=failed_batteries,\n                    excess_power=distribution.remaining_power,\n                )\n            else:\n                succeed_batteries = set(battery_distribution.keys())\n                response = Success(\n                    request=request,\n                    succeeded_power=distributed_power_value,\n                    succeeded_batteries=succeed_batteries,\n                    excess_power=distribution.remaining_power,\n                )\n\n            asyncio.gather(\n                *[\n                    self._all_battery_status.update_status(\n                        succeed_batteries, failed_batteries\n                    ),\n                    self._send_result(request.namespace, response),\n                ]\n            )\n\n    async def _set_distributed_power(\n        self,\n        api: MicrogridApiClient,\n        distribution: DistributionResult,\n        timeout_sec: float,\n    ) -&gt; Tuple[float, Set[int]]:\n\"\"\"Send distributed power to the inverters.\n\n        Args:\n            api: Microgrid api client\n            distribution: Distribution result\n            timeout_sec: How long wait for the response\n\n        Returns:\n            Tuple where first element is total failed power, and the second element\n            set of batteries that failed.\n        \"\"\"\n        tasks = {\n            inverter_id: asyncio.create_task(api.set_power(inverter_id, power))\n            for inverter_id, power in distribution.distribution.items()\n        }\n\n        _, pending = await asyncio.wait(\n            tasks.values(),\n            timeout=timeout_sec,\n            return_when=ALL_COMPLETED,\n        )\n\n        await self._cancel_tasks(pending)\n\n        return self._parse_result(tasks, distribution.distribution, timeout_sec)\n\n    def _get_power_distribution(\n        self, request: Request, inv_bat_pairs: List[InvBatPair]\n    ) -&gt; DistributionResult:\n\"\"\"Get power distribution result for the batteries in the request.\n\n        Args:\n            request: the power request to process.\n            inv_bat_pairs: the battery and adjacent inverter data pairs.\n\n        Returns:\n            the power distribution result.\n        \"\"\"\n        available_bat_ids = {battery.component_id for battery, _ in inv_bat_pairs}\n        unavailable_bat_ids = request.batteries - available_bat_ids\n        unavailable_inv_ids = {\n            self._bat_inv_map[battery_id] for battery_id in unavailable_bat_ids\n        }\n\n        if request.include_broken_batteries and not available_bat_ids:\n            return self.distribution_algorithm.distribute_power_equally(\n                request.power, unavailable_inv_ids\n            )\n\n        result = self.distribution_algorithm.distribute_power(\n            request.power, inv_bat_pairs\n        )\n\n        if request.include_broken_batteries and unavailable_inv_ids:\n            additional_result = self.distribution_algorithm.distribute_power_equally(\n                result.remaining_power, unavailable_inv_ids\n            )\n\n            for inv_id, power in additional_result.distribution.items():\n                result.distribution[inv_id] = power\n            result.remaining_power = 0.0\n\n        return result\n\n    def _check_request(self, request: Request) -&gt; Optional[Result]:\n\"\"\"Check whether the given request if correct.\n\n        Args:\n            request: request to check\n\n        Returns:\n            Result for the user if the request is wrong, None otherwise.\n        \"\"\"\n        if not request.batteries:\n            return Error(request=request, msg=\"Empty battery IDs in the request\")\n\n        for battery in request.batteries:\n            if battery not in self._battery_receivers:\n                msg = (\n                    f\"No battery {battery}, available batteries: \"\n                    f\"{list(self._battery_receivers.keys())}\"\n                )\n                return Error(request=request, msg=msg)\n\n        if not request.adjust_power:\n            if request.power &lt; 0:\n                bound = self._get_lower_bound(\n                    request.batteries, request.include_broken_batteries\n                )\n                if request.power &lt; bound:\n                    return OutOfBound(request=request, bound=bound)\n            else:\n                bound = self._get_upper_bound(\n                    request.batteries, request.include_broken_batteries\n                )\n                if request.power &gt; bound:\n                    return OutOfBound(request=request, bound=bound)\n\n        return None\n\n    def _get_components_pairs(\n        self, component_graph: ComponentGraph\n    ) -&gt; Tuple[Dict[int, int], Dict[int, int]]:\n\"\"\"Create maps between battery and adjacent inverter.\n\n        Args:\n            component_graph: component graph\n\n        Returns:\n            Tuple where first element is map between battery and adjacent inverter,\n                second element of the tuple is map between inverter and adjacent\n                battery.\n        \"\"\"\n        bat_inv_map: Dict[int, int] = {}\n        inv_bat_map: Dict[int, int] = {}\n\n        batteries: Iterable[Component] = component_graph.components(\n            component_category={ComponentCategory.BATTERY}\n        )\n\n        for battery in batteries:\n            inverters: List[Component] = [\n                component\n                for component in component_graph.predecessors(battery.component_id)\n                if component.category == ComponentCategory.INVERTER\n            ]\n\n            if len(inverters) == 0:\n                _logger.error(\"No inverters for battery %d\", battery.component_id)\n                continue\n\n            if len(inverters) &gt; 1:\n                _logger.error(\n                    \"Battery %d has more then one inverter. It is not supported now.\",\n                    battery.component_id,\n                )\n\n            bat_inv_map[battery.component_id] = inverters[0].component_id\n            inv_bat_map[inverters[0].component_id] = battery.component_id\n\n        return bat_inv_map, inv_bat_map\n\n    def _get_components_data(\n        self, batteries: abc.Set[int], include_broken: bool\n    ) -&gt; List[InvBatPair]:\n\"\"\"Get data for the given batteries and adjacent inverters.\n\n        Args:\n            batteries: Batteries that needs data.\n            include_broken: whether all batteries in the batteries set in the\n                request must be used regardless the status.\n\n        Raises:\n            KeyError: If any battery in the given list doesn't exists in microgrid.\n\n        Returns:\n            Pairs of battery and adjacent inverter data.\n        \"\"\"\n        pairs_data: List[InvBatPair] = []\n        working_batteries = (\n            batteries\n            if include_broken\n            else self._all_battery_status.get_working_batteries(batteries)\n        )\n\n        for battery_id in working_batteries:\n            if battery_id not in self._battery_receivers:\n                raise KeyError(\n                    f\"No battery {battery_id}, \"\n                    f\"available batteries: {list(self._battery_receivers.keys())}\"\n                )\n\n            inverter_id: int = self._bat_inv_map[battery_id]\n\n            data = self._get_battery_inverter_data(battery_id, inverter_id)\n            if not data and include_broken:\n                cached_entry = self._cached_metrics[battery_id]\n                if cached_entry and not cached_entry.has_expired():\n                    data = cached_entry.inv_bat_pair\n                else:\n                    data = None\n            if data is None:\n                _logger.warning(\n                    \"Skipping battery %d because its message isn't correct.\",\n                    battery_id,\n                )\n                continue\n\n            pairs_data.append(data)\n        return pairs_data\n\n    def _get_battery_inverter_data(\n        self, battery_id: int, inverter_id: int\n    ) -&gt; Optional[InvBatPair]:\n\"\"\"Get battery and inverter data if they are correct.\n\n        Each float data from the microgrid can be \"NaN\".\n        We can't do math operations on \"NaN\".\n        So check all the metrics and:\n        * if power bounds are NaN, then try to replace it with the corresponding\n          power bounds from the adjacent component. If metric in the adjacent component\n          is also NaN, then return None.\n        * if other metrics are NaN then return None. We can't assume anything for other\n          metrics.\n\n        Args:\n            battery_id: battery id\n            inverter_id: inverter id\n\n        Returns:\n            Data for the battery and adjacent inverter without NaN values.\n                Return None if we could not replace NaN values.\n        \"\"\"\n        battery_data = self._battery_receivers[battery_id].peek()\n        inverter_data = self._inverter_receivers[inverter_id].peek()\n\n        # It means that nothing has been send on this channels, yet.\n        # This should be handled by BatteryStatus. BatteryStatus should not return\n        # this batteries as working.\n        if battery_data is None or inverter_data is None:\n            _logger.error(\n                \"Battery %d or inverter %d send no data, yet. They should be not used.\",\n                battery_id,\n                inverter_id,\n            )\n            return None\n\n        not_replaceable_metrics = [\n            battery_data.soc,\n            battery_data.soc_lower_bound,\n            battery_data.soc_upper_bound,\n            # We could replace capacity with 0, but it won't change distribution.\n            # This battery will be ignored in distribution anyway.\n            battery_data.capacity,\n        ]\n        if any(map(isnan, not_replaceable_metrics)):\n            _logger.debug(\"Some metrics for battery %d are NaN\", battery_id)\n            return None\n\n        replaceable_metrics = [\n            battery_data.power_lower_bound,\n            battery_data.power_upper_bound,\n            inverter_data.active_power_lower_bound,\n            inverter_data.active_power_upper_bound,\n        ]\n\n        # If all values are ok then return them.\n        if not any(map(isnan, replaceable_metrics)):\n            inv_bat_pair = InvBatPair(battery_data, inverter_data)\n            self._cached_metrics[battery_id] = _CacheEntry.from_ttl(inv_bat_pair)\n            return inv_bat_pair\n\n        # Replace NaN with the corresponding value in the adjacent component.\n        # If both metrics are None, return None to ignore this battery.\n        replaceable_pairs = [\n            (\"power_lower_bound\", \"active_power_lower_bound\"),\n            (\"power_upper_bound\", \"active_power_upper_bound\"),\n        ]\n\n        battery_new_metrics = {}\n        inverter_new_metrics = {}\n        for bat_attr, inv_attr in replaceable_pairs:\n            bat_bound = getattr(battery_data, bat_attr)\n            inv_bound = getattr(inverter_data, inv_attr)\n            if isnan(bat_bound) and isnan(inv_bound):\n                _logger.debug(\"Some metrics for battery %d are NaN\", battery_id)\n                return None\n            if isnan(bat_bound):\n                battery_new_metrics[bat_attr] = inv_bound\n            elif isnan(inv_bound):\n                inverter_new_metrics[inv_attr] = bat_bound\n\n        inv_bat_pair = InvBatPair(\n            replace(battery_data, **battery_new_metrics),\n            replace(inverter_data, **inverter_new_metrics),\n        )\n        self._cached_metrics[battery_id] = _CacheEntry.from_ttl(inv_bat_pair)\n        return inv_bat_pair\n\n    async def _create_channels(self) -&gt; None:\n\"\"\"Create channels to get data of components in microgrid.\"\"\"\n        api = connection_manager.get().api_client\n        for battery_id, inverter_id in self._bat_inv_map.items():\n            bat_recv: Receiver[BatteryData] = await api.battery_data(battery_id)\n            self._battery_receivers[battery_id] = bat_recv.into_peekable()\n\n            inv_recv: Receiver[InverterData] = await api.inverter_data(inverter_id)\n            self._inverter_receivers[inverter_id] = inv_recv.into_peekable()\n\n    def _parse_result(\n        self,\n        # type comment to quiet pylint and mypy `unused-import` error\n        tasks,  # type: Dict[int, asyncio.Task[Empty]]\n        distribution: Dict[int, float],\n        request_timeout_sec: float,\n    ) -&gt; Tuple[float, Set[int]]:\n\"\"\"Parse the results of `set_power` requests.\n\n        Check if any task has failed and determine the reason for failure.\n        If any task did not succeed, then the corresponding battery is marked as broken.\n\n        Args:\n            tasks: A dictionary where the key is the inverter ID and the value is the task that\n                set the power for this inverter. Each task should be finished or cancelled.\n            distribution: A dictionary where the key is the inverter ID and the value is how much\n                power was set to the corresponding inverter.\n            request_timeout_sec: The timeout that was used for the request.\n\n        Returns:\n            A tuple where the first element is the total failed power, and the second element is\n            the set of batteries that failed.\n        \"\"\"\n        failed_power: float = 0.0\n        failed_batteries: Set[int] = set()\n\n        for inverter_id, aws in tasks.items():\n            battery_id = self._inv_bat_map[inverter_id]\n            try:\n                aws.result()\n            except grpc.aio.AioRpcError as err:\n                failed_power += distribution[inverter_id]\n                failed_batteries.add(battery_id)\n                if err.code() == grpc.StatusCode.OUT_OF_RANGE:\n                    _logger.debug(\n                        \"Set power for battery %d failed, error %s\",\n                        battery_id,\n                        str(err),\n                    )\n                else:\n                    _logger.warning(\n                        \"Set power for battery %d failed, error %s. Mark it as broken.\",\n                        battery_id,\n                        str(err),\n                    )\n            except asyncio.exceptions.CancelledError:\n                failed_power += distribution[inverter_id]\n                failed_batteries.add(battery_id)\n                _logger.warning(\n                    \"Battery %d didn't respond in %f sec. Mark it as broken.\",\n                    battery_id,\n                    request_timeout_sec,\n                )\n\n        return failed_power, failed_batteries\n\n    async def _cancel_tasks(self, tasks: Iterable[asyncio.Task[Any]]) -&gt; None:\n\"\"\"Cancel given asyncio tasks and wait for them.\n\n        Args:\n            tasks: tasks to cancel.\n        \"\"\"\n        for aws in tasks:\n            aws.cancel()\n\n        await asyncio.gather(*tasks, return_exceptions=True)\n\n    async def _stop_actor(self) -&gt; None:\n\"\"\"Stop all running async tasks.\"\"\"\n        await self._all_battery_status.stop()\n        await self._stop()  # type: ignore # pylint: disable=no-member\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.PowerDistributingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__init__","title":"<code>__init__(requests_receiver, channel_registry, battery_status_sender, wait_for_data_sec=2)</code>","text":"<p>Create class instance.</p> PARAMETER DESCRIPTION <code>requests_receiver</code> <p>Receiver for receiving power requests from other actors.</p> <p> TYPE: <code>Receiver[Request]</code> </p> <code>channel_registry</code> <p>Channel registry for creating result channels dynamically for each request namespace.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>battery_status_sender</code> <p>Channel for sending information which batteries are working.</p> <p> TYPE: <code>Sender[BatteryStatus]</code> </p> <code>wait_for_data_sec</code> <p>How long actor should wait before processing first request. It is a time needed to collect first components data.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>def __init__(\n    self,\n    requests_receiver: Receiver[Request],\n    channel_registry: ChannelRegistry,\n    battery_status_sender: Sender[BatteryStatus],\n    wait_for_data_sec: float = 2,\n) -&gt; None:\n\"\"\"Create class instance.\n\n    Args:\n        requests_receiver: Receiver for receiving power requests from other actors.\n        channel_registry: Channel registry for creating result channels dynamically\n            for each request namespace.\n        battery_status_sender: Channel for sending information which batteries are\n            working.\n        wait_for_data_sec: How long actor should wait before processing first\n            request. It is a time needed to collect first components data.\n    \"\"\"\n    self._requests_receiver = requests_receiver\n    self._channel_registry = channel_registry\n    self._wait_for_data_sec = wait_for_data_sec\n    self._result_senders: Dict[str, Sender[Result]] = {}\n\"\"\"Dictionary of result senders for each request namespace.\n\n    They are for channels owned by the channel registry, we just hold a reference\n    to their senders, for fast access.\n    \"\"\"\n\n    # NOTE: power_distributor_exponent should be received from ConfigManager\n    self.power_distributor_exponent: float = 1.0\n    self.distribution_algorithm = DistributionAlgorithm(\n        self.power_distributor_exponent\n    )\n\n    self._bat_inv_map, self._inv_bat_map = self._get_components_pairs(\n        connection_manager.get().component_graph\n    )\n    self._battery_receivers: Dict[int, Peekable[BatteryData]] = {}\n    self._inverter_receivers: Dict[int, Peekable[InverterData]] = {}\n\n    self._all_battery_status = BatteryPoolStatus(\n        battery_ids=set(self._bat_inv_map.keys()),\n        battery_status_sender=battery_status_sender,\n        max_blocking_duration_sec=30.0,\n        max_data_age_sec=10.0,\n    )\n\n    self._cached_metrics: dict[int, _CacheEntry | None] = {\n        bat_id: None for bat_id, _ in self._bat_inv_map.items()\n    }\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Run actor main function.</p> <p>It waits for new requests in task_queue and process it, and send <code>set_power</code> request with distributed power. The output of the <code>set_power</code> method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>async def run(self) -&gt; None:\n\"\"\"Run actor main function.\n\n    It waits for new requests in task_queue and process it, and send\n    `set_power` request with distributed power.\n    The output of the `set_power` method is processed.\n    Every battery and inverter that failed or didn't respond in time will be marked\n    as broken for some time.\n    \"\"\"\n    await self._create_channels()\n\n    api = connection_manager.get().api_client\n\n    # Wait few seconds to get data from the channels created above.\n    await asyncio.sleep(self._wait_for_data_sec)\n\n    async for request in self._requests_receiver:\n        error = self._check_request(request)\n        if error:\n            await self._send_result(request.namespace, error)\n            continue\n\n        try:\n            pairs_data: List[InvBatPair] = self._get_components_data(\n                request.batteries, request.include_broken_batteries\n            )\n        except KeyError as err:\n            await self._send_result(\n                request.namespace, Error(request=request, msg=str(err))\n            )\n            continue\n\n        if not pairs_data and not request.include_broken_batteries:\n            error_msg = f\"No data for the given batteries {str(request.batteries)}\"\n            await self._send_result(\n                request.namespace, Error(request=request, msg=str(error_msg))\n            )\n            continue\n\n        try:\n            distribution = self._get_power_distribution(request, pairs_data)\n        except ValueError as err:\n            error_msg = f\"Couldn't distribute power, error: {str(err)}\"\n            await self._send_result(\n                request.namespace, Error(request=request, msg=str(error_msg))\n            )\n            continue\n\n        distributed_power_value = request.power - distribution.remaining_power\n        battery_distribution = {\n            self._inv_bat_map[bat_id]: dist\n            for bat_id, dist in distribution.distribution.items()\n        }\n        _logger.debug(\n            \"Distributing power %d between the batteries %s\",\n            distributed_power_value,\n            str(battery_distribution),\n        )\n\n        failed_power, failed_batteries = await self._set_distributed_power(\n            api, distribution, request.request_timeout_sec\n        )\n\n        response: Success | PartialFailure\n        if len(failed_batteries) &gt; 0:\n            succeed_batteries = set(battery_distribution.keys()) - failed_batteries\n            response = PartialFailure(\n                request=request,\n                succeeded_power=distributed_power_value,\n                succeeded_batteries=succeed_batteries,\n                failed_power=failed_power,\n                failed_batteries=failed_batteries,\n                excess_power=distribution.remaining_power,\n            )\n        else:\n            succeed_batteries = set(battery_distribution.keys())\n            response = Success(\n                request=request,\n                succeeded_power=distributed_power_value,\n                succeeded_batteries=succeed_batteries,\n                excess_power=distribution.remaining_power,\n            )\n\n        asyncio.gather(\n            *[\n                self._all_battery_status.update_status(\n                    succeed_batteries, failed_batteries\n                ),\n                self._send_result(request.namespace, response),\n            ]\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request","title":"<code>frequenz.sdk.actor.power_distributing.Request</code>  <code>dataclass</code>","text":"<p>Request to set power to the <code>PowerDistributingActor</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/request.py</code> <pre><code>@dataclasses.dataclass\nclass Request:\n\"\"\"Request to set power to the `PowerDistributingActor`.\"\"\"\n\n    namespace: str\n\"\"\"The namespace of the request.\n\n    This will be used to identify the channel for sending the response into, in the\n    channel registry.\n    \"\"\"\n\n    power: float\n\"\"\"The requested power in watts.\"\"\"\n\n    batteries: abc.Set[int]\n\"\"\"The component ids of the batteries to be used for this request.\"\"\"\n\n    request_timeout_sec: float = 5.0\n\"\"\"The maximum amount of time to wait for the request to be fulfilled.\"\"\"\n\n    adjust_power: bool = True\n\"\"\"Whether to adjust the power to match the bounds.\n\n    If `True`, the power will be adjusted (lowered) to match the bounds, so\n    only the reduced power will be set.\n\n    If `False` and the power is outside the batteries' bounds, the request will\n    fail and be replied to with an `OutOfBound` result.\n    \"\"\"\n\n    include_broken_batteries: bool = False\n\"\"\"Whether to use all batteries included in the batteries set regardless the status.\n\n    If set to `True`, the power distribution algorithm will consider all batteries,\n    including the broken ones, when distributing power.  In such cases, any remaining\n    power after distributing among the available batteries will be distributed equally\n    among the unavailable (broken) batteries.  If all batteries in the set are\n    unavailable, the power will be equally distributed among all the unavailable\n    batteries in the request.\n\n    If set to `False`, the power distribution will only take into account the available\n    batteries, excluding any broken ones.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Request-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.request.Request.adjust_power","title":"<code>adjust_power: bool = True</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Whether to adjust the power to match the bounds.</p> <p>If <code>True</code>, the power will be adjusted (lowered) to match the bounds, so only the reduced power will be set.</p> <p>If <code>False</code> and the power is outside the batteries' bounds, the request will fail and be replied to with an <code>OutOfBound</code> result.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.request.Request.batteries","title":"<code>batteries: abc.Set[int]</code>  <code>instance-attribute</code>","text":"<p>The component ids of the batteries to be used for this request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.request.Request.include_broken_batteries","title":"<code>include_broken_batteries: bool = False</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Whether to use all batteries included in the batteries set regardless the status.</p> <p>If set to <code>True</code>, the power distribution algorithm will consider all batteries, including the broken ones, when distributing power.  In such cases, any remaining power after distributing among the available batteries will be distributed equally among the unavailable (broken) batteries.  If all batteries in the set are unavailable, the power will be equally distributed among all the unavailable batteries in the request.</p> <p>If set to <code>False</code>, the power distribution will only take into account the available batteries, excluding any broken ones.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.request.Request.namespace","title":"<code>namespace: str</code>  <code>instance-attribute</code>","text":"<p>The namespace of the request.</p> <p>This will be used to identify the channel for sending the response into, in the channel registry.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.request.Request.power","title":"<code>power: float</code>  <code>instance-attribute</code>","text":"<p>The requested power in watts.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.request.Request.request_timeout_sec","title":"<code>request_timeout_sec: float = 5.0</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The maximum amount of time to wait for the request to be fulfilled.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Result","title":"<code>frequenz.sdk.actor.power_distributing.Result</code>  <code>dataclass</code>","text":"<p>         Bases: <code>_BaseResultMixin</code></p> <p>Power distribution result.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Result(_BaseResultMixin):\n\"\"\"Power distribution result.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/#frequenz.sdk.actor.power_distributing.Success","title":"<code>frequenz.sdk.actor.power_distributing.Success</code>  <code>dataclass</code>","text":"<p>         Bases: <code>_BaseSuccessMixin</code>, <code>Result</code></p> <p>Result returned when setting the power succeeded for all batteries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Success(_BaseSuccessMixin, Result):  # Order matters here. See above.\n\"\"\"Result returned when setting the power succeeded for all batteries.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/","title":"power_distributing","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing","title":"<code>frequenz.sdk.actor.power_distributing.power_distributing</code>","text":"<p>Actor to distribute power between batteries.</p> <p>When charge/discharge method is called the power should be distributed so that the SoC in batteries stays at the same level. That way of distribution prevents using only one battery, increasing temperature, and maximize the total amount power to charge/discharge.</p> <p>Purpose of this actor is to keep SoC level of each component at the equal level.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor","title":"<code>frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor</code>","text":"<p>Actor to distribute the power between batteries in a microgrid.</p> <p>The purpose of this tool is to keep an equal SoC level in all batteries. The PowerDistributingActor can have many concurrent users which at this time need to be known at construction time.</p> <p>For each user a bidirectional channel needs to be created through which they can send and receive requests and responses.</p> <p>It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if the processing function fails then the response will never come. The timeout should be Result:request_timeout_sec + time for processing the request.</p> <p>Edge cases: * If there are 2 requests to be processed for the same subset of batteries, then only the latest request will be processed. Older request will be ignored. User with older request will get response with Result.Status.IGNORED.</p> <ul> <li>If there are 2 requests and their subset of batteries is different but they overlap (they have at least one common battery), then then both batteries will be processed. However it is not expected so the proper error log will be printed.</li> </ul> Example <pre><code>from frequenz.sdk import microgrid\nfrom frequenz.sdk.microgrid.component import ComponentCategory\nfrom frequenz.sdk.actor import ResamplerConfig\nfrom frequenz.sdk.actor.power_distributing import (\n    PowerDistributingActor,\n    Request,\n    Result,\n    Success,\n    Error,\n    PartialFailure,\n    Ignored,\n)\nfrom frequenz.channels import Broadcast, Receiver, Sender\nfrom datetime import timedelta\nfrom frequenz.sdk import actor\n\nHOST = \"localhost\"\nPORT = 50051\n\nawait microgrid.initialize(\n    HOST,\n    PORT,\n    ResamplerConfig(resampling_period=timedelta(seconds=1))\n)\n\ngraph = microgrid.connection_manager.get().component_graph\n\nbatteries = graph.components(component_category={ComponentCategory.BATTERY})\nbatteries_ids = {c.component_id for c in batteries}\n\nbattery_status_channel = Broadcast[BatteryStatus](\"battery-status\")\n\nchannel = Broadcast[Request](\"power_distributor\")\nchannel_registry = ChannelRegistry(name=\"power_distributor\")\npower_distributor = PowerDistributingActor(\n    requests_receiver=channel.new_receiver(),\n    channel_registry=channel_registry,\n    battery_status_sender=battery_status_channel.new_sender(),\n)\n\nsender = channel.new_sender()\nnamespace: str = \"namespace\"\n# Set power 1200W to given batteries.\nrequest = Request(\n    namespace=namespace,\n    power=1200.0,\n    batteries=batteries_ids,\n    request_timeout_sec=10.0\n)\nawait sender.send(request)\nresult_rx = channel_registry.new_receiver(namespace)\n\n# It is recommended to use timeout when waiting for the response!\nresult: Result = await asyncio.wait_for(result_rx.receive(), timeout=10)\n\nif isinstance(result, Success):\n    print(\"Command succeed\")\nelif isinstance(result, PartialFailure):\n    print(\n        f\"Batteries {result.failed_batteries} failed, total failed power\"                 f\"{result.failed_power}\"\n    )\nelif isinstance(result, Ignored):\n    print(\"Request was ignored, because of newer request\")\nelif isinstance(result, Error):\n    print(f\"Request failed with error: {result.msg}\")\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>@actor\nclass PowerDistributingActor:\n    # pylint: disable=too-many-instance-attributes\n\"\"\"Actor to distribute the power between batteries in a microgrid.\n\n    The purpose of this tool is to keep an equal SoC level in all batteries.\n    The PowerDistributingActor can have many concurrent users which at this time\n    need to be known at construction time.\n\n    For each user a bidirectional channel needs to be created through which\n    they can send and receive requests and responses.\n\n    It is recommended to wait for PowerDistributingActor output with timeout. Otherwise if\n    the processing function fails then the response will never come.\n    The timeout should be Result:request_timeout_sec + time for processing the request.\n\n    Edge cases:\n    * If there are 2 requests to be processed for the same subset of batteries, then\n    only the latest request will be processed. Older request will be ignored. User with\n    older request will get response with Result.Status.IGNORED.\n\n    * If there are 2 requests and their subset of batteries is different but they\n    overlap (they have at least one common battery), then then both batteries\n    will be processed. However it is not expected so the proper error log will be\n    printed.\n\n    Example:\n        ```python\n        from frequenz.sdk import microgrid\n        from frequenz.sdk.microgrid.component import ComponentCategory\n        from frequenz.sdk.actor import ResamplerConfig\n        from frequenz.sdk.actor.power_distributing import (\n            PowerDistributingActor,\n            Request,\n            Result,\n            Success,\n            Error,\n            PartialFailure,\n            Ignored,\n        )\n        from frequenz.channels import Broadcast, Receiver, Sender\n        from datetime import timedelta\n        from frequenz.sdk import actor\n\n        HOST = \"localhost\"\n        PORT = 50051\n\n        await microgrid.initialize(\n            HOST,\n            PORT,\n            ResamplerConfig(resampling_period=timedelta(seconds=1))\n        )\n\n        graph = microgrid.connection_manager.get().component_graph\n\n        batteries = graph.components(component_category={ComponentCategory.BATTERY})\n        batteries_ids = {c.component_id for c in batteries}\n\n        battery_status_channel = Broadcast[BatteryStatus](\"battery-status\")\n\n        channel = Broadcast[Request](\"power_distributor\")\n        channel_registry = ChannelRegistry(name=\"power_distributor\")\n        power_distributor = PowerDistributingActor(\n            requests_receiver=channel.new_receiver(),\n            channel_registry=channel_registry,\n            battery_status_sender=battery_status_channel.new_sender(),\n        )\n\n        sender = channel.new_sender()\n        namespace: str = \"namespace\"\n        # Set power 1200W to given batteries.\n        request = Request(\n            namespace=namespace,\n            power=1200.0,\n            batteries=batteries_ids,\n            request_timeout_sec=10.0\n        )\n        await sender.send(request)\n        result_rx = channel_registry.new_receiver(namespace)\n\n        # It is recommended to use timeout when waiting for the response!\n        result: Result = await asyncio.wait_for(result_rx.receive(), timeout=10)\n\n        if isinstance(result, Success):\n            print(\"Command succeed\")\n        elif isinstance(result, PartialFailure):\n            print(\n                f\"Batteries {result.failed_batteries} failed, total failed power\" \\\n                f\"{result.failed_power}\"\n            )\n        elif isinstance(result, Ignored):\n            print(\"Request was ignored, because of newer request\")\n        elif isinstance(result, Error):\n            print(f\"Request failed with error: {result.msg}\")\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        requests_receiver: Receiver[Request],\n        channel_registry: ChannelRegistry,\n        battery_status_sender: Sender[BatteryStatus],\n        wait_for_data_sec: float = 2,\n    ) -&gt; None:\n\"\"\"Create class instance.\n\n        Args:\n            requests_receiver: Receiver for receiving power requests from other actors.\n            channel_registry: Channel registry for creating result channels dynamically\n                for each request namespace.\n            battery_status_sender: Channel for sending information which batteries are\n                working.\n            wait_for_data_sec: How long actor should wait before processing first\n                request. It is a time needed to collect first components data.\n        \"\"\"\n        self._requests_receiver = requests_receiver\n        self._channel_registry = channel_registry\n        self._wait_for_data_sec = wait_for_data_sec\n        self._result_senders: Dict[str, Sender[Result]] = {}\n\"\"\"Dictionary of result senders for each request namespace.\n\n        They are for channels owned by the channel registry, we just hold a reference\n        to their senders, for fast access.\n        \"\"\"\n\n        # NOTE: power_distributor_exponent should be received from ConfigManager\n        self.power_distributor_exponent: float = 1.0\n        self.distribution_algorithm = DistributionAlgorithm(\n            self.power_distributor_exponent\n        )\n\n        self._bat_inv_map, self._inv_bat_map = self._get_components_pairs(\n            connection_manager.get().component_graph\n        )\n        self._battery_receivers: Dict[int, Peekable[BatteryData]] = {}\n        self._inverter_receivers: Dict[int, Peekable[InverterData]] = {}\n\n        self._all_battery_status = BatteryPoolStatus(\n            battery_ids=set(self._bat_inv_map.keys()),\n            battery_status_sender=battery_status_sender,\n            max_blocking_duration_sec=30.0,\n            max_data_age_sec=10.0,\n        )\n\n        self._cached_metrics: dict[int, _CacheEntry | None] = {\n            bat_id: None for bat_id, _ in self._bat_inv_map.items()\n        }\n\n    def _get_upper_bound(self, batteries: abc.Set[int], include_broken: bool) -&gt; float:\n\"\"\"Get total upper bound of power to be set for given batteries.\n\n        Note, output of that function doesn't guarantee that this bound will be\n        the same when the request is processed.\n\n        Args:\n            batteries: List of batteries\n            include_broken: whether all batteries in the batteries set in the\n                request must be used regardless the status.\n\n        Returns:\n            Upper bound for `set_power` operation.\n        \"\"\"\n        pairs_data: List[InvBatPair] = self._get_components_data(\n            batteries, include_broken\n        )\n        return sum(\n            min(battery.power_upper_bound, inverter.active_power_upper_bound)\n            for battery, inverter in pairs_data\n        )\n\n    def _get_lower_bound(self, batteries: abc.Set[int], include_broken: bool) -&gt; float:\n\"\"\"Get total lower bound of power to be set for given batteries.\n\n        Note, output of that function doesn't guarantee that this bound will be\n        the same when the request is processed.\n\n        Args:\n            batteries: List of batteries\n            include_broken: whether all batteries in the batteries set in the\n                request must be used regardless the status.\n\n        Returns:\n            Lower bound for `set_power` operation.\n        \"\"\"\n        pairs_data: List[InvBatPair] = self._get_components_data(\n            batteries, include_broken\n        )\n        return sum(\n            max(battery.power_lower_bound, inverter.active_power_lower_bound)\n            for battery, inverter in pairs_data\n        )\n\n    async def _send_result(self, namespace: str, result: Result) -&gt; None:\n\"\"\"Send result to the user.\n\n        Args:\n            namespace: namespace of the sender, to identify the result channel with.\n            result: Result to send out.\n        \"\"\"\n        if not namespace in self._result_senders:\n            self._result_senders[namespace] = self._channel_registry.new_sender(\n                namespace\n            )\n\n        await self._result_senders[namespace].send(result)\n\n    async def run(self) -&gt; None:\n\"\"\"Run actor main function.\n\n        It waits for new requests in task_queue and process it, and send\n        `set_power` request with distributed power.\n        The output of the `set_power` method is processed.\n        Every battery and inverter that failed or didn't respond in time will be marked\n        as broken for some time.\n        \"\"\"\n        await self._create_channels()\n\n        api = connection_manager.get().api_client\n\n        # Wait few seconds to get data from the channels created above.\n        await asyncio.sleep(self._wait_for_data_sec)\n\n        async for request in self._requests_receiver:\n            error = self._check_request(request)\n            if error:\n                await self._send_result(request.namespace, error)\n                continue\n\n            try:\n                pairs_data: List[InvBatPair] = self._get_components_data(\n                    request.batteries, request.include_broken_batteries\n                )\n            except KeyError as err:\n                await self._send_result(\n                    request.namespace, Error(request=request, msg=str(err))\n                )\n                continue\n\n            if not pairs_data and not request.include_broken_batteries:\n                error_msg = f\"No data for the given batteries {str(request.batteries)}\"\n                await self._send_result(\n                    request.namespace, Error(request=request, msg=str(error_msg))\n                )\n                continue\n\n            try:\n                distribution = self._get_power_distribution(request, pairs_data)\n            except ValueError as err:\n                error_msg = f\"Couldn't distribute power, error: {str(err)}\"\n                await self._send_result(\n                    request.namespace, Error(request=request, msg=str(error_msg))\n                )\n                continue\n\n            distributed_power_value = request.power - distribution.remaining_power\n            battery_distribution = {\n                self._inv_bat_map[bat_id]: dist\n                for bat_id, dist in distribution.distribution.items()\n            }\n            _logger.debug(\n                \"Distributing power %d between the batteries %s\",\n                distributed_power_value,\n                str(battery_distribution),\n            )\n\n            failed_power, failed_batteries = await self._set_distributed_power(\n                api, distribution, request.request_timeout_sec\n            )\n\n            response: Success | PartialFailure\n            if len(failed_batteries) &gt; 0:\n                succeed_batteries = set(battery_distribution.keys()) - failed_batteries\n                response = PartialFailure(\n                    request=request,\n                    succeeded_power=distributed_power_value,\n                    succeeded_batteries=succeed_batteries,\n                    failed_power=failed_power,\n                    failed_batteries=failed_batteries,\n                    excess_power=distribution.remaining_power,\n                )\n            else:\n                succeed_batteries = set(battery_distribution.keys())\n                response = Success(\n                    request=request,\n                    succeeded_power=distributed_power_value,\n                    succeeded_batteries=succeed_batteries,\n                    excess_power=distribution.remaining_power,\n                )\n\n            asyncio.gather(\n                *[\n                    self._all_battery_status.update_status(\n                        succeed_batteries, failed_batteries\n                    ),\n                    self._send_result(request.namespace, response),\n                ]\n            )\n\n    async def _set_distributed_power(\n        self,\n        api: MicrogridApiClient,\n        distribution: DistributionResult,\n        timeout_sec: float,\n    ) -&gt; Tuple[float, Set[int]]:\n\"\"\"Send distributed power to the inverters.\n\n        Args:\n            api: Microgrid api client\n            distribution: Distribution result\n            timeout_sec: How long wait for the response\n\n        Returns:\n            Tuple where first element is total failed power, and the second element\n            set of batteries that failed.\n        \"\"\"\n        tasks = {\n            inverter_id: asyncio.create_task(api.set_power(inverter_id, power))\n            for inverter_id, power in distribution.distribution.items()\n        }\n\n        _, pending = await asyncio.wait(\n            tasks.values(),\n            timeout=timeout_sec,\n            return_when=ALL_COMPLETED,\n        )\n\n        await self._cancel_tasks(pending)\n\n        return self._parse_result(tasks, distribution.distribution, timeout_sec)\n\n    def _get_power_distribution(\n        self, request: Request, inv_bat_pairs: List[InvBatPair]\n    ) -&gt; DistributionResult:\n\"\"\"Get power distribution result for the batteries in the request.\n\n        Args:\n            request: the power request to process.\n            inv_bat_pairs: the battery and adjacent inverter data pairs.\n\n        Returns:\n            the power distribution result.\n        \"\"\"\n        available_bat_ids = {battery.component_id for battery, _ in inv_bat_pairs}\n        unavailable_bat_ids = request.batteries - available_bat_ids\n        unavailable_inv_ids = {\n            self._bat_inv_map[battery_id] for battery_id in unavailable_bat_ids\n        }\n\n        if request.include_broken_batteries and not available_bat_ids:\n            return self.distribution_algorithm.distribute_power_equally(\n                request.power, unavailable_inv_ids\n            )\n\n        result = self.distribution_algorithm.distribute_power(\n            request.power, inv_bat_pairs\n        )\n\n        if request.include_broken_batteries and unavailable_inv_ids:\n            additional_result = self.distribution_algorithm.distribute_power_equally(\n                result.remaining_power, unavailable_inv_ids\n            )\n\n            for inv_id, power in additional_result.distribution.items():\n                result.distribution[inv_id] = power\n            result.remaining_power = 0.0\n\n        return result\n\n    def _check_request(self, request: Request) -&gt; Optional[Result]:\n\"\"\"Check whether the given request if correct.\n\n        Args:\n            request: request to check\n\n        Returns:\n            Result for the user if the request is wrong, None otherwise.\n        \"\"\"\n        if not request.batteries:\n            return Error(request=request, msg=\"Empty battery IDs in the request\")\n\n        for battery in request.batteries:\n            if battery not in self._battery_receivers:\n                msg = (\n                    f\"No battery {battery}, available batteries: \"\n                    f\"{list(self._battery_receivers.keys())}\"\n                )\n                return Error(request=request, msg=msg)\n\n        if not request.adjust_power:\n            if request.power &lt; 0:\n                bound = self._get_lower_bound(\n                    request.batteries, request.include_broken_batteries\n                )\n                if request.power &lt; bound:\n                    return OutOfBound(request=request, bound=bound)\n            else:\n                bound = self._get_upper_bound(\n                    request.batteries, request.include_broken_batteries\n                )\n                if request.power &gt; bound:\n                    return OutOfBound(request=request, bound=bound)\n\n        return None\n\n    def _get_components_pairs(\n        self, component_graph: ComponentGraph\n    ) -&gt; Tuple[Dict[int, int], Dict[int, int]]:\n\"\"\"Create maps between battery and adjacent inverter.\n\n        Args:\n            component_graph: component graph\n\n        Returns:\n            Tuple where first element is map between battery and adjacent inverter,\n                second element of the tuple is map between inverter and adjacent\n                battery.\n        \"\"\"\n        bat_inv_map: Dict[int, int] = {}\n        inv_bat_map: Dict[int, int] = {}\n\n        batteries: Iterable[Component] = component_graph.components(\n            component_category={ComponentCategory.BATTERY}\n        )\n\n        for battery in batteries:\n            inverters: List[Component] = [\n                component\n                for component in component_graph.predecessors(battery.component_id)\n                if component.category == ComponentCategory.INVERTER\n            ]\n\n            if len(inverters) == 0:\n                _logger.error(\"No inverters for battery %d\", battery.component_id)\n                continue\n\n            if len(inverters) &gt; 1:\n                _logger.error(\n                    \"Battery %d has more then one inverter. It is not supported now.\",\n                    battery.component_id,\n                )\n\n            bat_inv_map[battery.component_id] = inverters[0].component_id\n            inv_bat_map[inverters[0].component_id] = battery.component_id\n\n        return bat_inv_map, inv_bat_map\n\n    def _get_components_data(\n        self, batteries: abc.Set[int], include_broken: bool\n    ) -&gt; List[InvBatPair]:\n\"\"\"Get data for the given batteries and adjacent inverters.\n\n        Args:\n            batteries: Batteries that needs data.\n            include_broken: whether all batteries in the batteries set in the\n                request must be used regardless the status.\n\n        Raises:\n            KeyError: If any battery in the given list doesn't exists in microgrid.\n\n        Returns:\n            Pairs of battery and adjacent inverter data.\n        \"\"\"\n        pairs_data: List[InvBatPair] = []\n        working_batteries = (\n            batteries\n            if include_broken\n            else self._all_battery_status.get_working_batteries(batteries)\n        )\n\n        for battery_id in working_batteries:\n            if battery_id not in self._battery_receivers:\n                raise KeyError(\n                    f\"No battery {battery_id}, \"\n                    f\"available batteries: {list(self._battery_receivers.keys())}\"\n                )\n\n            inverter_id: int = self._bat_inv_map[battery_id]\n\n            data = self._get_battery_inverter_data(battery_id, inverter_id)\n            if not data and include_broken:\n                cached_entry = self._cached_metrics[battery_id]\n                if cached_entry and not cached_entry.has_expired():\n                    data = cached_entry.inv_bat_pair\n                else:\n                    data = None\n            if data is None:\n                _logger.warning(\n                    \"Skipping battery %d because its message isn't correct.\",\n                    battery_id,\n                )\n                continue\n\n            pairs_data.append(data)\n        return pairs_data\n\n    def _get_battery_inverter_data(\n        self, battery_id: int, inverter_id: int\n    ) -&gt; Optional[InvBatPair]:\n\"\"\"Get battery and inverter data if they are correct.\n\n        Each float data from the microgrid can be \"NaN\".\n        We can't do math operations on \"NaN\".\n        So check all the metrics and:\n        * if power bounds are NaN, then try to replace it with the corresponding\n          power bounds from the adjacent component. If metric in the adjacent component\n          is also NaN, then return None.\n        * if other metrics are NaN then return None. We can't assume anything for other\n          metrics.\n\n        Args:\n            battery_id: battery id\n            inverter_id: inverter id\n\n        Returns:\n            Data for the battery and adjacent inverter without NaN values.\n                Return None if we could not replace NaN values.\n        \"\"\"\n        battery_data = self._battery_receivers[battery_id].peek()\n        inverter_data = self._inverter_receivers[inverter_id].peek()\n\n        # It means that nothing has been send on this channels, yet.\n        # This should be handled by BatteryStatus. BatteryStatus should not return\n        # this batteries as working.\n        if battery_data is None or inverter_data is None:\n            _logger.error(\n                \"Battery %d or inverter %d send no data, yet. They should be not used.\",\n                battery_id,\n                inverter_id,\n            )\n            return None\n\n        not_replaceable_metrics = [\n            battery_data.soc,\n            battery_data.soc_lower_bound,\n            battery_data.soc_upper_bound,\n            # We could replace capacity with 0, but it won't change distribution.\n            # This battery will be ignored in distribution anyway.\n            battery_data.capacity,\n        ]\n        if any(map(isnan, not_replaceable_metrics)):\n            _logger.debug(\"Some metrics for battery %d are NaN\", battery_id)\n            return None\n\n        replaceable_metrics = [\n            battery_data.power_lower_bound,\n            battery_data.power_upper_bound,\n            inverter_data.active_power_lower_bound,\n            inverter_data.active_power_upper_bound,\n        ]\n\n        # If all values are ok then return them.\n        if not any(map(isnan, replaceable_metrics)):\n            inv_bat_pair = InvBatPair(battery_data, inverter_data)\n            self._cached_metrics[battery_id] = _CacheEntry.from_ttl(inv_bat_pair)\n            return inv_bat_pair\n\n        # Replace NaN with the corresponding value in the adjacent component.\n        # If both metrics are None, return None to ignore this battery.\n        replaceable_pairs = [\n            (\"power_lower_bound\", \"active_power_lower_bound\"),\n            (\"power_upper_bound\", \"active_power_upper_bound\"),\n        ]\n\n        battery_new_metrics = {}\n        inverter_new_metrics = {}\n        for bat_attr, inv_attr in replaceable_pairs:\n            bat_bound = getattr(battery_data, bat_attr)\n            inv_bound = getattr(inverter_data, inv_attr)\n            if isnan(bat_bound) and isnan(inv_bound):\n                _logger.debug(\"Some metrics for battery %d are NaN\", battery_id)\n                return None\n            if isnan(bat_bound):\n                battery_new_metrics[bat_attr] = inv_bound\n            elif isnan(inv_bound):\n                inverter_new_metrics[inv_attr] = bat_bound\n\n        inv_bat_pair = InvBatPair(\n            replace(battery_data, **battery_new_metrics),\n            replace(inverter_data, **inverter_new_metrics),\n        )\n        self._cached_metrics[battery_id] = _CacheEntry.from_ttl(inv_bat_pair)\n        return inv_bat_pair\n\n    async def _create_channels(self) -&gt; None:\n\"\"\"Create channels to get data of components in microgrid.\"\"\"\n        api = connection_manager.get().api_client\n        for battery_id, inverter_id in self._bat_inv_map.items():\n            bat_recv: Receiver[BatteryData] = await api.battery_data(battery_id)\n            self._battery_receivers[battery_id] = bat_recv.into_peekable()\n\n            inv_recv: Receiver[InverterData] = await api.inverter_data(inverter_id)\n            self._inverter_receivers[inverter_id] = inv_recv.into_peekable()\n\n    def _parse_result(\n        self,\n        # type comment to quiet pylint and mypy `unused-import` error\n        tasks,  # type: Dict[int, asyncio.Task[Empty]]\n        distribution: Dict[int, float],\n        request_timeout_sec: float,\n    ) -&gt; Tuple[float, Set[int]]:\n\"\"\"Parse the results of `set_power` requests.\n\n        Check if any task has failed and determine the reason for failure.\n        If any task did not succeed, then the corresponding battery is marked as broken.\n\n        Args:\n            tasks: A dictionary where the key is the inverter ID and the value is the task that\n                set the power for this inverter. Each task should be finished or cancelled.\n            distribution: A dictionary where the key is the inverter ID and the value is how much\n                power was set to the corresponding inverter.\n            request_timeout_sec: The timeout that was used for the request.\n\n        Returns:\n            A tuple where the first element is the total failed power, and the second element is\n            the set of batteries that failed.\n        \"\"\"\n        failed_power: float = 0.0\n        failed_batteries: Set[int] = set()\n\n        for inverter_id, aws in tasks.items():\n            battery_id = self._inv_bat_map[inverter_id]\n            try:\n                aws.result()\n            except grpc.aio.AioRpcError as err:\n                failed_power += distribution[inverter_id]\n                failed_batteries.add(battery_id)\n                if err.code() == grpc.StatusCode.OUT_OF_RANGE:\n                    _logger.debug(\n                        \"Set power for battery %d failed, error %s\",\n                        battery_id,\n                        str(err),\n                    )\n                else:\n                    _logger.warning(\n                        \"Set power for battery %d failed, error %s. Mark it as broken.\",\n                        battery_id,\n                        str(err),\n                    )\n            except asyncio.exceptions.CancelledError:\n                failed_power += distribution[inverter_id]\n                failed_batteries.add(battery_id)\n                _logger.warning(\n                    \"Battery %d didn't respond in %f sec. Mark it as broken.\",\n                    battery_id,\n                    request_timeout_sec,\n                )\n\n        return failed_power, failed_batteries\n\n    async def _cancel_tasks(self, tasks: Iterable[asyncio.Task[Any]]) -&gt; None:\n\"\"\"Cancel given asyncio tasks and wait for them.\n\n        Args:\n            tasks: tasks to cancel.\n        \"\"\"\n        for aws in tasks:\n            aws.cancel()\n\n        await asyncio.gather(*tasks, return_exceptions=True)\n\n    async def _stop_actor(self) -&gt; None:\n\"\"\"Stop all running async tasks.\"\"\"\n        await self._all_battery_status.stop()\n        await self._stop()  # type: ignore # pylint: disable=no-member\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.__init__","title":"<code>__init__(requests_receiver, channel_registry, battery_status_sender, wait_for_data_sec=2)</code>","text":"<p>Create class instance.</p> PARAMETER DESCRIPTION <code>requests_receiver</code> <p>Receiver for receiving power requests from other actors.</p> <p> TYPE: <code>Receiver[Request]</code> </p> <code>channel_registry</code> <p>Channel registry for creating result channels dynamically for each request namespace.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>battery_status_sender</code> <p>Channel for sending information which batteries are working.</p> <p> TYPE: <code>Sender[BatteryStatus]</code> </p> <code>wait_for_data_sec</code> <p>How long actor should wait before processing first request. It is a time needed to collect first components data.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>def __init__(\n    self,\n    requests_receiver: Receiver[Request],\n    channel_registry: ChannelRegistry,\n    battery_status_sender: Sender[BatteryStatus],\n    wait_for_data_sec: float = 2,\n) -&gt; None:\n\"\"\"Create class instance.\n\n    Args:\n        requests_receiver: Receiver for receiving power requests from other actors.\n        channel_registry: Channel registry for creating result channels dynamically\n            for each request namespace.\n        battery_status_sender: Channel for sending information which batteries are\n            working.\n        wait_for_data_sec: How long actor should wait before processing first\n            request. It is a time needed to collect first components data.\n    \"\"\"\n    self._requests_receiver = requests_receiver\n    self._channel_registry = channel_registry\n    self._wait_for_data_sec = wait_for_data_sec\n    self._result_senders: Dict[str, Sender[Result]] = {}\n\"\"\"Dictionary of result senders for each request namespace.\n\n    They are for channels owned by the channel registry, we just hold a reference\n    to their senders, for fast access.\n    \"\"\"\n\n    # NOTE: power_distributor_exponent should be received from ConfigManager\n    self.power_distributor_exponent: float = 1.0\n    self.distribution_algorithm = DistributionAlgorithm(\n        self.power_distributor_exponent\n    )\n\n    self._bat_inv_map, self._inv_bat_map = self._get_components_pairs(\n        connection_manager.get().component_graph\n    )\n    self._battery_receivers: Dict[int, Peekable[BatteryData]] = {}\n    self._inverter_receivers: Dict[int, Peekable[InverterData]] = {}\n\n    self._all_battery_status = BatteryPoolStatus(\n        battery_ids=set(self._bat_inv_map.keys()),\n        battery_status_sender=battery_status_sender,\n        max_blocking_duration_sec=30.0,\n        max_data_age_sec=10.0,\n    )\n\n    self._cached_metrics: dict[int, _CacheEntry | None] = {\n        bat_id: None for bat_id, _ in self._bat_inv_map.items()\n    }\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing.PowerDistributingActor.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Run actor main function.</p> <p>It waits for new requests in task_queue and process it, and send <code>set_power</code> request with distributed power. The output of the <code>set_power</code> method is processed. Every battery and inverter that failed or didn't respond in time will be marked as broken for some time.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/power_distributing.py</code> <pre><code>async def run(self) -&gt; None:\n\"\"\"Run actor main function.\n\n    It waits for new requests in task_queue and process it, and send\n    `set_power` request with distributed power.\n    The output of the `set_power` method is processed.\n    Every battery and inverter that failed or didn't respond in time will be marked\n    as broken for some time.\n    \"\"\"\n    await self._create_channels()\n\n    api = connection_manager.get().api_client\n\n    # Wait few seconds to get data from the channels created above.\n    await asyncio.sleep(self._wait_for_data_sec)\n\n    async for request in self._requests_receiver:\n        error = self._check_request(request)\n        if error:\n            await self._send_result(request.namespace, error)\n            continue\n\n        try:\n            pairs_data: List[InvBatPair] = self._get_components_data(\n                request.batteries, request.include_broken_batteries\n            )\n        except KeyError as err:\n            await self._send_result(\n                request.namespace, Error(request=request, msg=str(err))\n            )\n            continue\n\n        if not pairs_data and not request.include_broken_batteries:\n            error_msg = f\"No data for the given batteries {str(request.batteries)}\"\n            await self._send_result(\n                request.namespace, Error(request=request, msg=str(error_msg))\n            )\n            continue\n\n        try:\n            distribution = self._get_power_distribution(request, pairs_data)\n        except ValueError as err:\n            error_msg = f\"Couldn't distribute power, error: {str(err)}\"\n            await self._send_result(\n                request.namespace, Error(request=request, msg=str(error_msg))\n            )\n            continue\n\n        distributed_power_value = request.power - distribution.remaining_power\n        battery_distribution = {\n            self._inv_bat_map[bat_id]: dist\n            for bat_id, dist in distribution.distribution.items()\n        }\n        _logger.debug(\n            \"Distributing power %d between the batteries %s\",\n            distributed_power_value,\n            str(battery_distribution),\n        )\n\n        failed_power, failed_batteries = await self._set_distributed_power(\n            api, distribution, request.request_timeout_sec\n        )\n\n        response: Success | PartialFailure\n        if len(failed_batteries) &gt; 0:\n            succeed_batteries = set(battery_distribution.keys()) - failed_batteries\n            response = PartialFailure(\n                request=request,\n                succeeded_power=distributed_power_value,\n                succeeded_batteries=succeed_batteries,\n                failed_power=failed_power,\n                failed_batteries=failed_batteries,\n                excess_power=distribution.remaining_power,\n            )\n        else:\n            succeed_batteries = set(battery_distribution.keys())\n            response = Success(\n                request=request,\n                succeeded_power=distributed_power_value,\n                succeeded_batteries=succeed_batteries,\n                excess_power=distribution.remaining_power,\n            )\n\n        asyncio.gather(\n            *[\n                self._all_battery_status.update_status(\n                    succeed_batteries, failed_batteries\n                ),\n                self._send_result(request.namespace, response),\n            ]\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/power_distributing/#frequenz.sdk.actor.power_distributing.power_distributing-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/","title":"request","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request","title":"<code>frequenz.sdk.actor.power_distributing.request</code>","text":"<p>Definition of the user request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request","title":"<code>frequenz.sdk.actor.power_distributing.request.Request</code>  <code>dataclass</code>","text":"<p>Request to set power to the <code>PowerDistributingActor</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/request.py</code> <pre><code>@dataclasses.dataclass\nclass Request:\n\"\"\"Request to set power to the `PowerDistributingActor`.\"\"\"\n\n    namespace: str\n\"\"\"The namespace of the request.\n\n    This will be used to identify the channel for sending the response into, in the\n    channel registry.\n    \"\"\"\n\n    power: float\n\"\"\"The requested power in watts.\"\"\"\n\n    batteries: abc.Set[int]\n\"\"\"The component ids of the batteries to be used for this request.\"\"\"\n\n    request_timeout_sec: float = 5.0\n\"\"\"The maximum amount of time to wait for the request to be fulfilled.\"\"\"\n\n    adjust_power: bool = True\n\"\"\"Whether to adjust the power to match the bounds.\n\n    If `True`, the power will be adjusted (lowered) to match the bounds, so\n    only the reduced power will be set.\n\n    If `False` and the power is outside the batteries' bounds, the request will\n    fail and be replied to with an `OutOfBound` result.\n    \"\"\"\n\n    include_broken_batteries: bool = False\n\"\"\"Whether to use all batteries included in the batteries set regardless the status.\n\n    If set to `True`, the power distribution algorithm will consider all batteries,\n    including the broken ones, when distributing power.  In such cases, any remaining\n    power after distributing among the available batteries will be distributed equally\n    among the unavailable (broken) batteries.  If all batteries in the set are\n    unavailable, the power will be equally distributed among all the unavailable\n    batteries in the request.\n\n    If set to `False`, the power distribution will only take into account the available\n    batteries, excluding any broken ones.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.adjust_power","title":"<code>adjust_power: bool = True</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Whether to adjust the power to match the bounds.</p> <p>If <code>True</code>, the power will be adjusted (lowered) to match the bounds, so only the reduced power will be set.</p> <p>If <code>False</code> and the power is outside the batteries' bounds, the request will fail and be replied to with an <code>OutOfBound</code> result.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.batteries","title":"<code>batteries: abc.Set[int]</code>  <code>instance-attribute</code>","text":"<p>The component ids of the batteries to be used for this request.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.include_broken_batteries","title":"<code>include_broken_batteries: bool = False</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Whether to use all batteries included in the batteries set regardless the status.</p> <p>If set to <code>True</code>, the power distribution algorithm will consider all batteries, including the broken ones, when distributing power.  In such cases, any remaining power after distributing among the available batteries will be distributed equally among the unavailable (broken) batteries.  If all batteries in the set are unavailable, the power will be equally distributed among all the unavailable batteries in the request.</p> <p>If set to <code>False</code>, the power distribution will only take into account the available batteries, excluding any broken ones.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.namespace","title":"<code>namespace: str</code>  <code>instance-attribute</code>","text":"<p>The namespace of the request.</p> <p>This will be used to identify the channel for sending the response into, in the channel registry.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.power","title":"<code>power: float</code>  <code>instance-attribute</code>","text":"<p>The requested power in watts.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/request/#frequenz.sdk.actor.power_distributing.request.Request.request_timeout_sec","title":"<code>request_timeout_sec: float = 5.0</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The maximum amount of time to wait for the request to be fulfilled.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/","title":"result","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result","title":"<code>frequenz.sdk.actor.power_distributing.result</code>","text":"<p>Results from PowerDistributingActor.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error","title":"<code>frequenz.sdk.actor.power_distributing.result.Error</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Result</code></p> <p>Result returned when an error occurred and power was not set at all.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Error(Result):\n\"\"\"Result returned when an error occurred and power was not set at all.\"\"\"\n\n    msg: str\n\"\"\"The error message explaining why error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Error.msg","title":"<code>msg: str</code>  <code>instance-attribute</code>","text":"<p>The error message explaining why error happened.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBound","title":"<code>frequenz.sdk.actor.power_distributing.result.OutOfBound</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Result</code></p> <p>Result returned when the power was not set because it was out of bounds.</p> <p>This result happens when the originating request was done with <code>adjust_power = False</code> and the requested power is not within the batteries bounds.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass OutOfBound(Result):\n\"\"\"Result returned when the power was not set because it was out of bounds.\n\n    This result happens when the originating request was done with\n    `adjust_power = False` and the requested power is not within the batteries bounds.\n    \"\"\"\n\n    bound: float\n\"\"\"The total power bound for the requested batteries.\n\n    If the requested power negative, then this value is the lower bound.\n    Otherwise it is upper bound.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBound-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.OutOfBound.bound","title":"<code>bound: float</code>  <code>instance-attribute</code>","text":"<p>The total power bound for the requested batteries.</p> <p>If the requested power negative, then this value is the lower bound. Otherwise it is upper bound.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure","title":"<code>frequenz.sdk.actor.power_distributing.result.PartialFailure</code>  <code>dataclass</code>","text":"<p>         Bases: <code>_BaseSuccessMixin</code>, <code>Result</code></p> <p>Result returned when any battery failed to perform the request.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass PartialFailure(_BaseSuccessMixin, Result):\n\"\"\"Result returned when any battery failed to perform the request.\"\"\"\n\n    failed_power: float\n\"\"\"The part of the requested power that failed to be set.\"\"\"\n\n    failed_batteries: set[int]\n\"\"\"The subset of batteries for which the request failed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_batteries","title":"<code>failed_batteries: set[int]</code>  <code>instance-attribute</code>","text":"<p>The subset of batteries for which the request failed.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.PartialFailure.failed_power","title":"<code>failed_power: float</code>  <code>instance-attribute</code>","text":"<p>The part of the requested power that failed to be set.</p>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Result","title":"<code>frequenz.sdk.actor.power_distributing.result.Result</code>  <code>dataclass</code>","text":"<p>         Bases: <code>_BaseResultMixin</code></p> <p>Power distribution result.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Result(_BaseResultMixin):\n\"\"\"Power distribution result.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/actor/power_distributing/result/#frequenz.sdk.actor.power_distributing.result.Success","title":"<code>frequenz.sdk.actor.power_distributing.result.Success</code>  <code>dataclass</code>","text":"<p>         Bases: <code>_BaseSuccessMixin</code>, <code>Result</code></p> <p>Result returned when setting the power succeeded for all batteries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/actor/power_distributing/result.py</code> <pre><code>@dataclasses.dataclass\nclass Success(_BaseSuccessMixin, Result):  # Order matters here. See above.\n\"\"\"Result returned when setting the power succeeded for all batteries.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/config/","title":"config","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config","title":"<code>frequenz.sdk.config</code>","text":"<p>Config interface.</p>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config","title":"<code>frequenz.sdk.config.Config</code>","text":"<p>Stores config variables.</p> <p>Config variables are read from a file. Only single file can be read. If new file is read, then previous configs will be forgotten.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>class Config:\n\"\"\"\n    Stores config variables.\n\n    Config variables are read from a file.\n    Only single file can be read.\n    If new file is read, then previous configs will be forgotten.\n    \"\"\"\n\n    def __init__(self, conf_vars: Dict[str, Any]):\n\"\"\"Instantiate the config store and read config variables from the file.\n\n        Args:\n            conf_vars: Dict containing configuration variables\n        \"\"\"\n        self._conf_store: Dict[str, Any] = conf_vars\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n\"\"\"Get the value for the specified key.\n\n        If the key is not in the configs, then return default.\n\n        Args:\n            key: Key to be searched.\n            default: Value to be returned if the key is not found.  Defaults to\n                None.\n\n        Returns:\n            value in str format or default.\n        \"\"\"\n        return self._conf_store.get(key, default)\n\n    def get_dict(\n        self, key_prefix: str, expected_values_type: Optional[T]\n    ) -&gt; Dict[str, Any]:\n\"\"\"Get a dictionary based on config key prefixes.\n\n        For example, if key_prefix is \"my_dict\", then the following config store:\n            {\n                'some_key': 'some_value',\n                'my_dict_key1': 'value1',\n                'my_dict_key2': 'value2',\n            }\n        Will return:\n            {\n                'key1': 'value1',\n                'key2': 'value2',\n            }\n\n        Args:\n            key_prefix: Only get configuration variables starting with this\n                prefix.\n            expected_values_type: If provided, the value will be validated against\n                this type.\n\n        Returns:\n            A dictionary containing the keys prefixed with `key_prefix` as keys\n                (but with the prefix removed) and the values as values.\n        \"\"\"\n        result: Dict[str, Any] = {}\n        for key, value in self._conf_store.items():\n            if key.startswith(key_prefix):\n                new_key = key[len(key_prefix) :]\n                if expected_values_type is not None:\n                    value = self.get_as(key, expected_values_type)\n                result[new_key] = value\n        return result\n\n    def get_as(self, key: str, expected_type: Any) -&gt; Any:\n\"\"\"Get and convert the value to specified type.\n\n        Check if type of the value is as expected.  If type is correct, then\n        return converted value.  Otherwise Raise ValueError.\n\n        Type can be:\n            * Any typing module type.\n            * Any pydantic strict types (e.g. pydantic.StrictInt)\n\n        Args:\n            key: Key to be search\n            expected_type: type for the value\n\n        Raises:\n            ValueError: If can't convert value to the expected type.\n            KeyError: If specified key is not in config.\n\n        Returns:\n            Value for the specified key, converted to specified type.\n\n        Example:\n            For `var1='[1, 2.0, 3.5]'`:\n                * `get_as(\"var1\", List[int])` -&gt; `[1,2,3]`\n                * `get_as(\"var1\", List[float])` -&gt; `[1.0,2.0,3.5]`\n                * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; [ValueError][]\n                * `get_as(\"var1\", List[pydantic.StrictFloat])` -&gt; [ValueError][]\n\n            For `var1='[1,2,3]'`:\n                * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; `[1,2,3]`\n\n        \"\"\"\n        value = self[key]\n\n        if str is expected_type:\n            return value\n\n        try:\n            parsed_value: Any = parse_raw_as(expected_type, value)\n        except (ValidationError, ValueError) as err:\n            raise ValueError(\n                f\"Could not convert config variable: {key} = '{value}' \"\n                f\"to type {str(expected_type)}, err:\" + str(err)\n            ) from err\n\n        return parsed_value\n\n    def __getitem__(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified key.\n\n        If the key is not in the configs, then raise KeyError.\n\n        Args:\n            key: key to be searched.\n\n        Raises:\n            KeyError: If key is not in found.\n\n        Returns:\n            Dictionary if the corresponding value is a subsection in the .toml\n                file or a primitive type it is a simple value.\n        \"\"\"\n        value = self._conf_store.get(key, None)\n        if value is None:\n            raise KeyError(f\"Unknown config name {key}\")\n\n        return value\n\n    def __contains__(self, key: str) -&gt; bool:\n\"\"\"Return whether the specified key is in the storage.\n\n        Args:\n            key: Config variable name.\n\n        Returns:\n            True if key is in the storage, otherwise returns False.\n        \"\"\"\n        return key in self._conf_store\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config.Config-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Return whether the specified key is in the storage.</p> PARAMETER DESCRIPTION <code>key</code> <p>Config variable name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if key is in the storage, otherwise returns False.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n\"\"\"Return whether the specified key is in the storage.\n\n    Args:\n        key: Config variable name.\n\n    Returns:\n        True if key is in the storage, otherwise returns False.\n    \"\"\"\n    return key in self._conf_store\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get the value for the specified key.</p> <p>If the key is not in the configs, then raise KeyError.</p> PARAMETER DESCRIPTION <code>key</code> <p>key to be searched.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>KeyError</code> <p>If key is not in found.</p> RETURNS DESCRIPTION <code>Any</code> <p>Dictionary if the corresponding value is a subsection in the .toml file or a primitive type it is a simple value.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n\"\"\"Get the value for the specified key.\n\n    If the key is not in the configs, then raise KeyError.\n\n    Args:\n        key: key to be searched.\n\n    Raises:\n        KeyError: If key is not in found.\n\n    Returns:\n        Dictionary if the corresponding value is a subsection in the .toml\n            file or a primitive type it is a simple value.\n    \"\"\"\n    value = self._conf_store.get(key, None)\n    if value is None:\n        raise KeyError(f\"Unknown config name {key}\")\n\n    return value\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.__init__","title":"<code>__init__(conf_vars)</code>","text":"<p>Instantiate the config store and read config variables from the file.</p> PARAMETER DESCRIPTION <code>conf_vars</code> <p>Dict containing configuration variables</p> <p> TYPE: <code>Dict[str, Any]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def __init__(self, conf_vars: Dict[str, Any]):\n\"\"\"Instantiate the config store and read config variables from the file.\n\n    Args:\n        conf_vars: Dict containing configuration variables\n    \"\"\"\n    self._conf_store: Dict[str, Any] = conf_vars\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.get","title":"<code>get(key, default=None)</code>","text":"<p>Get the value for the specified key.</p> <p>If the key is not in the configs, then return default.</p> PARAMETER DESCRIPTION <code>key</code> <p>Key to be searched.</p> <p> TYPE: <code>str</code> </p> <code>default</code> <p>Value to be returned if the key is not found.  Defaults to None.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>value in str format or default.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n\"\"\"Get the value for the specified key.\n\n    If the key is not in the configs, then return default.\n\n    Args:\n        key: Key to be searched.\n        default: Value to be returned if the key is not found.  Defaults to\n            None.\n\n    Returns:\n        value in str format or default.\n    \"\"\"\n    return self._conf_store.get(key, default)\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.get_as","title":"<code>get_as(key, expected_type)</code>","text":"<p>Get and convert the value to specified type.</p> <p>Check if type of the value is as expected.  If type is correct, then return converted value.  Otherwise Raise ValueError.</p> Type can be <ul> <li>Any typing module type.</li> <li>Any pydantic strict types (e.g. pydantic.StrictInt)</li> </ul> PARAMETER DESCRIPTION <code>key</code> <p>Key to be search</p> <p> TYPE: <code>str</code> </p> <code>expected_type</code> <p>type for the value</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If can't convert value to the expected type.</p> <code>KeyError</code> <p>If specified key is not in config.</p> RETURNS DESCRIPTION <code>Any</code> <p>Value for the specified key, converted to specified type.</p> Example <p>For <code>var1='[1, 2.0, 3.5]'</code>:     * <code>get_as(\"var1\", List[int])</code> -&gt; <code>[1,2,3]</code>     * <code>get_as(\"var1\", List[float])</code> -&gt; <code>[1.0,2.0,3.5]</code>     * <code>get_as(\"var1\", List[pydantic.StrictInt])</code> -&gt; ValueError     * <code>get_as(\"var1\", List[pydantic.StrictFloat])</code> -&gt; ValueError</p> <p>For <code>var1='[1,2,3]'</code>:     * <code>get_as(\"var1\", List[pydantic.StrictInt])</code> -&gt; <code>[1,2,3]</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def get_as(self, key: str, expected_type: Any) -&gt; Any:\n\"\"\"Get and convert the value to specified type.\n\n    Check if type of the value is as expected.  If type is correct, then\n    return converted value.  Otherwise Raise ValueError.\n\n    Type can be:\n        * Any typing module type.\n        * Any pydantic strict types (e.g. pydantic.StrictInt)\n\n    Args:\n        key: Key to be search\n        expected_type: type for the value\n\n    Raises:\n        ValueError: If can't convert value to the expected type.\n        KeyError: If specified key is not in config.\n\n    Returns:\n        Value for the specified key, converted to specified type.\n\n    Example:\n        For `var1='[1, 2.0, 3.5]'`:\n            * `get_as(\"var1\", List[int])` -&gt; `[1,2,3]`\n            * `get_as(\"var1\", List[float])` -&gt; `[1.0,2.0,3.5]`\n            * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; [ValueError][]\n            * `get_as(\"var1\", List[pydantic.StrictFloat])` -&gt; [ValueError][]\n\n        For `var1='[1,2,3]'`:\n            * `get_as(\"var1\", List[pydantic.StrictInt])` -&gt; `[1,2,3]`\n\n    \"\"\"\n    value = self[key]\n\n    if str is expected_type:\n        return value\n\n    try:\n        parsed_value: Any = parse_raw_as(expected_type, value)\n    except (ValidationError, ValueError) as err:\n        raise ValueError(\n            f\"Could not convert config variable: {key} = '{value}' \"\n            f\"to type {str(expected_type)}, err:\" + str(err)\n        ) from err\n\n    return parsed_value\n</code></pre>"},{"location":"reference/frequenz/sdk/config/#frequenz.sdk.config._config.Config.get_dict","title":"<code>get_dict(key_prefix, expected_values_type)</code>","text":"<p>Get a dictionary based on config key prefixes.</p> <p>For example, if key_prefix is \"my_dict\", then the following config store:     {         'some_key': 'some_value',         'my_dict_key1': 'value1',         'my_dict_key2': 'value2',     }</p> Will return <p>{     'key1': 'value1',     'key2': 'value2', }</p> PARAMETER DESCRIPTION <code>key_prefix</code> <p>Only get configuration variables starting with this prefix.</p> <p> TYPE: <code>str</code> </p> <code>expected_values_type</code> <p>If provided, the value will be validated against this type.</p> <p> TYPE: <code>Optional[T]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>A dictionary containing the keys prefixed with <code>key_prefix</code> as keys (but with the prefix removed) and the values as values.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/config/_config.py</code> <pre><code>def get_dict(\n    self, key_prefix: str, expected_values_type: Optional[T]\n) -&gt; Dict[str, Any]:\n\"\"\"Get a dictionary based on config key prefixes.\n\n    For example, if key_prefix is \"my_dict\", then the following config store:\n        {\n            'some_key': 'some_value',\n            'my_dict_key1': 'value1',\n            'my_dict_key2': 'value2',\n        }\n    Will return:\n        {\n            'key1': 'value1',\n            'key2': 'value2',\n        }\n\n    Args:\n        key_prefix: Only get configuration variables starting with this\n            prefix.\n        expected_values_type: If provided, the value will be validated against\n            this type.\n\n    Returns:\n        A dictionary containing the keys prefixed with `key_prefix` as keys\n            (but with the prefix removed) and the values as values.\n    \"\"\"\n    result: Dict[str, Any] = {}\n    for key, value in self._conf_store.items():\n        if key.startswith(key_prefix):\n            new_key = key[len(key_prefix) :]\n            if expected_values_type is not None:\n                value = self.get_as(key, expected_values_type)\n            result[new_key] = value\n    return result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/","title":"microgrid","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid","title":"<code>frequenz.sdk.microgrid</code>","text":"<p>Microgrid monitoring and control system.</p> <p>This package provides a complete suite of data structures and functionality for monitoring and adjusting the state of a microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph","title":"<code>frequenz.sdk.microgrid.ComponentGraph</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Interface for component graph implementations.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>class ComponentGraph(ABC):\n\"\"\"Interface for component graph implementations.\"\"\"\n\n    @abstractmethod\n    def components(\n        self,\n        component_id: Optional[Set[int]] = None,\n        component_category: Optional[Set[ComponentCategory]] = None,\n    ) -&gt; Set[Component]:\n\"\"\"Fetch the components of the microgrid.\n\n        Args:\n            component_id: filter out any components not matching one of the provided IDs\n            component_category: filter out any components not matching one of the\n                provided types\n\n        Returns:\n            Set of the components currently connected to the microgrid, filtered by\n                the provided `component_id` and `component_category` values.\n        \"\"\"\n\n    @abstractmethod\n    def connections(\n        self,\n        start: Optional[Set[int]] = None,\n        end: Optional[Set[int]] = None,\n    ) -&gt; Set[Connection]:\n\"\"\"Fetch the connections between microgrid components.\n\n        Args:\n            start: filter out any connections whose `start` does not match one of these\n                component IDs\n            end: filter out any connections whose `end` does not match one of these\n                component IDs\n\n        Returns:\n            Set of the connections between components in the microgrid, filtered by\n                the provided `start`/`end` choices.\n        \"\"\"\n\n    @abstractmethod\n    def predecessors(self, component_id: int) -&gt; Set[Component]:\n\"\"\"Fetch the graph predecessors of the specified component.\n\n        Args:\n            component_id: numerical ID of the component whose predecessors should be\n                fetched\n\n        Returns:\n            Set of IDs of the components that are predecessors of `component_id`,\n                i.e. for which there is a connection from each of these components to\n                `component_id`.\n\n        Raises:\n            KeyError: if the specified `component_id` is not in the graph\n        \"\"\"\n\n    @abstractmethod\n    def successors(self, component_id: int) -&gt; Set[Component]:\n\"\"\"Fetch the graph successors of the specified component.\n\n        Args:\n            component_id: numerical ID of the component whose successors should be\n                fetched\n\n        Returns:\n            Set of IDs of the components that are successors of `component_id`,\n                i.e. for which there is a connection from `component_id` to each of\n                these components.\n\n        Raises:\n            KeyError: if the specified `component_id` is not in the graph\n        \"\"\"\n\n    @abstractmethod\n    def is_pv_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a PV inverter.\n        \"\"\"\n\n    @abstractmethod\n    def is_pv_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV meter.\n\n        This is done by checking if the component has only PV inverters as its\n        successors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a PV meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_pv_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a PV chain.\n\n        A component is part of a PV chain if it is a PV meter or a PV inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of a PV chain.\n        \"\"\"\n\n    @abstractmethod\n    def is_battery_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a battery inverter.\n        \"\"\"\n\n    @abstractmethod\n    def is_battery_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery meter.\n\n        This is done by checking if the component has only battery inverters as its\n        predecessors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a battery meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_battery_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a battery chain.\n\n        A component is part of a battery chain if it is a battery meter or a battery\n        inverter.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of a battery chain.\n        \"\"\"\n\n    @abstractmethod\n    def is_ev_charger(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is an EV charger.\n        \"\"\"\n\n    @abstractmethod\n    def is_ev_charger_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger meter.\n\n        This is done by checking if the component has only EV chargers as its\n        successors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is an EV charger meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_ev_charger_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of an EV charger chain.\n\n        A component is part of an EV charger chain if it is an EV charger meter or an\n        EV charger.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of an EV charger chain.\n        \"\"\"\n\n    @abstractmethod\n    def is_chp(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a CHP.\n        \"\"\"\n\n    @abstractmethod\n    def is_chp_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP meter.\n\n        This is done by checking if the component has only CHPs as its successors.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is a CHP meter.\n        \"\"\"\n\n    @abstractmethod\n    def is_chp_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a CHP chain.\n\n        A component is part of a CHP chain if it is a CHP meter or a CHP.\n\n        Args:\n            component: component to check.\n\n        Returns:\n            Whether the specified component is part of a CHP chain.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ComponentGraph-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.components","title":"<code>components(component_id=None, component_category=None)</code>  <code>abstractmethod</code>","text":"<p>Fetch the components of the microgrid.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>filter out any components not matching one of the provided IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> <code>component_category</code> <p>filter out any components not matching one of the provided types</p> <p> TYPE: <code>Optional[Set[ComponentCategory]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Set[Component]</code> <p>Set of the components currently connected to the microgrid, filtered by the provided <code>component_id</code> and <code>component_category</code> values.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef components(\n    self,\n    component_id: Optional[Set[int]] = None,\n    component_category: Optional[Set[ComponentCategory]] = None,\n) -&gt; Set[Component]:\n\"\"\"Fetch the components of the microgrid.\n\n    Args:\n        component_id: filter out any components not matching one of the provided IDs\n        component_category: filter out any components not matching one of the\n            provided types\n\n    Returns:\n        Set of the components currently connected to the microgrid, filtered by\n            the provided `component_id` and `component_category` values.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.connections","title":"<code>connections(start=None, end=None)</code>  <code>abstractmethod</code>","text":"<p>Fetch the connections between microgrid components.</p> PARAMETER DESCRIPTION <code>start</code> <p>filter out any connections whose <code>start</code> does not match one of these component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> <code>end</code> <p>filter out any connections whose <code>end</code> does not match one of these component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Set[Connection]</code> <p>Set of the connections between components in the microgrid, filtered by the provided <code>start</code>/<code>end</code> choices.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef connections(\n    self,\n    start: Optional[Set[int]] = None,\n    end: Optional[Set[int]] = None,\n) -&gt; Set[Connection]:\n\"\"\"Fetch the connections between microgrid components.\n\n    Args:\n        start: filter out any connections whose `start` does not match one of these\n            component IDs\n        end: filter out any connections whose `end` does not match one of these\n            component IDs\n\n    Returns:\n        Set of the connections between components in the microgrid, filtered by\n            the provided `start`/`end` choices.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_battery_chain","title":"<code>is_battery_chain(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is part of a battery chain.</p> <p>A component is part of a battery chain if it is a battery meter or a battery inverter.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a battery chain.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a battery chain.\n\n    A component is part of a battery chain if it is a battery meter or a battery\n    inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of a battery chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_battery_inverter","title":"<code>is_battery_inverter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a battery inverter.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a battery inverter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a battery inverter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_battery_meter","title":"<code>is_battery_meter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a battery meter.</p> <p>This is done by checking if the component has only battery inverters as its predecessors.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a battery meter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_battery_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a battery meter.\n\n    This is done by checking if the component has only battery inverters as its\n    predecessors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a battery meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_chp","title":"<code>is_chp(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a CHP.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a CHP.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_chp(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a CHP.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_chp_chain","title":"<code>is_chp_chain(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is part of a CHP chain.</p> <p>A component is part of a CHP chain if it is a CHP meter or a CHP.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a CHP chain.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_chp_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a CHP chain.\n\n    A component is part of a CHP chain if it is a CHP meter or a CHP.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of a CHP chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_chp_meter","title":"<code>is_chp_meter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a CHP meter.</p> <p>This is done by checking if the component has only CHPs as its successors.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a CHP meter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_chp_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a CHP meter.\n\n    This is done by checking if the component has only CHPs as its successors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a CHP meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_ev_charger","title":"<code>is_ev_charger(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is an EV charger.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is an EV charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is an EV charger.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_ev_charger_chain","title":"<code>is_ev_charger_chain(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is part of an EV charger chain.</p> <p>A component is part of an EV charger chain if it is an EV charger meter or an EV charger.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of an EV charger chain.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of an EV charger chain.\n\n    A component is part of an EV charger chain if it is an EV charger meter or an\n    EV charger.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of an EV charger chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_ev_charger_meter","title":"<code>is_ev_charger_meter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is an EV charger meter.</p> <p>This is done by checking if the component has only EV chargers as its successors.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is an EV charger meter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_ev_charger_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is an EV charger meter.\n\n    This is done by checking if the component has only EV chargers as its\n    successors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is an EV charger meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_pv_chain","title":"<code>is_pv_chain(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is part of a PV chain.</p> <p>A component is part of a PV chain if it is a PV meter or a PV inverter.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is part of a PV chain.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_chain(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is part of a PV chain.\n\n    A component is part of a PV chain if it is a PV meter or a PV inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is part of a PV chain.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_pv_inverter","title":"<code>is_pv_inverter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a PV inverter.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a PV inverter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_inverter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV inverter.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a PV inverter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.is_pv_meter","title":"<code>is_pv_meter(component)</code>  <code>abstractmethod</code>","text":"<p>Check if the specified component is a PV meter.</p> <p>This is done by checking if the component has only PV inverters as its successors.</p> PARAMETER DESCRIPTION <code>component</code> <p>component to check.</p> <p> TYPE: <code>Component</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the specified component is a PV meter.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef is_pv_meter(self, component: Component) -&gt; bool:\n\"\"\"Check if the specified component is a PV meter.\n\n    This is done by checking if the component has only PV inverters as its\n    successors.\n\n    Args:\n        component: component to check.\n\n    Returns:\n        Whether the specified component is a PV meter.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.predecessors","title":"<code>predecessors(component_id)</code>  <code>abstractmethod</code>","text":"<p>Fetch the graph predecessors of the specified component.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>numerical ID of the component whose predecessors should be fetched</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Set[Component]</code> <p>Set of IDs of the components that are predecessors of <code>component_id</code>, i.e. for which there is a connection from each of these components to <code>component_id</code>.</p> RAISES DESCRIPTION <code>KeyError</code> <p>if the specified <code>component_id</code> is not in the graph</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef predecessors(self, component_id: int) -&gt; Set[Component]:\n\"\"\"Fetch the graph predecessors of the specified component.\n\n    Args:\n        component_id: numerical ID of the component whose predecessors should be\n            fetched\n\n    Returns:\n        Set of IDs of the components that are predecessors of `component_id`,\n            i.e. for which there is a connection from each of these components to\n            `component_id`.\n\n    Raises:\n        KeyError: if the specified `component_id` is not in the graph\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid._graph.ComponentGraph.successors","title":"<code>successors(component_id)</code>  <code>abstractmethod</code>","text":"<p>Fetch the graph successors of the specified component.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>numerical ID of the component whose successors should be fetched</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Set[Component]</code> <p>Set of IDs of the components that are successors of <code>component_id</code>, i.e. for which there is a connection from <code>component_id</code> to each of these components.</p> RAISES DESCRIPTION <code>KeyError</code> <p>if the specified <code>component_id</code> is not in the graph</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_graph.py</code> <pre><code>@abstractmethod\ndef successors(self, component_id: int) -&gt; Set[Component]:\n\"\"\"Fetch the graph successors of the specified component.\n\n    Args:\n        component_id: numerical ID of the component whose successors should be\n            fetched\n\n    Returns:\n        Set of IDs of the components that are successors of `component_id`,\n            i.e. for which there is a connection from `component_id` to each of\n            these components.\n\n    Raises:\n        KeyError: if the specified `component_id` is not in the graph\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.battery_pool","title":"<code>frequenz.sdk.microgrid.battery_pool(battery_ids=None)</code>","text":"<p>Return the corresponding BatteryPool instance for the given ids.</p> <p>If a BatteryPool instance for the given ids doesn't exist, a new one is created and returned.</p> PARAMETER DESCRIPTION <code>battery_ids</code> <p>Optional set of IDs of batteries to be managed by the BatteryPool.  If not specified, all batteries available in the component graph are used.</p> <p> TYPE: <code>abc.Set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>BatteryPool</code> <p>A BatteryPool instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def battery_pool(battery_ids: abc.Set[int] | None = None) -&gt; BatteryPool:\n\"\"\"Return the corresponding BatteryPool instance for the given ids.\n\n    If a BatteryPool instance for the given ids doesn't exist, a new one is\n    created and returned.\n\n    Args:\n        battery_ids: Optional set of IDs of batteries to be managed by the\n            BatteryPool.  If not specified, all batteries available in the\n            component graph are used.\n\n    Returns:\n        A BatteryPool instance.\n    \"\"\"\n    return _get().battery_pool(battery_ids)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.ev_charger_pool","title":"<code>frequenz.sdk.microgrid.ev_charger_pool(ev_charger_ids=None)</code>","text":"<p>Return the corresponding EVChargerPool instance for the given ids.</p> <p>If an EVChargerPool instance for the given ids doesn't exist, a new one is created and returned.</p> PARAMETER DESCRIPTION <code>ev_charger_ids</code> <p>Optional set of IDs of EV Chargers to be managed by the EVChargerPool.  If not specified, all EV Chargers available in the component graph are used.</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>EVChargerPool</code> <p>An EVChargerPool instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def ev_charger_pool(ev_charger_ids: set[int] | None = None) -&gt; EVChargerPool:\n\"\"\"Return the corresponding EVChargerPool instance for the given ids.\n\n    If an EVChargerPool instance for the given ids doesn't exist, a new one is\n    created and returned.\n\n    Args:\n        ev_charger_ids: Optional set of IDs of EV Chargers to be managed by the\n            EVChargerPool.  If not specified, all EV Chargers available in the\n            component graph are used.\n\n    Returns:\n        An EVChargerPool instance.\n    \"\"\"\n    return _get().ev_charger_pool(ev_charger_ids)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.initialize","title":"<code>frequenz.sdk.microgrid.initialize(host, port, resampler_config)</code>  <code>async</code>","text":"<p>Initialize the microgrid connection manager and the data pipeline.</p> PARAMETER DESCRIPTION <code>host</code> <p>Host to connect to, to reach the microgrid API.</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>port to connect to.</p> <p> TYPE: <code>int</code> </p> <code>resampler_config</code> <p>Configuration for the resampling actor.</p> <p> TYPE: <code>ResamplerConfig</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/__init__.py</code> <pre><code>async def initialize(host: str, port: int, resampler_config: ResamplerConfig) -&gt; None:\n\"\"\"Initialize the microgrid connection manager and the data pipeline.\n\n    Args:\n        host: Host to connect to, to reach the microgrid API.\n        port: port to connect to.\n        resampler_config: Configuration for the resampling actor.\n    \"\"\"\n    await connection_manager.initialize(host, port)\n    _data_pipeline.initialize(resampler_config)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/#frequenz.sdk.microgrid.logical_meter","title":"<code>frequenz.sdk.microgrid.logical_meter()</code>","text":"<p>Return the logical meter instance.</p> <p>If a LogicalMeter instance doesn't exist, a new one is created and returned.</p> RETURNS DESCRIPTION <code>LogicalMeter</code> <p>A logical meter instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/_data_pipeline.py</code> <pre><code>def logical_meter() -&gt; LogicalMeter:\n\"\"\"Return the logical meter instance.\n\n    If a LogicalMeter instance doesn't exist, a new one is created and returned.\n\n    Returns:\n        A logical meter instance.\n    \"\"\"\n    return _get().logical_meter()\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/","title":"connection_manager","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager","title":"<code>frequenz.sdk.microgrid.connection_manager</code>","text":"<p>Microgrid Connection Manager singleton abstraction.</p> <p>This module provides a singleton abstraction over the microgrid. The main purpose is to provide the connection the microgrid API client and the microgrid component graph.</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager","title":"<code>frequenz.sdk.microgrid.connection_manager.ConnectionManager</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Creates and stores core features.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>class ConnectionManager(ABC):\n\"\"\"Creates and stores core features.\"\"\"\n\n    def __init__(self, host: str, port: int) -&gt; None:\n\"\"\"Create object instance.\n\n        Args:\n            host: server host\n            port: server port\n        \"\"\"\n        super().__init__()\n        self._host: str = host\n        self._port: int = port\n\n    @property\n    def host(self) -&gt; str:\n\"\"\"Get host of the currently connected server.\n\n        Returns:\n            host\n        \"\"\"\n        return self._host\n\n    @property\n    def port(self) -&gt; int:\n\"\"\"Get port of the currently connected server.\n\n        Returns:\n            port\n        \"\"\"\n        return self._port\n\n    @property\n    @abstractmethod\n    def api_client(self) -&gt; MicrogridApiClient:\n\"\"\"Get MicrogridApiClient.\n\n        Returns:\n            api client\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def component_graph(self) -&gt; ComponentGraph:\n\"\"\"Get component graph.\n\n        Returns:\n            component graph\n        \"\"\"\n\n    async def _update_api(self, host: str, port: int) -&gt; None:\n        self._host = host\n        self._port = port\n\n    @abstractmethod\n    async def _initialize(self) -&gt; None:\n\"\"\"Initialize the object. This function should be called only once.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.api_client","title":"<code>api_client: MicrogridApiClient</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get MicrogridApiClient.</p> RETURNS DESCRIPTION <code>MicrogridApiClient</code> <p>api client</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.component_graph","title":"<code>component_graph: ComponentGraph</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get component graph.</p> RETURNS DESCRIPTION <code>ComponentGraph</code> <p>component graph</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.host","title":"<code>host: str</code>  <code>property</code>","text":"<p>Get host of the currently connected server.</p> RETURNS DESCRIPTION <code>str</code> <p>host</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.port","title":"<code>port: int</code>  <code>property</code>","text":"<p>Get port of the currently connected server.</p> RETURNS DESCRIPTION <code>int</code> <p>port</p>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.ConnectionManager.__init__","title":"<code>__init__(host, port)</code>","text":"<p>Create object instance.</p> PARAMETER DESCRIPTION <code>host</code> <p>server host</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>server port</p> <p> TYPE: <code>int</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>def __init__(self, host: str, port: int) -&gt; None:\n\"\"\"Create object instance.\n\n    Args:\n        host: server host\n        port: server port\n    \"\"\"\n    super().__init__()\n    self._host: str = host\n    self._port: int = port\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.get","title":"<code>frequenz.sdk.microgrid.connection_manager.get()</code>","text":"<p>Get the MicrogridApi instance created by initialize().</p> <p>This function should be only called after initialize().</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>Raised when: * If <code>initialize()</code> method was not called before this call. * If <code>initialize()</code> methods was called but was not awaited and instance was     not created yet.</p> RETURNS DESCRIPTION <code>ConnectionManager</code> <p>MicrogridApi instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>def get() -&gt; ConnectionManager:\n\"\"\"Get the MicrogridApi instance created by initialize().\n\n    This function should be only called after initialize().\n\n    Raises:\n        RuntimeError: Raised when:\n            * If `initialize()` method was not called before this call.\n            * If `initialize()` methods was called but was not awaited and instance was\n                not created yet.\n\n    Returns:\n        MicrogridApi instance.\n    \"\"\"\n    if _CONNECTION_MANAGER is None:\n        raise RuntimeError(\n            \"ConnectionManager is not initialized. \"\n            \"Call `await microgrid.initialize()` first.\"\n        )\n\n    return _CONNECTION_MANAGER\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/connection_manager/#frequenz.sdk.microgrid.connection_manager.initialize","title":"<code>frequenz.sdk.microgrid.connection_manager.initialize(host, port)</code>  <code>async</code>","text":"<p>Initialize the MicrogridApi. This function should be called only once.</p> PARAMETER DESCRIPTION <code>host</code> <p>Microgrid host</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Microgrid port</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If method was called more then once.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/connection_manager.py</code> <pre><code>async def initialize(host: str, port: int) -&gt; None:\n\"\"\"Initialize the MicrogridApi. This function should be called only once.\n\n    Args:\n        host: Microgrid host\n        port: Microgrid port\n\n    Raises:\n        AssertionError: If method was called more then once.\n    \"\"\"\n    # From Doc: pylint just try to discourage this usage.\n    # That doesn't mean you cannot use it.\n    global _CONNECTION_MANAGER  # pylint: disable=global-statement\n\n    if _CONNECTION_MANAGER is not None:\n        raise AssertionError(\"MicrogridApi was already initialized.\")\n\n    _logger.info(\"Connecting to microgrid at %s:%s\", host, port)\n\n    microgrid_api = _InsecureConnectionManager(host, port)\n    await microgrid_api._initialize()  # pylint: disable=protected-access\n\n    # Check again that _MICROGRID_API is None in case somebody had the great idea of\n    # calling initialize() twice and in parallel.\n    if _CONNECTION_MANAGER is not None:\n        raise AssertionError(\"MicrogridApi was already initialized.\")\n\n    _CONNECTION_MANAGER = microgrid_api\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/","title":"client","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client","title":"<code>frequenz.sdk.microgrid.client</code>","text":"<p>Microgrid API client.</p> <p>This package provides an easy way to connect to the microgrid API.</p>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection","title":"<code>frequenz.sdk.microgrid.client.Connection</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Metadata for a connection between microgrid components.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_connection.py</code> <pre><code>class Connection(NamedTuple):\n\"\"\"Metadata for a connection between microgrid components.\"\"\"\n\n    start: int\n    end: int\n\n    def is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n\n        Returns:\n            `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n                otherwise.\n        \"\"\"\n        return self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.Connection-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._connection.Connection.is_valid","title":"<code>is_valid()</code>","text":"<p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>start &gt;= 0</code>, <code>end &gt; 0</code>, and <code>start != end</code>, <code>False</code> otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_connection.py</code> <pre><code>def is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n\n    Returns:\n        `True` if `start &gt;= 0`, `end &gt; 0`, and `start != end`, `False`\n            otherwise.\n    \"\"\"\n    return self.start &gt;= 0 and self.end &gt; 0 and self.start != self.end\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff","title":"<code>frequenz.sdk.microgrid.client.ExponentialBackoff</code>","text":"<p>         Bases: <code>RetryStrategy</code></p> <p>Provides methods for calculating the exponential interval between retries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class ExponentialBackoff(RetryStrategy):\n\"\"\"Provides methods for calculating the exponential interval between retries.\"\"\"\n\n    DEFAULT_INTERVAL = DEFAULT_RETRY_INTERVAL\n    DEFAULT_MAX_INTERVAL = 60.0\n    DEFAULT_MULTIPLIER = 2.0\n\n    # pylint: disable=too-many-arguments\n    def __init__(\n        self,\n        initial_interval: float = DEFAULT_INTERVAL,\n        max_interval: float = DEFAULT_MAX_INTERVAL,\n        multiplier: float = DEFAULT_MULTIPLIER,\n        jitter: float = DEFAULT_RETRY_JITTER,\n        limit: Optional[int] = None,\n    ) -&gt; None:\n\"\"\"Create a `ExponentialBackoff` instance.\n\n        Args:\n            initial_interval: time to wait for before the first retry, in\n                seconds.\n            max_interval: maximum interval, in seconds.\n            multiplier: exponential increment for interval.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\n        self._initial = initial_interval\n        self._max = max_interval\n        self._multiplier = multiplier\n        self._jitter = jitter\n        self._limit = limit\n\n        self._count = 0\n\n    def next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n        if self._limit is not None and self._count &gt;= self._limit:\n            return None\n        self._count += 1\n        exp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\n        return min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.ExponentialBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.ExponentialBackoff.__init__","title":"<code>__init__(initial_interval=DEFAULT_INTERVAL, max_interval=DEFAULT_MAX_INTERVAL, multiplier=DEFAULT_MULTIPLIER, jitter=DEFAULT_RETRY_JITTER, limit=None)</code>","text":"<p>Create a <code>ExponentialBackoff</code> instance.</p> PARAMETER DESCRIPTION <code>initial_interval</code> <p>time to wait for before the first retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_INTERVAL</code> </p> <code>max_interval</code> <p>maximum interval, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MAX_INTERVAL</code> </p> <code>multiplier</code> <p>exponential increment for interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MULTIPLIER</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __init__(\n    self,\n    initial_interval: float = DEFAULT_INTERVAL,\n    max_interval: float = DEFAULT_MAX_INTERVAL,\n    multiplier: float = DEFAULT_MULTIPLIER,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: Optional[int] = None,\n) -&gt; None:\n\"\"\"Create a `ExponentialBackoff` instance.\n\n    Args:\n        initial_interval: time to wait for before the first retry, in\n            seconds.\n        max_interval: maximum interval, in seconds.\n        multiplier: exponential increment for interval.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\n    self._initial = initial_interval\n    self._max = max_interval\n    self._multiplier = multiplier\n    self._jitter = jitter\n    self._limit = limit\n\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.ExponentialBackoff.next_interval","title":"<code>next_interval()</code>","text":"<p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n    if self._limit is not None and self._count &gt;= self._limit:\n        return None\n    self._count += 1\n    exp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\n    return min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff","title":"<code>frequenz.sdk.microgrid.client.LinearBackoff</code>","text":"<p>         Bases: <code>RetryStrategy</code></p> <p>Provides methods for calculating the interval between retries.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class LinearBackoff(RetryStrategy):\n\"\"\"Provides methods for calculating the interval between retries.\"\"\"\n\n    def __init__(\n        self,\n        interval: float = DEFAULT_RETRY_INTERVAL,\n        jitter: float = DEFAULT_RETRY_JITTER,\n        limit: Optional[int] = None,\n    ) -&gt; None:\n\"\"\"Create a `LinearBackoff` instance.\n\n        Args:\n            interval: time to wait for before the next retry, in seconds.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\n        self._interval = interval\n        self._jitter = jitter\n        self._limit = limit\n\n        self._count = 0\n\n    def next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n        if self._limit is not None and self._count &gt;= self._limit:\n            return None\n        self._count += 1\n        return self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.LinearBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.LinearBackoff.__init__","title":"<code>__init__(interval=DEFAULT_RETRY_INTERVAL, jitter=DEFAULT_RETRY_JITTER, limit=None)</code>","text":"<p>Create a <code>LinearBackoff</code> instance.</p> PARAMETER DESCRIPTION <code>interval</code> <p>time to wait for before the next retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_INTERVAL</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __init__(\n    self,\n    interval: float = DEFAULT_RETRY_INTERVAL,\n    jitter: float = DEFAULT_RETRY_JITTER,\n    limit: Optional[int] = None,\n) -&gt; None:\n\"\"\"Create a `LinearBackoff` instance.\n\n    Args:\n        interval: time to wait for before the next retry, in seconds.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\n    self._interval = interval\n    self._jitter = jitter\n    self._limit = limit\n\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.LinearBackoff.next_interval","title":"<code>next_interval()</code>","text":"<p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n    if self._limit is not None and self._count &gt;= self._limit:\n        return None\n    self._count += 1\n    return self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient","title":"<code>frequenz.sdk.microgrid.client.MicrogridApiClient</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base interface for microgrid API clients to implement.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>class MicrogridApiClient(ABC):\n\"\"\"Base interface for microgrid API clients to implement.\"\"\"\n\n    @abstractmethod\n    async def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n\n        Returns:\n            Iterator whose elements are all the components in the microgrid.\n        \"\"\"\n\n    @abstractmethod\n    async def connections(\n        self,\n        starts: Optional[Set[int]] = None,\n        ends: Optional[Set[int]] = None,\n    ) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n\n        Args:\n            starts: if set and non-empty, only include connections whose start\n                value matches one of the provided component IDs\n            ends: if set and non-empty, only include connections whose end value\n                matches one of the provided component IDs\n\n        Returns:\n            Microgrid connections matching the provided start and end filters.\n        \"\"\"\n\n    @abstractmethod\n    async def meter_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n\n        Args:\n            component_id: id of the meter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime meter data.\n        \"\"\"\n\n    @abstractmethod\n    async def battery_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n\n        Args:\n            component_id: id of the battery to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime battery data.\n        \"\"\"\n\n    @abstractmethod\n    async def inverter_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n\n        Args:\n            component_id: id of the inverter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime inverter data.\n        \"\"\"\n\n    @abstractmethod\n    async def ev_charger_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n\n        Args:\n            component_id: id of the ev charger to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime ev charger data.\n        \"\"\"\n\n    @abstractmethod\n    async def set_power(self, component_id: int, power_w: float) -&gt; Empty:\n\"\"\"Send request to the Microgrid to set power for component.\n\n        If power &gt; 0, then component will be charged with this power.\n        If power &lt; 0, then component will be discharged with this power.\n        If power == 0, then stop charging or discharging component.\n\n\n        Args:\n            component_id: id of the component to set power.\n            power_w: power to set for the component.\n\n        Returns:\n            Empty response.\n        \"\"\"\n\n    @abstractmethod\n    async def set_bounds(self, component_id: int, lower: float, upper: float) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to nitrogen.\n\n        Args:\n            component_id: ID of the component to set bounds for.\n            lower: Lower bound to be set for the component.\n            upper: Upper bound to be set for the component.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridApiClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.battery_data","title":"<code>battery_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Return a channel receiver that provides a <code>BatteryData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the battery to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[BatteryData]</code> <p>A channel receiver that provides realtime battery data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def battery_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n\n    Args:\n        component_id: id of the battery to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime battery data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.components","title":"<code>components()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Fetch all the components present in the microgrid.</p> RETURNS DESCRIPTION <code>Iterable[Component]</code> <p>Iterator whose elements are all the components in the microgrid.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n\n    Returns:\n        Iterator whose elements are all the components in the microgrid.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.connections","title":"<code>connections(starts=None, ends=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Fetch the connections between components in the microgrid.</p> PARAMETER DESCRIPTION <code>starts</code> <p>if set and non-empty, only include connections whose start value matches one of the provided component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> <code>ends</code> <p>if set and non-empty, only include connections whose end value matches one of the provided component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[Connection]</code> <p>Microgrid connections matching the provided start and end filters.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def connections(\n    self,\n    starts: Optional[Set[int]] = None,\n    ends: Optional[Set[int]] = None,\n) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n\n    Args:\n        starts: if set and non-empty, only include connections whose start\n            value matches one of the provided component IDs\n        ends: if set and non-empty, only include connections whose end value\n            matches one of the provided component IDs\n\n    Returns:\n        Microgrid connections matching the provided start and end filters.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.ev_charger_data","title":"<code>ev_charger_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Return a channel receiver that provides an <code>EvChargeData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the ev charger to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A channel receiver that provides realtime ev charger data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def ev_charger_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n\n    Args:\n        component_id: id of the ev charger to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime ev charger data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.inverter_data","title":"<code>inverter_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Return a channel receiver that provides an <code>InverterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the inverter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[InverterData]</code> <p>A channel receiver that provides realtime inverter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def inverter_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n\n    Args:\n        component_id: id of the inverter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime inverter data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.meter_data","title":"<code>meter_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Return a channel receiver that provides a <code>MeterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the meter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[MeterData]</code> <p>A channel receiver that provides realtime meter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def meter_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n\n    Args:\n        component_id: id of the meter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime meter data.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.set_bounds","title":"<code>set_bounds(component_id, lower, upper)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Send <code>SetBoundsParam</code>s received from a channel to nitrogen.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>ID of the component to set bounds for.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>Lower bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> <code>upper</code> <p>Upper bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def set_bounds(self, component_id: int, lower: float, upper: float) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to nitrogen.\n\n    Args:\n        component_id: ID of the component to set bounds for.\n        lower: Lower bound to be set for the component.\n        upper: Upper bound to be set for the component.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridApiClient.set_power","title":"<code>set_power(component_id, power_w)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Send request to the Microgrid to set power for component.</p> <p>If power &gt; 0, then component will be charged with this power. If power &lt; 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the component to set power.</p> <p> TYPE: <code>int</code> </p> <code>power_w</code> <p>power to set for the component.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Empty</code> <p>Empty response.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>@abstractmethod\nasync def set_power(self, component_id: int, power_w: float) -&gt; Empty:\n\"\"\"Send request to the Microgrid to set power for component.\n\n    If power &gt; 0, then component will be charged with this power.\n    If power &lt; 0, then component will be discharged with this power.\n    If power == 0, then stop charging or discharging component.\n\n\n    Args:\n        component_id: id of the component to set power.\n        power_w: power to set for the component.\n\n    Returns:\n        Empty response.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient","title":"<code>frequenz.sdk.microgrid.client.MicrogridGrpcClient</code>","text":"<p>         Bases: <code>MicrogridApiClient</code></p> <p>Microgrid API client implementation using gRPC as the underlying protocol.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>class MicrogridGrpcClient(MicrogridApiClient):\n\"\"\"Microgrid API client implementation using gRPC as the underlying protocol.\"\"\"\n\n    def __init__(\n        self,\n        grpc_channel: grpc.aio.Channel,\n        target: str,\n        retry_spec: RetryStrategy = LinearBackoff(),\n    ) -&gt; None:\n\"\"\"Initialize the class instance.\n\n        Args:\n            grpc_channel: asyncio-supporting gRPC channel\n            target: server (host:port) to be used for asyncio-supporting gRPC\n                channel that the client should use to contact the API\n            retry_spec: Specs on how to retry if the connection to a streaming\n                method gets lost.\n        \"\"\"\n        self.target = target\n        self.api = MicrogridStub(grpc_channel)\n        self._component_streams: Dict[int, Broadcast[Any]] = {}\n        self._retry_spec = retry_spec\n\n    async def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n\n        Returns:\n            Iterator whose elements are all the components in the microgrid.\n\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\n        try:\n            # grpc.aio is missing types and mypy thinks this is not awaitable,\n            # but it is\n            component_list = await self.api.ListComponents(\n                microgrid_pb.ComponentFilter(),\n                timeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n            )  # type: ignore[misc]\n        except grpc.aio.AioRpcError as err:\n            msg = f\"Failed to list components. Microgrid API: {self.target}. Err: {err.details()}\"\n            raise grpc.aio.AioRpcError(\n                code=err.code(),\n                initial_metadata=err.initial_metadata(),\n                trailing_metadata=err.trailing_metadata(),\n                details=msg,\n                debug_error_string=err.debug_error_string(),\n            )\n        components_only = filter(\n            lambda c: c.category\n            not in (\n                microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_SENSOR,\n                microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_LOAD,\n            ),\n            component_list.components,\n        )\n        result: Iterable[Component] = map(\n            lambda c: Component(\n                c.id,\n                _component_category_from_protobuf(c.category),\n                _component_type_from_protobuf(c.category, c.inverter),\n            ),\n            components_only,\n        )\n\n        return result\n\n    async def connections(\n        self,\n        starts: Optional[Set[int]] = None,\n        ends: Optional[Set[int]] = None,\n    ) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n\n        Args:\n            starts: if set and non-empty, only include connections whose start\n                value matches one of the provided component IDs\n            ends: if set and non-empty, only include connections whose end value\n                matches one of the provided component IDs\n\n        Returns:\n            Microgrid connections matching the provided start and end filters.\n\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\n        connection_filter = microgrid_pb.ConnectionFilter(starts=starts, ends=ends)\n        try:\n            valid_components, all_connections = await asyncio.gather(\n                self.components(),\n                # grpc.aio is missing types and mypy thinks this is not\n                # awaitable, but it is\n                cast(\n                    Awaitable[microgrid_pb.ConnectionList],\n                    self.api.ListConnections(\n                        connection_filter,\n                        timeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n                    ),\n                ),\n            )\n        except grpc.aio.AioRpcError as err:\n            msg = f\"Failed to list connections. Microgrid API: {self.target}. Err: {err.details()}\"\n            raise grpc.aio.AioRpcError(\n                code=err.code(),\n                initial_metadata=err.initial_metadata(),\n                trailing_metadata=err.trailing_metadata(),\n                details=msg,\n                debug_error_string=err.debug_error_string(),\n            )\n        # Filter out the components filtered in `components` method.\n        # id=0 is an exception indicating grid component.\n        valid_ids = {c.component_id for c in valid_components}\n        valid_ids.add(0)\n\n        connections = filter(\n            lambda c: (c.start in valid_ids and c.end in valid_ids),\n            all_connections.connections,\n        )\n\n        result: Iterable[Connection] = map(\n            lambda c: Connection(c.start, c.end), connections\n        )\n\n        return result\n\n    async def _component_data_task(\n        self,\n        component_id: int,\n        transform: Callable[[microgrid_pb.ComponentData], _GenericComponentData],\n        sender: Sender[_GenericComponentData],\n    ) -&gt; None:\n\"\"\"Read data from the microgrid API and send to a channel.\n\n        Args:\n            component_id: id of the component to get data for.\n            transform: A method for transforming raw component data into the\n                desired output type.\n            sender: A channel sender, to send the component data to.\n\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established\n        \"\"\"\n        retry_spec: RetryStrategy = self._retry_spec.copy()\n        while True:\n            _logger.debug(\n                \"Making call to `GetComponentData`, for component_id=%d\", component_id\n            )\n            try:\n                call = self.api.GetComponentData(\n                    microgrid_pb.ComponentIdParam(id=component_id),\n                )\n                # grpc.aio is missing types and mypy thinks this is not\n                # async iterable, but it is\n                async for msg in call:  # type: ignore[attr-defined]\n                    await sender.send(transform(msg))\n            except grpc.aio.AioRpcError as err:\n                api_details = f\"Microgrid API: {self.target}.\"\n                _logger.exception(\n                    \"`GetComponentData`, for component_id=%d: exception: %s api: %s\",\n                    component_id,\n                    err,\n                    api_details,\n                )\n\n            if interval := retry_spec.next_interval():\n                _logger.warning(\n                    \"`GetComponentData`, for component_id=%d: connection ended, \"\n                    \"retrying %s in %0.3f seconds.\",\n                    component_id,\n                    retry_spec.get_progress(),\n                    interval,\n                )\n                await asyncio.sleep(interval)\n            else:\n                _logger.warning(\n                    \"`GetComponentData`, for component_id=%d: connection ended, \"\n                    \"retry limit exceeded %s.\",\n                    component_id,\n                    retry_spec.get_progress(),\n                )\n                break\n\n    def _get_component_data_channel(\n        self,\n        component_id: int,\n        transform: Callable[[microgrid_pb.ComponentData], _GenericComponentData],\n    ) -&gt; Broadcast[_GenericComponentData]:\n\"\"\"Return the broadcast channel for a given component_id.\n\n        If a broadcast channel for the given component_id doesn't exist, create\n        a new channel and a task for reading data from the microgrid api and\n        sending them to the channel.\n\n        Args:\n            component_id: id of the component to get data for.\n            transform: A method for transforming raw component data into the\n                desired output type.\n\n        Returns:\n            The channel for the given component_id.\n        \"\"\"\n        if component_id in self._component_streams:\n            return self._component_streams[component_id]\n        task_name = f\"raw-component-data-{component_id}\"\n        chan = Broadcast[_GenericComponentData](task_name)\n        self._component_streams[component_id] = chan\n\n        asyncio.create_task(\n            self._component_data_task(\n                component_id,\n                transform,\n                chan.new_sender(),\n            ),\n            name=task_name,\n        )\n        return chan\n\n    async def _expect_category(\n        self,\n        component_id: int,\n        expected_category: ComponentCategory,\n    ) -&gt; None:\n\"\"\"Check if the given component_id is of the expected type.\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: Component id to check.\n            expected_category: Component category that the given id is expected\n                to have.\n        \"\"\"\n        try:\n            comp = next(\n                comp\n                for comp in await self.components()\n                if comp.component_id == component_id\n            )\n        except StopIteration as exc:\n            raise ValueError(\n                f\"Unable to find component with id {component_id}\"\n            ) from exc\n\n        if comp.category != expected_category:\n            raise ValueError(\n                f\"Component id {component_id} is a {comp.category}\"\n                f\", not a {expected_category}.\"\n            )\n\n    async def meter_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the meter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime meter data.\n        \"\"\"\n        await self._expect_category(\n            component_id,\n            ComponentCategory.METER,\n        )\n        return self._get_component_data_channel(\n            component_id,\n            MeterData.from_proto,\n        ).new_receiver(maxsize=maxsize)\n\n    async def battery_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the battery to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime battery data.\n        \"\"\"\n        await self._expect_category(\n            component_id,\n            ComponentCategory.BATTERY,\n        )\n        return self._get_component_data_channel(\n            component_id,\n            BatteryData.from_proto,\n        ).new_receiver(maxsize=maxsize)\n\n    async def inverter_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the inverter to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime inverter data.\n        \"\"\"\n        await self._expect_category(\n            component_id,\n            ComponentCategory.INVERTER,\n        )\n        return self._get_component_data_channel(\n            component_id,\n            InverterData.from_proto,\n        ).new_receiver(maxsize=maxsize)\n\n    async def ev_charger_data(\n        self,\n        component_id: int,\n        maxsize: int = RECEIVER_MAX_SIZE,\n    ) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n        If only the latest value is required, the `Receiver` returned by this\n        method can be converted into a `Peekable` with the `into_peekable`\n        method on the `Receiver.`\n\n        Raises:\n            ValueError: if the given id is unknown or has a different type.\n\n        Args:\n            component_id: id of the ev charger to get data for.\n            maxsize: Size of the receiver's buffer.\n\n        Returns:\n            A channel receiver that provides realtime ev charger data.\n        \"\"\"\n        await self._expect_category(\n            component_id,\n            ComponentCategory.EV_CHARGER,\n        )\n        return self._get_component_data_channel(\n            component_id,\n            EVChargerData.from_proto,\n        ).new_receiver(maxsize=maxsize)\n\n    async def set_power(self, component_id: int, power_w: float) -&gt; Empty:\n\"\"\"Send request to the Microgrid to set power for component.\n\n        If power &gt; 0, then component will be charged with this power.\n        If power &lt; 0, then component will be discharged with this power.\n        If power == 0, then stop charging or discharging component.\n\n\n        Args:\n            component_id: id of the component to set power.\n            power_w: power to set for the component.\n\n        Returns:\n            Empty response.\n\n        Raises:\n            AioRpcError: if connection to Microgrid API cannot be established or\n                when the api call exceeded timeout\n        \"\"\"\n        try:\n            if power_w &gt;= 0:\n                # grpc.aio is missing types and mypy thinks this is not\n                # async iterable, but it is\n                result: Empty = await self.api.Charge(\n                    microgrid_pb.PowerLevelParam(\n                        component_id=component_id, power_w=math.floor(power_w)\n                    ),\n                    timeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n                )  # type: ignore[misc]\n            else:\n                # grpc.aio is missing types and mypy thinks this is not\n                # async iterable, but it is\n                power_w *= -1\n                result = await self.api.Discharge(\n                    microgrid_pb.PowerLevelParam(\n                        component_id=component_id, power_w=math.floor(power_w)\n                    ),\n                    timeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n                )  # type: ignore[misc]\n        except grpc.aio.AioRpcError as err:\n            msg = f\"Failed to set power. Microgrid API: {self.target}. Err: {err.details()}\"\n            raise grpc.aio.AioRpcError(\n                code=err.code(),\n                initial_metadata=err.initial_metadata(),\n                trailing_metadata=err.trailing_metadata(),\n                details=msg,\n                debug_error_string=err.debug_error_string(),\n            )\n        return result\n\n    async def set_bounds(\n        self,\n        component_id: int,\n        lower: float,\n        upper: float,\n    ) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to nitrogen.\n\n        Args:\n            component_id: ID of the component to set bounds for.\n            lower: Lower bound to be set for the component.\n            upper: Upper bound to be set for the component.\n\n        Raises:\n            ValueError: when upper bound is less than 0, or when lower bound is\n                greater than 0.\n            grpc.aio.AioRpcError: if connection to Microgrid API cannot be established\n                or when the api call exceeded timeout\n        \"\"\"\n        api_details = f\"Microgrid API: {self.target}.\"\n        if upper &lt; 0:\n            raise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\n        if lower &gt; 0:\n            raise ValueError(f\"Lower bound {upper} must be less than or equal to 0.\")\n\n        # grpc.aio is missing types and mypy thinks request_iterator is\n        # a required argument, but it is not\n        set_bounds_call = self.api.SetBounds(\n            timeout=DEFAULT_GRPC_CALL_TIMEOUT,\n        )  # type: ignore[call-arg]\n        try:\n            # grpc.aio is missing types and mypy thinks set_bounds_call can be Empty\n            assert not isinstance(set_bounds_call, Empty)\n            await set_bounds_call.write(\n                microgrid_pb.SetBoundsParam(\n                    component_id=component_id,\n                    # pylint: disable=no-member,line-too-long\n                    target_metric=microgrid_pb.SetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE,\n                    bounds=common_pb.Bounds(lower=lower, upper=upper),\n                ),\n            )\n        except grpc.aio.AioRpcError as err:\n            _logger.error(\n                \"set_bounds write failed: %s, for message: %s, api: %s. Err: %s\",\n                err,\n                next,\n                api_details,\n                err.details(),\n            )\n            raise\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.MicrogridGrpcClient-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.__init__","title":"<code>__init__(grpc_channel, target, retry_spec=LinearBackoff())</code>","text":"<p>Initialize the class instance.</p> PARAMETER DESCRIPTION <code>grpc_channel</code> <p>asyncio-supporting gRPC channel</p> <p> TYPE: <code>grpc.aio.Channel</code> </p> <code>target</code> <p>server (host:port) to be used for asyncio-supporting gRPC channel that the client should use to contact the API</p> <p> TYPE: <code>str</code> </p> <code>retry_spec</code> <p>Specs on how to retry if the connection to a streaming method gets lost.</p> <p> TYPE: <code>RetryStrategy</code> DEFAULT: <code>LinearBackoff()</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>def __init__(\n    self,\n    grpc_channel: grpc.aio.Channel,\n    target: str,\n    retry_spec: RetryStrategy = LinearBackoff(),\n) -&gt; None:\n\"\"\"Initialize the class instance.\n\n    Args:\n        grpc_channel: asyncio-supporting gRPC channel\n        target: server (host:port) to be used for asyncio-supporting gRPC\n            channel that the client should use to contact the API\n        retry_spec: Specs on how to retry if the connection to a streaming\n            method gets lost.\n    \"\"\"\n    self.target = target\n    self.api = MicrogridStub(grpc_channel)\n    self._component_streams: Dict[int, Broadcast[Any]] = {}\n    self._retry_spec = retry_spec\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.battery_data","title":"<code>battery_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>async</code>","text":"<p>Return a channel receiver that provides a <code>BatteryData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the battery to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[BatteryData]</code> <p>A channel receiver that provides realtime battery data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def battery_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[BatteryData]:\n\"\"\"Return a channel receiver that provides a `BatteryData` stream.\n\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the battery to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime battery data.\n    \"\"\"\n    await self._expect_category(\n        component_id,\n        ComponentCategory.BATTERY,\n    )\n    return self._get_component_data_channel(\n        component_id,\n        BatteryData.from_proto,\n    ).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.components","title":"<code>components()</code>  <code>async</code>","text":"<p>Fetch all the components present in the microgrid.</p> RETURNS DESCRIPTION <code>Iterable[Component]</code> <p>Iterator whose elements are all the components in the microgrid.</p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def components(self) -&gt; Iterable[Component]:\n\"\"\"Fetch all the components present in the microgrid.\n\n    Returns:\n        Iterator whose elements are all the components in the microgrid.\n\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\n    try:\n        # grpc.aio is missing types and mypy thinks this is not awaitable,\n        # but it is\n        component_list = await self.api.ListComponents(\n            microgrid_pb.ComponentFilter(),\n            timeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n        )  # type: ignore[misc]\n    except grpc.aio.AioRpcError as err:\n        msg = f\"Failed to list components. Microgrid API: {self.target}. Err: {err.details()}\"\n        raise grpc.aio.AioRpcError(\n            code=err.code(),\n            initial_metadata=err.initial_metadata(),\n            trailing_metadata=err.trailing_metadata(),\n            details=msg,\n            debug_error_string=err.debug_error_string(),\n        )\n    components_only = filter(\n        lambda c: c.category\n        not in (\n            microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_SENSOR,\n            microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_LOAD,\n        ),\n        component_list.components,\n    )\n    result: Iterable[Component] = map(\n        lambda c: Component(\n            c.id,\n            _component_category_from_protobuf(c.category),\n            _component_type_from_protobuf(c.category, c.inverter),\n        ),\n        components_only,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.connections","title":"<code>connections(starts=None, ends=None)</code>  <code>async</code>","text":"<p>Fetch the connections between components in the microgrid.</p> PARAMETER DESCRIPTION <code>starts</code> <p>if set and non-empty, only include connections whose start value matches one of the provided component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> <code>ends</code> <p>if set and non-empty, only include connections whose end value matches one of the provided component IDs</p> <p> TYPE: <code>Optional[Set[int]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[Connection]</code> <p>Microgrid connections matching the provided start and end filters.</p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def connections(\n    self,\n    starts: Optional[Set[int]] = None,\n    ends: Optional[Set[int]] = None,\n) -&gt; Iterable[Connection]:\n\"\"\"Fetch the connections between components in the microgrid.\n\n    Args:\n        starts: if set and non-empty, only include connections whose start\n            value matches one of the provided component IDs\n        ends: if set and non-empty, only include connections whose end value\n            matches one of the provided component IDs\n\n    Returns:\n        Microgrid connections matching the provided start and end filters.\n\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\n    connection_filter = microgrid_pb.ConnectionFilter(starts=starts, ends=ends)\n    try:\n        valid_components, all_connections = await asyncio.gather(\n            self.components(),\n            # grpc.aio is missing types and mypy thinks this is not\n            # awaitable, but it is\n            cast(\n                Awaitable[microgrid_pb.ConnectionList],\n                self.api.ListConnections(\n                    connection_filter,\n                    timeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n                ),\n            ),\n        )\n    except grpc.aio.AioRpcError as err:\n        msg = f\"Failed to list connections. Microgrid API: {self.target}. Err: {err.details()}\"\n        raise grpc.aio.AioRpcError(\n            code=err.code(),\n            initial_metadata=err.initial_metadata(),\n            trailing_metadata=err.trailing_metadata(),\n            details=msg,\n            debug_error_string=err.debug_error_string(),\n        )\n    # Filter out the components filtered in `components` method.\n    # id=0 is an exception indicating grid component.\n    valid_ids = {c.component_id for c in valid_components}\n    valid_ids.add(0)\n\n    connections = filter(\n        lambda c: (c.start in valid_ids and c.end in valid_ids),\n        all_connections.connections,\n    )\n\n    result: Iterable[Connection] = map(\n        lambda c: Connection(c.start, c.end), connections\n    )\n\n    return result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.ev_charger_data","title":"<code>ev_charger_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>async</code>","text":"<p>Return a channel receiver that provides an <code>EvChargeData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the ev charger to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A channel receiver that provides realtime ev charger data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def ev_charger_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[EVChargerData]:\n\"\"\"Return a channel receiver that provides an `EvChargeData` stream.\n\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the ev charger to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime ev charger data.\n    \"\"\"\n    await self._expect_category(\n        component_id,\n        ComponentCategory.EV_CHARGER,\n    )\n    return self._get_component_data_channel(\n        component_id,\n        EVChargerData.from_proto,\n    ).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.inverter_data","title":"<code>inverter_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>async</code>","text":"<p>Return a channel receiver that provides an <code>InverterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the inverter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[InverterData]</code> <p>A channel receiver that provides realtime inverter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def inverter_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[InverterData]:\n\"\"\"Return a channel receiver that provides an `InverterData` stream.\n\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the inverter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime inverter data.\n    \"\"\"\n    await self._expect_category(\n        component_id,\n        ComponentCategory.INVERTER,\n    )\n    return self._get_component_data_channel(\n        component_id,\n        InverterData.from_proto,\n    ).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.meter_data","title":"<code>meter_data(component_id, maxsize=RECEIVER_MAX_SIZE)</code>  <code>async</code>","text":"<p>Return a channel receiver that provides a <code>MeterData</code> stream.</p> <p>If only the latest value is required, the <code>Receiver</code> returned by this method can be converted into a <code>Peekable</code> with the <code>into_peekable</code> method on the <code>Receiver.</code></p> RAISES DESCRIPTION <code>ValueError</code> <p>if the given id is unknown or has a different type.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the meter to get data for.</p> <p> TYPE: <code>int</code> </p> <code>maxsize</code> <p>Size of the receiver's buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>RECEIVER_MAX_SIZE</code> </p> RETURNS DESCRIPTION <code>Receiver[MeterData]</code> <p>A channel receiver that provides realtime meter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def meter_data(\n    self,\n    component_id: int,\n    maxsize: int = RECEIVER_MAX_SIZE,\n) -&gt; Receiver[MeterData]:\n\"\"\"Return a channel receiver that provides a `MeterData` stream.\n\n    If only the latest value is required, the `Receiver` returned by this\n    method can be converted into a `Peekable` with the `into_peekable`\n    method on the `Receiver.`\n\n    Raises:\n        ValueError: if the given id is unknown or has a different type.\n\n    Args:\n        component_id: id of the meter to get data for.\n        maxsize: Size of the receiver's buffer.\n\n    Returns:\n        A channel receiver that provides realtime meter data.\n    \"\"\"\n    await self._expect_category(\n        component_id,\n        ComponentCategory.METER,\n    )\n    return self._get_component_data_channel(\n        component_id,\n        MeterData.from_proto,\n    ).new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.set_bounds","title":"<code>set_bounds(component_id, lower, upper)</code>  <code>async</code>","text":"<p>Send <code>SetBoundsParam</code>s received from a channel to nitrogen.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>ID of the component to set bounds for.</p> <p> TYPE: <code>int</code> </p> <code>lower</code> <p>Lower bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> <code>upper</code> <p>Upper bound to be set for the component.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>when upper bound is less than 0, or when lower bound is greater than 0.</p> <code>grpc.aio.AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def set_bounds(\n    self,\n    component_id: int,\n    lower: float,\n    upper: float,\n) -&gt; None:\n\"\"\"Send `SetBoundsParam`s received from a channel to nitrogen.\n\n    Args:\n        component_id: ID of the component to set bounds for.\n        lower: Lower bound to be set for the component.\n        upper: Upper bound to be set for the component.\n\n    Raises:\n        ValueError: when upper bound is less than 0, or when lower bound is\n            greater than 0.\n        grpc.aio.AioRpcError: if connection to Microgrid API cannot be established\n            or when the api call exceeded timeout\n    \"\"\"\n    api_details = f\"Microgrid API: {self.target}.\"\n    if upper &lt; 0:\n        raise ValueError(f\"Upper bound {upper} must be greater than or equal to 0.\")\n    if lower &gt; 0:\n        raise ValueError(f\"Lower bound {upper} must be less than or equal to 0.\")\n\n    # grpc.aio is missing types and mypy thinks request_iterator is\n    # a required argument, but it is not\n    set_bounds_call = self.api.SetBounds(\n        timeout=DEFAULT_GRPC_CALL_TIMEOUT,\n    )  # type: ignore[call-arg]\n    try:\n        # grpc.aio is missing types and mypy thinks set_bounds_call can be Empty\n        assert not isinstance(set_bounds_call, Empty)\n        await set_bounds_call.write(\n            microgrid_pb.SetBoundsParam(\n                component_id=component_id,\n                # pylint: disable=no-member,line-too-long\n                target_metric=microgrid_pb.SetBoundsParam.TargetMetric.TARGET_METRIC_POWER_ACTIVE,\n                bounds=common_pb.Bounds(lower=lower, upper=upper),\n            ),\n        )\n    except grpc.aio.AioRpcError as err:\n        _logger.error(\n            \"set_bounds write failed: %s, for message: %s, api: %s. Err: %s\",\n            err,\n            next,\n            api_details,\n            err.details(),\n        )\n        raise\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._client.MicrogridGrpcClient.set_power","title":"<code>set_power(component_id, power_w)</code>  <code>async</code>","text":"<p>Send request to the Microgrid to set power for component.</p> <p>If power &gt; 0, then component will be charged with this power. If power &lt; 0, then component will be discharged with this power. If power == 0, then stop charging or discharging component.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the component to set power.</p> <p> TYPE: <code>int</code> </p> <code>power_w</code> <p>power to set for the component.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Empty</code> <p>Empty response.</p> RAISES DESCRIPTION <code>AioRpcError</code> <p>if connection to Microgrid API cannot be established or when the api call exceeded timeout</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_client.py</code> <pre><code>async def set_power(self, component_id: int, power_w: float) -&gt; Empty:\n\"\"\"Send request to the Microgrid to set power for component.\n\n    If power &gt; 0, then component will be charged with this power.\n    If power &lt; 0, then component will be discharged with this power.\n    If power == 0, then stop charging or discharging component.\n\n\n    Args:\n        component_id: id of the component to set power.\n        power_w: power to set for the component.\n\n    Returns:\n        Empty response.\n\n    Raises:\n        AioRpcError: if connection to Microgrid API cannot be established or\n            when the api call exceeded timeout\n    \"\"\"\n    try:\n        if power_w &gt;= 0:\n            # grpc.aio is missing types and mypy thinks this is not\n            # async iterable, but it is\n            result: Empty = await self.api.Charge(\n                microgrid_pb.PowerLevelParam(\n                    component_id=component_id, power_w=math.floor(power_w)\n                ),\n                timeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n            )  # type: ignore[misc]\n        else:\n            # grpc.aio is missing types and mypy thinks this is not\n            # async iterable, but it is\n            power_w *= -1\n            result = await self.api.Discharge(\n                microgrid_pb.PowerLevelParam(\n                    component_id=component_id, power_w=math.floor(power_w)\n                ),\n                timeout=DEFAULT_GRPC_CALL_TIMEOUT,  # type: ignore[arg-type]\n            )  # type: ignore[misc]\n    except grpc.aio.AioRpcError as err:\n        msg = f\"Failed to set power. Microgrid API: {self.target}. Err: {err.details()}\"\n        raise grpc.aio.AioRpcError(\n            code=err.code(),\n            initial_metadata=err.initial_metadata(),\n            trailing_metadata=err.trailing_metadata(),\n            details=msg,\n            debug_error_string=err.debug_error_string(),\n        )\n    return result\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy","title":"<code>frequenz.sdk.microgrid.client.RetryStrategy</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Interface for implementing retry strategies.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>class RetryStrategy(ABC):\n\"\"\"Interface for implementing retry strategies.\"\"\"\n\n    _limit: Optional[int]\n    _count: int\n\n    @abstractmethod\n    def next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\n\n    def get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n\n        Returns:\n            String denoting retry progress in the form \"(count/limit)\"\n        \"\"\"\n        if self._limit is None:\n            return f\"({self._count}/\u221e)\"\n\n        return f\"({self._count}/{self._limit})\"\n\n    def reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n\n        To be called as soon as a connection is successful.\n        \"\"\"\n        self._count = 0\n\n    def copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n\n        Returns:\n            A deepcopy of `self`.\n        \"\"\"\n        ret = deepcopy(self)\n        ret.reset()\n        return ret\n\n    def __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n\n        Yields:\n            Next retry interval in seconds.\n        \"\"\"\n        while True:\n            interval = self.next_interval()\n            if interval is None:\n                break\n            yield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client.RetryStrategy-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.RetryStrategy.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>Iterator[float]</code> <p>Next retry interval in seconds.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\n    while True:\n        interval = self.next_interval()\n        if interval is None:\n            break\n        yield interval\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.RetryStrategy.copy","title":"<code>copy()</code>","text":"<p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>RetryStrategy</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\n    ret = deepcopy(self)\n    ret.reset()\n    return ret\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.RetryStrategy.get_progress","title":"<code>get_progress()</code>","text":"<p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\n    if self._limit is None:\n        return f\"({self._count}/\u221e)\"\n\n    return f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.RetryStrategy.next_interval","title":"<code>next_interval()</code>  <code>abstractmethod</code>","text":"<p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>Optional[float]</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>@abstractmethod\ndef next_interval(self) -&gt; Optional[float]:\n\"\"\"Return the time to wait before the next retry.\n\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/client/#frequenz.sdk.microgrid.client._retry.RetryStrategy.reset","title":"<code>reset()</code>","text":"<p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/client/_retry.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n\n    To be called as soon as a connection is successful.\n    \"\"\"\n    self._count = 0\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/","title":"component","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component","title":"<code>frequenz.sdk.microgrid.component</code>","text":"<p>Microgrid component abstractions.</p> <p>This package provides classes to operate con microgrid components.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData","title":"<code>frequenz.sdk.microgrid.component.BatteryData</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ComponentData</code></p> <p>A wrapper class for holding battery data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass BatteryData(ComponentData):\n\"\"\"A wrapper class for holding battery data.\"\"\"\n\n    soc: float\n\"\"\"Battery's overall SoC in percent (%).\"\"\"\n\n    soc_lower_bound: float\n\"\"\"The SoC below which discharge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\n\n    soc_upper_bound: float\n\"\"\"The SoC above which charge commands will be blocked by the system,\n        in percent (%).\n    \"\"\"\n\n    capacity: float\n\"\"\"The capacity of the battery in Wh (Watt-hour).\"\"\"\n\n    power_lower_bound: float\n\"\"\"The maximum discharge power, in watts, represented in the passive sign\n        convention. this will be a negative number, or zero if no discharging is\n        possible.\n    \"\"\"\n\n    power_upper_bound: float\n\"\"\"The maximum charge power, in Watts, represented in the passive sign convention.\n        This will be a positive number, or zero if no charging is possible.\n    \"\"\"\n\n    temperature_max: float\n\"\"\"The maximum temperature of all the blocks in a battery, in Celcius (\u00b0C).\"\"\"\n\n    _relay_state: battery_pb.RelayState.ValueType\n\"\"\"State of the battery relay.\"\"\"\n\n    _component_state: battery_pb.ComponentState.ValueType\n\"\"\"State of the battery.\"\"\"\n\n    _errors: List[battery_pb.Error]\n\"\"\"List of errors in protobuf struct.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; BatteryData:\n\"\"\"Create BatteryData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of BatteryData created from the protobuf message.\n        \"\"\"\n        battery_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            soc=raw.battery.data.soc.avg,\n            soc_lower_bound=raw.battery.data.soc.system_bounds.lower,\n            soc_upper_bound=raw.battery.data.soc.system_bounds.upper,\n            capacity=raw.battery.properties.capacity,\n            power_lower_bound=raw.battery.data.dc.power.system_bounds.lower,\n            power_upper_bound=raw.battery.data.dc.power.system_bounds.upper,\n            temperature_max=raw.battery.data.temperature.max,\n            _relay_state=raw.battery.state.relay_state,\n            _component_state=raw.battery.state.component_state,\n            _errors=list(raw.battery.errors),\n        )\n        battery_data._set_raw(raw=raw)\n        return battery_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.capacity","title":"<code>capacity: float</code>  <code>instance-attribute</code>","text":"<p>The capacity of the battery in Wh (Watt-hour).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.power_lower_bound","title":"<code>power_lower_bound: float</code>  <code>instance-attribute</code>","text":"<p>The maximum discharge power, in watts, represented in the passive sign convention. this will be a negative number, or zero if no discharging is possible.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.power_upper_bound","title":"<code>power_upper_bound: float</code>  <code>instance-attribute</code>","text":"<p>The maximum charge power, in Watts, represented in the passive sign convention. This will be a positive number, or zero if no charging is possible.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.soc","title":"<code>soc: float</code>  <code>instance-attribute</code>","text":"<p>Battery's overall SoC in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.soc_lower_bound","title":"<code>soc_lower_bound: float</code>  <code>instance-attribute</code>","text":"<p>The SoC below which discharge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.soc_upper_bound","title":"<code>soc_upper_bound: float</code>  <code>instance-attribute</code>","text":"<p>The SoC above which charge commands will be blocked by the system, in percent (%).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.temperature_max","title":"<code>temperature_max: float</code>  <code>instance-attribute</code>","text":"<p>The maximum temperature of all the blocks in a battery, in Celcius (\u00b0C).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.BatteryData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.BatteryData.from_proto","title":"<code>from_proto(raw)</code>  <code>classmethod</code>","text":"<p>Create BatteryData from a protobuf message.</p> PARAMETER DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>microgrid_pb.ComponentData</code> </p> RETURNS DESCRIPTION <code>BatteryData</code> <p>Instance of BatteryData created from the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; BatteryData:\n\"\"\"Create BatteryData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of BatteryData created from the protobuf message.\n    \"\"\"\n    battery_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        soc=raw.battery.data.soc.avg,\n        soc_lower_bound=raw.battery.data.soc.system_bounds.lower,\n        soc_upper_bound=raw.battery.data.soc.system_bounds.upper,\n        capacity=raw.battery.properties.capacity,\n        power_lower_bound=raw.battery.data.dc.power.system_bounds.lower,\n        power_upper_bound=raw.battery.data.dc.power.system_bounds.upper,\n        temperature_max=raw.battery.data.temperature.max,\n        _relay_state=raw.battery.state.relay_state,\n        _component_state=raw.battery.state.component_state,\n        _errors=list(raw.battery.errors),\n    )\n    battery_data._set_raw(raw=raw)\n    return battery_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component","title":"<code>frequenz.sdk.microgrid.component.Component</code>  <code>dataclass</code>","text":"<p>Metadata for a single microgrid component.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>@dataclass(frozen=True)\nclass Component:\n\"\"\"Metadata for a single microgrid component.\"\"\"\n\n    component_id: int\n    category: ComponentCategory\n    type: Optional[ComponentType] = None\n\n    def is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n\n        Returns:\n            `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n                == 0` and `type` is `GRID`, `False` otherwise\n        \"\"\"\n        return (\n            self.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n        ) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.Component-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component.Component.is_valid","title":"<code>is_valid()</code>","text":"<p>Check if this instance contains valid data.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if <code>id &gt; 0</code> and <code>type</code> is a valid <code>ComponentCategory</code>, or if <code>id == 0</code> and <code>type</code> is <code>GRID</code>, <code>False</code> otherwise</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>def is_valid(self) -&gt; bool:\n\"\"\"Check if this instance contains valid data.\n\n    Returns:\n        `True` if `id &gt; 0` and `type` is a valid `ComponentCategory`, or if `id\n            == 0` and `type` is `GRID`, `False` otherwise\n    \"\"\"\n    return (\n        self.component_id &gt; 0 and any(t == self.category for t in ComponentCategory)\n    ) or (self.component_id == 0 and self.category == ComponentCategory.GRID)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentCategory","title":"<code>frequenz.sdk.microgrid.component.ComponentCategory</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Possible types of microgrid component.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class ComponentCategory(Enum):\n\"\"\"Possible types of microgrid component.\"\"\"\n\n    NONE = microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_UNSPECIFIED\n    GRID = microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_GRID\n    JUNCTION = microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_JUNCTION\n    METER = microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_METER\n    INVERTER = microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_INVERTER\n    BATTERY = microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_BATTERY\n    EV_CHARGER = microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_EV_CHARGER\n    LOAD = microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_LOAD\n    CHP = microgrid_pb.ComponentCategory.COMPONENT_CATEGORY_CHP\n\n    # types not yet supported by the API but which can be inferred\n    # from available graph info\n    PV_ARRAY = 1000001\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData","title":"<code>frequenz.sdk.microgrid.component.ComponentData</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ABC</code></p> <p>A private base class for strongly typed component data classes.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentData(ABC):\n\"\"\"A private base class for strongly typed component data classes.\"\"\"\n\n    component_id: int\n\"\"\"The ID identifying this component in the microgrid.\"\"\"\n\n    timestamp: datetime\n\"\"\"The timestamp of when the data was measured.\"\"\"\n\n    # The `raw` attribute is excluded from the constructor as it can only be provided\n    # when instantiating `ComponentData` using the `from_proto` method, which reads\n    # data from a protobuf message. The whole protobuf message is stored as the `raw`\n    # attribute. When `ComponentData` is not instantiated from a protobuf message,\n    # i.e. using the constructor, `raw` will be set to `None`.\n    raw: Optional[microgrid_pb.ComponentData] = field(default=None, init=False)\n\"\"\"Raw component data as decoded from the wire.\"\"\"\n\n    def _set_raw(self, raw: microgrid_pb.ComponentData) -&gt; None:\n\"\"\"Store raw protobuf message.\n\n        It is preferred to keep the dataclasses immutable (frozen) and make the `raw`\n            attribute read-only, which is why the approach of writing to `__dict__`\n            was used, instead of mutating the `self.raw = raw` attribute directly.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n        \"\"\"\n        self.__dict__[\"raw\"] = raw\n\n    @classmethod\n    @abstractmethod\n    def from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; ComponentData:\n\"\"\"Create ComponentData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.ComponentData.component_id","title":"<code>component_id: int</code>  <code>instance-attribute</code>","text":"<p>The ID identifying this component in the microgrid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.ComponentData.raw","title":"<code>raw: Optional[microgrid_pb.ComponentData] = field(default=None, init=False)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Raw component data as decoded from the wire.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.ComponentData.timestamp","title":"<code>timestamp: datetime</code>  <code>instance-attribute</code>","text":"<p>The timestamp of when the data was measured.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.ComponentData.from_proto","title":"<code>from_proto(raw)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create ComponentData from a protobuf message.</p> PARAMETER DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>microgrid_pb.ComponentData</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; ComponentData:\n\"\"\"Create ComponentData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.ComponentMetricId","title":"<code>frequenz.sdk.microgrid.component.ComponentMetricId</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enum representing the various metrics available in the microgrid.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class ComponentMetricId(Enum):\n\"\"\"An enum representing the various metrics available in the microgrid.\"\"\"\n\n    ACTIVE_POWER = \"active_power\"\n\n    CURRENT_PHASE_1 = \"current_phase_1\"\n    CURRENT_PHASE_2 = \"current_phase_2\"\n    CURRENT_PHASE_3 = \"current_phase_3\"\n\n    VOLTAGE_PHASE_1 = \"voltage_phase_1\"\n    VOLTAGE_PHASE_2 = \"voltage_phase_2\"\n    VOLTAGE_PHASE_3 = \"voltage_phase_3\"\n\n    SOC = \"soc\"\n    SOC_LOWER_BOUND = \"soc_lower_bound\"\n    SOC_UPPER_BOUND = \"soc_upper_bound\"\n    CAPACITY = \"capacity\"\n\n    POWER_LOWER_BOUND = \"power_lower_bound\"\n    POWER_UPPER_BOUND = \"power_upper_bound\"\n\n    ACTIVE_POWER_LOWER_BOUND = \"active_power_lower_bound\"\n    ACTIVE_POWER_UPPER_BOUND = \"active_power_upper_bound\"\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState","title":"<code>frequenz.sdk.microgrid.component.EVChargerCableState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Cable states of an EV Charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>class EVChargerCableState(Enum):\n\"\"\"Cable states of an EV Charger.\"\"\"\n\n    UNSPECIFIED = ev_charger_pb.CableState.CABLE_STATE_UNSPECIFIED\n    UNPLUGGED = ev_charger_pb.CableState.CABLE_STATE_UNPLUGGED\n    CHARGING_STATION_PLUGGED = (\n        ev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_PLUGGED\n    )\n    CHARGING_STATION_LOCKED = (\n        ev_charger_pb.CableState.CABLE_STATE_CHARGING_STATION_LOCKED\n    )\n    EV_PLUGGED = ev_charger_pb.CableState.CABLE_STATE_EV_PLUGGED\n    EV_LOCKED = ev_charger_pb.CableState.CABLE_STATE_EV_LOCKED\n\n    @classmethod\n    def from_pb(\n        cls, evc_state: ev_charger_pb.CableState.ValueType\n    ) -&gt; EVChargerCableState:\n\"\"\"Convert a protobuf CableState value to EVChargerCableState enum.\n\n        Args:\n            evc_state: protobuf cable state to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(t.value == evc_state for t in EVChargerCableState):\n            return cls.UNSPECIFIED\n\n        return EVChargerCableState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerCableState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_states.EVChargerCableState.from_pb","title":"<code>from_pb(evc_state)</code>  <code>classmethod</code>","text":"<p>Convert a protobuf CableState value to EVChargerCableState enum.</p> PARAMETER DESCRIPTION <code>evc_state</code> <p>protobuf cable state to convert.</p> <p> TYPE: <code>ev_charger_pb.CableState.ValueType</code> </p> RETURNS DESCRIPTION <code>EVChargerCableState</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, evc_state: ev_charger_pb.CableState.ValueType\n) -&gt; EVChargerCableState:\n\"\"\"Convert a protobuf CableState value to EVChargerCableState enum.\n\n    Args:\n        evc_state: protobuf cable state to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(t.value == evc_state for t in EVChargerCableState):\n        return cls.UNSPECIFIED\n\n    return EVChargerCableState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState","title":"<code>frequenz.sdk.microgrid.component.EVChargerComponentState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Component State of an EV Charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>class EVChargerComponentState(Enum):\n\"\"\"Component State of an EV Charger.\"\"\"\n\n    UNSPECIFIED = ev_charger_pb.ComponentState.COMPONENT_STATE_UNSPECIFIED\n    STARTING = ev_charger_pb.ComponentState.COMPONENT_STATE_STARTING\n    NOT_READY = ev_charger_pb.ComponentState.COMPONENT_STATE_NOT_READY\n    READY = ev_charger_pb.ComponentState.COMPONENT_STATE_READY\n    CHARGING = ev_charger_pb.ComponentState.COMPONENT_STATE_CHARGING\n    DISCHARGING = ev_charger_pb.ComponentState.COMPONENT_STATE_DISCHARGING\n    ERROR = ev_charger_pb.ComponentState.COMPONENT_STATE_ERROR\n    AUTHORIZATION_REJECTED = (\n        ev_charger_pb.ComponentState.COMPONENT_STATE_AUTHORIZATION_REJECTED\n    )\n    INTERRUPTED = ev_charger_pb.ComponentState.COMPONENT_STATE_INTERRUPTED\n\n    @classmethod\n    def from_pb(\n        cls, evc_state: ev_charger_pb.ComponentState.ValueType\n    ) -&gt; EVChargerComponentState:\n\"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum.\n\n        Args:\n            evc_state: protobuf component state to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(t.value == evc_state for t in EVChargerComponentState):\n            return cls.UNSPECIFIED\n\n        return EVChargerComponentState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerComponentState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_states.EVChargerComponentState.from_pb","title":"<code>from_pb(evc_state)</code>  <code>classmethod</code>","text":"<p>Convert a protobuf ComponentState value to EVChargerComponentState enum.</p> PARAMETER DESCRIPTION <code>evc_state</code> <p>protobuf component state to convert.</p> <p> TYPE: <code>ev_charger_pb.ComponentState.ValueType</code> </p> RETURNS DESCRIPTION <code>EVChargerComponentState</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_states.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, evc_state: ev_charger_pb.ComponentState.ValueType\n) -&gt; EVChargerComponentState:\n\"\"\"Convert a protobuf ComponentState value to EVChargerComponentState enum.\n\n    Args:\n        evc_state: protobuf component state to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(t.value == evc_state for t in EVChargerComponentState):\n        return cls.UNSPECIFIED\n\n    return EVChargerComponentState(evc_state)\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData","title":"<code>frequenz.sdk.microgrid.component.EVChargerData</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ComponentData</code></p> <p>A wrapper class for holding ev_charger data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass EVChargerData(ComponentData):\n\"\"\"A wrapper class for holding ev_charger data.\"\"\"\n\n    active_power: float\n\"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n        +ve current means consumption, away from the grid.\n        -ve current means supply into the grid.\n    \"\"\"\n\n    current_per_phase: Tuple[float, float, float]\n\"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n        +ve current means consumption, away from the grid.\n        -ve current means supply into the grid.\n    \"\"\"\n\n    voltage_per_phase: Tuple[float, float, float]\n\"\"\"The AC voltage in Volts (V) between the line and the neutral\n        wire for phase/line 1,2 and 3 respectively.\n    \"\"\"\n\n    cable_state: EVChargerCableState\n\"\"\"The state of the ev charger's cable.\"\"\"\n\n    component_state: EVChargerComponentState\n\"\"\"The state of the ev charger.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; EVChargerData:\n\"\"\"Create EVChargerData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of EVChargerData created from the protobuf message.\n        \"\"\"\n        ev_charger_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw.ev_charger.data.ac.power_active.value,\n            current_per_phase=(\n                raw.ev_charger.data.ac.phase_1.current.value,\n                raw.ev_charger.data.ac.phase_2.current.value,\n                raw.ev_charger.data.ac.phase_3.current.value,\n            ),\n            voltage_per_phase=(\n                raw.ev_charger.data.ac.phase_1.voltage.value,\n                raw.ev_charger.data.ac.phase_2.voltage.value,\n                raw.ev_charger.data.ac.phase_3.voltage.value,\n            ),\n            cable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\n            component_state=EVChargerComponentState.from_pb(\n                raw.ev_charger.state.component_state\n            ),\n        )\n        ev_charger_data._set_raw(raw=raw)\n        return ev_charger_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.active_power","title":"<code>active_power: float</code>  <code>instance-attribute</code>","text":"<p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.cable_state","title":"<code>cable_state: EVChargerCableState</code>  <code>instance-attribute</code>","text":"<p>The state of the ev charger's cable.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.component_state","title":"<code>component_state: EVChargerComponentState</code>  <code>instance-attribute</code>","text":"<p>The state of the ev charger.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.current_per_phase","title":"<code>current_per_phase: Tuple[float, float, float]</code>  <code>instance-attribute</code>","text":"<p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.voltage_per_phase","title":"<code>voltage_per_phase: Tuple[float, float, float]</code>  <code>instance-attribute</code>","text":"<p>The AC voltage in Volts (V) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.EVChargerData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.EVChargerData.from_proto","title":"<code>from_proto(raw)</code>  <code>classmethod</code>","text":"<p>Create EVChargerData from a protobuf message.</p> PARAMETER DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>microgrid_pb.ComponentData</code> </p> RETURNS DESCRIPTION <code>EVChargerData</code> <p>Instance of EVChargerData created from the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; EVChargerData:\n\"\"\"Create EVChargerData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of EVChargerData created from the protobuf message.\n    \"\"\"\n    ev_charger_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw.ev_charger.data.ac.power_active.value,\n        current_per_phase=(\n            raw.ev_charger.data.ac.phase_1.current.value,\n            raw.ev_charger.data.ac.phase_2.current.value,\n            raw.ev_charger.data.ac.phase_3.current.value,\n        ),\n        voltage_per_phase=(\n            raw.ev_charger.data.ac.phase_1.voltage.value,\n            raw.ev_charger.data.ac.phase_2.voltage.value,\n            raw.ev_charger.data.ac.phase_3.voltage.value,\n        ),\n        cable_state=EVChargerCableState.from_pb(raw.ev_charger.state.cable_state),\n        component_state=EVChargerComponentState.from_pb(\n            raw.ev_charger.state.component_state\n        ),\n    )\n    ev_charger_data._set_raw(raw=raw)\n    return ev_charger_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData","title":"<code>frequenz.sdk.microgrid.component.InverterData</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ComponentData</code></p> <p>A wrapper class for holding inverter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass InverterData(ComponentData):\n\"\"\"A wrapper class for holding inverter data.\"\"\"\n\n    active_power: float\n\"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\n\n    active_power_lower_bound: float\n\"\"\"The maximum discharge power, in Watts, represented in the passive sign\n        convention. This will be a negative number, or zero if no discharging is\n        possible.\n    \"\"\"\n\n    active_power_upper_bound: float\n\"\"\"The maximum charge power, in Watts, represented in the passive sign convention.\n        This will be a positive number, or zero if no charging is possible.\n    \"\"\"\n\n    _component_state: inverter_pb.ComponentState.ValueType\n\"\"\"State of the inverter.\"\"\"\n\n    _errors: List[inverter_pb.Error]\n\"\"\"List of errors from the component.\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; InverterData:\n\"\"\"Create InverterData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of InverterData created from the protobuf message.\n        \"\"\"\n        inverter_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw.inverter.data.ac.power_active.value,\n            active_power_lower_bound=raw.inverter.data.ac.power_active.system_bounds.lower,\n            active_power_upper_bound=raw.inverter.data.ac.power_active.system_bounds.upper,\n            _component_state=raw.inverter.state.component_state,\n            _errors=list(raw.inverter.errors),\n        )\n\n        inverter_data._set_raw(raw=raw)\n        return inverter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.InverterData.active_power","title":"<code>active_power: float</code>  <code>instance-attribute</code>","text":"<p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.InverterData.active_power_lower_bound","title":"<code>active_power_lower_bound: float</code>  <code>instance-attribute</code>","text":"<p>The maximum discharge power, in Watts, represented in the passive sign convention. This will be a negative number, or zero if no discharging is possible.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.InverterData.active_power_upper_bound","title":"<code>active_power_upper_bound: float</code>  <code>instance-attribute</code>","text":"<p>The maximum charge power, in Watts, represented in the passive sign convention. This will be a positive number, or zero if no charging is possible.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.InverterData.from_proto","title":"<code>from_proto(raw)</code>  <code>classmethod</code>","text":"<p>Create InverterData from a protobuf message.</p> PARAMETER DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>microgrid_pb.ComponentData</code> </p> RETURNS DESCRIPTION <code>InverterData</code> <p>Instance of InverterData created from the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; InverterData:\n\"\"\"Create InverterData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of InverterData created from the protobuf message.\n    \"\"\"\n    inverter_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw.inverter.data.ac.power_active.value,\n        active_power_lower_bound=raw.inverter.data.ac.power_active.system_bounds.lower,\n        active_power_upper_bound=raw.inverter.data.ac.power_active.system_bounds.upper,\n        _component_state=raw.inverter.state.component_state,\n        _errors=list(raw.inverter.errors),\n    )\n\n    inverter_data._set_raw(raw=raw)\n    return inverter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.InverterType","title":"<code>frequenz.sdk.microgrid.component.InverterType</code>","text":"<p>         Bases: <code>ComponentType</code></p> <p>Enum representing inverter types.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component.py</code> <pre><code>class InverterType(ComponentType):\n\"\"\"Enum representing inverter types.\"\"\"\n\n    NONE = inverter_pb.Type.TYPE_UNSPECIFIED\n    BATTERY = inverter_pb.Type.TYPE_BATTERY\n    SOLAR = inverter_pb.Type.TYPE_SOLAR\n    HYBRID = inverter_pb.Type.TYPE_HYBRID\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData","title":"<code>frequenz.sdk.microgrid.component.MeterData</code>  <code>dataclass</code>","text":"<p>         Bases: <code>ComponentData</code></p> <p>A wrapper class for holding meter data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@dataclass(frozen=True)\nclass MeterData(ComponentData):\n\"\"\"A wrapper class for holding meter data.\"\"\"\n\n    active_power: float\n\"\"\"The 3-phase active power, in Watts, represented in the passive sign convention.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\n\n    current_per_phase: Tuple[float, float, float]\n\"\"\"AC current in Amperes (A) for phase/line 1,2 and 3 respectively.\n            +ve current means consumption, away from the grid.\n            -ve current means supply into the grid.\n    \"\"\"\n\n    voltage_per_phase: Tuple[float, float, float]\n\"\"\"The ac voltage in volts (v) between the line and the neutral wire for phase/line\n        1,2 and 3 respectively.\n    \"\"\"\n\n    frequency: float\n\"\"\"The AC power frequency in Hertz (Hz).\"\"\"\n\n    @classmethod\n    def from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; MeterData:\n\"\"\"Create MeterData from a protobuf message.\n\n        Args:\n            raw: raw component data as decoded from the wire.\n\n        Returns:\n            Instance of MeterData created from the protobuf message.\n        \"\"\"\n        meter_data = cls(\n            component_id=raw.id,\n            timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n            active_power=raw.meter.data.ac.power_active.value,\n            current_per_phase=(\n                raw.meter.data.ac.phase_1.current.value,\n                raw.meter.data.ac.phase_2.current.value,\n                raw.meter.data.ac.phase_3.current.value,\n            ),\n            voltage_per_phase=(\n                raw.meter.data.ac.phase_1.voltage.value,\n                raw.meter.data.ac.phase_2.voltage.value,\n                raw.meter.data.ac.phase_3.voltage.value,\n            ),\n            frequency=raw.meter.data.ac.frequency.value,\n        )\n        meter_data._set_raw(raw=raw)\n        return meter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.MeterData.active_power","title":"<code>active_power: float</code>  <code>instance-attribute</code>","text":"<p>The 3-phase active power, in Watts, represented in the passive sign convention. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.MeterData.current_per_phase","title":"<code>current_per_phase: Tuple[float, float, float]</code>  <code>instance-attribute</code>","text":"<p>AC current in Amperes (A) for phase/line 1,2 and 3 respectively. +ve current means consumption, away from the grid. -ve current means supply into the grid.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.MeterData.frequency","title":"<code>frequency: float</code>  <code>instance-attribute</code>","text":"<p>The AC power frequency in Hertz (Hz).</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.MeterData.voltage_per_phase","title":"<code>voltage_per_phase: Tuple[float, float, float]</code>  <code>instance-attribute</code>","text":"<p>The ac voltage in volts (v) between the line and the neutral wire for phase/line 1,2 and 3 respectively.</p>"},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component.MeterData-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/microgrid/component/#frequenz.sdk.microgrid.component._component_data.MeterData.from_proto","title":"<code>from_proto(raw)</code>  <code>classmethod</code>","text":"<p>Create MeterData from a protobuf message.</p> PARAMETER DESCRIPTION <code>raw</code> <p>raw component data as decoded from the wire.</p> <p> TYPE: <code>microgrid_pb.ComponentData</code> </p> RETURNS DESCRIPTION <code>MeterData</code> <p>Instance of MeterData created from the protobuf message.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/microgrid/component/_component_data.py</code> <pre><code>@classmethod\ndef from_proto(cls, raw: microgrid_pb.ComponentData) -&gt; MeterData:\n\"\"\"Create MeterData from a protobuf message.\n\n    Args:\n        raw: raw component data as decoded from the wire.\n\n    Returns:\n        Instance of MeterData created from the protobuf message.\n    \"\"\"\n    meter_data = cls(\n        component_id=raw.id,\n        timestamp=raw.ts.ToDatetime(tzinfo=timezone.utc),\n        active_power=raw.meter.data.ac.power_active.value,\n        current_per_phase=(\n            raw.meter.data.ac.phase_1.current.value,\n            raw.meter.data.ac.phase_2.current.value,\n            raw.meter.data.ac.phase_3.current.value,\n        ),\n        voltage_per_phase=(\n            raw.meter.data.ac.phase_1.voltage.value,\n            raw.meter.data.ac.phase_2.voltage.value,\n            raw.meter.data.ac.phase_3.voltage.value,\n        ),\n        frequency=raw.meter.data.ac.frequency.value,\n    )\n    meter_data._set_raw(raw=raw)\n    return meter_data\n</code></pre>"},{"location":"reference/frequenz/sdk/power/","title":"power","text":""},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power","title":"<code>frequenz.sdk.power</code>","text":"<p>Utilities to manage power in a microgrid.</p>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.DistributionAlgorithm","title":"<code>frequenz.sdk.power.DistributionAlgorithm</code>","text":"<p>Distribute power between many components.</p> <p>The purpose of this tool is to keep equal SoC level in the batteries. It takes total power that should be to be set for some subset of battery-inverter pairs. The total power is distributed between given battery-inverter pairs. Distribution is calculated based on data below:</p> <ul> <li>Battery current SoC.</li> <li>Battery upper and lower SoC bound.</li> <li>Battery capacity.</li> <li>Battery lower and upper power bound.</li> <li>Inverter lower and upper active power bound.</li> </ul>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.DistributionAlgorithm--distribution-algorithm","title":"Distribution algorithm","text":"<p>Lets assume that:</p> <ul> <li><code>N</code> - number of batteries</li> <li><code>power_w</code> - power to distribute</li> <li><code>capacity[i]</code> - capacity of i'th battery</li> <li> <p><code>available_soc[i]</code> - how much SoC remained to reach:</p> <ul> <li>SoC upper bound - if need to distribute power that charges inverters.</li> <li>SoC lower bound - if need to distribute power that discharges inverters.</li> <li><code>0</code> - if SoC is outside SoC bounds.</li> </ul> </li> <li> <p><code>total_capacity</code> - <code>sum(c for c in capacity.values())</code></p> </li> <li><code>capacity_ratio[i]</code> - <code>capacity[i]/total_capacity</code></li> </ul> <p>We would like our distribution to meet the equation:</p> <pre><code>distribution[i] = power_w * capacity_ratio[i] * x[i]\n</code></pre> <p>where:</p> <pre><code>sum(capacity_ratio[i] * x[i] for i in range(N)) == 1\n</code></pre> <p>Let <code>y</code> be our unknown, the proportion to discharge each battery would be (1):</p> <pre><code>x[i] = available_soc[i]*y\n</code></pre> <p>We can compute <code>y</code> from equation above (2):</p> <pre><code>sum(capacity_ratio[i] * x[i] for i in range(N)) == 1\n# =&gt;\nsum(capacity_ratio[i] * available_soc[i] * y for i in range(N)) == 1\n# =&gt;\ny = 1 / sum(capacity_ratio[i] * available_soc[i])\n</code></pre> <p>Now we know everything and we can compute distribution:</p> <pre><code>distribution[i] = power_w * capacity_ratio[i] * x[i]  # from (1)\ndistribution[i] = \\\n        power_w * capacity_ratio[i] * available_soc[i] * y  # from (2)\ndistribution[i] = power_w * capacity_ratio[i] * available_soc[i] * \\\n        1/sum(capacity_ratio[i] * available_soc[i])\n</code></pre> <p>Let:</p> <pre><code>battery_availability_ratio[i] = capacity_ratio[i] * available_soc[i]\ntotal_battery_availability_ratio = sum(battery_availability_ratio)\n</code></pre> <p>Then: <pre><code>distribution[i] = power_w * battery_availability_ratio[i] \\\n        / total_battery_availability_ratio\n</code></pre></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/power/_distribution_algorithm.py</code> <pre><code>class DistributionAlgorithm:\nr\"\"\"Distribute power between many components.\n\n    The purpose of this tool is to keep equal SoC level in the batteries.\n    It takes total power that should be to be set for some subset of battery-inverter\n    pairs. The total power is distributed between given battery-inverter pairs.\n    Distribution is calculated based on data below:\n\n    * Battery current SoC.\n    * Battery upper and lower SoC bound.\n    * Battery capacity.\n    * Battery lower and upper power bound.\n    * Inverter lower and upper active power bound.\n\n    # Distribution algorithm\n\n    Lets assume that:\n\n    * `N` - number of batteries\n    * `power_w` - power to distribute\n    * `capacity[i]` - capacity of i'th battery\n    * `available_soc[i]` - how much SoC remained to reach:\n        * SoC upper bound - if need to distribute power that charges inverters.\n        * SoC lower bound - if need to distribute power that discharges inverters.\n        * `0` - if SoC is outside SoC bounds.\n\n    * `total_capacity` - `sum(c for c in capacity.values())`\n    * `capacity_ratio[i]` - `capacity[i]/total_capacity`\n\n\n    We would like our distribution to meet the equation:\n\n    ```\n    distribution[i] = power_w * capacity_ratio[i] * x[i]\n    ```\n\n    where:\n\n    ```\n    sum(capacity_ratio[i] * x[i] for i in range(N)) == 1\n    ```\n\n    Let `y` be our unknown, the proportion to discharge each battery would be\n    (1):\n\n    ```\n    x[i] = available_soc[i]*y\n    ```\n\n    We can compute `y` from equation above (2):\n\n    ```\n    sum(capacity_ratio[i] * x[i] for i in range(N)) == 1\n    # =&gt;\n    sum(capacity_ratio[i] * available_soc[i] * y for i in range(N)) == 1\n    # =&gt;\n    y = 1 / sum(capacity_ratio[i] * available_soc[i])\n    ```\n\n    Now we know everything and we can compute distribution:\n\n    ```\n    distribution[i] = power_w * capacity_ratio[i] * x[i]  # from (1)\n    distribution[i] = \\\n            power_w * capacity_ratio[i] * available_soc[i] * y  # from (2)\n    distribution[i] = power_w * capacity_ratio[i] * available_soc[i] * \\\n            1/sum(capacity_ratio[i] * available_soc[i])\n    ```\n\n    Let:\n\n    ```\n    battery_availability_ratio[i] = capacity_ratio[i] * available_soc[i]\n    total_battery_availability_ratio = sum(battery_availability_ratio)\n    ```\n\n    Then:\n    ```\n    distribution[i] = power_w * battery_availability_ratio[i] \\\n            / total_battery_availability_ratio\n    ```\n    \"\"\"\n\n    def __init__(self, distributor_exponent: float = 1) -&gt; None:\n\"\"\"Create distribution algorithm instance.\n\n        Args:\n            distributor_exponent: How fast the batteries should strive to the\n                equal SoC level. Should be float &gt;= 0. Defaults=1.\n                For example for distributor_exponent equal:\n                    * 1 - means that proportion will be linear from SoC.\n                    * 2 - means proportion would be like squared from SoC\n                    * 3 - means proportion would be like x^3 from SoC.\n\n        Example:\n            Lets say we have two batteries `Bat1` and `Bat2`. All parameters\n            except SoC are equal. SoC bounds for each battery is `lower = 20`,\n            `upper = 80`.\n\n            # Example 1\n\n            Let:\n\n            * `Bat1.soc = 70` and `Bat2.soc = 50`.\n            * `Bat1.available_soc = 10`, `Bat2.available_soc = 30`\n            * `Bat1.available_soc / Bat2.available_soc = 3`\n\n            We need to distribute 8000W.\n\n            If `distribution_exponent` is:\n\n            * `0`: distribution for each battery will be the equal.\n              ```python\n              BAT1_DISTRIBUTION = 4000\n              BAT2_DISTRIBUTION = 4000\n              ```\n\n            * `1`: then `Bat2` will have 3x more power assigned then `Bat1`.\n              ```python\n              # 10 * x + 30 * x = 8000\n              X = 200\n              BAT1_DISTRIBUTION = 2000\n              BAT2_DISTRIBUTION = 6000\n              ```\n\n            * `2`: then `Bat2` will have 9x more power assigned then `Bat1`.\n              ```python\n              # 10^2 * x + 30^2 * x = 8000\n              X = 80\n              BAT1_DISTRIBUTION = 800\n              BAT2_DISTRIBUTION = 7200\n              ```\n\n            * `3`: then `Bat2` will have 27x more power assigned then `Bat1`.\n              ```python\n              # 10^3 * x + 30^3 * x = 8000\n              X = 0.285714286\n              BAT1_DISTRIBUTION = 285\n              BAT2_DISTRIBUTION = 7715\n              ```\n\n            # Example 2\n\n            Let:\n\n            * `Bat1.soc = 50` and `Bat2.soc = 20`.\n            * `Bat1.available_soc = 30`, `Bat2.available_soc = 60`\n            * `Bat1.available_soc / Bat2.available_soc = 2`\n\n            We need to distribute 900W.\n\n            If `distribution_exponent` is:\n\n            * `0`: distribution for each battery will be the same.\n              ```python\n              BAT1_DISTRIBUTION = 4500\n              BAT2_DISTRIBUTION = 450\n              ```\n\n            * `1`: then `Bat2` will have 2x more power assigned then `Bat1`.\n              ```python\n              # 30 * x + 60 * x = 900\n              X = 100\n              BAT1_DISTRIBUTION = 300\n              BAT2_DISTRIBUTION = 600\n              ```\n\n            * `2`: then `Bat2` will have 4x more power assigned then `Bat1`.\n              ```python\n              # 30^2 * x + 60^2 * x = 900\n              X = 0.2\n              BAT1_DISTRIBUTION = 180\n              BAT2_DISTRIBUTION = 720\n              ```\n\n            * `3`: then `Bat2` will have 8x more power assigned then `Bat1`.\n              ```python\n              # 30^3 * x + 60^3 * x = 900\n              X = 0.003703704\n              BAT1_DISTRIBUTION = 100\n              BAT2_DISTRIBUTION = 800\n              ```\n\n            # Example 3\n\n            Let:\n\n            * `Bat1.soc = 44` and `Bat2.soc = 64`.\n            * `Bat1.available_soc = 36 (80 - 44)`, `Bat2.available_soc = 16 (80 - 64)`\n\n            We need to distribute 900W.\n\n            If `distribution_exponent` is:\n\n            * `0`: distribution for each battery will be the equal.\n              ```python\n              BAT1_DISTRIBUTION = 450\n              BAT2_DISTRIBUTION = 450\n              ```\n\n            * `0.5`: then `Bat2` will have 6/4x more power assigned then `Bat1`.\n              ```python\n              # sqrt(36) * x + sqrt(16) * x = 900\n              X = 100\n              BAT1_DISTRIBUTION = 600\n              BAT2_DISTRIBUTION = 400\n              ```\n\n        Raises:\n            ValueError: If distributor_exponent &lt; 0\n        \"\"\"\n        super().__init__()\n\n        if distributor_exponent &lt; 0:\n            raise ValueError(\"Distribution factor should be float &gt;= 0.\")\n        self._distributor_exponent: float = distributor_exponent\n\n    def _total_capacity(self, components: List[InvBatPair]) -&gt; float:\n\"\"\"Sum capacity between all batteries in the components list.\n\n        Args:\n            components: list of the components\n\n        Raises:\n            ValueError: If total capacity is 0.\n\n        Returns:\n            Sum of all batteries capacity in the components list.\n        \"\"\"\n        total_capacity: float = sum(bat.capacity for bat, _ in components)\n        if is_close_to_zero(total_capacity):\n            msg = \"All batteries have capacity 0.\"\n            _logger.error(msg)\n            raise ValueError(msg)\n\n        return total_capacity\n\n    def _compute_battery_availability_ratio(\n        self, components: List[InvBatPair], available_soc: Dict[int, float]\n    ) -&gt; Tuple[List[Tuple[InvBatPair, float]], float]:\nr\"\"\"Compute battery ratio and the total sum of all of them.\n\n        battery_availability_ratio = capacity_ratio[i] * available_soc[i]\n        Where:\n        capacity_ratio[i] = components[i].battery.capacity \\\n            / sum(battery.capacity for battery, _ in components)\n\n        Args:\n            components: list of the components\n            available_soc: How much SoC remained to reach\n                * SoC upper bound - if need to distribute consumption power\n                * SoC lower bound - if need to distribute supply power\n\n        Returns:\n            Tuple where first argument is battery availability ratio for each\n                battery-inverter pair. The list is sorted by ratio in\n                descending order.  The second element of the tuple is total sum\n                of all battery ratios in the list.\n        \"\"\"\n        total_capacity = self._total_capacity(components)\n        battery_availability_ratio: List[Tuple[InvBatPair, float]] = []\n        total_battery_availability_ratio: float = 0.0\n\n        for pair in components:\n            battery = pair[0]\n            capacity_ratio = battery.capacity / total_capacity\n            soc_factor = pow(\n                available_soc[battery.component_id], self._distributor_exponent\n            )\n\n            ratio = capacity_ratio * soc_factor\n            battery_availability_ratio.append((pair, ratio))\n            total_battery_availability_ratio += ratio\n\n        battery_availability_ratio.sort(key=lambda item: item[1], reverse=True)\n\n        return battery_availability_ratio, total_battery_availability_ratio\n\n    def _distribute_power(\n        self,\n        components: List[InvBatPair],\n        power_w: float,\n        available_soc: Dict[int, float],\n        upper_bounds: Dict[int, float],\n    ) -&gt; DistributionResult:\n        # pylint: disable=too-many-locals\n\"\"\"Distribute power between given components.\n\n        After this method power should be distributed between batteries\n        in a way that equalize SoC between batteries.\n\n        Args:\n            components: list of components.\n            power_w: power to distribute\n            available_soc: how much SoC remained to reach:\n                * SoC upper bound - if need to distribute consumption power\n                * SoC lower bound - if need to distribute supply power\n            upper_bounds: Min between upper bound of each pair in the components list:\n                * supply upper bound - if need to distribute consumption power\n                * consumption lower bound - if need to distribute supply power\n\n        Returns:\n            Distribution result.\n        \"\"\"\n        (\n            battery_availability_ratio,\n            sum_ratio,\n        ) = self._compute_battery_availability_ratio(components, available_soc)\n\n        distribution: Dict[int, float] = {}\n\n        # sum_ratio == 0 means that all batteries are fully charged / discharged\n        if is_close_to_zero(sum_ratio):\n            distribution = {inverter.component_id: 0 for _, inverter in components}\n            return DistributionResult(distribution, power_w)\n\n        distributed_power: float = 0.0\n        power_to_distribute: float = power_w\n        used_ratio: float = 0.0\n        ratio = sum_ratio\n        for pair, battery_ratio in battery_availability_ratio:\n            inverter = pair[1]\n            # ratio = 0, means all remaining batteries reach max SoC lvl or have no\n            # capacity\n            if is_close_to_zero(ratio):\n                distribution[inverter.component_id] = 0.0\n                continue\n\n            distribution[inverter.component_id] = (\n                power_to_distribute * battery_ratio / ratio\n            )\n\n            used_ratio += battery_ratio\n\n            # If the power allocated for that inverter is out of bound,\n            # then we need to distribute more power over all remaining batteries.\n            upper_bound = upper_bounds[inverter.component_id]\n            if distribution[inverter.component_id] &gt; upper_bound:\n                distribution[inverter.component_id] = upper_bound\n                distributed_power += upper_bound\n                # Distribute only the remaining power.\n                power_to_distribute = power_w - distributed_power\n                # Distribute between remaining batteries\n                ratio = sum_ratio - used_ratio\n            else:\n                distributed_power += distribution[inverter.component_id]\n\n        return DistributionResult(distribution, power_w - distributed_power)\n\n    def _greedy_distribute_remaining_power(\n        self,\n        distribution: Dict[int, float],\n        upper_bounds: Dict[int, float],\n        remaining_power: float,\n    ) -&gt; DistributionResult:\n\"\"\"Add remaining power greedily to the given distribution.\n\n        Distribution for each inverter will not exceed its upper bound.\n\n        Args:\n            distribution: distribution\n            upper_bounds: upper bounds inverter and adjacent battery in\n                distribution.\n            remaining_power: power to distribute\n\n        Returns:\n            Return the power for each inverter in given distribution.\n        \"\"\"\n        if is_close_to_zero(remaining_power):\n            return DistributionResult(distribution, remaining_power)\n\n        new_distribution: Dict[int, float] = {}\n\n        for inverter_id, power in distribution.items():\n            if is_close_to_zero(remaining_power) or is_close_to_zero(power):\n                new_distribution[inverter_id] = power\n            else:\n                remaining_power_capacity: float = upper_bounds[inverter_id] - power\n                to_add = min(remaining_power_capacity, remaining_power)\n                new_distribution[inverter_id] = power + to_add\n                remaining_power -= to_add\n\n        return DistributionResult(new_distribution, remaining_power)\n\n    def distribute_power_equally(\n        self, power: float, inverters: set[int]\n    ) -&gt; DistributionResult:\n\"\"\"Distribute the power equally between the inverters in the set.\n\n        This function is mainly useful to set the power for components that are\n        broken or have no metrics available.\n\n        Args:\n            power: the power to distribute.\n            inverters: the inverters to set the power to.\n\n        Returns:\n            the power distribution result.\n        \"\"\"\n        power_per_inverter = power / len(inverters)\n        return DistributionResult(\n            distribution={id: power_per_inverter for id in inverters},\n            remaining_power=0.0,\n        )\n\n    def distribute_power(\n        self, power: float, components: List[InvBatPair]\n    ) -&gt; DistributionResult:\n\"\"\"Distribute given power between given components.\n\n        Args:\n            power: Power to distribute\n            components: InvBatPaired components data. Each pair should have data\n                for battery and adjacent inverter.\n\n        Returns:\n            Distribution result\n        \"\"\"\n        if power &gt;= 0.0:\n            return self._distribute_consume_power(power, components)\n        return self._distribute_supply_power(power, components)\n\n    def _distribute_consume_power(\n        self, power_w: float, components: List[InvBatPair]\n    ) -&gt; DistributionResult:\n\"\"\"Distribute power between the given components.\n\n        Distribute power in a way that the SoC level between given components will:\n            * stay on the same level, equal in all given components\n            * will try to align himself to the same level.\n\n        Args:\n            power_w: power to distribute\n            components: list of components between which the power should be\n                distributed.\n\n        Returns:\n            Distribution result, batteries with no SoC and capacity won't be used.\n        \"\"\"\n        # If SoC exceeded bound then remaining SoC should be 0.\n        # Otherwise algorithm would try to supply power from that battery\n        # in order to keep equal SoC level.\n        available_soc: Dict[int, float] = {}\n        for battery, _ in components:\n            available_soc[battery.component_id] = max(\n                0.0, battery.soc_upper_bound - battery.soc\n            )\n\n        bounds: Dict[int, float] = {}\n        for battery, inverter in components:\n            # We can supply/consume with int only\n            inverter_bound = inverter.active_power_upper_bound\n            battery_bound = battery.power_upper_bound\n            bounds[inverter.component_id] = min(inverter_bound, battery_bound)\n\n        result: DistributionResult = self._distribute_power(\n            components, power_w, available_soc, bounds\n        )\n\n        return self._greedy_distribute_remaining_power(\n            result.distribution, bounds, result.remaining_power\n        )\n\n    def _distribute_supply_power(\n        self, power_w: float, components: List[InvBatPair]\n    ) -&gt; DistributionResult:\n\"\"\"Distribute power between the given components.\n\n        Distribute power in a way that the SoC level between given components will:\n            * stay on the same level, equal in all given components\n            * will try to align himself to the same level.\n\n        Args:\n            power_w: power to distribute\n            components: list of components between which the power should be\n                distributed.\n\n        Returns:\n            Distribution result.\n        \"\"\"\n        available_soc: Dict[int, float] = {}\n        for battery, _ in components:\n            available_soc[battery.component_id] = max(\n                0.0, battery.soc - battery.soc_lower_bound\n            )\n\n        bounds: Dict[int, float] = {}\n        for battery, inverter in components:\n            # We can consume with int only\n            inverter_bound = inverter.active_power_lower_bound\n            battery_bound = battery.power_lower_bound\n            bounds[inverter.component_id] = -1 * max(inverter_bound, battery_bound)\n\n        result: DistributionResult = self._distribute_power(\n            components, -1 * power_w, available_soc, bounds\n        )\n\n        result = self._greedy_distribute_remaining_power(\n            result.distribution, bounds, result.remaining_power\n        )\n\n        for inverter_id in result.distribution.keys():\n            result.distribution[inverter_id] *= -1\n        result.remaining_power *= -1\n\n        return result\n</code></pre>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.DistributionAlgorithm-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionAlgorithm.__init__","title":"<code>__init__(distributor_exponent=1)</code>","text":"<p>Create distribution algorithm instance.</p> PARAMETER DESCRIPTION <code>distributor_exponent</code> <p>How fast the batteries should strive to the equal SoC level. Should be float &gt;= 0. Defaults=1. For example for distributor_exponent equal:     * 1 - means that proportion will be linear from SoC.     * 2 - means proportion would be like squared from SoC     * 3 - means proportion would be like x^3 from SoC.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1</code> </p> Example <p>Lets say we have two batteries <code>Bat1</code> and <code>Bat2</code>. All parameters except SoC are equal. SoC bounds for each battery is <code>lower = 20</code>, <code>upper = 80</code>.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If distributor_exponent &lt; 0</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/power/_distribution_algorithm.py</code> <pre><code>def __init__(self, distributor_exponent: float = 1) -&gt; None:\n\"\"\"Create distribution algorithm instance.\n\n    Args:\n        distributor_exponent: How fast the batteries should strive to the\n            equal SoC level. Should be float &gt;= 0. Defaults=1.\n            For example for distributor_exponent equal:\n                * 1 - means that proportion will be linear from SoC.\n                * 2 - means proportion would be like squared from SoC\n                * 3 - means proportion would be like x^3 from SoC.\n\n    Example:\n        Lets say we have two batteries `Bat1` and `Bat2`. All parameters\n        except SoC are equal. SoC bounds for each battery is `lower = 20`,\n        `upper = 80`.\n\n        # Example 1\n\n        Let:\n\n        * `Bat1.soc = 70` and `Bat2.soc = 50`.\n        * `Bat1.available_soc = 10`, `Bat2.available_soc = 30`\n        * `Bat1.available_soc / Bat2.available_soc = 3`\n\n        We need to distribute 8000W.\n\n        If `distribution_exponent` is:\n\n        * `0`: distribution for each battery will be the equal.\n          ```python\n          BAT1_DISTRIBUTION = 4000\n          BAT2_DISTRIBUTION = 4000\n          ```\n\n        * `1`: then `Bat2` will have 3x more power assigned then `Bat1`.\n          ```python\n          # 10 * x + 30 * x = 8000\n          X = 200\n          BAT1_DISTRIBUTION = 2000\n          BAT2_DISTRIBUTION = 6000\n          ```\n\n        * `2`: then `Bat2` will have 9x more power assigned then `Bat1`.\n          ```python\n          # 10^2 * x + 30^2 * x = 8000\n          X = 80\n          BAT1_DISTRIBUTION = 800\n          BAT2_DISTRIBUTION = 7200\n          ```\n\n        * `3`: then `Bat2` will have 27x more power assigned then `Bat1`.\n          ```python\n          # 10^3 * x + 30^3 * x = 8000\n          X = 0.285714286\n          BAT1_DISTRIBUTION = 285\n          BAT2_DISTRIBUTION = 7715\n          ```\n\n        # Example 2\n\n        Let:\n\n        * `Bat1.soc = 50` and `Bat2.soc = 20`.\n        * `Bat1.available_soc = 30`, `Bat2.available_soc = 60`\n        * `Bat1.available_soc / Bat2.available_soc = 2`\n\n        We need to distribute 900W.\n\n        If `distribution_exponent` is:\n\n        * `0`: distribution for each battery will be the same.\n          ```python\n          BAT1_DISTRIBUTION = 4500\n          BAT2_DISTRIBUTION = 450\n          ```\n\n        * `1`: then `Bat2` will have 2x more power assigned then `Bat1`.\n          ```python\n          # 30 * x + 60 * x = 900\n          X = 100\n          BAT1_DISTRIBUTION = 300\n          BAT2_DISTRIBUTION = 600\n          ```\n\n        * `2`: then `Bat2` will have 4x more power assigned then `Bat1`.\n          ```python\n          # 30^2 * x + 60^2 * x = 900\n          X = 0.2\n          BAT1_DISTRIBUTION = 180\n          BAT2_DISTRIBUTION = 720\n          ```\n\n        * `3`: then `Bat2` will have 8x more power assigned then `Bat1`.\n          ```python\n          # 30^3 * x + 60^3 * x = 900\n          X = 0.003703704\n          BAT1_DISTRIBUTION = 100\n          BAT2_DISTRIBUTION = 800\n          ```\n\n        # Example 3\n\n        Let:\n\n        * `Bat1.soc = 44` and `Bat2.soc = 64`.\n        * `Bat1.available_soc = 36 (80 - 44)`, `Bat2.available_soc = 16 (80 - 64)`\n\n        We need to distribute 900W.\n\n        If `distribution_exponent` is:\n\n        * `0`: distribution for each battery will be the equal.\n          ```python\n          BAT1_DISTRIBUTION = 450\n          BAT2_DISTRIBUTION = 450\n          ```\n\n        * `0.5`: then `Bat2` will have 6/4x more power assigned then `Bat1`.\n          ```python\n          # sqrt(36) * x + sqrt(16) * x = 900\n          X = 100\n          BAT1_DISTRIBUTION = 600\n          BAT2_DISTRIBUTION = 400\n          ```\n\n    Raises:\n        ValueError: If distributor_exponent &lt; 0\n    \"\"\"\n    super().__init__()\n\n    if distributor_exponent &lt; 0:\n        raise ValueError(\"Distribution factor should be float &gt;= 0.\")\n    self._distributor_exponent: float = distributor_exponent\n</code></pre>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionAlgorithm.__init__--example-1","title":"Example 1","text":"<p>Let:</p> <ul> <li><code>Bat1.soc = 70</code> and <code>Bat2.soc = 50</code>.</li> <li><code>Bat1.available_soc = 10</code>, <code>Bat2.available_soc = 30</code></li> <li><code>Bat1.available_soc / Bat2.available_soc = 3</code></li> </ul> <p>We need to distribute 8000W.</p> <p>If <code>distribution_exponent</code> is:</p> <ul> <li> <p><code>0</code>: distribution for each battery will be the equal.   <pre><code>BAT1_DISTRIBUTION = 4000\nBAT2_DISTRIBUTION = 4000\n</code></pre></p> </li> <li> <p><code>1</code>: then <code>Bat2</code> will have 3x more power assigned then <code>Bat1</code>.   <pre><code># 10 * x + 30 * x = 8000\nX = 200\nBAT1_DISTRIBUTION = 2000\nBAT2_DISTRIBUTION = 6000\n</code></pre></p> </li> <li> <p><code>2</code>: then <code>Bat2</code> will have 9x more power assigned then <code>Bat1</code>.   <pre><code># 10^2 * x + 30^2 * x = 8000\nX = 80\nBAT1_DISTRIBUTION = 800\nBAT2_DISTRIBUTION = 7200\n</code></pre></p> </li> <li> <p><code>3</code>: then <code>Bat2</code> will have 27x more power assigned then <code>Bat1</code>.   <pre><code># 10^3 * x + 30^3 * x = 8000\nX = 0.285714286\nBAT1_DISTRIBUTION = 285\nBAT2_DISTRIBUTION = 7715\n</code></pre></p> </li> </ul>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionAlgorithm.__init__--example-2","title":"Example 2","text":"<p>Let:</p> <ul> <li><code>Bat1.soc = 50</code> and <code>Bat2.soc = 20</code>.</li> <li><code>Bat1.available_soc = 30</code>, <code>Bat2.available_soc = 60</code></li> <li><code>Bat1.available_soc / Bat2.available_soc = 2</code></li> </ul> <p>We need to distribute 900W.</p> <p>If <code>distribution_exponent</code> is:</p> <ul> <li> <p><code>0</code>: distribution for each battery will be the same.   <pre><code>BAT1_DISTRIBUTION = 4500\nBAT2_DISTRIBUTION = 450\n</code></pre></p> </li> <li> <p><code>1</code>: then <code>Bat2</code> will have 2x more power assigned then <code>Bat1</code>.   <pre><code># 30 * x + 60 * x = 900\nX = 100\nBAT1_DISTRIBUTION = 300\nBAT2_DISTRIBUTION = 600\n</code></pre></p> </li> <li> <p><code>2</code>: then <code>Bat2</code> will have 4x more power assigned then <code>Bat1</code>.   <pre><code># 30^2 * x + 60^2 * x = 900\nX = 0.2\nBAT1_DISTRIBUTION = 180\nBAT2_DISTRIBUTION = 720\n</code></pre></p> </li> <li> <p><code>3</code>: then <code>Bat2</code> will have 8x more power assigned then <code>Bat1</code>.   <pre><code># 30^3 * x + 60^3 * x = 900\nX = 0.003703704\nBAT1_DISTRIBUTION = 100\nBAT2_DISTRIBUTION = 800\n</code></pre></p> </li> </ul>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionAlgorithm.__init__--example-3","title":"Example 3","text":"<p>Let:</p> <ul> <li><code>Bat1.soc = 44</code> and <code>Bat2.soc = 64</code>.</li> <li><code>Bat1.available_soc = 36 (80 - 44)</code>, <code>Bat2.available_soc = 16 (80 - 64)</code></li> </ul> <p>We need to distribute 900W.</p> <p>If <code>distribution_exponent</code> is:</p> <ul> <li> <p><code>0</code>: distribution for each battery will be the equal.   <pre><code>BAT1_DISTRIBUTION = 450\nBAT2_DISTRIBUTION = 450\n</code></pre></p> </li> <li> <p><code>0.5</code>: then <code>Bat2</code> will have 6/4x more power assigned then <code>Bat1</code>.   <pre><code># sqrt(36) * x + sqrt(16) * x = 900\nX = 100\nBAT1_DISTRIBUTION = 600\nBAT2_DISTRIBUTION = 400\n</code></pre></p> </li> </ul>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionAlgorithm.distribute_power","title":"<code>distribute_power(power, components)</code>","text":"<p>Distribute given power between given components.</p> PARAMETER DESCRIPTION <code>power</code> <p>Power to distribute</p> <p> TYPE: <code>float</code> </p> <code>components</code> <p>InvBatPaired components data. Each pair should have data for battery and adjacent inverter.</p> <p> TYPE: <code>List[InvBatPair]</code> </p> RETURNS DESCRIPTION <code>DistributionResult</code> <p>Distribution result</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/power/_distribution_algorithm.py</code> <pre><code>def distribute_power(\n    self, power: float, components: List[InvBatPair]\n) -&gt; DistributionResult:\n\"\"\"Distribute given power between given components.\n\n    Args:\n        power: Power to distribute\n        components: InvBatPaired components data. Each pair should have data\n            for battery and adjacent inverter.\n\n    Returns:\n        Distribution result\n    \"\"\"\n    if power &gt;= 0.0:\n        return self._distribute_consume_power(power, components)\n    return self._distribute_supply_power(power, components)\n</code></pre>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionAlgorithm.distribute_power_equally","title":"<code>distribute_power_equally(power, inverters)</code>","text":"<p>Distribute the power equally between the inverters in the set.</p> <p>This function is mainly useful to set the power for components that are broken or have no metrics available.</p> PARAMETER DESCRIPTION <code>power</code> <p>the power to distribute.</p> <p> TYPE: <code>float</code> </p> <code>inverters</code> <p>the inverters to set the power to.</p> <p> TYPE: <code>set[int]</code> </p> RETURNS DESCRIPTION <code>DistributionResult</code> <p>the power distribution result.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/power/_distribution_algorithm.py</code> <pre><code>def distribute_power_equally(\n    self, power: float, inverters: set[int]\n) -&gt; DistributionResult:\n\"\"\"Distribute the power equally between the inverters in the set.\n\n    This function is mainly useful to set the power for components that are\n    broken or have no metrics available.\n\n    Args:\n        power: the power to distribute.\n        inverters: the inverters to set the power to.\n\n    Returns:\n        the power distribution result.\n    \"\"\"\n    power_per_inverter = power / len(inverters)\n    return DistributionResult(\n        distribution={id: power_per_inverter for id in inverters},\n        remaining_power=0.0,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.DistributionResult","title":"<code>frequenz.sdk.power.DistributionResult</code>  <code>dataclass</code>","text":"<p>Distribution result.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/power/_distribution_algorithm.py</code> <pre><code>@dataclass\nclass DistributionResult:\n\"\"\"Distribution result.\"\"\"\n\n    distribution: Dict[int, float]\n\"\"\"The power to be set for each inverter.\n\n    The key is inverter ID, and the value is the power that should be set for\n    that inverter.\n    \"\"\"\n\n    remaining_power: float\n\"\"\"The power which could not be distributed because of bounds.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.DistributionResult-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionResult.distribution","title":"<code>distribution: Dict[int, float]</code>  <code>instance-attribute</code>","text":"<p>The power to be set for each inverter.</p> <p>The key is inverter ID, and the value is the power that should be set for that inverter.</p>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.DistributionResult.remaining_power","title":"<code>remaining_power: float</code>  <code>instance-attribute</code>","text":"<p>The power which could not be distributed because of bounds.</p>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.InvBatPair","title":"<code>frequenz.sdk.power.InvBatPair</code>","text":"<p>         Bases: <code>NamedTuple</code></p> <p>InvBatPair with inverter and adjacent battery data.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/power/_distribution_algorithm.py</code> <pre><code>class InvBatPair(NamedTuple):\n\"\"\"InvBatPair with inverter and adjacent battery data.\"\"\"\n\n    battery: BatteryData\n\"\"\"The battery data.\"\"\"\n\n    inverter: InverterData\n\"\"\"The inverter data.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power.InvBatPair-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.InvBatPair.battery","title":"<code>battery: BatteryData</code>  <code>instance-attribute</code>","text":"<p>The battery data.</p>"},{"location":"reference/frequenz/sdk/power/#frequenz.sdk.power._distribution_algorithm.InvBatPair.inverter","title":"<code>inverter: InverterData</code>  <code>instance-attribute</code>","text":"<p>The inverter data.</p>"},{"location":"reference/frequenz/sdk/timeseries/","title":"timeseries","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries","title":"<code>frequenz.sdk.timeseries</code>","text":"<p>Handling of timeseries streams.</p> <p>A timeseries is a stream (normally an async iterator) of <code>Sample</code>s.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries--periodicity-and-alignment","title":"Periodicity and alignment","text":"<p>All the data produced by this package is always periodic and aligned to the <code>UNIX_EPOCH</code> (by default).</p> <p>Classes normally take a (re)sampling period as and argument and, optionally, an <code>align_to</code> argument.</p> <p>This means timestamps are always separated exaclty by a period, and that this timestamp falls always at multiples of the period, starting at the <code>align_to</code>.</p> <p>This ensures that the data is predictable and consistent among restarts.</p> Example <p>If we have a period of 10 seconds, and are aligning to the UNIX epoch. Assuming the following timeline starts in 1970-01-01 00:00:00 UTC and our current <code>now</code> is 1970-01-01 00:00:32 UTC, then the next timestamp will be at 1970-01-01 00:00:40 UTC:</p> <pre><code>align_to = 1970-01-01 00:00:00         next event = 1970-01-01 00:00:40\n|                                       |\n|---------|---------|---------|-|-------|---------|---------|---------|\n0        10        20        30 |      40        50        60        70\n                               now = 1970-01-01 00:00:32\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.UNIX_EPOCH","title":"<code>frequenz.sdk.timeseries.UNIX_EPOCH = datetime.fromtimestamp(0.0, tz=timezone.utc)</code>  <code>module-attribute</code>","text":"<p>The UNIX epoch (in UTC).</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow","title":"<code>frequenz.sdk.timeseries.MovingWindow</code>","text":"<p>A data window that moves with the latest datapoints of a data stream.</p> <p>After initialization the <code>MovingWindow</code> can be accessed by an integer index or a timestamp. A sub window can be accessed by using a slice of integers or timestamps.</p> <p>Note that a numpy ndarray is returned and thus users can use numpys operations directly on a window.</p> <p>The window uses a ring buffer for storage and the first element is aligned to a fixed defined point in time. Since the moving nature of the window, the date of the first and the last element are constantly changing and therefore the point in time that defines the alignment can be outside of the time window. Modulo arithmetic is used to move the <code>align_to</code> timestamp into the latest window.</p> <p>If for example the <code>align_to</code> parameter is set to <code>datetime(1, 1, 1, tzinfo=timezone.utc)</code> and the window size is bigger than one day then the first element will always be aligned to midnight.</p> <p>Resampling might be required to reduce the number of samples to store, and it can be set by specifying the resampler config parameter so that the user can control the granularity of the samples to be stored in the underlying buffer.</p> <p>If resampling is not required, the resampler config parameter can be set to None in which case the MovingWindow will not perform any resampling.</p> Calculate the mean of a time interval <pre><code>from datetime import datetime, timedelta, timezone\n\nasync def send_mock_data(sender: Sender[Sample]) -&gt; None:\n    while True:\n        await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n        await asyncio.sleep(1.0)\n\nasync def run() -&gt; None:\n    resampled_data_channel = Broadcast[Sample](\"sample-data\")\n    resampled_data_receiver = resampled_data_channel.new_receiver()\n    resampled_data_sender = resampled_data_channel.new_sender()\n\n    send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n    window = MovingWindow(\n        size=timedelta(minutes=5),\n        resampled_data_recv=resampled_data_receiver,\n        input_sampling_period=timedelta(seconds=1),\n    )\n\n    time_start = datetime.now(tz=timezone.utc)\n    time_end = time_start + timedelta(minutes=5)\n\n    # ... wait for 5 minutes until the buffer is filled\n    await asyncio.sleep(5)\n\n    # return an numpy array from the window\n    array = window[time_start:time_end]\n    # and use it to for example calculate the mean\n    mean = array.mean()\n\nasyncio.run(run())\n</code></pre> Create a polars data frame from a <code>MovingWindow</code> <pre><code>import polars as pl\nfrom datetime import datetime, timedelta, timezone\n\nasync def send_mock_data(sender: Sender[Sample]) -&gt; None:\n    while True:\n        await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n        await asyncio.sleep(1.0)\n\nasync def run() -&gt; None:\n    resampled_data_channel = Broadcast[Sample](\"sample-data\")\n    resampled_data_receiver = resampled_data_channel.new_receiver()\n    resampled_data_sender = resampled_data_channel.new_sender()\n\n    send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n    # create a window that stores two days of data\n    # starting at 1.1.23 with samplerate=1\n    window = MovingWindow(\n        size=timedelta(days=2),\n        resampled_data_recv=resampled_data_receiver,\n        input_sampling_period=timedelta(seconds=1),\n    )\n\n    # wait for one full day until the buffer is filled\n    await asyncio.sleep(60*60*24)\n\n    # create a polars series with one full day of data\n    time_start = datetime(2023, 1, 1, tzinfo=timezone.utc)\n    time_end = datetime(2023, 1, 2, tzinfo=timezone.utc)\n    series = pl.Series(\"Jan_1\", window[time_start:time_end])\n\nasyncio.run(run())\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>class MovingWindow:\n\"\"\"\n    A data window that moves with the latest datapoints of a data stream.\n\n    After initialization the `MovingWindow` can be accessed by an integer\n    index or a timestamp. A sub window can be accessed by using a slice of\n    integers or timestamps.\n\n    Note that a numpy ndarray is returned and thus users can use\n    numpys operations directly on a window.\n\n    The window uses a ring buffer for storage and the first element is aligned to\n    a fixed defined point in time. Since the moving nature of the window, the\n    date of the first and the last element are constantly changing and therefore\n    the point in time that defines the alignment can be outside of the time window.\n    Modulo arithmetic is used to move the `align_to` timestamp into the latest\n    window.\n\n    If for example the `align_to` parameter is set to\n    `datetime(1, 1, 1, tzinfo=timezone.utc)` and the window size is bigger than\n    one day then the first element will always be aligned to midnight.\n\n    Resampling might be required to reduce the number of samples to store, and\n    it can be set by specifying the resampler config parameter so that the user\n    can control the granularity of the samples to be stored in the underlying\n    buffer.\n\n    If resampling is not required, the resampler config parameter can be\n    set to None in which case the MovingWindow will not perform any resampling.\n\n    Example: Calculate the mean of a time interval\n\n        ```python\n        from datetime import datetime, timedelta, timezone\n\n        async def send_mock_data(sender: Sender[Sample]) -&gt; None:\n            while True:\n                await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n                await asyncio.sleep(1.0)\n\n        async def run() -&gt; None:\n            resampled_data_channel = Broadcast[Sample](\"sample-data\")\n            resampled_data_receiver = resampled_data_channel.new_receiver()\n            resampled_data_sender = resampled_data_channel.new_sender()\n\n            send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n            window = MovingWindow(\n                size=timedelta(minutes=5),\n                resampled_data_recv=resampled_data_receiver,\n                input_sampling_period=timedelta(seconds=1),\n            )\n\n            time_start = datetime.now(tz=timezone.utc)\n            time_end = time_start + timedelta(minutes=5)\n\n            # ... wait for 5 minutes until the buffer is filled\n            await asyncio.sleep(5)\n\n            # return an numpy array from the window\n            array = window[time_start:time_end]\n            # and use it to for example calculate the mean\n            mean = array.mean()\n\n        asyncio.run(run())\n        ```\n\n    Example: Create a polars data frame from a `MovingWindow`\n\n        ```python\n        import polars as pl\n        from datetime import datetime, timedelta, timezone\n\n        async def send_mock_data(sender: Sender[Sample]) -&gt; None:\n            while True:\n                await sender.send(Sample(datetime.now(tz=timezone.utc), 10.0))\n                await asyncio.sleep(1.0)\n\n        async def run() -&gt; None:\n            resampled_data_channel = Broadcast[Sample](\"sample-data\")\n            resampled_data_receiver = resampled_data_channel.new_receiver()\n            resampled_data_sender = resampled_data_channel.new_sender()\n\n            send_task = asyncio.create_task(send_mock_data(resampled_data_sender))\n\n            # create a window that stores two days of data\n            # starting at 1.1.23 with samplerate=1\n            window = MovingWindow(\n                size=timedelta(days=2),\n                resampled_data_recv=resampled_data_receiver,\n                input_sampling_period=timedelta(seconds=1),\n            )\n\n            # wait for one full day until the buffer is filled\n            await asyncio.sleep(60*60*24)\n\n            # create a polars series with one full day of data\n            time_start = datetime(2023, 1, 1, tzinfo=timezone.utc)\n            time_end = datetime(2023, 1, 2, tzinfo=timezone.utc)\n            series = pl.Series(\"Jan_1\", window[time_start:time_end])\n\n        asyncio.run(run())\n        ```\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        size: timedelta,\n        resampled_data_recv: Receiver[Sample],\n        input_sampling_period: timedelta,\n        resampler_config: ResamplerConfig | None = None,\n        align_to: datetime = UNIX_EPOCH,\n    ) -&gt; None:\n\"\"\"\n        Initialize the MovingWindow.\n\n        This method creates the underlying ring buffer and starts a\n        new task that updates the ring buffer with new incoming samples.\n        The task stops running only if the channel receiver is closed.\n\n        Args:\n            size: The time span of the moving window over which samples will be stored.\n            resampled_data_recv: A receiver that delivers samples with a\n                given sampling period.\n            input_sampling_period: The time interval between consecutive input samples.\n            resampler_config: The resampler configuration in case resampling is required.\n            align_to: A datetime object that defines a point in time to which\n                the window is aligned to modulo window size. For further\n                information, consult the class level documentation.\n\n        Raises:\n            asyncio.CancelledError: when the task gets cancelled.\n        \"\"\"\n        assert (\n            input_sampling_period.total_seconds() &gt; 0\n        ), \"The input sampling period should be greater than zero.\"\n        assert (\n            input_sampling_period &lt;= size\n        ), \"The input sampling period should be equal to or lower than the window size.\"\n\n        self._sampling_period = input_sampling_period\n\n        self._resampler: Resampler | None = None\n        self._resampler_sender: Sender[Sample] | None = None\n        self._resampler_task: asyncio.Task[None] | None = None\n\n        if resampler_config:\n            assert (\n                resampler_config.resampling_period &lt;= size\n            ), \"The resampling period should be equal to or lower than the window size.\"\n\n            self._resampler = Resampler(resampler_config)\n            self._sampling_period = resampler_config.resampling_period\n\n        # Sampling period might not fit perfectly into the window size.\n        num_samples = math.ceil(\n            size.total_seconds() / self._sampling_period.total_seconds()\n        )\n\n        self._resampled_data_recv = resampled_data_recv\n        self._buffer = OrderedRingBuffer(\n            np.empty(shape=num_samples, dtype=float),\n            sampling_period=self._sampling_period,\n            align_to=align_to,\n        )\n\n        if self._resampler:\n            self._configure_resampler()\n\n        self._update_window_task: asyncio.Task[None] = asyncio.create_task(\n            self._run_impl()\n        )\n\n    @property\n    def sampling_period(self) -&gt; timedelta:\n\"\"\"\n        Return the sampling period of the MovingWindow.\n\n        Returns:\n            The sampling period of the MovingWindow.\n        \"\"\"\n        return self._sampling_period\n\n    async def _run_impl(self) -&gt; None:\n\"\"\"Awaits samples from the receiver and updates the underlying ring buffer.\n\n        Raises:\n            asyncio.CancelledError: if the MovingWindow task is cancelled.\n        \"\"\"\n        try:\n            async for sample in self._resampled_data_recv:\n                _logger.debug(\"Received new sample: %s\", sample)\n                if self._resampler and self._resampler_sender:\n                    await self._resampler_sender.send(sample)\n                else:\n                    self._buffer.update(sample)\n\n        except asyncio.CancelledError:\n            _logger.info(\"MovingWindow task has been cancelled.\")\n            raise\n\n        _logger.error(\"Channel has been closed\")\n\n    async def stop(self) -&gt; None:\n\"\"\"Cancel the running tasks and stop the MovingWindow.\"\"\"\n        await cancel_and_await(self._update_window_task)\n        if self._resampler_task:\n            await cancel_and_await(self._resampler_task)\n\n    def _configure_resampler(self) -&gt; None:\n\"\"\"Configure the components needed to run the resampler.\"\"\"\n        assert self._resampler is not None\n\n        async def sink_buffer(sample: Sample) -&gt; None:\n            if sample.value is not None:\n                self._buffer.update(sample)\n\n        resampler_channel = Broadcast[Sample](\"average\")\n        self._resampler_sender = resampler_channel.new_sender()\n        self._resampler.add_timeseries(\n            \"avg\", resampler_channel.new_receiver(), sink_buffer\n        )\n        self._resampler_task = asyncio.create_task(self._resampler.resample())\n\n    def __len__(self) -&gt; int:\n\"\"\"\n        Return the size of the `MovingWindow`s underlying buffer.\n\n        Returns:\n            The size of the `MovingWindow`.\n        \"\"\"\n        return len(self._buffer)\n\n    @overload\n    def __getitem__(self, key: SupportsIndex) -&gt; float:\n\"\"\"See the main __getitem__ method.\n\n        # noqa: DAR101 key\n        \"\"\"\n\n    @overload\n    def __getitem__(self, key: datetime) -&gt; float:\n\"\"\"See the main __getitem__ method.\n\n        # noqa: DAR101 key\n        \"\"\"\n\n    @overload\n    def __getitem__(self, key: slice) -&gt; ArrayLike:\n\"\"\"See the main __getitem__ method.\n\n        # noqa: DAR101 key\n        \"\"\"\n\n    def __getitem__(self, key: SupportsIndex | datetime | slice) -&gt; float | ArrayLike:\n\"\"\"\n        Return a sub window of the `MovingWindow`.\n\n        The `MovingWindow` is accessed either by timestamp or by index\n        or by a slice of timestamps or integers.\n\n        * If the key is an integer, the float value of that key\n          at the given position is returned.\n        * If the key is a datetime object, the float value of that key\n          that corresponds to the timestamp is returned.\n        * If the key is a slice of timestamps or integers, an ndarray is returned,\n          where the bounds correspond to the slice bounds.\n          Note that a half open interval, which is open at the end, is returned.\n\n        Args:\n            key: Either an integer or a timestamp or a slice of timestamps or integers.\n\n        Raises:\n            IndexError: when requesting an out of range timestamp or index\n            TypeError: when the key is not a datetime or slice object.\n\n        Returns:\n            A float if the key is a number or a timestamp.\n            an numpy array if the key is a slice.\n        \"\"\"\n        if isinstance(key, slice):\n            if isinstance(key.start, int) or isinstance(key.stop, int):\n                if key.start is None or key.stop is None:\n                    key = slice(slice(key.start, key.stop).indices(self.__len__()))\n            elif isinstance(key.start, datetime) or isinstance(key.stop, datetime):\n                if key.start is None:\n                    key = slice(self._buffer.time_bound_oldest, key.stop)\n                if key.stop is None:\n                    key = slice(key.start, self._buffer.time_bound_newest)\n\n            _logger.debug(\"Returning slice for [%s:%s].\", key.start, key.stop)\n\n            # we are doing runtime typechecks since there is no abstract slice type yet\n            # see also (https://peps.python.org/pep-0696)\n            if isinstance(key.start, datetime) and isinstance(key.stop, datetime):\n                return self._buffer.window(key.start, key.stop)\n            if isinstance(key.start, int) and isinstance(key.stop, int):\n                return self._buffer[key]\n        elif isinstance(key, datetime):\n            _logger.debug(\"Returning value at time %s \", key)\n            return self._buffer[self._buffer.datetime_to_index(key)]\n        elif isinstance(key, SupportsIndex):\n            return self._buffer[key]\n\n        raise TypeError(\n            \"Key has to be either a timestamp or an integer \"\n            \"or a slice of timestamps or integers\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._moving_window.MovingWindow.sampling_period","title":"<code>sampling_period: timedelta</code>  <code>property</code>","text":"<p>Return the sampling period of the MovingWindow.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The sampling period of the MovingWindow.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.MovingWindow-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._moving_window.MovingWindow.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Return a sub window of the <code>MovingWindow</code>.</p> <p>The <code>MovingWindow</code> is accessed either by timestamp or by index or by a slice of timestamps or integers.</p> <ul> <li>If the key is an integer, the float value of that key   at the given position is returned.</li> <li>If the key is a datetime object, the float value of that key   that corresponds to the timestamp is returned.</li> <li>If the key is a slice of timestamps or integers, an ndarray is returned,   where the bounds correspond to the slice bounds.   Note that a half open interval, which is open at the end, is returned.</li> </ul> PARAMETER DESCRIPTION <code>key</code> <p>Either an integer or a timestamp or a slice of timestamps or integers.</p> <p> TYPE: <code>SupportsIndex | datetime | slice</code> </p> RAISES DESCRIPTION <code>IndexError</code> <p>when requesting an out of range timestamp or index</p> <code>TypeError</code> <p>when the key is not a datetime or slice object.</p> RETURNS DESCRIPTION <code>float | ArrayLike</code> <p>A float if the key is a number or a timestamp.</p> <code>float | ArrayLike</code> <p>an numpy array if the key is a slice.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __getitem__(self, key: SupportsIndex | datetime | slice) -&gt; float | ArrayLike:\n\"\"\"\n    Return a sub window of the `MovingWindow`.\n\n    The `MovingWindow` is accessed either by timestamp or by index\n    or by a slice of timestamps or integers.\n\n    * If the key is an integer, the float value of that key\n      at the given position is returned.\n    * If the key is a datetime object, the float value of that key\n      that corresponds to the timestamp is returned.\n    * If the key is a slice of timestamps or integers, an ndarray is returned,\n      where the bounds correspond to the slice bounds.\n      Note that a half open interval, which is open at the end, is returned.\n\n    Args:\n        key: Either an integer or a timestamp or a slice of timestamps or integers.\n\n    Raises:\n        IndexError: when requesting an out of range timestamp or index\n        TypeError: when the key is not a datetime or slice object.\n\n    Returns:\n        A float if the key is a number or a timestamp.\n        an numpy array if the key is a slice.\n    \"\"\"\n    if isinstance(key, slice):\n        if isinstance(key.start, int) or isinstance(key.stop, int):\n            if key.start is None or key.stop is None:\n                key = slice(slice(key.start, key.stop).indices(self.__len__()))\n        elif isinstance(key.start, datetime) or isinstance(key.stop, datetime):\n            if key.start is None:\n                key = slice(self._buffer.time_bound_oldest, key.stop)\n            if key.stop is None:\n                key = slice(key.start, self._buffer.time_bound_newest)\n\n        _logger.debug(\"Returning slice for [%s:%s].\", key.start, key.stop)\n\n        # we are doing runtime typechecks since there is no abstract slice type yet\n        # see also (https://peps.python.org/pep-0696)\n        if isinstance(key.start, datetime) and isinstance(key.stop, datetime):\n            return self._buffer.window(key.start, key.stop)\n        if isinstance(key.start, int) and isinstance(key.stop, int):\n            return self._buffer[key]\n    elif isinstance(key, datetime):\n        _logger.debug(\"Returning value at time %s \", key)\n        return self._buffer[self._buffer.datetime_to_index(key)]\n    elif isinstance(key, SupportsIndex):\n        return self._buffer[key]\n\n    raise TypeError(\n        \"Key has to be either a timestamp or an integer \"\n        \"or a slice of timestamps or integers\"\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._moving_window.MovingWindow.__init__","title":"<code>__init__(size, resampled_data_recv, input_sampling_period, resampler_config=None, align_to=UNIX_EPOCH)</code>","text":"<p>Initialize the MovingWindow.</p> <p>This method creates the underlying ring buffer and starts a new task that updates the ring buffer with new incoming samples. The task stops running only if the channel receiver is closed.</p> PARAMETER DESCRIPTION <code>size</code> <p>The time span of the moving window over which samples will be stored.</p> <p> TYPE: <code>timedelta</code> </p> <code>resampled_data_recv</code> <p>A receiver that delivers samples with a given sampling period.</p> <p> TYPE: <code>Receiver[Sample]</code> </p> <code>input_sampling_period</code> <p>The time interval between consecutive input samples.</p> <p> TYPE: <code>timedelta</code> </p> <code>resampler_config</code> <p>The resampler configuration in case resampling is required.</p> <p> TYPE: <code>ResamplerConfig | None</code> DEFAULT: <code>None</code> </p> <code>align_to</code> <p>A datetime object that defines a point in time to which the window is aligned to modulo window size. For further information, consult the class level documentation.</p> <p> TYPE: <code>datetime</code> DEFAULT: <code>UNIX_EPOCH</code> </p> RAISES DESCRIPTION <code>asyncio.CancelledError</code> <p>when the task gets cancelled.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    size: timedelta,\n    resampled_data_recv: Receiver[Sample],\n    input_sampling_period: timedelta,\n    resampler_config: ResamplerConfig | None = None,\n    align_to: datetime = UNIX_EPOCH,\n) -&gt; None:\n\"\"\"\n    Initialize the MovingWindow.\n\n    This method creates the underlying ring buffer and starts a\n    new task that updates the ring buffer with new incoming samples.\n    The task stops running only if the channel receiver is closed.\n\n    Args:\n        size: The time span of the moving window over which samples will be stored.\n        resampled_data_recv: A receiver that delivers samples with a\n            given sampling period.\n        input_sampling_period: The time interval between consecutive input samples.\n        resampler_config: The resampler configuration in case resampling is required.\n        align_to: A datetime object that defines a point in time to which\n            the window is aligned to modulo window size. For further\n            information, consult the class level documentation.\n\n    Raises:\n        asyncio.CancelledError: when the task gets cancelled.\n    \"\"\"\n    assert (\n        input_sampling_period.total_seconds() &gt; 0\n    ), \"The input sampling period should be greater than zero.\"\n    assert (\n        input_sampling_period &lt;= size\n    ), \"The input sampling period should be equal to or lower than the window size.\"\n\n    self._sampling_period = input_sampling_period\n\n    self._resampler: Resampler | None = None\n    self._resampler_sender: Sender[Sample] | None = None\n    self._resampler_task: asyncio.Task[None] | None = None\n\n    if resampler_config:\n        assert (\n            resampler_config.resampling_period &lt;= size\n        ), \"The resampling period should be equal to or lower than the window size.\"\n\n        self._resampler = Resampler(resampler_config)\n        self._sampling_period = resampler_config.resampling_period\n\n    # Sampling period might not fit perfectly into the window size.\n    num_samples = math.ceil(\n        size.total_seconds() / self._sampling_period.total_seconds()\n    )\n\n    self._resampled_data_recv = resampled_data_recv\n    self._buffer = OrderedRingBuffer(\n        np.empty(shape=num_samples, dtype=float),\n        sampling_period=self._sampling_period,\n        align_to=align_to,\n    )\n\n    if self._resampler:\n        self._configure_resampler()\n\n    self._update_window_task: asyncio.Task[None] = asyncio.create_task(\n        self._run_impl()\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._moving_window.MovingWindow.__len__","title":"<code>__len__()</code>","text":"<p>Return the size of the <code>MovingWindow</code>s underlying buffer.</p> RETURNS DESCRIPTION <code>int</code> <p>The size of the <code>MovingWindow</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    Return the size of the `MovingWindow`s underlying buffer.\n\n    Returns:\n        The size of the `MovingWindow`.\n    \"\"\"\n    return len(self._buffer)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._moving_window.MovingWindow.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Cancel the running tasks and stop the MovingWindow.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_moving_window.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Cancel the running tasks and stop the MovingWindow.\"\"\"\n    await cancel_and_await(self._update_window_task)\n    if self._resampler_task:\n        await cancel_and_await(self._resampler_task)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor","title":"<code>frequenz.sdk.timeseries.PeriodicFeatureExtractor</code>","text":"<p>A feature extractor for historical timeseries data.</p> <p>This class is creating a profile from periodically occurring windows in a buffer of historical data.</p> <p>The profile is created out of all windows that are fully contained in the underlying buffer with the same start and end time modulo a fixed period.</p> <p>Consider for example a timeseries $T$ of historical data and sub-series $S_i$ of $T$ all having the same size $l$ and the same fixed distance $p$ called period, where period of two sub-windows is defined as the distance of two points at the same position within the sub-windows.</p> <p>This class calculates a statistical profile $S$ over all $S_i$, i.e. the value of $S$ at position $i$ is calculated by performing a certain calculation, e.g. an average, over all values of $S_i$ at position $i$.</p> Note <p>The oldest window or the window that is currently overwritten in the <code>MovingWindow</code> is not considered in the profile.</p> Note <p>When constructing a <code>PeriodicFeatureExtractor</code> object the <code>MovingWindow</code> size has to be a integer multiple of the period.</p> Example <pre><code>from datetime import datetime, timedelta, timezone\n\nmoving_window = MovingWindow(\n    size=timedelta(days=35),\n    resampled_data_recv=microgrid.logical_meter().grid_power.new_receiver(),\n    input_sampling_period=timedelta(seconds=1),\n)\n\nfeature_extractor = PeriodicFeatureExtractor(\n    moving_window = moving_window,\n    period=timedelta(days=7),\n)\n\nnow = datetime.now(timezone.utc)\n\n# create a daily weighted average for the next 24h\navg_24h = feature_extractor.avg(\n    now,\n    now + timedelta(hours=24),\n    weights=[0.1, 0.2, 0.3, 0.4]\n)\n\n# create a daily average for Thursday March 23 2023\nth_avg_24h = feature_extractor.avg(datetime(2023, 3, 23), datetime(2023, 3, 24))\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>class PeriodicFeatureExtractor:\n\"\"\"\n    A feature extractor for historical timeseries data.\n\n    This class is creating a profile from periodically occurring windows in a\n    buffer of historical data.\n\n    The profile is created out of all windows that are fully contained in the\n    underlying buffer with the same start and end time modulo a fixed period.\n\n    Consider for example a timeseries $T$ of historical data and sub-series\n    $S_i$ of $T$ all having the same size $l$ and the same fixed distance $p$\n    called period, where period of two sub-windows is defined as the distance\n    of two points at the same position within the sub-windows.\n\n    This class calculates a statistical profile $S$ over all $S_i$, i.e. the\n    value of $S$ at position $i$ is calculated by performing a certain\n    calculation, e.g. an average, over all values of $S_i$ at position $i$.\n\n    Note:\n        The oldest window or the window that is currently overwritten in the\n        `MovingWindow` is not considered in the profile.\n\n    Note:\n        When constructing a `PeriodicFeatureExtractor` object the\n        `MovingWindow` size has to be a integer multiple of the period.\n\n    Example:\n        ```python\n        from datetime import datetime, timedelta, timezone\n\n        moving_window = MovingWindow(\n            size=timedelta(days=35),\n            resampled_data_recv=microgrid.logical_meter().grid_power.new_receiver(),\n            input_sampling_period=timedelta(seconds=1),\n        )\n\n        feature_extractor = PeriodicFeatureExtractor(\n            moving_window = moving_window,\n            period=timedelta(days=7),\n        )\n\n        now = datetime.now(timezone.utc)\n\n        # create a daily weighted average for the next 24h\n        avg_24h = feature_extractor.avg(\n            now,\n            now + timedelta(hours=24),\n            weights=[0.1, 0.2, 0.3, 0.4]\n        )\n\n        # create a daily average for Thursday March 23 2023\n        th_avg_24h = feature_extractor.avg(datetime(2023, 3, 23), datetime(2023, 3, 24))\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        moving_window: MovingWindow,\n        period: timedelta,\n    ) -&gt; None:\n\"\"\"\n        Initialize a PeriodicFeatureExtractor object.\n\n        Args:\n            moving_window: The MovingWindow that is used for the average calculation.\n            period: The distance between two succeeding intervals.\n\n        Raises:\n            ValueError: If the MovingWindow size is not a integer multiple of the period.\n        \"\"\"\n        self._moving_window = moving_window\n\n        self._sampling_period = self._moving_window.sampling_period\n\"\"\"The sampling_period as float to use it for indexing of samples.\"\"\"\n\n        self._period = int(period / self._sampling_period)\n\"\"\"Distance between two succeeding intervals in samples.\"\"\"\n\n        _logger.debug(\"Initializing PeriodicFeatureExtractor!\")\n        _logger.debug(\"MovingWindow size: %i\", len(self._moving_window))\n        _logger.debug(\n            \"Period between two succeeding intervals (in samples): %i\",\n            self._period,\n        )\n\n        if not len(self._moving_window) % self._period == 0:\n            raise ValueError(\n                \"The MovingWindow size is not a integer multiple of the period.\"\n            )\n\n        if not is_close_to_zero(self._period - period / self._sampling_period):\n            raise ValueError(\n                \"The period is not a multiple of the sampling period. \"\n                \"This might result in unexpected behaviour.\"\n            )\n\n    @property\n    def _buffer(self) -&gt; OrderedRingBuffer[NDArray[np.float64]]:\n        return self._moving_window._buffer  # pylint: disable=protected-access\n\n    def _timestamp_to_rel_index(self, timestamp: datetime) -&gt; int:\n\"\"\"\n        Get the index of a timestamp relative to the oldest sample in the MovingWindow.\n\n        In other word consider an integer axis where the zero is defined as the\n        oldest element in the MovingWindow. This function returns the index of\n        the given timestamp an this axis.\n\n        This method can return negative values.\n\n        Args:\n            timestamp: A timestamp that we want to shift into the window.\n\n        Returns:\n            The index of the timestamp shifted into the MovingWindow.\n        \"\"\"\n        # align timestamp to the sampling period\n        timestamp = self._buffer.normalize_timestamp(timestamp)\n\n        # distance between the input ts and the ts of oldest known samples (in samples)\n        dist_to_oldest = int(\n            (timestamp - self._buffer.time_bound_oldest) / self._sampling_period\n        )\n\n        _logger.debug(\"Shifting ts: %s\", timestamp)\n        _logger.debug(\"Oldest timestamp in buffer: %s\", self._buffer.time_bound_oldest)\n        _logger.debug(\"Distance to the oldest sample: %i\", dist_to_oldest)\n\n        return dist_to_oldest\n\n    def _reshape_np_array(\n        self, array: NDArray[np.float_], window_size: int\n    ) -&gt; NDArray[np.float_]:\n\"\"\"\n        Reshape a numpy array to a 2D array where each row represents a window.\n\n        There are three cases to consider\n\n        1. The array size is a multiple of window_size + period,\n           i.e. num_windows is integer and we can simply reshape.\n        2. The array size is NOT a multiple of window_size + period and\n           it has length n * period + m, where m &lt; window_size.\n        3. The array size is NOT a multiple of window_size + period and\n           it has length n * period + m, where m &gt;= window_size.\n\n        Note that in the current implementation of this class we have the restriction\n        that period is a multiple integer of the size of the MovingWindow and hence\n        only case 1 can occur.\n\n        Args:\n            array: The numpy array to reshape.\n            window_size: The size of the window in samples.\n\n        Returns:\n            The reshaped 2D array.\n\n        Raises:\n            ValueError: If the array is smaller or equal to the given period.\n        \"\"\"\n        # Not using the num_windows function here because we want to\n        # differentiate between the three cases.\n        if len(array) &lt; self._period:\n            raise ValueError(\n                f\"The array (length:{len(array)}) is too small to be reshaped.\"\n            )\n\n        num_windows = len(array) // self._period\n\n        # Case 1:\n        if len(array) - num_windows * self._period == 0:\n            resized_array = array\n        # Case 2\n        elif len(array) - num_windows * self._period &lt; window_size:\n            resized_array = array[: num_windows * self._period]\n        # Case 3\n        else:\n            num_windows += 1\n            resized_array = np.resize(array, num_windows * self._period)\n\n        return resized_array.reshape(num_windows, self._period)\n\n    def _get_relative_positions(\n        self, start: datetime, window_size: int\n    ) -&gt; RelativePositions:\n\"\"\"\n        Return relative positions of the MovingWindow.\n\n        This method calculates the shifted relative positions of the start\n        timestamp, the end timestamps as well as the next position that is\n        overwritten in the ringbuffer.\n        Shifted in that context means that the positions are moved as close\n        assume possible to the oldest sample in the MovingWindow.\n\n        Args:\n            start: The start timestamp of the window.\n            window_size: The size of the window in samples.\n\n        Returns:\n            The relative positions of the start, end and next samples.\n\n        Raises:\n            ValueError: If the start timestamp is after the end timestamp.\n        \"\"\"\n        # The number of usable windows can change, when the current position of\n        # the ringbuffer is inside one of the windows inside the MovingWindow.\n        # Since this is possible, we assume that one window is always not used\n        # for the average calculation.\n        #\n        # We are ignoring either the window that is currently overwritten if\n        # the current position is inside that window or the window that would\n        # be overwritten next.\n        #\n        # Move the window to its first appereance in the MovingWindow relative\n        # to the oldest sample stored in the MovingWindow.\n        #\n        # In other words the oldest stored sample is considered to have index 0.\n        #\n        # Note that the returned value is a index not a timestamp\n        rel_start_sample = self._timestamp_to_rel_index(start) % self._period\n        rel_end_sample = rel_start_sample + window_size\n\n        # check if the newest time bound, i.e. the sample that is currently written,\n        # is inside the interval\n        rb_current_position = self._buffer.time_bound_newest\n        rel_next_position = (\n            self._timestamp_to_rel_index(rb_current_position) + 1\n        ) % self._period\n        # fix the rel_next_position if modulo period the next position\n        # is smaller then the start sample position\n        if rel_next_position &lt; rel_start_sample:\n            rel_next_position += self._period\n\n        rel_next_position += self._period * (window_size // self._period)\n\n        _logger.debug(\"current position of the ringbuffer: %s\", rb_current_position)\n        _logger.debug(\"relative start_sample: %s\", rel_start_sample)\n        _logger.debug(\"relative end_sample: %s\", rel_end_sample)\n        _logger.debug(\"relative next_position: %s\", rel_next_position)\n\n        return RelativePositions(rel_start_sample, rel_end_sample, rel_next_position)\n\n    def _get_buffer_bounds(\n        self, start: datetime, end: datetime\n    ) -&gt; Tuple[int, int, int]:\n\"\"\"\n        Get the bounds of the ringbuffer used for further operations.\n\n        This method uses the given start and end timestamps to calculate the\n        part of the ringbuffer that can be used for further operations, like\n        average or min/max.\n\n        Here we cut out the oldest window or the window that is currently\n        overwritten in the MovingWindow such that it is not considered in any\n        further operation.\n\n        Args:\n            start: The start timestamp of the window.\n            end: The end timestamp of the window.\n\n        Returns:\n            The bounds of the to be used buffer and the window size.\n\n        Raises:\n            ValueError: If the start timestamp is after the end timestamp.\n        \"\"\"\n        window_size = self._timestamp_to_rel_index(end) - self._timestamp_to_rel_index(\n            start\n        )\n        if window_size &lt;= 0:\n            raise ValueError(\"Start timestamp must be before end timestamp\")\n        if window_size &gt; self._period:\n            raise ValueError(\n                \"The window size must be smaller or equal than the period.\"\n            )\n\n        rel_pos = self._get_relative_positions(start, window_size)\n\n        if window_size &gt; len(self._moving_window):\n            raise ValueError(\n                \"The window size must be smaller than the size of the `MovingWindow`\"\n            )\n\n        # shifted distance between the next incoming sample and the start of the window\n        dist_to_start = rel_pos.next - rel_pos.start\n\n        # get the start and end position inside the ringbuffer\n        end_pos = (\n            self._timestamp_to_rel_index(self._buffer.time_bound_newest) + 1\n        ) - dist_to_start\n\n        # Note that these check is working since we are using the positions\n        # relative to the oldest sample stored in the MovingWindow.\n        if rel_pos.start &lt;= rel_pos.next &lt; rel_pos.end:\n            # end position is start_position of the window that is currently written\n            # that's how end_pos is currently set\n            _logger.debug(\"Next sample will be inside the window time interval!\")\n        else:\n            _logger.debug(\"Next sample will be outside the window time interval!\")\n            # end position is start_position of the window that\n            # is overwritten next, hence we adding period.\n            end_pos += self._period\n\n        # add the offset to the oldest sample in the ringbuffer and wrap around\n        # to get the start and end positions in the ringbuffer\n        rb_offset = self._buffer.datetime_to_index(self._buffer.time_bound_oldest)\n        start_pos = self._buffer.wrap(end_pos + self._period + rb_offset)\n        end_pos = self._buffer.wrap(end_pos + rb_offset)\n\n        _logger.debug(\"start_pos in ringbuffer: %s\", start_pos)\n        _logger.debug(\"end_pos in ringbuffer: %s\", end_pos)\n\n        return (start_pos, end_pos, window_size)\n\n    def _get_reshaped_np_array(\n        self, start: datetime, end: datetime\n    ) -&gt; Tuple[NDArray[np.float_], int]:\n\"\"\"\n        Create a reshaped numpy array from the MovingWindow.\n\n        The reshaped array is a two dimemsional array, where one dimension is\n        the window_size and the other the number of windows returned by the\n        `_get_buffer_bounds` method.\n\n        Args:\n            start: The start timestamp of the window.\n            end: The end timestamp of the window.\n\n        Returns:\n            A tuple containing the reshaped numpy array and the window size.\n        \"\"\"\n        (start_pos, end_pos, window_size) = self._get_buffer_bounds(start, end)\n\n        if start_pos &gt;= end_pos:\n            window_start = self._buffer[start_pos : len(self._moving_window)]\n            window_end = self._buffer[0:end_pos]\n            # make the linter happy\n            assert isinstance(window_start, np.ndarray)\n            assert isinstance(window_end, np.ndarray)\n            window_array = np.concatenate((window_start, window_end))\n        else:\n            window_array = self._buffer[start_pos:end_pos]\n\n        return (self._reshape_np_array(window_array, window_size), window_size)\n\n    def avg(\n        self, start: datetime, end: datetime, weights: List[float] | None = None\n    ) -&gt; NDArray[np.float_]:\n\"\"\"\n        Create the average window out of the window defined by `start` and `end`.\n\n        This method calculates the average of a window by averaging over all\n        windows fully inside the MovingWindow having the period\n        `self.period`.\n\n        Args:\n            start: The start of the window to average over.\n            end: The end of the window to average over.\n            weights: The weights to use for the average calculation (oldest first).\n\n        Returns:\n            The averaged timeseries window.\n        \"\"\"\n        (reshaped, window_size) = self._get_reshaped_np_array(start, end)\n        return np.average(  # type: ignore[no-any-return]\n            reshaped[:, :window_size], axis=0, weights=weights\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.PeriodicFeatureExtractor-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._periodic_feature_extractor.PeriodicFeatureExtractor.__init__","title":"<code>__init__(moving_window, period)</code>","text":"<p>Initialize a PeriodicFeatureExtractor object.</p> PARAMETER DESCRIPTION <code>moving_window</code> <p>The MovingWindow that is used for the average calculation.</p> <p> TYPE: <code>MovingWindow</code> </p> <code>period</code> <p>The distance between two succeeding intervals.</p> <p> TYPE: <code>timedelta</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the MovingWindow size is not a integer multiple of the period.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>def __init__(\n    self,\n    moving_window: MovingWindow,\n    period: timedelta,\n) -&gt; None:\n\"\"\"\n    Initialize a PeriodicFeatureExtractor object.\n\n    Args:\n        moving_window: The MovingWindow that is used for the average calculation.\n        period: The distance between two succeeding intervals.\n\n    Raises:\n        ValueError: If the MovingWindow size is not a integer multiple of the period.\n    \"\"\"\n    self._moving_window = moving_window\n\n    self._sampling_period = self._moving_window.sampling_period\n\"\"\"The sampling_period as float to use it for indexing of samples.\"\"\"\n\n    self._period = int(period / self._sampling_period)\n\"\"\"Distance between two succeeding intervals in samples.\"\"\"\n\n    _logger.debug(\"Initializing PeriodicFeatureExtractor!\")\n    _logger.debug(\"MovingWindow size: %i\", len(self._moving_window))\n    _logger.debug(\n        \"Period between two succeeding intervals (in samples): %i\",\n        self._period,\n    )\n\n    if not len(self._moving_window) % self._period == 0:\n        raise ValueError(\n            \"The MovingWindow size is not a integer multiple of the period.\"\n        )\n\n    if not is_close_to_zero(self._period - period / self._sampling_period):\n        raise ValueError(\n            \"The period is not a multiple of the sampling period. \"\n            \"This might result in unexpected behaviour.\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._periodic_feature_extractor.PeriodicFeatureExtractor.avg","title":"<code>avg(start, end, weights=None)</code>","text":"<p>Create the average window out of the window defined by <code>start</code> and <code>end</code>.</p> <p>This method calculates the average of a window by averaging over all windows fully inside the MovingWindow having the period <code>self.period</code>.</p> PARAMETER DESCRIPTION <code>start</code> <p>The start of the window to average over.</p> <p> TYPE: <code>datetime</code> </p> <code>end</code> <p>The end of the window to average over.</p> <p> TYPE: <code>datetime</code> </p> <code>weights</code> <p>The weights to use for the average calculation (oldest first).</p> <p> TYPE: <code>List[float] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>NDArray[np.float_]</code> <p>The averaged timeseries window.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_periodic_feature_extractor.py</code> <pre><code>def avg(\n    self, start: datetime, end: datetime, weights: List[float] | None = None\n) -&gt; NDArray[np.float_]:\n\"\"\"\n    Create the average window out of the window defined by `start` and `end`.\n\n    This method calculates the average of a window by averaging over all\n    windows fully inside the MovingWindow having the period\n    `self.period`.\n\n    Args:\n        start: The start of the window to average over.\n        end: The end of the window to average over.\n        weights: The weights to use for the average calculation (oldest first).\n\n    Returns:\n        The averaged timeseries window.\n    \"\"\"\n    (reshaped, window_size) = self._get_reshaped_np_array(start, end)\n    return np.average(  # type: ignore[no-any-return]\n        reshaped[:, :window_size], axis=0, weights=weights\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig","title":"<code>frequenz.sdk.timeseries.ResamplerConfig</code>  <code>dataclass</code>","text":"<p>Resampler configuration.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_resampling.py</code> <pre><code>@dataclass(frozen=True)\nclass ResamplerConfig:\n\"\"\"Resampler configuration.\"\"\"\n\n    resampling_period: timedelta\n\"\"\"The resampling period.\n\n    This is the time it passes between resampled data should be calculated.\n\n    It must be a positive time span.\n    \"\"\"\n\n    max_data_age_in_periods: float = 3.0\n\"\"\"The maximum age a sample can have to be considered *relevant* for resampling.\n\n    Expressed in number of periods, where period is the `resampling_period`\n    if we are downsampling (resampling period bigger than the input period) or\n    the input sampling period if we are upsampling (input period bigger than\n    the resampling period).\n\n    It must be bigger than 1.0.\n\n    Example:\n        If `resampling_period` is 3 seconds, the input sampling period is\n        1 and `max_data_age_in_periods` is 2, then data older than 3*2\n        = 6 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n\n        If `resampling_period` is 3 seconds, the input sampling period is\n        5 and `max_data_age_in_periods` is 2, then data older than 5*2\n        = 10 seconds will be discarded when creating a new sample and never\n        passed to the resampling function.\n    \"\"\"\n\n    resampling_function: ResamplingFunction = average\n\"\"\"The resampling function.\n\n    This function will be applied to the sequence of relevant samples at\n    a given time. The result of the function is what is sent as the resampled\n    value.\n    \"\"\"\n\n    initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT\n\"\"\"The initial length of the resampling buffer.\n\n    The buffer could grow or shrink depending on the source properties,\n    like sampling rate, to make sure all the requested past sampling periods\n    can be stored.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN\n\"\"\"The minimum length of the resampling buffer that will emit a warning.\n\n    If a buffer grows bigger than this value, it will emit a warning in the\n    logs, so buffers don't grow too big inadvertently.\n\n    It must be at least 1 and at most `max_buffer_len`.\n    \"\"\"\n\n    max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX\n\"\"\"The maximum length of the resampling buffer.\n\n    Buffers won't be allowed to grow beyond this point even if it would be\n    needed to keep all the requested past sampling periods. An error will be\n    emitted in the logs if the buffer length needs to be truncated to this\n    value.\n\n    It must be at bigger than `warn_buffer_len`.\n    \"\"\"\n\n    align_to: datetime | None = UNIX_EPOCH\n\"\"\"The time to align the resampling period to.\n\n    The resampling period will be aligned to this time, so the first resampled\n    sample will be at the first multiple of `resampling_period` starting from\n    `align_to`. It must be an aware datetime and can be in the future too.\n\n    If `align_to` is `None`, the resampling period will be aligned to the\n    time the resampler is created.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n\n        Raises:\n            ValueError: If any value is out of range.\n        \"\"\"\n        if self.resampling_period.total_seconds() &lt; 0.0:\n            raise ValueError(\n                f\"resampling_period ({self.resampling_period}) must be positive\"\n            )\n        if self.max_data_age_in_periods &lt; 1.0:\n            raise ValueError(\n                f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n            )\n        if self.warn_buffer_len &lt; 1:\n            raise ValueError(\n                f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n            )\n        if self.max_buffer_len &lt;= self.warn_buffer_len:\n            raise ValueError(\n                f\"max_buffer_len ({self.max_buffer_len}) should \"\n                f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n            )\n\n        if self.initial_buffer_len &lt; 1:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n            )\n        if self.initial_buffer_len &gt; self.max_buffer_len:\n            raise ValueError(\n                f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n                f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n                \"initial_buffer_len or a bigger max_buffer_len\"\n            )\n        if self.initial_buffer_len &gt; self.warn_buffer_len:\n            _logger.warning(\n                \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n                self.initial_buffer_len,\n                self.warn_buffer_len,\n            )\n        if self.align_to is not None and self.align_to.tzinfo is None:\n            raise ValueError(\n                f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._resampling.ResamplerConfig.align_to","title":"<code>align_to: datetime | None = UNIX_EPOCH</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The time to align the resampling period to.</p> <p>The resampling period will be aligned to this time, so the first resampled sample will be at the first multiple of <code>resampling_period</code> starting from <code>align_to</code>. It must be an aware datetime and can be in the future too.</p> <p>If <code>align_to</code> is <code>None</code>, the resampling period will be aligned to the time the resampler is created.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._resampling.ResamplerConfig.initial_buffer_len","title":"<code>initial_buffer_len: int = DEFAULT_BUFFER_LEN_INIT</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The initial length of the resampling buffer.</p> <p>The buffer could grow or shrink depending on the source properties, like sampling rate, to make sure all the requested past sampling periods can be stored.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._resampling.ResamplerConfig.max_buffer_len","title":"<code>max_buffer_len: int = DEFAULT_BUFFER_LEN_MAX</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The maximum length of the resampling buffer.</p> <p>Buffers won't be allowed to grow beyond this point even if it would be needed to keep all the requested past sampling periods. An error will be emitted in the logs if the buffer length needs to be truncated to this value.</p> <p>It must be at bigger than <code>warn_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._resampling.ResamplerConfig.max_data_age_in_periods","title":"<code>max_data_age_in_periods: float = 3.0</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The maximum age a sample can have to be considered relevant for resampling.</p> <p>Expressed in number of periods, where period is the <code>resampling_period</code> if we are downsampling (resampling period bigger than the input period) or the input sampling period if we are upsampling (input period bigger than the resampling period).</p> <p>It must be bigger than 1.0.</p> Example <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 1 and <code>max_data_age_in_periods</code> is 2, then data older than 3*2 = 6 seconds will be discarded when creating a new sample and never passed to the resampling function.</p> <p>If <code>resampling_period</code> is 3 seconds, the input sampling period is 5 and <code>max_data_age_in_periods</code> is 2, then data older than 5*2 = 10 seconds will be discarded when creating a new sample and never passed to the resampling function.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._resampling.ResamplerConfig.resampling_function","title":"<code>resampling_function: ResamplingFunction = average</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The resampling function.</p> <p>This function will be applied to the sequence of relevant samples at a given time. The result of the function is what is sent as the resampled value.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._resampling.ResamplerConfig.resampling_period","title":"<code>resampling_period: timedelta</code>  <code>instance-attribute</code>","text":"<p>The resampling period.</p> <p>This is the time it passes between resampled data should be calculated.</p> <p>It must be a positive time span.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._resampling.ResamplerConfig.warn_buffer_len","title":"<code>warn_buffer_len: int = DEFAULT_BUFFER_LEN_WARN</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The minimum length of the resampling buffer that will emit a warning.</p> <p>If a buffer grows bigger than this value, it will emit a warning in the logs, so buffers don't grow too big inadvertently.</p> <p>It must be at least 1 and at most <code>max_buffer_len</code>.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.ResamplerConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._resampling.ResamplerConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check that config values are valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If any value is out of range.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_resampling.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Check that config values are valid.\n\n    Raises:\n        ValueError: If any value is out of range.\n    \"\"\"\n    if self.resampling_period.total_seconds() &lt; 0.0:\n        raise ValueError(\n            f\"resampling_period ({self.resampling_period}) must be positive\"\n        )\n    if self.max_data_age_in_periods &lt; 1.0:\n        raise ValueError(\n            f\"max_data_age_in_periods ({self.max_data_age_in_periods}) should be at least 1.0\"\n        )\n    if self.warn_buffer_len &lt; 1:\n        raise ValueError(\n            f\"warn_buffer_len ({self.warn_buffer_len}) should be at least 1\"\n        )\n    if self.max_buffer_len &lt;= self.warn_buffer_len:\n        raise ValueError(\n            f\"max_buffer_len ({self.max_buffer_len}) should \"\n            f\"be bigger than warn_buffer_len ({self.warn_buffer_len})\"\n        )\n\n    if self.initial_buffer_len &lt; 1:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) should at least 1\"\n        )\n    if self.initial_buffer_len &gt; self.max_buffer_len:\n        raise ValueError(\n            f\"initial_buffer_len ({self.initial_buffer_len}) is bigger \"\n            f\"than max_buffer_len ({self.max_buffer_len}), use a smaller \"\n            \"initial_buffer_len or a bigger max_buffer_len\"\n        )\n    if self.initial_buffer_len &gt; self.warn_buffer_len:\n        _logger.warning(\n            \"initial_buffer_len (%s) is bigger than warn_buffer_len (%s)\",\n            self.initial_buffer_len,\n            self.warn_buffer_len,\n        )\n    if self.align_to is not None and self.align_to.tzinfo is None:\n        raise ValueError(\n            f\"align_to ({self.align_to}) should be a timezone aware datetime\"\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample","title":"<code>frequenz.sdk.timeseries.Sample</code>  <code>dataclass</code>","text":"<p>A measurement taken at a particular point in time.</p> <p>The <code>value</code> could be <code>None</code> if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True, order=True)\nclass Sample:\n\"\"\"A measurement taken at a particular point in time.\n\n    The `value` could be `None` if a component is malfunctioning or data is\n    lacking for another reason, but a sample still needs to be sent to have a\n    coherent view on a group of component metrics for a particular timestamp.\n    \"\"\"\n\n    timestamp: datetime\n\"\"\"The time when this sample was generated.\"\"\"\n\n    value: float | None = None\n\"\"\"The value of this sample.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample.timestamp","title":"<code>timestamp: datetime</code>  <code>instance-attribute</code>","text":"<p>The time when this sample was generated.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample.value","title":"<code>value: float | None = None</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>The value of this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase","title":"<code>frequenz.sdk.timeseries.Sample3Phase</code>  <code>dataclass</code>","text":"<p>A 3-phase measurement made at a particular point in time.</p> <p>Each of the <code>value</code> fields could be <code>None</code> if a component is malfunctioning or data is lacking for another reason, but a sample still needs to be sent to have a coherent view on a group of component metrics for a particular timestamp.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Sample3Phase:\n\"\"\"A 3-phase measurement made at a particular point in time.\n\n    Each of the `value` fields could be `None` if a component is malfunctioning\n    or data is lacking for another reason, but a sample still needs to be sent\n    to have a coherent view on a group of component metrics for a particular\n    timestamp.\n    \"\"\"\n\n    timestamp: datetime\n\"\"\"The time when this sample was generated.\"\"\"\n    value_p1: float | None\n\"\"\"The value of the 1st phase in this sample.\"\"\"\n\n    value_p2: float | None\n\"\"\"The value of the 2nd phase in this sample.\"\"\"\n\n    value_p3: float | None\n\"\"\"The value of the 3rd phase in this sample.\"\"\"\n\n    def __iter__(self) -&gt; Iterator[float | None]:\n\"\"\"Return an iterator that yields values from each of the phases.\n\n        Yields:\n            Per-phase measurements one-by-one.\n        \"\"\"\n        yield self.value_p1\n        yield self.value_p2\n        yield self.value_p3\n\n    @overload\n    def max(self, default: float) -&gt; float:\n        ...\n\n    @overload\n    def max(self, default: None = None) -&gt; float | None:\n        ...\n\n    def max(self, default: float | None = None) -&gt; float | None:\n\"\"\"Return the max value among all phases, or default if they are all `None`.\n\n        Args:\n            default: value to return if all phases are `None`.\n\n        Returns:\n            Max value among all phases, if available, default value otherwise.\n        \"\"\"\n        if not any(self):\n            return default\n        value: float = functools.reduce(\n            lambda x, y: x if x &gt; y else y,\n            filter(None, self),\n        )\n        return value\n\n    @overload\n    def min(self, default: float) -&gt; float:\n        ...\n\n    @overload\n    def min(self, default: None = None) -&gt; float | None:\n        ...\n\n    def min(self, default: float | None = None) -&gt; float | None:\n\"\"\"Return the min value among all phases, or default if they are all `None`.\n\n        Args:\n            default: value to return if all phases are `None`.\n\n        Returns:\n            Min value among all phases, if available, default value otherwise.\n        \"\"\"\n        if not any(self):\n            return default\n        value: float = functools.reduce(\n            lambda x, y: x if x &lt; y else y,\n            filter(None, self),\n        )\n        return value\n\n    def map(\n        self, function: Callable[[float], float], default: float | None = None\n    ) -&gt; Self:\n\"\"\"Apply the given function on each of the phase values and return the result.\n\n        If a phase value is `None`, replace it with `default` instead.\n\n        Args:\n            function: The function to apply on each of the phase values.\n            default: The value to apply if a phase value is `None`.\n\n        Returns:\n            A new instance, with the given function applied on values for each of the\n                phases.\n        \"\"\"\n        return self.__class__(\n            timestamp=self.timestamp,\n            value_p1=default if self.value_p1 is None else function(self.value_p1),\n            value_p2=default if self.value_p2 is None else function(self.value_p2),\n            value_p3=default if self.value_p3 is None else function(self.value_p3),\n        )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.timestamp","title":"<code>timestamp: datetime</code>  <code>instance-attribute</code>","text":"<p>The time when this sample was generated.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.value_p1","title":"<code>value_p1: float | None</code>  <code>instance-attribute</code>","text":"<p>The value of the 1st phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.value_p2","title":"<code>value_p2: float | None</code>  <code>instance-attribute</code>","text":"<p>The value of the 2nd phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.value_p3","title":"<code>value_p3: float | None</code>  <code>instance-attribute</code>","text":"<p>The value of the 3rd phase in this sample.</p>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries.Sample3Phase-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator that yields values from each of the phases.</p> YIELDS DESCRIPTION <code>Iterator[float | None]</code> <p>Per-phase measurements one-by-one.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float | None]:\n\"\"\"Return an iterator that yields values from each of the phases.\n\n    Yields:\n        Per-phase measurements one-by-one.\n    \"\"\"\n    yield self.value_p1\n    yield self.value_p2\n    yield self.value_p3\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.map","title":"<code>map(function, default=None)</code>","text":"<p>Apply the given function on each of the phase values and return the result.</p> <p>If a phase value is <code>None</code>, replace it with <code>default</code> instead.</p> PARAMETER DESCRIPTION <code>function</code> <p>The function to apply on each of the phase values.</p> <p> TYPE: <code>Callable[[float], float]</code> </p> <code>default</code> <p>The value to apply if a phase value is <code>None</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new instance, with the given function applied on values for each of the phases.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def map(\n    self, function: Callable[[float], float], default: float | None = None\n) -&gt; Self:\n\"\"\"Apply the given function on each of the phase values and return the result.\n\n    If a phase value is `None`, replace it with `default` instead.\n\n    Args:\n        function: The function to apply on each of the phase values.\n        default: The value to apply if a phase value is `None`.\n\n    Returns:\n        A new instance, with the given function applied on values for each of the\n            phases.\n    \"\"\"\n    return self.__class__(\n        timestamp=self.timestamp,\n        value_p1=default if self.value_p1 is None else function(self.value_p1),\n        value_p2=default if self.value_p2 is None else function(self.value_p2),\n        value_p3=default if self.value_p3 is None else function(self.value_p3),\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.max","title":"<code>max(default=None)</code>","text":"<p>Return the max value among all phases, or default if they are all <code>None</code>.</p> PARAMETER DESCRIPTION <code>default</code> <p>value to return if all phases are <code>None</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float | None</code> <p>Max value among all phases, if available, default value otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def max(self, default: float | None = None) -&gt; float | None:\n\"\"\"Return the max value among all phases, or default if they are all `None`.\n\n    Args:\n        default: value to return if all phases are `None`.\n\n    Returns:\n        Max value among all phases, if available, default value otherwise.\n    \"\"\"\n    if not any(self):\n        return default\n    value: float = functools.reduce(\n        lambda x, y: x if x &gt; y else y,\n        filter(None, self),\n    )\n    return value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/#frequenz.sdk.timeseries._base_types.Sample3Phase.min","title":"<code>min(default=None)</code>","text":"<p>Return the min value among all phases, or default if they are all <code>None</code>.</p> PARAMETER DESCRIPTION <code>default</code> <p>value to return if all phases are <code>None</code>.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float | None</code> <p>Min value among all phases, if available, default value otherwise.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/_base_types.py</code> <pre><code>def min(self, default: float | None = None) -&gt; float | None:\n\"\"\"Return the min value among all phases, or default if they are all `None`.\n\n    Args:\n        default: value to return if all phases are `None`.\n\n    Returns:\n        Min value among all phases, if available, default value otherwise.\n    \"\"\"\n    if not any(self):\n        return default\n    value: float = functools.reduce(\n        lambda x, y: x if x &lt; y else y,\n        filter(None, self),\n    )\n    return value\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/","title":"battery_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool","title":"<code>frequenz.sdk.timeseries.battery_pool</code>","text":"<p>Manage a pool of batteries.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool","title":"<code>frequenz.sdk.timeseries.battery_pool.BatteryPool</code>","text":"<p>Calculate high level metrics for a pool of the batteries.</p> <p>BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>class BatteryPool:\n\"\"\"Calculate high level metrics for a pool of the batteries.\n\n    BatterPool accepts subset of the battery ids and provides methods methods for\n    fetching high level metrics for this subset.\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        channel_registry: ChannelRegistry,\n        resampler_subscription_sender: Sender[ComponentMetricRequest],\n        batteries_status_receiver: Receiver[BatteryStatus],\n        power_distributing_sender: Sender[Request],\n        min_update_interval: timedelta,\n        batteries_id: Set[int] | None = None,\n    ) -&gt; None:\n\"\"\"Create the class instance.\n\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n            batteries_status_receiver: Receiver to receive status of the batteries.\n                Receivers should has maxsize = 1 to fetch only the latest status.\n                Battery status channel should has resend_latest = True.\n                It should send information when any battery changed status.\n                Battery status should include status of the inverter adjacent to this\n                battery.\n            power_distributing_sender: A Channel sender for sending power requests to\n                the power distributing actor.\n            min_update_interval: Some metrics in BatteryPool are send only when they\n                change. For these metrics min_update_interval is the minimum time\n                interval between the following messages.\n                Note that this argument is similar to the resampling period\n                argument in the ComponentMetricsResamplingActor. But as opposed to\n                ResamplingActor, timestamp returned in the resulting message will be\n                the timestamp of the last received component data.\n                It is currently impossible to use resampling actor for these metrics,\n                because we can't specify resampling function for them.\n            batteries_id: Subset of the batteries that should be included in the\n                battery pool. If None or empty, then all batteries from the microgrid\n                will be used.\n        \"\"\"\n        if batteries_id:\n            self._batteries: Set[int] = batteries_id\n        else:\n            self._batteries = self._get_all_batteries()\n\n        self._working_batteries: set[int] = set()\n\n        self._update_battery_status_task: asyncio.Task[None] | None = None\n        if self._batteries:\n            self._update_battery_status_task = asyncio.create_task(\n                self._update_battery_status(batteries_status_receiver)\n            )\n\n        self._min_update_interval = min_update_interval\n\n        self._power_distributing_sender = power_distributing_sender\n        self._active_methods: dict[str, MetricAggregator[Any]] = {}\n\n        self._namespace: str = f\"battery-pool-{self._batteries}-{uuid.uuid4()}\"\n        self._power_distributing_namespace: str = f\"power-distributor-{self._namespace}\"\n        self._channel_registry: ChannelRegistry = channel_registry\n        self._formula_pool: FormulaEnginePool = FormulaEnginePool(\n            self._namespace,\n            channel_registry,\n            resampler_subscription_sender,\n        )\n\n    async def set_power(\n        self,\n        power: float,\n        *,\n        adjust_power: bool = True,\n        request_timeout: timedelta = timedelta(seconds=5.0),\n        include_broken_batteries: bool = False,\n    ) -&gt; None:\n\"\"\"Set the given power for the batteries in the pool.\n\n        Power values need to follow the Passive Sign Convention (PSC). That is, positive\n        values indicate charge power and negative values indicate discharge power.\n\n        When not using the Passive Sign Convention, the `charge` and `discharge` methods\n        might be more convenient.\n\n        Args:\n            power: The power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n        \"\"\"\n        await self._power_distributing_sender.send(\n            Request(\n                namespace=self._power_distributing_namespace,\n                power=power,\n                batteries=self._batteries,\n                adjust_power=adjust_power,\n                request_timeout_sec=request_timeout.total_seconds(),\n                include_broken_batteries=include_broken_batteries,\n            )\n        )\n\n    async def charge(\n        self,\n        power: float,\n        *,\n        adjust_power: bool = True,\n        request_timeout: timedelta = timedelta(seconds=5.0),\n        include_broken_batteries: bool = False,\n    ) -&gt; None:\n\"\"\"Set the given charge power for the batteries in the pool.\n\n        Power values need to be positive values, indicating charge power.\n\n        When using the Passive Sign Convention, the `set_power` method might be more\n        convenient.\n\n        Args:\n            power: Unsigned charge power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\n        if power &lt; 0.0:\n            raise ValueError(\"Charge power must be positive.\")\n        await self.set_power(\n            power,\n            adjust_power=adjust_power,\n            request_timeout=request_timeout,\n            include_broken_batteries=include_broken_batteries,\n        )\n\n    async def discharge(\n        self,\n        power: float,\n        *,\n        adjust_power: bool = True,\n        request_timeout: timedelta = timedelta(seconds=5.0),\n        include_broken_batteries: bool = False,\n    ) -&gt; None:\n\"\"\"Set the given discharge power for the batteries in the pool.\n\n        Power values need to be positive values, indicating discharge power.\n\n        When using the Passive Sign Convention, the `set_power` method might be more\n        convenient.\n\n        Args:\n            power: Unsigned discharge power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\n        if power &lt; 0.0:\n            raise ValueError(\"Discharge power must be positive.\")\n        await self.set_power(\n            -power,\n            adjust_power=adjust_power,\n            request_timeout=request_timeout,\n            include_broken_batteries=include_broken_batteries,\n        )\n\n    def power_distribution_results(self) -&gt; Receiver[Result]:\n\"\"\"Return a receiver for the power distribution results.\n\n        Returns:\n            A receiver for the power distribution results.\n        \"\"\"\n        return self._channel_registry.new_receiver(self._power_distributing_namespace)\n\n    @property\n    def battery_ids(self) -&gt; Set[int]:\n\"\"\"Return ids of the batteries in the pool.\n\n        Returns:\n            Ids of the batteries in the pool\n        \"\"\"\n        return self._batteries\n\n    @property\n    def power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the total power of the batteries in the pool.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all\n                batteries in the pool.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"battery_pool_power\",\n            BatteryPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._batteries,\n                formula_type=FormulaType.PASSIVE_SIGN_CONVENTION,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def production_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the total production power of the batteries in the pool.\n\n        This formula produces positive values when producing power and 0 otherwise.\n\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total production power of\n                all batteries in the pool.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"battery_pool_production_power\",\n            BatteryPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._batteries,\n                formula_type=FormulaType.PRODUCTION,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def consumption_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the total consumption power of the batteries in the pool.\n\n        This formula produces positive values when consuming power and 0 otherwise.\n\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total consumption power of\n                all batteries in the pool.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"battery_pool_consumption_power\",\n            BatteryPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._batteries,\n                formula_type=FormulaType.CONSUMPTION,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def soc(self) -&gt; MetricAggregator[SoCMetrics]:\n\"\"\"Get receiver to receive new soc metrics when they change.\n\n        Soc formulas are described in the receiver return type.  None will be send if\n        there is no component to calculate metric.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the aggregate soc of\n                all batteries in the pool.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + SoCCalculator.name()\n\n        if method_name not in self._active_methods:\n            calculator = SoCCalculator(self._batteries)\n            self._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._working_batteries,\n                min_update_interval=self._min_update_interval,\n            )\n\n        return self._active_methods[method_name]\n\n    @property\n    def capacity(self) -&gt; MetricAggregator[CapacityMetrics]:\n\"\"\"Get receiver to receive new capacity metrics when they change.\n\n        Capacity formulas are described in the receiver return type.  None will be send\n        if there is no component to calculate metrics.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the capacity of all\n                batteries in the pool.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + CapacityCalculator.name()\n\n        if method_name not in self._active_methods:\n            calculator = CapacityCalculator(self._batteries)\n            self._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._working_batteries,\n                min_update_interval=self._min_update_interval,\n            )\n\n        return self._active_methods[method_name]\n\n    @property\n    def power_bounds(self) -&gt; MetricAggregator[PowerMetrics]:\n\"\"\"Get receiver to receive new power bounds when they change.\n\n        Power bounds formulas are described in the receiver return type.\n        None will be send if there is no component to calculate metrics.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the power bounds\n                of all batteries in the pool.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + PowerBoundsCalculator.name()\n\n        if method_name not in self._active_methods:\n            calculator = PowerBoundsCalculator(self._batteries)\n            self._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._working_batteries,\n                min_update_interval=self._min_update_interval,\n            )\n\n        return self._active_methods[method_name]\n\n    async def stop(self) -&gt; None:\n\"\"\"Stop all pending async tasks.\"\"\"\n        tasks_to_stop: list[Awaitable[Any]] = [\n            method.stop() for method in self._active_methods.values()\n        ]\n        tasks_to_stop.append(self._formula_pool.stop())\n        if self._update_battery_status_task:\n            tasks_to_stop.append(cancel_and_await(self._update_battery_status_task))\n        await asyncio.gather(*tasks_to_stop)\n\n    def _get_all_batteries(self) -&gt; Set[int]:\n\"\"\"Get all batteries from the microgrid.\n\n        Returns:\n            All batteries in the microgrid.\n        \"\"\"\n        graph = connection_manager.get().component_graph\n        return {\n            battery.component_id\n            for battery in graph.components(\n                component_category={ComponentCategory.BATTERY}\n            )\n        }\n\n    async def _update_battery_status(self, receiver: Receiver[BatteryStatus]) -&gt; None:\n        async for status in receiver:\n            self._working_batteries = status.get_working_batteries(self._batteries)\n            for item in self._active_methods.values():\n                item.update_working_batteries(self._working_batteries)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.battery_ids","title":"<code>battery_ids: Set[int]</code>  <code>property</code>","text":"<p>Return ids of the batteries in the pool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Ids of the batteries in the pool</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.capacity","title":"<code>capacity: MetricAggregator[CapacityMetrics]</code>  <code>property</code>","text":"<p>Get receiver to receive new capacity metrics when they change.</p> <p>Capacity formulas are described in the receiver return type.  None will be send if there is no component to calculate metrics.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[CapacityMetrics]</code> <p>A MetricAggregator that will calculate and stream the capacity of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.consumption_power","title":"<code>consumption_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the total consumption power of the batteries in the pool.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream the total consumption power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.power","title":"<code>power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the total power of the batteries in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream the total power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.power_bounds","title":"<code>power_bounds: MetricAggregator[PowerMetrics]</code>  <code>property</code>","text":"<p>Get receiver to receive new power bounds when they change.</p> <p>Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[PowerMetrics]</code> <p>A MetricAggregator that will calculate and stream the power bounds of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.production_power","title":"<code>production_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the total production power of the batteries in the pool.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream the total production power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.soc","title":"<code>soc: MetricAggregator[SoCMetrics]</code>  <code>property</code>","text":"<p>Get receiver to receive new soc metrics when they change.</p> <p>Soc formulas are described in the receiver return type.  None will be send if there is no component to calculate metric.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[SoCMetrics]</code> <p>A MetricAggregator that will calculate and stream the aggregate soc of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.BatteryPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.__init__","title":"<code>__init__(channel_registry, resampler_subscription_sender, batteries_status_receiver, power_distributing_sender, min_update_interval, batteries_id=None)</code>","text":"<p>Create the class instance.</p> PARAMETER DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>batteries_status_receiver</code> <p>Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery.</p> <p> TYPE: <code>Receiver[BatteryStatus]</code> </p> <code>power_distributing_sender</code> <p>A Channel sender for sending power requests to the power distributing actor.</p> <p> TYPE: <code>Sender[Request]</code> </p> <code>min_update_interval</code> <p>Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them.</p> <p> TYPE: <code>timedelta</code> </p> <code>batteries_id</code> <p>Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used.</p> <p> TYPE: <code>Set[int] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n    batteries_status_receiver: Receiver[BatteryStatus],\n    power_distributing_sender: Sender[Request],\n    min_update_interval: timedelta,\n    batteries_id: Set[int] | None = None,\n) -&gt; None:\n\"\"\"Create the class instance.\n\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n        batteries_status_receiver: Receiver to receive status of the batteries.\n            Receivers should has maxsize = 1 to fetch only the latest status.\n            Battery status channel should has resend_latest = True.\n            It should send information when any battery changed status.\n            Battery status should include status of the inverter adjacent to this\n            battery.\n        power_distributing_sender: A Channel sender for sending power requests to\n            the power distributing actor.\n        min_update_interval: Some metrics in BatteryPool are send only when they\n            change. For these metrics min_update_interval is the minimum time\n            interval between the following messages.\n            Note that this argument is similar to the resampling period\n            argument in the ComponentMetricsResamplingActor. But as opposed to\n            ResamplingActor, timestamp returned in the resulting message will be\n            the timestamp of the last received component data.\n            It is currently impossible to use resampling actor for these metrics,\n            because we can't specify resampling function for them.\n        batteries_id: Subset of the batteries that should be included in the\n            battery pool. If None or empty, then all batteries from the microgrid\n            will be used.\n    \"\"\"\n    if batteries_id:\n        self._batteries: Set[int] = batteries_id\n    else:\n        self._batteries = self._get_all_batteries()\n\n    self._working_batteries: set[int] = set()\n\n    self._update_battery_status_task: asyncio.Task[None] | None = None\n    if self._batteries:\n        self._update_battery_status_task = asyncio.create_task(\n            self._update_battery_status(batteries_status_receiver)\n        )\n\n    self._min_update_interval = min_update_interval\n\n    self._power_distributing_sender = power_distributing_sender\n    self._active_methods: dict[str, MetricAggregator[Any]] = {}\n\n    self._namespace: str = f\"battery-pool-{self._batteries}-{uuid.uuid4()}\"\n    self._power_distributing_namespace: str = f\"power-distributor-{self._namespace}\"\n    self._channel_registry: ChannelRegistry = channel_registry\n    self._formula_pool: FormulaEnginePool = FormulaEnginePool(\n        self._namespace,\n        channel_registry,\n        resampler_subscription_sender,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.charge","title":"<code>charge(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given charge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating charge power.</p> <p>When using the Passive Sign Convention, the <code>set_power</code> method might be more convenient.</p> PARAMETER DESCRIPTION <code>power</code> <p>Unsigned charge power to set for the batteries in the pool.</p> <p> TYPE: <code>float</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def charge(\n    self,\n    power: float,\n    *,\n    adjust_power: bool = True,\n    request_timeout: timedelta = timedelta(seconds=5.0),\n    include_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given charge power for the batteries in the pool.\n\n    Power values need to be positive values, indicating charge power.\n\n    When using the Passive Sign Convention, the `set_power` method might be more\n    convenient.\n\n    Args:\n        power: Unsigned charge power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\n    if power &lt; 0.0:\n        raise ValueError(\"Charge power must be positive.\")\n    await self.set_power(\n        power,\n        adjust_power=adjust_power,\n        request_timeout=request_timeout,\n        include_broken_batteries=include_broken_batteries,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.discharge","title":"<code>discharge(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given discharge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating discharge power.</p> <p>When using the Passive Sign Convention, the <code>set_power</code> method might be more convenient.</p> PARAMETER DESCRIPTION <code>power</code> <p>Unsigned discharge power to set for the batteries in the pool.</p> <p> TYPE: <code>float</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def discharge(\n    self,\n    power: float,\n    *,\n    adjust_power: bool = True,\n    request_timeout: timedelta = timedelta(seconds=5.0),\n    include_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given discharge power for the batteries in the pool.\n\n    Power values need to be positive values, indicating discharge power.\n\n    When using the Passive Sign Convention, the `set_power` method might be more\n    convenient.\n\n    Args:\n        power: Unsigned discharge power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\n    if power &lt; 0.0:\n        raise ValueError(\"Discharge power must be positive.\")\n    await self.set_power(\n        -power,\n        adjust_power=adjust_power,\n        request_timeout=request_timeout,\n        include_broken_batteries=include_broken_batteries,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.power_distribution_results","title":"<code>power_distribution_results()</code>","text":"<p>Return a receiver for the power distribution results.</p> RETURNS DESCRIPTION <code>Receiver[Result]</code> <p>A receiver for the power distribution results.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>def power_distribution_results(self) -&gt; Receiver[Result]:\n\"\"\"Return a receiver for the power distribution results.\n\n    Returns:\n        A receiver for the power distribution results.\n    \"\"\"\n    return self._channel_registry.new_receiver(self._power_distributing_namespace)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.set_power","title":"<code>set_power(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given power for the batteries in the pool.</p> <p>Power values need to follow the Passive Sign Convention (PSC). That is, positive values indicate charge power and negative values indicate discharge power.</p> <p>When not using the Passive Sign Convention, the <code>charge</code> and <code>discharge</code> methods might be more convenient.</p> PARAMETER DESCRIPTION <code>power</code> <p>The power to set for the batteries in the pool.</p> <p> TYPE: <code>float</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def set_power(\n    self,\n    power: float,\n    *,\n    adjust_power: bool = True,\n    request_timeout: timedelta = timedelta(seconds=5.0),\n    include_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given power for the batteries in the pool.\n\n    Power values need to follow the Passive Sign Convention (PSC). That is, positive\n    values indicate charge power and negative values indicate discharge power.\n\n    When not using the Passive Sign Convention, the `charge` and `discharge` methods\n    might be more convenient.\n\n    Args:\n        power: The power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n    \"\"\"\n    await self._power_distributing_sender.send(\n        Request(\n            namespace=self._power_distributing_namespace,\n            power=power,\n            batteries=self._batteries,\n            adjust_power=adjust_power,\n            request_timeout_sec=request_timeout.total_seconds(),\n            include_broken_batteries=include_broken_batteries,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop all pending async tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop all pending async tasks.\"\"\"\n    tasks_to_stop: list[Awaitable[Any]] = [\n        method.stop() for method in self._active_methods.values()\n    ]\n    tasks_to_stop.append(self._formula_pool.stop())\n    if self._update_battery_status_task:\n        tasks_to_stop.append(cancel_and_await(self._update_battery_status_task))\n    await asyncio.gather(*tasks_to_stop)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Bound","title":"<code>frequenz.sdk.timeseries.battery_pool.Bound</code>  <code>dataclass</code>","text":"<p>Lower and upper bound values.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/_result_types.py</code> <pre><code>@dataclass\nclass Bound:\n\"\"\"Lower and upper bound values.\"\"\"\n\n    lower: float\n\"\"\"Lower bound.\"\"\"\n\n    upper: float\n\"\"\"Upper bound.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.Bound-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.Bound.lower","title":"<code>lower: float</code>  <code>instance-attribute</code>","text":"<p>Lower bound.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.Bound.upper","title":"<code>upper: float</code>  <code>instance-attribute</code>","text":"<p>Upper bound.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.CapacityMetrics","title":"<code>frequenz.sdk.timeseries.battery_pool.CapacityMetrics</code>  <code>dataclass</code>","text":"<p>Capacity metrics.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/_result_types.py</code> <pre><code>@dataclass\nclass CapacityMetrics:\n\"\"\"Capacity metrics.\"\"\"\n\n    # compare = False tells the dataclass to not use name for comparison methods\n    timestamp: datetime = field(compare=False)\n\"\"\"Timestamp of the metrics,\"\"\"\n\n    total_capacity: float\n\"\"\"Total batteries capacity.\n\n    Calculated with the formula:\n    ```python\n    working_batteries: Set[BatteryData] # working batteries from the battery pool\n    total_capacity = sum(battery.capacity for battery in working_batteries)\n    ```\n    \"\"\"\n    bound: Bound\n\"\"\"Capacity bounds.\n\n    Bounds are calculated with the formula:\n    ```python\n    working_batteries: Set[BatteryData] # working batteries from the battery\n    bound.lower = sum(\n        battery.capacity * battery.soc_lower_bound for battery in working_batteries)\n\n    bound.upper = sum(\n        battery.capacity * battery.soc_upper_bound for battery in working_batteries)\n    ```\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.CapacityMetrics-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.CapacityMetrics.bound","title":"<code>bound: Bound</code>  <code>instance-attribute</code>","text":"<p>Capacity bounds.</p> <p>Bounds are calculated with the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery\nbound.lower = sum(\n    battery.capacity * battery.soc_lower_bound for battery in working_batteries)\n\nbound.upper = sum(\n    battery.capacity * battery.soc_upper_bound for battery in working_batteries)\n</code></pre></p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.CapacityMetrics.timestamp","title":"<code>timestamp: datetime = field(compare=False)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Timestamp of the metrics,</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.CapacityMetrics.total_capacity","title":"<code>total_capacity: float</code>  <code>instance-attribute</code>","text":"<p>Total batteries capacity.</p> <p>Calculated with the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\ntotal_capacity = sum(battery.capacity for battery in working_batteries)\n</code></pre></p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics","title":"<code>frequenz.sdk.timeseries.battery_pool.PowerMetrics</code>  <code>dataclass</code>","text":"<p>Power bounds metrics.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/_result_types.py</code> <pre><code>@dataclass\nclass PowerMetrics:\n\"\"\"Power bounds metrics.\"\"\"\n\n    # compare = False tells the dataclass to not use name for comparison methods\n    timestamp: datetime = field(compare=False)\n\"\"\"Timestamp of the metrics.\"\"\"\n\n    supply_bound: Bound\n\"\"\"Supply power bounds.\n\n    Upper bound is always 0 and will be supported later.\n    Lower bound is negative number calculated with with the formula:\n    ```python\n    working_pairs: Set[BatteryData, InverterData] # working batteries from the battery\n        pool and adjacent inverters\n\n    supply_bound.lower = sum(\n        max(\n            battery.power_lower_bound, inverter.active_power_lower_bound)\n            for each working battery in battery pool\n            )\n        )\n    ```\n    \"\"\"\n\n    consume_bound: Bound\n\"\"\"Consume power bounds.\n\n    Lower bound is always 0 and will be supported later.\n    Upper bound is positive number calculated with with the formula:\n    ```python\n    working_pairs: Set[BatteryData, InverterData] # working batteries from the battery\n        pool and adjacent inverters\n\n    consume_bound.upper = sum(\n        min(\n            battery.power_upper_bound, inverter.active_power_upper_bound)\n            for each working battery in battery pool\n            )\n        )\n    ```\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.PowerMetrics-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.PowerMetrics.consume_bound","title":"<code>consume_bound: Bound</code>  <code>instance-attribute</code>","text":"<p>Consume power bounds.</p> <p>Lower bound is always 0 and will be supported later. Upper bound is positive number calculated with with the formula: <pre><code>working_pairs: Set[BatteryData, InverterData] # working batteries from the battery\n    pool and adjacent inverters\n\nconsume_bound.upper = sum(\n    min(\n        battery.power_upper_bound, inverter.active_power_upper_bound)\n        for each working battery in battery pool\n        )\n    )\n</code></pre></p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.PowerMetrics.supply_bound","title":"<code>supply_bound: Bound</code>  <code>instance-attribute</code>","text":"<p>Supply power bounds.</p> <p>Upper bound is always 0 and will be supported later. Lower bound is negative number calculated with with the formula: <pre><code>working_pairs: Set[BatteryData, InverterData] # working batteries from the battery\n    pool and adjacent inverters\n\nsupply_bound.lower = sum(\n    max(\n        battery.power_lower_bound, inverter.active_power_lower_bound)\n        for each working battery in battery pool\n        )\n    )\n</code></pre></p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.PowerMetrics.timestamp","title":"<code>timestamp: datetime = field(compare=False)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Timestamp of the metrics.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.SoCMetrics","title":"<code>frequenz.sdk.timeseries.battery_pool.SoCMetrics</code>  <code>dataclass</code>","text":"<p>Soc metrics.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/_result_types.py</code> <pre><code>@dataclass\nclass SoCMetrics:\n\"\"\"Soc metrics.\"\"\"\n\n    # compare = False tells the dataclass to not use name for comparison methods\n    timestamp: datetime = field(compare=False)\n\"\"\"Timestamp of the metrics.\"\"\"\n\n    average_soc: float\n\"\"\"Average soc.\n\n    Average soc is calculated with the formula:\n    ```python\n    working_batteries: Set[BatteryData] # working batteries from the battery pool\n\n    used_capacity = sum(battery.capacity * battery.soc for battery in working_batteries)\n    total_capacity = sum(battery.capacity for battery in working_batteries)\n    average_soc = used_capacity/total_capacity\n    ```\n    \"\"\"\n\n    bound: Bound\n\"\"\"SoC bounds weighted by capacity.\n\n    Bounds are calculated with the formula:\n    capacity_lower_bound = sum(\n        battery.capacity * battery.soc_lower_bound for battery in working_batteries)\n\n    capacity_upper_bound = sum(\n        battery.capacity * battery.soc_upper_bound for battery in working_batteries)\n\n    total_capacity = sum(battery.capacity for battery in working_batteries)\n\n    bound.lower = capacity_lower_bound/total_capacity\n    bound.upper = capacity_upper_bound/total_capacity\n\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool.SoCMetrics-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.SoCMetrics.average_soc","title":"<code>average_soc: float</code>  <code>instance-attribute</code>","text":"<p>Average soc.</p> <p>Average soc is calculated with the formula: <pre><code>working_batteries: Set[BatteryData] # working batteries from the battery pool\n\nused_capacity = sum(battery.capacity * battery.soc for battery in working_batteries)\ntotal_capacity = sum(battery.capacity for battery in working_batteries)\naverage_soc = used_capacity/total_capacity\n</code></pre></p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.SoCMetrics.bound","title":"<code>bound: Bound</code>  <code>instance-attribute</code>","text":"<p>SoC bounds weighted by capacity.</p> <p>Bounds are calculated with the formula: capacity_lower_bound = sum(     battery.capacity * battery.soc_lower_bound for battery in working_batteries)</p> <p>capacity_upper_bound = sum(     battery.capacity * battery.soc_upper_bound for battery in working_batteries)</p> <p>total_capacity = sum(battery.capacity for battery in working_batteries)</p> <p>bound.lower = capacity_lower_bound/total_capacity bound.upper = capacity_upper_bound/total_capacity</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/#frequenz.sdk.timeseries.battery_pool._result_types.SoCMetrics.timestamp","title":"<code>timestamp: datetime = field(compare=False)</code>  <code>instance-attribute</code> <code>class-attribute</code>","text":"<p>Timestamp of the metrics.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/","title":"battery_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool","title":"<code>frequenz.sdk.timeseries.battery_pool.battery_pool</code>","text":"<p>User interface for requesting aggregated battery-inverter data.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool","title":"<code>frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool</code>","text":"<p>Calculate high level metrics for a pool of the batteries.</p> <p>BatterPool accepts subset of the battery ids and provides methods methods for fetching high level metrics for this subset.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>class BatteryPool:\n\"\"\"Calculate high level metrics for a pool of the batteries.\n\n    BatterPool accepts subset of the battery ids and provides methods methods for\n    fetching high level metrics for this subset.\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        channel_registry: ChannelRegistry,\n        resampler_subscription_sender: Sender[ComponentMetricRequest],\n        batteries_status_receiver: Receiver[BatteryStatus],\n        power_distributing_sender: Sender[Request],\n        min_update_interval: timedelta,\n        batteries_id: Set[int] | None = None,\n    ) -&gt; None:\n\"\"\"Create the class instance.\n\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n            batteries_status_receiver: Receiver to receive status of the batteries.\n                Receivers should has maxsize = 1 to fetch only the latest status.\n                Battery status channel should has resend_latest = True.\n                It should send information when any battery changed status.\n                Battery status should include status of the inverter adjacent to this\n                battery.\n            power_distributing_sender: A Channel sender for sending power requests to\n                the power distributing actor.\n            min_update_interval: Some metrics in BatteryPool are send only when they\n                change. For these metrics min_update_interval is the minimum time\n                interval between the following messages.\n                Note that this argument is similar to the resampling period\n                argument in the ComponentMetricsResamplingActor. But as opposed to\n                ResamplingActor, timestamp returned in the resulting message will be\n                the timestamp of the last received component data.\n                It is currently impossible to use resampling actor for these metrics,\n                because we can't specify resampling function for them.\n            batteries_id: Subset of the batteries that should be included in the\n                battery pool. If None or empty, then all batteries from the microgrid\n                will be used.\n        \"\"\"\n        if batteries_id:\n            self._batteries: Set[int] = batteries_id\n        else:\n            self._batteries = self._get_all_batteries()\n\n        self._working_batteries: set[int] = set()\n\n        self._update_battery_status_task: asyncio.Task[None] | None = None\n        if self._batteries:\n            self._update_battery_status_task = asyncio.create_task(\n                self._update_battery_status(batteries_status_receiver)\n            )\n\n        self._min_update_interval = min_update_interval\n\n        self._power_distributing_sender = power_distributing_sender\n        self._active_methods: dict[str, MetricAggregator[Any]] = {}\n\n        self._namespace: str = f\"battery-pool-{self._batteries}-{uuid.uuid4()}\"\n        self._power_distributing_namespace: str = f\"power-distributor-{self._namespace}\"\n        self._channel_registry: ChannelRegistry = channel_registry\n        self._formula_pool: FormulaEnginePool = FormulaEnginePool(\n            self._namespace,\n            channel_registry,\n            resampler_subscription_sender,\n        )\n\n    async def set_power(\n        self,\n        power: float,\n        *,\n        adjust_power: bool = True,\n        request_timeout: timedelta = timedelta(seconds=5.0),\n        include_broken_batteries: bool = False,\n    ) -&gt; None:\n\"\"\"Set the given power for the batteries in the pool.\n\n        Power values need to follow the Passive Sign Convention (PSC). That is, positive\n        values indicate charge power and negative values indicate discharge power.\n\n        When not using the Passive Sign Convention, the `charge` and `discharge` methods\n        might be more convenient.\n\n        Args:\n            power: The power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n        \"\"\"\n        await self._power_distributing_sender.send(\n            Request(\n                namespace=self._power_distributing_namespace,\n                power=power,\n                batteries=self._batteries,\n                adjust_power=adjust_power,\n                request_timeout_sec=request_timeout.total_seconds(),\n                include_broken_batteries=include_broken_batteries,\n            )\n        )\n\n    async def charge(\n        self,\n        power: float,\n        *,\n        adjust_power: bool = True,\n        request_timeout: timedelta = timedelta(seconds=5.0),\n        include_broken_batteries: bool = False,\n    ) -&gt; None:\n\"\"\"Set the given charge power for the batteries in the pool.\n\n        Power values need to be positive values, indicating charge power.\n\n        When using the Passive Sign Convention, the `set_power` method might be more\n        convenient.\n\n        Args:\n            power: Unsigned charge power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\n        if power &lt; 0.0:\n            raise ValueError(\"Charge power must be positive.\")\n        await self.set_power(\n            power,\n            adjust_power=adjust_power,\n            request_timeout=request_timeout,\n            include_broken_batteries=include_broken_batteries,\n        )\n\n    async def discharge(\n        self,\n        power: float,\n        *,\n        adjust_power: bool = True,\n        request_timeout: timedelta = timedelta(seconds=5.0),\n        include_broken_batteries: bool = False,\n    ) -&gt; None:\n\"\"\"Set the given discharge power for the batteries in the pool.\n\n        Power values need to be positive values, indicating discharge power.\n\n        When using the Passive Sign Convention, the `set_power` method might be more\n        convenient.\n\n        Args:\n            power: Unsigned discharge power to set for the batteries in the pool.\n            adjust_power: If True, the power will be adjusted to fit the power bounds,\n                if necessary. If False, then power requests outside the bounds will be\n                rejected.\n            request_timeout: The timeout for the request.\n            include_broken_batteries: if True, the power will be set for all batteries\n                in the pool, including the broken ones. If False, then the power will be\n                set only for the working batteries.  This is not a guarantee that the\n                power will be set for all working batteries, as the microgrid API may\n                still reject the request.\n\n        Raises:\n            ValueError: If the given power is negative.\n        \"\"\"\n        if power &lt; 0.0:\n            raise ValueError(\"Discharge power must be positive.\")\n        await self.set_power(\n            -power,\n            adjust_power=adjust_power,\n            request_timeout=request_timeout,\n            include_broken_batteries=include_broken_batteries,\n        )\n\n    def power_distribution_results(self) -&gt; Receiver[Result]:\n\"\"\"Return a receiver for the power distribution results.\n\n        Returns:\n            A receiver for the power distribution results.\n        \"\"\"\n        return self._channel_registry.new_receiver(self._power_distributing_namespace)\n\n    @property\n    def battery_ids(self) -&gt; Set[int]:\n\"\"\"Return ids of the batteries in the pool.\n\n        Returns:\n            Ids of the batteries in the pool\n        \"\"\"\n        return self._batteries\n\n    @property\n    def power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the total power of the batteries in the pool.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all\n                batteries in the pool.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"battery_pool_power\",\n            BatteryPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._batteries,\n                formula_type=FormulaType.PASSIVE_SIGN_CONVENTION,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def production_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the total production power of the batteries in the pool.\n\n        This formula produces positive values when producing power and 0 otherwise.\n\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total production power of\n                all batteries in the pool.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"battery_pool_production_power\",\n            BatteryPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._batteries,\n                formula_type=FormulaType.PRODUCTION,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def consumption_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the total consumption power of the batteries in the pool.\n\n        This formula produces positive values when consuming power and 0 otherwise.\n\n        If a formula engine to calculate this metric is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be obtained by calling the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total consumption power of\n                all batteries in the pool.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"battery_pool_consumption_power\",\n            BatteryPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._batteries,\n                formula_type=FormulaType.CONSUMPTION,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def soc(self) -&gt; MetricAggregator[SoCMetrics]:\n\"\"\"Get receiver to receive new soc metrics when they change.\n\n        Soc formulas are described in the receiver return type.  None will be send if\n        there is no component to calculate metric.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the aggregate soc of\n                all batteries in the pool.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + SoCCalculator.name()\n\n        if method_name not in self._active_methods:\n            calculator = SoCCalculator(self._batteries)\n            self._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._working_batteries,\n                min_update_interval=self._min_update_interval,\n            )\n\n        return self._active_methods[method_name]\n\n    @property\n    def capacity(self) -&gt; MetricAggregator[CapacityMetrics]:\n\"\"\"Get receiver to receive new capacity metrics when they change.\n\n        Capacity formulas are described in the receiver return type.  None will be send\n        if there is no component to calculate metrics.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the capacity of all\n                batteries in the pool.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + CapacityCalculator.name()\n\n        if method_name not in self._active_methods:\n            calculator = CapacityCalculator(self._batteries)\n            self._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._working_batteries,\n                min_update_interval=self._min_update_interval,\n            )\n\n        return self._active_methods[method_name]\n\n    @property\n    def power_bounds(self) -&gt; MetricAggregator[PowerMetrics]:\n\"\"\"Get receiver to receive new power bounds when they change.\n\n        Power bounds formulas are described in the receiver return type.\n        None will be send if there is no component to calculate metrics.\n\n        A receiver from the MetricAggregator can be obtained by calling the\n        `new_receiver` method.\n\n        Returns:\n            A MetricAggregator that will calculate and stream the power bounds\n                of all batteries in the pool.\n        \"\"\"\n        method_name = SendOnUpdate.name() + \"_\" + PowerBoundsCalculator.name()\n\n        if method_name not in self._active_methods:\n            calculator = PowerBoundsCalculator(self._batteries)\n            self._active_methods[method_name] = SendOnUpdate(\n                metric_calculator=calculator,\n                working_batteries=self._working_batteries,\n                min_update_interval=self._min_update_interval,\n            )\n\n        return self._active_methods[method_name]\n\n    async def stop(self) -&gt; None:\n\"\"\"Stop all pending async tasks.\"\"\"\n        tasks_to_stop: list[Awaitable[Any]] = [\n            method.stop() for method in self._active_methods.values()\n        ]\n        tasks_to_stop.append(self._formula_pool.stop())\n        if self._update_battery_status_task:\n            tasks_to_stop.append(cancel_and_await(self._update_battery_status_task))\n        await asyncio.gather(*tasks_to_stop)\n\n    def _get_all_batteries(self) -&gt; Set[int]:\n\"\"\"Get all batteries from the microgrid.\n\n        Returns:\n            All batteries in the microgrid.\n        \"\"\"\n        graph = connection_manager.get().component_graph\n        return {\n            battery.component_id\n            for battery in graph.components(\n                component_category={ComponentCategory.BATTERY}\n            )\n        }\n\n    async def _update_battery_status(self, receiver: Receiver[BatteryStatus]) -&gt; None:\n        async for status in receiver:\n            self._working_batteries = status.get_working_batteries(self._batteries)\n            for item in self._active_methods.values():\n                item.update_working_batteries(self._working_batteries)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.battery_ids","title":"<code>battery_ids: Set[int]</code>  <code>property</code>","text":"<p>Return ids of the batteries in the pool.</p> RETURNS DESCRIPTION <code>Set[int]</code> <p>Ids of the batteries in the pool</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.capacity","title":"<code>capacity: MetricAggregator[CapacityMetrics]</code>  <code>property</code>","text":"<p>Get receiver to receive new capacity metrics when they change.</p> <p>Capacity formulas are described in the receiver return type.  None will be send if there is no component to calculate metrics.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[CapacityMetrics]</code> <p>A MetricAggregator that will calculate and stream the capacity of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.consumption_power","title":"<code>consumption_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the total consumption power of the batteries in the pool.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream the total consumption power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.power","title":"<code>power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the total power of the batteries in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream the total power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.power_bounds","title":"<code>power_bounds: MetricAggregator[PowerMetrics]</code>  <code>property</code>","text":"<p>Get receiver to receive new power bounds when they change.</p> <p>Power bounds formulas are described in the receiver return type. None will be send if there is no component to calculate metrics.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[PowerMetrics]</code> <p>A MetricAggregator that will calculate and stream the power bounds of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.production_power","title":"<code>production_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the total production power of the batteries in the pool.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate this metric is not already running, it will be started.</p> <p>A receiver from the formula engine can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream the total production power of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.soc","title":"<code>soc: MetricAggregator[SoCMetrics]</code>  <code>property</code>","text":"<p>Get receiver to receive new soc metrics when they change.</p> <p>Soc formulas are described in the receiver return type.  None will be send if there is no component to calculate metric.</p> <p>A receiver from the MetricAggregator can be obtained by calling the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>MetricAggregator[SoCMetrics]</code> <p>A MetricAggregator that will calculate and stream the aggregate soc of all batteries in the pool.</p>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.__init__","title":"<code>__init__(channel_registry, resampler_subscription_sender, batteries_status_receiver, power_distributing_sender, min_update_interval, batteries_id=None)</code>","text":"<p>Create the class instance.</p> PARAMETER DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>batteries_status_receiver</code> <p>Receiver to receive status of the batteries. Receivers should has maxsize = 1 to fetch only the latest status. Battery status channel should has resend_latest = True. It should send information when any battery changed status. Battery status should include status of the inverter adjacent to this battery.</p> <p> TYPE: <code>Receiver[BatteryStatus]</code> </p> <code>power_distributing_sender</code> <p>A Channel sender for sending power requests to the power distributing actor.</p> <p> TYPE: <code>Sender[Request]</code> </p> <code>min_update_interval</code> <p>Some metrics in BatteryPool are send only when they change. For these metrics min_update_interval is the minimum time interval between the following messages. Note that this argument is similar to the resampling period argument in the ComponentMetricsResamplingActor. But as opposed to ResamplingActor, timestamp returned in the resulting message will be the timestamp of the last received component data. It is currently impossible to use resampling actor for these metrics, because we can't specify resampling function for them.</p> <p> TYPE: <code>timedelta</code> </p> <code>batteries_id</code> <p>Subset of the batteries that should be included in the battery pool. If None or empty, then all batteries from the microgrid will be used.</p> <p> TYPE: <code>Set[int] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n    batteries_status_receiver: Receiver[BatteryStatus],\n    power_distributing_sender: Sender[Request],\n    min_update_interval: timedelta,\n    batteries_id: Set[int] | None = None,\n) -&gt; None:\n\"\"\"Create the class instance.\n\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n        batteries_status_receiver: Receiver to receive status of the batteries.\n            Receivers should has maxsize = 1 to fetch only the latest status.\n            Battery status channel should has resend_latest = True.\n            It should send information when any battery changed status.\n            Battery status should include status of the inverter adjacent to this\n            battery.\n        power_distributing_sender: A Channel sender for sending power requests to\n            the power distributing actor.\n        min_update_interval: Some metrics in BatteryPool are send only when they\n            change. For these metrics min_update_interval is the minimum time\n            interval between the following messages.\n            Note that this argument is similar to the resampling period\n            argument in the ComponentMetricsResamplingActor. But as opposed to\n            ResamplingActor, timestamp returned in the resulting message will be\n            the timestamp of the last received component data.\n            It is currently impossible to use resampling actor for these metrics,\n            because we can't specify resampling function for them.\n        batteries_id: Subset of the batteries that should be included in the\n            battery pool. If None or empty, then all batteries from the microgrid\n            will be used.\n    \"\"\"\n    if batteries_id:\n        self._batteries: Set[int] = batteries_id\n    else:\n        self._batteries = self._get_all_batteries()\n\n    self._working_batteries: set[int] = set()\n\n    self._update_battery_status_task: asyncio.Task[None] | None = None\n    if self._batteries:\n        self._update_battery_status_task = asyncio.create_task(\n            self._update_battery_status(batteries_status_receiver)\n        )\n\n    self._min_update_interval = min_update_interval\n\n    self._power_distributing_sender = power_distributing_sender\n    self._active_methods: dict[str, MetricAggregator[Any]] = {}\n\n    self._namespace: str = f\"battery-pool-{self._batteries}-{uuid.uuid4()}\"\n    self._power_distributing_namespace: str = f\"power-distributor-{self._namespace}\"\n    self._channel_registry: ChannelRegistry = channel_registry\n    self._formula_pool: FormulaEnginePool = FormulaEnginePool(\n        self._namespace,\n        channel_registry,\n        resampler_subscription_sender,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.charge","title":"<code>charge(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given charge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating charge power.</p> <p>When using the Passive Sign Convention, the <code>set_power</code> method might be more convenient.</p> PARAMETER DESCRIPTION <code>power</code> <p>Unsigned charge power to set for the batteries in the pool.</p> <p> TYPE: <code>float</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def charge(\n    self,\n    power: float,\n    *,\n    adjust_power: bool = True,\n    request_timeout: timedelta = timedelta(seconds=5.0),\n    include_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given charge power for the batteries in the pool.\n\n    Power values need to be positive values, indicating charge power.\n\n    When using the Passive Sign Convention, the `set_power` method might be more\n    convenient.\n\n    Args:\n        power: Unsigned charge power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\n    if power &lt; 0.0:\n        raise ValueError(\"Charge power must be positive.\")\n    await self.set_power(\n        power,\n        adjust_power=adjust_power,\n        request_timeout=request_timeout,\n        include_broken_batteries=include_broken_batteries,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.discharge","title":"<code>discharge(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given discharge power for the batteries in the pool.</p> <p>Power values need to be positive values, indicating discharge power.</p> <p>When using the Passive Sign Convention, the <code>set_power</code> method might be more convenient.</p> PARAMETER DESCRIPTION <code>power</code> <p>Unsigned discharge power to set for the batteries in the pool.</p> <p> TYPE: <code>float</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given power is negative.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def discharge(\n    self,\n    power: float,\n    *,\n    adjust_power: bool = True,\n    request_timeout: timedelta = timedelta(seconds=5.0),\n    include_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given discharge power for the batteries in the pool.\n\n    Power values need to be positive values, indicating discharge power.\n\n    When using the Passive Sign Convention, the `set_power` method might be more\n    convenient.\n\n    Args:\n        power: Unsigned discharge power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n\n    Raises:\n        ValueError: If the given power is negative.\n    \"\"\"\n    if power &lt; 0.0:\n        raise ValueError(\"Discharge power must be positive.\")\n    await self.set_power(\n        -power,\n        adjust_power=adjust_power,\n        request_timeout=request_timeout,\n        include_broken_batteries=include_broken_batteries,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.power_distribution_results","title":"<code>power_distribution_results()</code>","text":"<p>Return a receiver for the power distribution results.</p> RETURNS DESCRIPTION <code>Receiver[Result]</code> <p>A receiver for the power distribution results.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>def power_distribution_results(self) -&gt; Receiver[Result]:\n\"\"\"Return a receiver for the power distribution results.\n\n    Returns:\n        A receiver for the power distribution results.\n    \"\"\"\n    return self._channel_registry.new_receiver(self._power_distributing_namespace)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.set_power","title":"<code>set_power(power, *, adjust_power=True, request_timeout=timedelta(seconds=5.0), include_broken_batteries=False)</code>  <code>async</code>","text":"<p>Set the given power for the batteries in the pool.</p> <p>Power values need to follow the Passive Sign Convention (PSC). That is, positive values indicate charge power and negative values indicate discharge power.</p> <p>When not using the Passive Sign Convention, the <code>charge</code> and <code>discharge</code> methods might be more convenient.</p> PARAMETER DESCRIPTION <code>power</code> <p>The power to set for the batteries in the pool.</p> <p> TYPE: <code>float</code> </p> <code>adjust_power</code> <p>If True, the power will be adjusted to fit the power bounds, if necessary. If False, then power requests outside the bounds will be rejected.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>request_timeout</code> <p>The timeout for the request.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=5.0)</code> </p> <code>include_broken_batteries</code> <p>if True, the power will be set for all batteries in the pool, including the broken ones. If False, then the power will be set only for the working batteries.  This is not a guarantee that the power will be set for all working batteries, as the microgrid API may still reject the request.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def set_power(\n    self,\n    power: float,\n    *,\n    adjust_power: bool = True,\n    request_timeout: timedelta = timedelta(seconds=5.0),\n    include_broken_batteries: bool = False,\n) -&gt; None:\n\"\"\"Set the given power for the batteries in the pool.\n\n    Power values need to follow the Passive Sign Convention (PSC). That is, positive\n    values indicate charge power and negative values indicate discharge power.\n\n    When not using the Passive Sign Convention, the `charge` and `discharge` methods\n    might be more convenient.\n\n    Args:\n        power: The power to set for the batteries in the pool.\n        adjust_power: If True, the power will be adjusted to fit the power bounds,\n            if necessary. If False, then power requests outside the bounds will be\n            rejected.\n        request_timeout: The timeout for the request.\n        include_broken_batteries: if True, the power will be set for all batteries\n            in the pool, including the broken ones. If False, then the power will be\n            set only for the working batteries.  This is not a guarantee that the\n            power will be set for all working batteries, as the microgrid API may\n            still reject the request.\n    \"\"\"\n    await self._power_distributing_sender.send(\n        Request(\n            namespace=self._power_distributing_namespace,\n            power=power,\n            batteries=self._batteries,\n            adjust_power=adjust_power,\n            request_timeout_sec=request_timeout.total_seconds(),\n            include_broken_batteries=include_broken_batteries,\n        )\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool.BatteryPool.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop all pending async tasks.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/battery_pool/battery_pool.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop all pending async tasks.\"\"\"\n    tasks_to_stop: list[Awaitable[Any]] = [\n        method.stop() for method in self._active_methods.values()\n    ]\n    tasks_to_stop.append(self._formula_pool.stop())\n    if self._update_battery_status_task:\n        tasks_to_stop.append(cancel_and_await(self._update_battery_status_task))\n    await asyncio.gather(*tasks_to_stop)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/battery_pool/battery_pool/#frequenz.sdk.timeseries.battery_pool.battery_pool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/","title":"ev_charger_pool","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool","title":"<code>frequenz.sdk.timeseries.ev_charger_pool</code>","text":"<p>Interactions with EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit","title":"<code>frequenz.sdk.timeseries.ev_charger_pool.ComponentCurrentLimit</code>  <code>dataclass</code>","text":"<p>A current limit, to be sent to the EV Charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_set_current_bounds.py</code> <pre><code>@dataclass\nclass ComponentCurrentLimit:\n\"\"\"A current limit, to be sent to the EV Charger.\"\"\"\n\n    component_id: int\n    max_amps: float\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerData","title":"<code>frequenz.sdk.timeseries.ev_charger_pool.EVChargerData</code>  <code>dataclass</code>","text":"<p>Data for an EV Charger, including the 3-phase current and the component state.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>@dataclass(frozen=True)\nclass EVChargerData:\n\"\"\"Data for an EV Charger, including the 3-phase current and the component state.\"\"\"\n\n    component_id: int\n    current: Sample3Phase\n    state: EVChargerState\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool","title":"<code>frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool</code>","text":"<p>Interactions with EV Chargers.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>class EVChargerPool:\n\"\"\"Interactions with EV Chargers.\"\"\"\n\n    def __init__(\n        self,\n        channel_registry: ChannelRegistry,\n        resampler_subscription_sender: Sender[ComponentMetricRequest],\n        component_ids: set[int] | None = None,\n        repeat_interval: timedelta = timedelta(seconds=3.0),\n    ) -&gt; None:\n\"\"\"Create an `EVChargerPool` instance.\n\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n            component_ids: An optional list of component_ids belonging to this pool.  If\n                not specified, IDs of all EV Chargers in the microgrid will be fetched\n                from the component graph.\n            repeat_interval: Interval after which to repeat the last set bounds to the\n                microgrid API, if no new calls to `set_bounds` have been made.\n        \"\"\"\n        self._channel_registry: ChannelRegistry = channel_registry\n        self._repeat_interval = repeat_interval\n        self._resampler_subscription_sender: Sender[\n            ComponentMetricRequest\n        ] = resampler_subscription_sender\n        self._component_ids: set[int] = set()\n        if component_ids is not None:\n            self._component_ids = component_ids\n        else:\n            graph = connection_manager.get().component_graph\n            self._component_ids = {\n                evc.component_id\n                for evc in graph.components(\n                    component_category={ComponentCategory.EV_CHARGER}\n                )\n            }\n        self._state_tracker: StateTracker | None = None\n        self._status_streams: dict[\n            int, tuple[Task[None], Broadcast[EVChargerData]]\n        ] = {}\n        self._namespace: str = f\"ev-charger-pool-{uuid.uuid4()}\"\n        self._formula_pool: FormulaEnginePool = FormulaEnginePool(\n            self._namespace,\n            self._channel_registry,\n            self._resampler_subscription_sender,\n        )\n        self._bounds_setter: BoundsSetter | None = None\n\n    @property\n    def component_ids(self) -&gt; abc.Set[int]:\n\"\"\"Return component IDs of all EV Chargers managed by this EVChargerPool.\n\n        Returns:\n            Set of managed component IDs.\n        \"\"\"\n        return self._component_ids\n\n    @property\n    def current(self) -&gt; FormulaEngine3Phase:\n\"\"\"Fetch the total current for the EV Chargers in the pool.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate EV Charger current is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total current of all EV\n                Chargers.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"ev_charger_total_current\",\n            EVChargerCurrentFormula,\n            FormulaGeneratorConfig(component_ids=self._component_ids),\n        )\n        assert isinstance(engine, FormulaEngine3Phase)\n        return engine\n\n    @property\n    def power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the total power for the EV Chargers in the pool.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate EV Charger power is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the total power of all EV\n                Chargers.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"ev_charger_power\",\n            EVChargerPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._component_ids,\n                formula_type=FormulaType.PASSIVE_SIGN_CONVENTION,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def production_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the total power produced by the EV Chargers in the pool.\n\n        This formula produces positive values when producing power and 0 otherwise.\n\n        If a formula engine to calculate EV Charger power is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the production power of all\n                EV Chargers.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"ev_charger_production_power\",\n            EVChargerPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._component_ids,\n                formula_type=FormulaType.PRODUCTION,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def consumption_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the total power consumed by the EV Chargers in the pool.\n\n        This formula produces positive values when consuming power and 0 otherwise.\n\n        If a formula engine to calculate EV Charger power is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream the consumption power of all\n                EV Chargers.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"ev_charger_consumption_power\",\n            EVChargerPowerFormula,\n            FormulaGeneratorConfig(\n                component_ids=self._component_ids,\n                formula_type=FormulaType.CONSUMPTION,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    def component_data(self, component_id: int) -&gt; Receiver[EVChargerData]:\n\"\"\"Stream 3-phase current values and state of an EV Charger.\n\n        Args:\n            component_id: id of the EV Charger for which data is requested.\n\n        Returns:\n            A receiver that streams objects containing 3-phase current and state of\n                an EV Charger.\n        \"\"\"\n        if recv := self._status_streams.get(component_id, None):\n            task, output_chan = recv\n            if not task.done():\n                return output_chan.new_receiver()\n            _logger.warning(\"Restarting component_status for id: %s\", component_id)\n        else:\n            output_chan = Broadcast[EVChargerData](\n                f\"evpool-component_status-{component_id}\"\n            )\n\n        task = asyncio.create_task(\n            self._stream_component_data(component_id, output_chan.new_sender())\n        )\n\n        self._status_streams[component_id] = (task, output_chan)\n\n        return output_chan.new_receiver()\n\n    async def set_bounds(self, component_id: int, max_amps: float) -&gt; None:\n\"\"\"Send given max current bound for the given EV Charger to the microgrid API.\n\n        Bounds are used to limit the max current drawn by an EV, although the exact\n        value will be determined by the EV.\n\n        Args:\n            component_id: ID of EV Charger to set the current bounds to.\n            max_amps: maximum current in amps, that an EV can draw from this EV Charger.\n        \"\"\"\n        if not self._bounds_setter:\n            self._bounds_setter = BoundsSetter(self._repeat_interval)\n        await self._bounds_setter.set(component_id, max_amps)\n\n    def new_bounds_sender(self) -&gt; Sender[ComponentCurrentLimit]:\n\"\"\"Return a `Sender` for setting EV Charger current bounds with.\n\n        Bounds are used to limit the max current drawn by an EV, although the exact\n        value will be determined by the EV.\n\n        Returns:\n            A new `Sender`.\n        \"\"\"\n        if not self._bounds_setter:\n            self._bounds_setter = BoundsSetter(self._repeat_interval)\n        return self._bounds_setter.new_bounds_sender()\n\n    async def stop(self) -&gt; None:\n\"\"\"Stop all tasks and channels owned by the EVChargerPool.\"\"\"\n        if self._bounds_setter:\n            await self._bounds_setter.stop()\n        if self._state_tracker:\n            await self._state_tracker.stop()\n        await self._formula_pool.stop()\n        for stream in self._status_streams.values():\n            task, chan = stream\n            await chan.close()\n            await cancel_and_await(task)\n\n    async def _get_current_streams(\n        self, component_id: int\n    ) -&gt; tuple[Receiver[Sample], Receiver[Sample], Receiver[Sample]]:\n\"\"\"Fetch current streams from the resampler for each phase.\n\n        Args:\n            component_id: id of EV Charger for which current streams are being fetched.\n\n        Returns:\n            A tuple of 3 receivers stream resampled current values for the given\n                component id, one for each phase.\n        \"\"\"\n\n        async def resampler_subscribe(metric_id: ComponentMetricId) -&gt; Receiver[Sample]:\n            request = ComponentMetricRequest(\n                namespace=\"ev-pool\",\n                component_id=component_id,\n                metric_id=metric_id,\n                start_time=None,\n            )\n            await self._resampler_subscription_sender.send(request)\n            return self._channel_registry.new_receiver(request.get_channel_name())\n\n        return (\n            await resampler_subscribe(ComponentMetricId.CURRENT_PHASE_1),\n            await resampler_subscribe(ComponentMetricId.CURRENT_PHASE_2),\n            await resampler_subscribe(ComponentMetricId.CURRENT_PHASE_3),\n        )\n\n    async def _stream_component_data(\n        self,\n        component_id: int,\n        sender: Sender[EVChargerData],\n    ) -&gt; None:\n\"\"\"Stream 3-phase current values and state of an EV Charger.\n\n        Args:\n            component_id: id of the EV Charger for which data is requested.\n            sender: A sender to stream EV Charger data to.\n\n        Raises:\n            ChannelClosedError: If the channels from the resampler are closed.\n        \"\"\"\n        if not self._state_tracker:\n            self._state_tracker = StateTracker(self._component_ids)\n\n        (phase_1_rx, phase_2_rx, phase_3_rx) = await self._get_current_streams(\n            component_id\n        )\n        while True:\n            try:\n                (phase_1, phase_2, phase_3) = (\n                    await phase_1_rx.receive(),\n                    await phase_2_rx.receive(),\n                    await phase_3_rx.receive(),\n                )\n            except ChannelClosedError:\n                _logger.exception(\"Streams closed for component_id=%s.\", component_id)\n                raise\n\n            sample = Sample3Phase(\n                timestamp=phase_1.timestamp,\n                value_p1=phase_1.value,\n                value_p2=phase_2.value,\n                value_p3=phase_3.value,\n            )\n\n            if (\n                phase_1.value is None\n                and phase_2.value is None\n                and phase_3.value is None\n            ):\n                state = EVChargerState.MISSING\n            else:\n                state = self._state_tracker.get(component_id)\n\n            await sender.send(\n                EVChargerData(\n                    component_id=component_id,\n                    current=sample,\n                    state=state,\n                )\n            )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.component_ids","title":"<code>component_ids: abc.Set[int]</code>  <code>property</code>","text":"<p>Return component IDs of all EV Chargers managed by this EVChargerPool.</p> RETURNS DESCRIPTION <code>abc.Set[int]</code> <p>Set of managed component IDs.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.consumption_power","title":"<code>consumption_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the total power consumed by the EV Chargers in the pool.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate EV Charger power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream the consumption power of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.current","title":"<code>current: FormulaEngine3Phase</code>  <code>property</code>","text":"<p>Fetch the total current for the EV Chargers in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate EV Charger current is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine3Phase</code> <p>A FormulaEngine that will calculate and stream the total current of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.power","title":"<code>power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the total power for the EV Chargers in the pool.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate EV Charger power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream the total power of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.production_power","title":"<code>production_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the total power produced by the EV Chargers in the pool.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate EV Charger power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream the production power of all EV Chargers.</p>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPool-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.__init__","title":"<code>__init__(channel_registry, resampler_subscription_sender, component_ids=None, repeat_interval=timedelta(seconds=3.0))</code>","text":"<p>Create an <code>EVChargerPool</code> instance.</p> PARAMETER DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> <code>component_ids</code> <p>An optional list of component_ids belonging to this pool.  If not specified, IDs of all EV Chargers in the microgrid will be fetched from the component graph.</p> <p> TYPE: <code>set[int] | None</code> DEFAULT: <code>None</code> </p> <code>repeat_interval</code> <p>Interval after which to repeat the last set bounds to the microgrid API, if no new calls to <code>set_bounds</code> have been made.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(seconds=3.0)</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def __init__(\n    self,\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n    component_ids: set[int] | None = None,\n    repeat_interval: timedelta = timedelta(seconds=3.0),\n) -&gt; None:\n\"\"\"Create an `EVChargerPool` instance.\n\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n        component_ids: An optional list of component_ids belonging to this pool.  If\n            not specified, IDs of all EV Chargers in the microgrid will be fetched\n            from the component graph.\n        repeat_interval: Interval after which to repeat the last set bounds to the\n            microgrid API, if no new calls to `set_bounds` have been made.\n    \"\"\"\n    self._channel_registry: ChannelRegistry = channel_registry\n    self._repeat_interval = repeat_interval\n    self._resampler_subscription_sender: Sender[\n        ComponentMetricRequest\n    ] = resampler_subscription_sender\n    self._component_ids: set[int] = set()\n    if component_ids is not None:\n        self._component_ids = component_ids\n    else:\n        graph = connection_manager.get().component_graph\n        self._component_ids = {\n            evc.component_id\n            for evc in graph.components(\n                component_category={ComponentCategory.EV_CHARGER}\n            )\n        }\n    self._state_tracker: StateTracker | None = None\n    self._status_streams: dict[\n        int, tuple[Task[None], Broadcast[EVChargerData]]\n    ] = {}\n    self._namespace: str = f\"ev-charger-pool-{uuid.uuid4()}\"\n    self._formula_pool: FormulaEnginePool = FormulaEnginePool(\n        self._namespace,\n        self._channel_registry,\n        self._resampler_subscription_sender,\n    )\n    self._bounds_setter: BoundsSetter | None = None\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.component_data","title":"<code>component_data(component_id)</code>","text":"<p>Stream 3-phase current values and state of an EV Charger.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>id of the EV Charger for which data is requested.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Receiver[EVChargerData]</code> <p>A receiver that streams objects containing 3-phase current and state of an EV Charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def component_data(self, component_id: int) -&gt; Receiver[EVChargerData]:\n\"\"\"Stream 3-phase current values and state of an EV Charger.\n\n    Args:\n        component_id: id of the EV Charger for which data is requested.\n\n    Returns:\n        A receiver that streams objects containing 3-phase current and state of\n            an EV Charger.\n    \"\"\"\n    if recv := self._status_streams.get(component_id, None):\n        task, output_chan = recv\n        if not task.done():\n            return output_chan.new_receiver()\n        _logger.warning(\"Restarting component_status for id: %s\", component_id)\n    else:\n        output_chan = Broadcast[EVChargerData](\n            f\"evpool-component_status-{component_id}\"\n        )\n\n    task = asyncio.create_task(\n        self._stream_component_data(component_id, output_chan.new_sender())\n    )\n\n    self._status_streams[component_id] = (task, output_chan)\n\n    return output_chan.new_receiver()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.new_bounds_sender","title":"<code>new_bounds_sender()</code>","text":"<p>Return a <code>Sender</code> for setting EV Charger current bounds with.</p> <p>Bounds are used to limit the max current drawn by an EV, although the exact value will be determined by the EV.</p> RETURNS DESCRIPTION <code>Sender[ComponentCurrentLimit]</code> <p>A new <code>Sender</code>.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>def new_bounds_sender(self) -&gt; Sender[ComponentCurrentLimit]:\n\"\"\"Return a `Sender` for setting EV Charger current bounds with.\n\n    Bounds are used to limit the max current drawn by an EV, although the exact\n    value will be determined by the EV.\n\n    Returns:\n        A new `Sender`.\n    \"\"\"\n    if not self._bounds_setter:\n        self._bounds_setter = BoundsSetter(self._repeat_interval)\n    return self._bounds_setter.new_bounds_sender()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.set_bounds","title":"<code>set_bounds(component_id, max_amps)</code>  <code>async</code>","text":"<p>Send given max current bound for the given EV Charger to the microgrid API.</p> <p>Bounds are used to limit the max current drawn by an EV, although the exact value will be determined by the EV.</p> PARAMETER DESCRIPTION <code>component_id</code> <p>ID of EV Charger to set the current bounds to.</p> <p> TYPE: <code>int</code> </p> <code>max_amps</code> <p>maximum current in amps, that an EV can draw from this EV Charger.</p> <p> TYPE: <code>float</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>async def set_bounds(self, component_id: int, max_amps: float) -&gt; None:\n\"\"\"Send given max current bound for the given EV Charger to the microgrid API.\n\n    Bounds are used to limit the max current drawn by an EV, although the exact\n    value will be determined by the EV.\n\n    Args:\n        component_id: ID of EV Charger to set the current bounds to.\n        max_amps: maximum current in amps, that an EV can draw from this EV Charger.\n    \"\"\"\n    if not self._bounds_setter:\n        self._bounds_setter = BoundsSetter(self._repeat_interval)\n    await self._bounds_setter.set(component_id, max_amps)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._ev_charger_pool.EVChargerPool.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop all tasks and channels owned by the EVChargerPool.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop all tasks and channels owned by the EVChargerPool.\"\"\"\n    if self._bounds_setter:\n        await self._bounds_setter.stop()\n    if self._state_tracker:\n        await self._state_tracker.stop()\n    await self._formula_pool.stop()\n    for stream in self._status_streams.values():\n        task, chan = stream\n        await chan.close()\n        await cancel_and_await(task)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolError","title":"<code>frequenz.sdk.timeseries.ev_charger_pool.EVChargerPoolError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>An error that occurred in any of the EVChargerPool methods.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_ev_charger_pool.py</code> <pre><code>class EVChargerPoolError(Exception):\n\"\"\"An error that occurred in any of the EVChargerPool methods.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState","title":"<code>frequenz.sdk.timeseries.ev_charger_pool.EVChargerState</code>","text":"<p>         Bases: <code>Enum</code></p> <p>State of individual ev charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>class EVChargerState(Enum):\n\"\"\"State of individual ev charger.\"\"\"\n\n    UNSPECIFIED = \"UNSPECIFIED\"\n    MISSING = \"MISSING\"\n\n    IDLE = \"IDLE\"\n    EV_PLUGGED = \"EV_PLUGGED\"\n    EV_LOCKED = \"EV_LOCKED\"\n    ERROR = \"ERROR\"\n\n    @classmethod\n    def from_ev_charger_data(cls, data: EVChargerData) -&gt; EVChargerState:\n\"\"\"Create an `EVChargerState` instance from component data.\n\n        Args:\n            data: ev charger data coming from microgrid.\n\n        Returns:\n            An `EVChargerState` instance.\n        \"\"\"\n        if data.component_state == EVChargerComponentState.UNSPECIFIED:\n            return EVChargerState.UNSPECIFIED\n        if data.component_state in (\n            EVChargerComponentState.AUTHORIZATION_REJECTED,\n            EVChargerComponentState.ERROR,\n        ):\n            return EVChargerState.ERROR\n\n        if data.cable_state == EVChargerCableState.UNSPECIFIED:\n            return EVChargerState.UNSPECIFIED\n        if data.cable_state == EVChargerCableState.EV_LOCKED:\n            return EVChargerState.EV_LOCKED\n        if data.cable_state == EVChargerCableState.EV_PLUGGED:\n            return EVChargerState.EV_PLUGGED\n        return EVChargerState.IDLE\n\n    def is_ev_connected(self) -&gt; bool:\n\"\"\"Check whether an EV is connected to the charger.\n\n        Returns:\n            Whether an EV is connected to the charger.\n        \"\"\"\n        return self in (EVChargerState.EV_PLUGGED, EVChargerState.EV_LOCKED)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool.EVChargerState-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._state_tracker.EVChargerState.from_ev_charger_data","title":"<code>from_ev_charger_data(data)</code>  <code>classmethod</code>","text":"<p>Create an <code>EVChargerState</code> instance from component data.</p> PARAMETER DESCRIPTION <code>data</code> <p>ev charger data coming from microgrid.</p> <p> TYPE: <code>EVChargerData</code> </p> RETURNS DESCRIPTION <code>EVChargerState</code> <p>An <code>EVChargerState</code> instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>@classmethod\ndef from_ev_charger_data(cls, data: EVChargerData) -&gt; EVChargerState:\n\"\"\"Create an `EVChargerState` instance from component data.\n\n    Args:\n        data: ev charger data coming from microgrid.\n\n    Returns:\n        An `EVChargerState` instance.\n    \"\"\"\n    if data.component_state == EVChargerComponentState.UNSPECIFIED:\n        return EVChargerState.UNSPECIFIED\n    if data.component_state in (\n        EVChargerComponentState.AUTHORIZATION_REJECTED,\n        EVChargerComponentState.ERROR,\n    ):\n        return EVChargerState.ERROR\n\n    if data.cable_state == EVChargerCableState.UNSPECIFIED:\n        return EVChargerState.UNSPECIFIED\n    if data.cable_state == EVChargerCableState.EV_LOCKED:\n        return EVChargerState.EV_LOCKED\n    if data.cable_state == EVChargerCableState.EV_PLUGGED:\n        return EVChargerState.EV_PLUGGED\n    return EVChargerState.IDLE\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/ev_charger_pool/#frequenz.sdk.timeseries.ev_charger_pool._state_tracker.EVChargerState.is_ev_connected","title":"<code>is_ev_connected()</code>","text":"<p>Check whether an EV is connected to the charger.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether an EV is connected to the charger.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/ev_charger_pool/_state_tracker.py</code> <pre><code>def is_ev_connected(self) -&gt; bool:\n\"\"\"Check whether an EV is connected to the charger.\n\n    Returns:\n        Whether an EV is connected to the charger.\n    \"\"\"\n    return self in (EVChargerState.EV_PLUGGED, EVChargerState.EV_LOCKED)\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/","title":"logical_meter","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter","title":"<code>frequenz.sdk.timeseries.logical_meter</code>","text":"<p>A logical meter for calculating high level metrics for a microgrid.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter-classes","title":"Classes","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter","title":"<code>frequenz.sdk.timeseries.logical_meter.LogicalMeter</code>","text":"<p>A logical meter for calculating high level metrics in a microgrid.</p> <p>LogicalMeter provides methods for fetching power values from different points in the microgrid.  These methods return <code>FormulaReceiver</code> objects, which can be used like normal <code>Receiver</code>s, but can also be composed to form higher-order formula streams.</p> Example <pre><code>from frequenz.channels import Sender, Broadcast\nfrom frequenz.sdk.actor import DataSourcingActor, ComponentMetricsResamplingActor\nfrom frequenz.sdk.timeseries import ResamplerConfig\nfrom frequenz.sdk.microgrid import initialize\nfrom datetime import timedelta\n\nchannel_registry = ChannelRegistry(name=\"data-registry\")\n\n# Create a channels for sending/receiving subscription requests\ndata_source_request_channel = Broadcast[ComponentMetricRequest](\"data-source\")\ndata_source_request_sender = data_source_request_channel.new_sender()\ndata_source_request_receiver = data_source_request_channel.new_receiver()\n\nresampling_request_channel = Broadcast[ComponentMetricRequest](\"resample\")\nresampling_request_sender = resampling_request_channel.new_sender()\nresampling_request_receiver = resampling_request_channel.new_receiver()\n\n# Instantiate a data sourcing actor\n_data_sourcing_actor = DataSourcingActor(\n    request_receiver=data_source_request_receiver, registry=channel_registry\n)\n\n# Instantiate a resampling actor\n_resampling_actor = ComponentMetricsResamplingActor(\n    channel_registry=channel_registry,\n    data_sourcing_request_sender=data_source_request_sender,\n    resampling_request_receiver=resampling_request_receiver,\n    config=ResamplerConfig(resampling_period=timedelta(seconds=1)),\n)\n\nawait initialize(\n    \"127.0.0.1\",\n    50051,\n    ResamplerConfig(resampling_period=timedelta(seconds=1))\n)\n\n# Create a logical meter instance\nlogical_meter = LogicalMeter(\n    channel_registry,\n    resampling_request_sender,\n)\n\n# Get a receiver for a builtin formula\ngrid_power_recv = logical_meter.grid_power.new_receiver()\nfor grid_power_sample in grid_power_recv:\n    print(grid_power_sample)\n\n# or compose formula receivers to create a new formula\nnet_power_recv = (\n    (\n        logical_meter.grid_power\n        - logical_meter.pv_power\n    )\n    .build(\"net_power\")\n    .new_receiver()\n)\nfor net_power_sample in net_power_recv:\n    print(net_power_sample)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>class LogicalMeter:\n\"\"\"A logical meter for calculating high level metrics in a microgrid.\n\n    LogicalMeter provides methods for fetching power values from different points in the\n    microgrid.  These methods return `FormulaReceiver` objects, which can be used like\n    normal `Receiver`s, but can also be composed to form higher-order formula streams.\n\n    Example:\n        ```python\n        from frequenz.channels import Sender, Broadcast\n        from frequenz.sdk.actor import DataSourcingActor, ComponentMetricsResamplingActor\n        from frequenz.sdk.timeseries import ResamplerConfig\n        from frequenz.sdk.microgrid import initialize\n        from datetime import timedelta\n\n        channel_registry = ChannelRegistry(name=\"data-registry\")\n\n        # Create a channels for sending/receiving subscription requests\n        data_source_request_channel = Broadcast[ComponentMetricRequest](\"data-source\")\n        data_source_request_sender = data_source_request_channel.new_sender()\n        data_source_request_receiver = data_source_request_channel.new_receiver()\n\n        resampling_request_channel = Broadcast[ComponentMetricRequest](\"resample\")\n        resampling_request_sender = resampling_request_channel.new_sender()\n        resampling_request_receiver = resampling_request_channel.new_receiver()\n\n        # Instantiate a data sourcing actor\n        _data_sourcing_actor = DataSourcingActor(\n            request_receiver=data_source_request_receiver, registry=channel_registry\n        )\n\n        # Instantiate a resampling actor\n        _resampling_actor = ComponentMetricsResamplingActor(\n            channel_registry=channel_registry,\n            data_sourcing_request_sender=data_source_request_sender,\n            resampling_request_receiver=resampling_request_receiver,\n            config=ResamplerConfig(resampling_period=timedelta(seconds=1)),\n        )\n\n        await initialize(\n            \"127.0.0.1\",\n            50051,\n            ResamplerConfig(resampling_period=timedelta(seconds=1))\n        )\n\n        # Create a logical meter instance\n        logical_meter = LogicalMeter(\n            channel_registry,\n            resampling_request_sender,\n        )\n\n        # Get a receiver for a builtin formula\n        grid_power_recv = logical_meter.grid_power.new_receiver()\n        for grid_power_sample in grid_power_recv:\n            print(grid_power_sample)\n\n        # or compose formula receivers to create a new formula\n        net_power_recv = (\n            (\n                logical_meter.grid_power\n                - logical_meter.pv_power\n            )\n            .build(\"net_power\")\n            .new_receiver()\n        )\n        for net_power_sample in net_power_recv:\n            print(net_power_sample)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        channel_registry: ChannelRegistry,\n        resampler_subscription_sender: Sender[ComponentMetricRequest],\n    ) -&gt; None:\n\"\"\"Create a `LogicalMeter instance`.\n\n        Args:\n            channel_registry: A channel registry instance shared with the resampling\n                actor.\n            resampler_subscription_sender: A sender for sending metric requests to the\n                resampling actor.\n        \"\"\"\n        self._channel_registry = channel_registry\n        self._resampler_subscription_sender = resampler_subscription_sender\n\n        # Use a randomly generated uuid to create a unique namespace name for the local\n        # meter to use when communicating with the resampling actor.\n        self._namespace = f\"logical-meter-{uuid.uuid4()}\"\n        self._formula_pool = FormulaEnginePool(\n            self._namespace,\n            self._channel_registry,\n            self._resampler_subscription_sender,\n        )\n\n    def start_formula(\n        self,\n        formula: str,\n        component_metric_id: ComponentMetricId,\n        nones_are_zeros: bool = False,\n    ) -&gt; FormulaEngine:\n\"\"\"Start execution of the given formula.\n\n        Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and\n        these operators: +, -, *, /, (, ).\n\n        For example, the input string: \"#20 + #5\" is a formula for adding metrics from\n        two components with ids 20 and 5.\n\n        Args:\n            formula: formula to execute.\n            component_metric_id: The metric ID to use when fetching receivers from the\n                resampling actor.\n            nones_are_zeros: Whether to treat None values from the stream as 0s.  If\n                False, the returned value will be a None.\n\n        Returns:\n            A FormulaEngine that applies the formula and streams values.\n        \"\"\"\n        return self._formula_pool.from_string(\n            formula, component_metric_id, nones_are_zeros\n        )\n\n    @property\n    def grid_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the grid power for the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate grid power is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream grid power.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"grid_power\",\n            GridPowerFormula,\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def grid_consumption_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the grid consumption power for the microgrid.\n\n        This formula produces positive values when consuming power and 0 otherwise.\n\n        If a formula engine to calculate grid consumption power is not already running,\n        it will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream grid consumption power.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"grid_consumption_power\",\n            GridPowerFormula,\n            FormulaGeneratorConfig(formula_type=FormulaType.CONSUMPTION),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def grid_production_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the grid production power for the microgrid.\n\n        This formula produces positive values when producing power and 0 otherwise.\n\n        If a formula engine to calculate grid production power is not already running,\n        it will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream grid production power.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"grid_production_power\",\n            GridPowerFormula,\n            FormulaGeneratorConfig(formula_type=FormulaType.PRODUCTION),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def grid_current(self) -&gt; FormulaEngine3Phase:\n\"\"\"Fetch the grid power for the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate grid current is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream grid current.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"grid_current\",\n            GridCurrentFormula,\n        )\n        assert isinstance(engine, FormulaEngine3Phase)\n        return engine\n\n    @property\n    def consumer_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the consumer power for the microgrid.\n\n        Under normal circumstances this is expected to correspond to the gross\n        consumption of the site excluding active parts and battery.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate consumer power is not already running, it will\n        be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream consumer power.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"consumer_power\",\n            ConsumerPowerFormula,\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def pv_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the PV power in the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate PV power is not already running, it will be\n        started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream PV total power.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"pv_power\",\n            PVPowerFormula,\n            FormulaGeneratorConfig(formula_type=FormulaType.PASSIVE_SIGN_CONVENTION),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def pv_production_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the PV power production in the microgrid.\n\n        This formula produces positive values when producing power and 0 otherwise.\n\n        If a formula engine to calculate PV power production is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream PV power production.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"pv_production_power\",\n            PVPowerFormula,\n            FormulaGeneratorConfig(formula_type=FormulaType.PRODUCTION),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def pv_consumption_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the PV power consumption in the microgrid.\n\n        This formula produces positive values when consuming power and 0 otherwise.\n\n        If a formula engine to calculate PV power consumption is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream PV power consumption.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"pv_consumption_power\",\n            PVPowerFormula,\n            FormulaGeneratorConfig(formula_type=FormulaType.CONSUMPTION),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def chp_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the CHP power production in the microgrid.\n\n        This formula produces values that are in the Passive Sign Convention (PSC).\n\n        If a formula engine to calculate CHP power production is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream CHP power production.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"chp_power\",\n            CHPPowerFormula,\n            FormulaGeneratorConfig(formula_type=FormulaType.PASSIVE_SIGN_CONVENTION),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def chp_production_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the CHP power production in the microgrid.\n\n        This formula produces positive values when producing power and 0 otherwise.\n\n        If a formula engine to calculate CHP power production is not already running, it\n        will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream CHP power production.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"chp_production_power\",\n            CHPPowerFormula,\n            FormulaGeneratorConfig(\n                formula_type=FormulaType.PRODUCTION,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    @property\n    def chp_consumption_power(self) -&gt; FormulaEngine:\n\"\"\"Fetch the CHP power consumption in the microgrid.\n\n        This formula produces positive values when consuming power and 0 otherwise.\n\n        If a formula engine to calculate CHP power consumption is not already running,\n        it will be started.\n\n        A receiver from the formula engine can be created using the `new_receiver`\n        method.\n\n        Returns:\n            A FormulaEngine that will calculate and stream CHP power consumption.\n        \"\"\"\n        engine = self._formula_pool.from_generator(\n            \"chp_consumption_power\",\n            CHPPowerFormula,\n            FormulaGeneratorConfig(\n                formula_type=FormulaType.CONSUMPTION,\n            ),\n        )\n        assert isinstance(engine, FormulaEngine)\n        return engine\n\n    async def stop(self) -&gt; None:\n\"\"\"Stop all formula engines.\"\"\"\n        await self._formula_pool.stop()\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.chp_consumption_power","title":"<code>chp_consumption_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the CHP power consumption in the microgrid.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate CHP power consumption is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream CHP power consumption.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.chp_power","title":"<code>chp_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the CHP power production in the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate CHP power production is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream CHP power production.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.chp_production_power","title":"<code>chp_production_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the CHP power production in the microgrid.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate CHP power production is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream CHP power production.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.consumer_power","title":"<code>consumer_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the consumer power for the microgrid.</p> <p>Under normal circumstances this is expected to correspond to the gross consumption of the site excluding active parts and battery.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate consumer power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream consumer power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.grid_consumption_power","title":"<code>grid_consumption_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the grid consumption power for the microgrid.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate grid consumption power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream grid consumption power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.grid_current","title":"<code>grid_current: FormulaEngine3Phase</code>  <code>property</code>","text":"<p>Fetch the grid power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate grid current is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine3Phase</code> <p>A FormulaEngine that will calculate and stream grid current.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.grid_power","title":"<code>grid_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the grid power for the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate grid power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream grid power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.grid_production_power","title":"<code>grid_production_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the grid production power for the microgrid.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate grid production power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream grid production power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.pv_consumption_power","title":"<code>pv_consumption_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the PV power consumption in the microgrid.</p> <p>This formula produces positive values when consuming power and 0 otherwise.</p> <p>If a formula engine to calculate PV power consumption is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream PV power consumption.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.pv_power","title":"<code>pv_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the PV power in the microgrid.</p> <p>This formula produces values that are in the Passive Sign Convention (PSC).</p> <p>If a formula engine to calculate PV power is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream PV total power.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.pv_production_power","title":"<code>pv_production_power: FormulaEngine</code>  <code>property</code>","text":"<p>Fetch the PV power production in the microgrid.</p> <p>This formula produces positive values when producing power and 0 otherwise.</p> <p>If a formula engine to calculate PV power production is not already running, it will be started.</p> <p>A receiver from the formula engine can be created using the <code>new_receiver</code> method.</p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that will calculate and stream PV power production.</p>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter.LogicalMeter-functions","title":"Functions","text":""},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.__init__","title":"<code>__init__(channel_registry, resampler_subscription_sender)</code>","text":"<p>Create a <code>LogicalMeter instance</code>.</p> PARAMETER DESCRIPTION <code>channel_registry</code> <p>A channel registry instance shared with the resampling actor.</p> <p> TYPE: <code>ChannelRegistry</code> </p> <code>resampler_subscription_sender</code> <p>A sender for sending metric requests to the resampling actor.</p> <p> TYPE: <code>Sender[ComponentMetricRequest]</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>def __init__(\n    self,\n    channel_registry: ChannelRegistry,\n    resampler_subscription_sender: Sender[ComponentMetricRequest],\n) -&gt; None:\n\"\"\"Create a `LogicalMeter instance`.\n\n    Args:\n        channel_registry: A channel registry instance shared with the resampling\n            actor.\n        resampler_subscription_sender: A sender for sending metric requests to the\n            resampling actor.\n    \"\"\"\n    self._channel_registry = channel_registry\n    self._resampler_subscription_sender = resampler_subscription_sender\n\n    # Use a randomly generated uuid to create a unique namespace name for the local\n    # meter to use when communicating with the resampling actor.\n    self._namespace = f\"logical-meter-{uuid.uuid4()}\"\n    self._formula_pool = FormulaEnginePool(\n        self._namespace,\n        self._channel_registry,\n        self._resampler_subscription_sender,\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.start_formula","title":"<code>start_formula(formula, component_metric_id, nones_are_zeros=False)</code>","text":"<p>Start execution of the given formula.</p> <p>Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and these operators: +, -, *, /, (, ).</p> <p>For example, the input string: \"#20 + #5\" is a formula for adding metrics from two components with ids 20 and 5.</p> PARAMETER DESCRIPTION <code>formula</code> <p>formula to execute.</p> <p> TYPE: <code>str</code> </p> <code>component_metric_id</code> <p>The metric ID to use when fetching receivers from the resampling actor.</p> <p> TYPE: <code>ComponentMetricId</code> </p> <code>nones_are_zeros</code> <p>Whether to treat None values from the stream as 0s.  If False, the returned value will be a None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>FormulaEngine</code> <p>A FormulaEngine that applies the formula and streams values.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>def start_formula(\n    self,\n    formula: str,\n    component_metric_id: ComponentMetricId,\n    nones_are_zeros: bool = False,\n) -&gt; FormulaEngine:\n\"\"\"Start execution of the given formula.\n\n    Formulas can have Component IDs that are preceeded by a pound symbol(\"#\"), and\n    these operators: +, -, *, /, (, ).\n\n    For example, the input string: \"#20 + #5\" is a formula for adding metrics from\n    two components with ids 20 and 5.\n\n    Args:\n        formula: formula to execute.\n        component_metric_id: The metric ID to use when fetching receivers from the\n            resampling actor.\n        nones_are_zeros: Whether to treat None values from the stream as 0s.  If\n            False, the returned value will be a None.\n\n    Returns:\n        A FormulaEngine that applies the formula and streams values.\n    \"\"\"\n    return self._formula_pool.from_string(\n        formula, component_metric_id, nones_are_zeros\n    )\n</code></pre>"},{"location":"reference/frequenz/sdk/timeseries/logical_meter/#frequenz.sdk.timeseries.logical_meter._logical_meter.LogicalMeter.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop all formula engines.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.3/x64/lib/python3.11/site-packages/frequenz/sdk/timeseries/logical_meter/_logical_meter.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop all formula engines.\"\"\"\n    await self._formula_pool.stop()\n</code></pre>"}]}